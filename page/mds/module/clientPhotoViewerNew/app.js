var $jscomp = $jscomp || {};
$jscomp.scope = {};
$jscomp.ASSUME_ES5 = false;
$jscomp.ASSUME_NO_NATIVE_MAP = false;
$jscomp.ASSUME_NO_NATIVE_SET = false;
$jscomp.defineProperty = $jscomp.ASSUME_ES5 || typeof Object.defineProperties == 'function' ? Object.defineProperty : function(target, property, descriptor) {
  descriptor = descriptor;
  if (target == Array.prototype || target == Object.prototype) {
    return;
  }
  target[property] = descriptor.value;
};
$jscomp.getGlobal = function(maybeGlobal) {
  return typeof window != 'undefined' && window === maybeGlobal ? maybeGlobal : typeof global != 'undefined' && global != null ? global : maybeGlobal;
};
$jscomp.global = $jscomp.getGlobal(this);
$jscomp.polyfill = function(target, polyfill, fromLang, toLang) {
  if (!polyfill) {
    return;
  }
  var obj = $jscomp.global;
  var split = target.split('.');
  for (var i = 0; i < split.length - 1; i++) {
    var key = split[i];
    if (!(key in obj)) {
      obj[key] = {};
    }
    obj = obj[key];
  }
  var property = split[split.length - 1];
  var orig = obj[property];
  var impl = polyfill(orig);
  if (impl == orig || impl == null) {
    return;
  }
  $jscomp.defineProperty(obj, property, {configurable:true, writable:true, value:impl});
};
$jscomp.polyfill('Array.prototype.copyWithin', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, start, opt_end) {
    var len = this.length;
    target = Number(target);
    start = Number(start);
    opt_end = Number(opt_end != null ? opt_end : len);
    if (target < start) {
      opt_end = Math.min(opt_end, len);
      while (start < opt_end) {
        if (start in this) {
          this[target++] = this[start++];
        } else {
          delete this[target++];
          start++;
        }
      }
    } else {
      opt_end = Math.min(opt_end, len + start - target);
      target += opt_end - start;
      while (opt_end > start) {
        if (--opt_end in this) {
          this[--target] = this[opt_end];
        } else {
          delete this[target];
        }
      }
    }
    return this;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.SYMBOL_PREFIX = 'jscomp_symbol_';
$jscomp.initSymbol = function() {
  $jscomp.initSymbol = function() {
  };
  if (!$jscomp.global['Symbol']) {
    $jscomp.global['Symbol'] = $jscomp.Symbol;
  }
};
$jscomp.Symbol = function() {
  var counter = 0;
  function Symbol(opt_description) {
    return $jscomp.SYMBOL_PREFIX + (opt_description || '') + counter++;
  }
  return Symbol;
}();
$jscomp.initSymbolIterator = function() {
  $jscomp.initSymbol();
  var symbolIterator = $jscomp.global['Symbol'].iterator;
  if (!symbolIterator) {
    symbolIterator = $jscomp.global['Symbol'].iterator = $jscomp.global['Symbol']('iterator');
  }
  if (typeof Array.prototype[symbolIterator] != 'function') {
    $jscomp.defineProperty(Array.prototype, symbolIterator, {configurable:true, writable:true, value:function() {
      return $jscomp.arrayIterator(this);
    }});
  }
  $jscomp.initSymbolIterator = function() {
  };
};
$jscomp.arrayIterator = function(array) {
  var index = 0;
  return $jscomp.iteratorPrototype(function() {
    if (index < array.length) {
      return {done:false, value:array[index++]};
    } else {
      return {done:true};
    }
  });
};
$jscomp.iteratorPrototype = function(next) {
  $jscomp.initSymbolIterator();
  var iterator = {next:next};
  iterator[$jscomp.global['Symbol'].iterator] = function() {
    return this;
  };
  return iterator;
};
$jscomp.iteratorFromArray = function(array, transform) {
  $jscomp.initSymbolIterator();
  if (array instanceof String) {
    array = array + '';
  }
  var i = 0;
  var iter = {next:function() {
    if (i < array.length) {
      var index = i++;
      return {value:transform(index, array[index]), done:false};
    }
    iter.next = function() {
      return {done:true, value:void 0};
    };
    return iter.next();
  }};
  iter[Symbol.iterator] = function() {
    return iter;
  };
  return iter;
};
$jscomp.polyfill('Array.prototype.entries', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function() {
    return $jscomp.iteratorFromArray(this, function(i, v) {
      return [i, v];
    });
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Array.prototype.fill', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(value, opt_start, opt_end) {
    var length = this.length || 0;
    if (opt_start < 0) {
      opt_start = Math.max(0, length + opt_start);
    }
    if (opt_end == null || opt_end > length) {
      opt_end = length;
    }
    opt_end = Number(opt_end);
    if (opt_end < 0) {
      opt_end = Math.max(0, length + opt_end);
    }
    for (var i = Number(opt_start || 0); i < opt_end; i++) {
      this[i] = value;
    }
    return this;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.findInternal = function(array, callback, thisArg) {
  if (array instanceof String) {
    array = String(array);
  }
  var len = array.length;
  for (var i = 0; i < len; i++) {
    var value = array[i];
    if (callback.call(thisArg, value, i, array)) {
      return {i:i, v:value};
    }
  }
  return {i:-1, v:void 0};
};
$jscomp.polyfill('Array.prototype.find', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(callback, opt_thisArg) {
    return $jscomp.findInternal(this, callback, opt_thisArg).v;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Array.prototype.findIndex', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(callback, opt_thisArg) {
    return $jscomp.findInternal(this, callback, opt_thisArg).i;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Array.from', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(arrayLike, opt_mapFn, opt_thisArg) {
    $jscomp.initSymbolIterator();
    opt_mapFn = opt_mapFn != null ? opt_mapFn : function(x) {
      return x;
    };
    var result = [];
    var iteratorFunction = arrayLike[Symbol.iterator];
    if (typeof iteratorFunction == 'function') {
      arrayLike = iteratorFunction.call(arrayLike);
      var next;
      while (!(next = arrayLike.next()).done) {
        result.push(opt_mapFn.call(opt_thisArg, next.value));
      }
    } else {
      var len = arrayLike.length;
      for (var i = 0; i < len; i++) {
        result.push(opt_mapFn.call(opt_thisArg, arrayLike[i]));
      }
    }
    return result;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Object.is', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(left, right) {
    if (left === right) {
      return left !== 0 || 1 / left === 1 / right;
    } else {
      return left !== left && right !== right;
    }
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Array.prototype.includes', function(orig) {
  if (orig) {
    return orig;
  }
  var includes = function(searchElement, opt_fromIndex) {
    var array = this;
    if (array instanceof String) {
      array = String(array);
    }
    var len = array.length;
    for (var i = opt_fromIndex || 0; i < len; i++) {
      if (array[i] == searchElement || Object.is(array[i], searchElement)) {
        return true;
      }
    }
    return false;
  };
  return includes;
}, 'es7', 'es3');
$jscomp.polyfill('Array.prototype.keys', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function() {
    return $jscomp.iteratorFromArray(this, function(i) {
      return i;
    });
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Array.of', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(var_args) {
    return Array.from(arguments);
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Array.prototype.values', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function() {
    return $jscomp.iteratorFromArray(this, function(k, v) {
      return v;
    });
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.makeIterator = function(iterable) {
  $jscomp.initSymbolIterator();
  var iteratorFunction = iterable[Symbol.iterator];
  return iteratorFunction ? iteratorFunction.call(iterable) : $jscomp.arrayIterator(iterable);
};
$jscomp.FORCE_POLYFILL_PROMISE = false;
$jscomp.polyfill('Promise', function(NativePromise) {
  if (NativePromise && !$jscomp.FORCE_POLYFILL_PROMISE) {
    return NativePromise;
  }
  function AsyncExecutor() {
    this.batch_ = null;
  }
  AsyncExecutor.prototype.asyncExecute = function(f) {
    if (this.batch_ == null) {
      this.batch_ = [];
      this.asyncExecuteBatch_();
    }
    this.batch_.push(f);
    return this;
  };
  AsyncExecutor.prototype.asyncExecuteBatch_ = function() {
    var self = this;
    this.asyncExecuteFunction(function() {
      self.executeBatch_();
    });
  };
  var nativeSetTimeout = $jscomp.global['setTimeout'];
  AsyncExecutor.prototype.asyncExecuteFunction = function(f) {
    nativeSetTimeout(f, 0);
  };
  AsyncExecutor.prototype.executeBatch_ = function() {
    while (this.batch_ && this.batch_.length) {
      var executingBatch = this.batch_;
      this.batch_ = [];
      for (var i = 0; i < executingBatch.length; ++i) {
        var f = executingBatch[i];
        delete executingBatch[i];
        try {
          f();
        } catch (error$0) {
          this.asyncThrow_(error$0);
        }
      }
    }
    this.batch_ = null;
  };
  AsyncExecutor.prototype.asyncThrow_ = function(exception) {
    this.asyncExecuteFunction(function() {
      throw exception;
    });
  };
  var PromiseState = {PENDING:0, FULFILLED:1, REJECTED:2};
  var PolyfillPromise = function(executor) {
    this.state_ = PromiseState.PENDING;
    this.result_ = undefined;
    this.onSettledCallbacks_ = [];
    var resolveAndReject = this.createResolveAndReject_();
    try {
      executor(resolveAndReject.resolve, resolveAndReject.reject);
    } catch (e) {
      resolveAndReject.reject(e);
    }
  };
  PolyfillPromise.prototype.createResolveAndReject_ = function() {
    var thisPromise = this;
    var alreadyCalled = false;
    function firstCallWins(method) {
      return function(x) {
        if (!alreadyCalled) {
          alreadyCalled = true;
          method.call(thisPromise, x);
        }
      };
    }
    return {resolve:firstCallWins(this.resolveTo_), reject:firstCallWins(this.reject_)};
  };
  PolyfillPromise.prototype.resolveTo_ = function(value) {
    if (value === this) {
      this.reject_(new TypeError('A Promise cannot resolve to itself'));
    } else {
      if (value instanceof PolyfillPromise) {
        this.settleSameAsPromise_(value);
      } else {
        if (isObject(value)) {
          this.resolveToNonPromiseObj_(value);
        } else {
          this.fulfill_(value);
        }
      }
    }
  };
  PolyfillPromise.prototype.resolveToNonPromiseObj_ = function(obj) {
    var thenMethod = undefined;
    try {
      thenMethod = obj.then;
    } catch (error$1) {
      this.reject_(error$1);
      return;
    }
    if (typeof thenMethod == 'function') {
      this.settleSameAsThenable_(thenMethod, obj);
    } else {
      this.fulfill_(obj);
    }
  };
  function isObject(value) {
    switch(typeof value) {
      case 'object':
        return value != null;
      case 'function':
        return true;
      default:
        return false;
    }
  }
  PolyfillPromise.prototype.reject_ = function(reason) {
    this.settle_(PromiseState.REJECTED, reason);
  };
  PolyfillPromise.prototype.fulfill_ = function(value) {
    this.settle_(PromiseState.FULFILLED, value);
  };
  PolyfillPromise.prototype.settle_ = function(settledState, valueOrReason) {
    if (this.state_ != PromiseState.PENDING) {
      throw new Error('Cannot settle(' + settledState + ', ' + valueOrReason | '): Promise already settled in state' + this.state_);
    }
    this.state_ = settledState;
    this.result_ = valueOrReason;
    this.executeOnSettledCallbacks_();
  };
  PolyfillPromise.prototype.executeOnSettledCallbacks_ = function() {
    if (this.onSettledCallbacks_ != null) {
      var callbacks = this.onSettledCallbacks_;
      for (var i = 0; i < callbacks.length; ++i) {
        callbacks[i].call();
        callbacks[i] = null;
      }
      this.onSettledCallbacks_ = null;
    }
  };
  var asyncExecutor = new AsyncExecutor;
  PolyfillPromise.prototype.settleSameAsPromise_ = function(promise) {
    var methods = this.createResolveAndReject_();
    promise.callWhenSettled_(methods.resolve, methods.reject);
  };
  PolyfillPromise.prototype.settleSameAsThenable_ = function(thenMethod, thenable) {
    var methods = this.createResolveAndReject_();
    try {
      thenMethod.call(thenable, methods.resolve, methods.reject);
    } catch (error$2) {
      methods.reject(error$2);
    }
  };
  PolyfillPromise.prototype.then = function(onFulfilled, onRejected) {
    var resolveChild;
    var rejectChild;
    var childPromise = new PolyfillPromise(function(resolve, reject) {
      resolveChild = resolve;
      rejectChild = reject;
    });
    function createCallback(paramF, defaultF) {
      if (typeof paramF == 'function') {
        return function(x) {
          try {
            resolveChild(paramF(x));
          } catch (error$3) {
            rejectChild(error$3);
          }
        };
      } else {
        return defaultF;
      }
    }
    this.callWhenSettled_(createCallback(onFulfilled, resolveChild), createCallback(onRejected, rejectChild));
    return childPromise;
  };
  PolyfillPromise.prototype['catch'] = function(onRejected) {
    return this.then(undefined, onRejected);
  };
  PolyfillPromise.prototype.callWhenSettled_ = function(onFulfilled, onRejected) {
    var thisPromise = this;
    function callback() {
      switch(thisPromise.state_) {
        case PromiseState.FULFILLED:
          onFulfilled(thisPromise.result_);
          break;
        case PromiseState.REJECTED:
          onRejected(thisPromise.result_);
          break;
        default:
          throw new Error('Unexpected state: ' + thisPromise.state_);
      }
    }
    if (this.onSettledCallbacks_ == null) {
      asyncExecutor.asyncExecute(callback);
    } else {
      this.onSettledCallbacks_.push(function() {
        asyncExecutor.asyncExecute(callback);
      });
    }
  };
  function resolvingPromise(opt_value) {
    if (opt_value instanceof PolyfillPromise) {
      return opt_value;
    } else {
      return new PolyfillPromise(function(resolve, reject) {
        resolve(opt_value);
      });
    }
  }
  PolyfillPromise['resolve'] = resolvingPromise;
  PolyfillPromise['reject'] = function(opt_reason) {
    return new PolyfillPromise(function(resolve, reject) {
      reject(opt_reason);
    });
  };
  PolyfillPromise['race'] = function(thenablesOrValues) {
    return new PolyfillPromise(function(resolve, reject) {
      var iterator = $jscomp.makeIterator(thenablesOrValues);
      for (var iterRec = iterator.next(); !iterRec.done; iterRec = iterator.next()) {
        resolvingPromise(iterRec.value).callWhenSettled_(resolve, reject);
      }
    });
  };
  PolyfillPromise['all'] = function(thenablesOrValues) {
    var iterator = $jscomp.makeIterator(thenablesOrValues);
    var iterRec = iterator.next();
    if (iterRec.done) {
      return resolvingPromise([]);
    } else {
      return new PolyfillPromise(function(resolveAll, rejectAll) {
        var resultsArray = [];
        var unresolvedCount = 0;
        function onFulfilled(i) {
          return function(ithResult) {
            resultsArray[i] = ithResult;
            unresolvedCount--;
            if (unresolvedCount == 0) {
              resolveAll(resultsArray);
            }
          };
        }
        do {
          resultsArray.push(undefined);
          unresolvedCount++;
          resolvingPromise(iterRec.value).callWhenSettled_(onFulfilled(resultsArray.length - 1), rejectAll);
          iterRec = iterator.next();
        } while (!iterRec.done);
      });
    }
  };
  return PolyfillPromise;
}, 'es6', 'es3');
$jscomp.executeAsyncGenerator = function(generator) {
  function passValueToGenerator(value) {
    return generator.next(value);
  }
  function passErrorToGenerator(error) {
    return generator['throw'](error);
  }
  return new Promise(function(resolve, reject) {
    function handleGeneratorRecord(genRec) {
      if (genRec.done) {
        resolve(genRec.value);
      } else {
        Promise.resolve(genRec.value).then(passValueToGenerator, passErrorToGenerator).then(handleGeneratorRecord, reject);
      }
    }
    handleGeneratorRecord(generator.next());
  });
};
$jscomp.owns = function(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
};
$jscomp.polyfill('WeakMap', function(NativeWeakMap) {
  function isConformant() {
    if (!NativeWeakMap || !Object.seal) {
      return false;
    }
    try {
      var x = Object.seal({});
      var y = Object.seal({});
      var map = new NativeWeakMap([[x, 2], [y, 3]]);
      if (map.get(x) != 2 || map.get(y) != 3) {
        return false;
      }
      map['delete'](x);
      map.set(y, 4);
      return !map.has(x) && map.get(y) == 4;
    } catch (err) {
      return false;
    }
  }
  if (isConformant()) {
    return NativeWeakMap;
  }
  var prop = '$jscomp_hidden_' + Math.random().toString().substring(2);
  function insert(target) {
    if (!$jscomp.owns(target, prop)) {
      var obj = {};
      $jscomp.defineProperty(target, prop, {value:obj});
    }
  }
  function patch(name) {
    var prev = Object[name];
    if (prev) {
      Object[name] = function(target) {
        insert(target);
        return prev(target);
      };
    }
  }
  patch('freeze');
  patch('preventExtensions');
  patch('seal');
  var index = 0;
  var PolyfillWeakMap = function(opt_iterable) {
    this.id_ = (index += Math.random() + 1).toString();
    if (opt_iterable) {
      $jscomp.initSymbol();
      $jscomp.initSymbolIterator();
      var iter = $jscomp.makeIterator(opt_iterable);
      var entry;
      while (!(entry = iter.next()).done) {
        var item = entry.value;
        this.set(item[0], item[1]);
      }
    }
  };
  PolyfillWeakMap.prototype.set = function(key, value) {
    insert(key);
    if (!$jscomp.owns(key, prop)) {
      throw new Error('WeakMap key fail: ' + key);
    }
    key[prop][this.id_] = value;
    return this;
  };
  PolyfillWeakMap.prototype.get = function(key) {
    return $jscomp.owns(key, prop) ? key[prop][this.id_] : undefined;
  };
  PolyfillWeakMap.prototype.has = function(key) {
    return $jscomp.owns(key, prop) && $jscomp.owns(key[prop], this.id_);
  };
  PolyfillWeakMap.prototype['delete'] = function(key) {
    if (!$jscomp.owns(key, prop) || !$jscomp.owns(key[prop], this.id_)) {
      return false;
    }
    return delete key[prop][this.id_];
  };
  return PolyfillWeakMap;
}, 'es6', 'es3');
$jscomp.MapEntry = function() {
  this.previous;
  this.next;
  this.head;
  this.key;
  this.value;
};
$jscomp.polyfill('Map', function(NativeMap) {
  var isConformant = !$jscomp.ASSUME_NO_NATIVE_MAP && function() {
    if (!NativeMap || !NativeMap.prototype.entries || typeof Object.seal != 'function') {
      return false;
    }
    try {
      NativeMap = NativeMap;
      var key = Object.seal({x:4});
      var map = new NativeMap($jscomp.makeIterator([[key, 's']]));
      if (map.get(key) != 's' || map.size != 1 || map.get({x:4}) || map.set({x:4}, 't') != map || map.size != 2) {
        return false;
      }
      var iter = map.entries();
      var item = iter.next();
      if (item.done || item.value[0] != key || item.value[1] != 's') {
        return false;
      }
      item = iter.next();
      if (item.done || item.value[0].x != 4 || item.value[1] != 't' || !iter.next().done) {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  }();
  if (isConformant) {
    return NativeMap;
  }
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  var idMap = new WeakMap;
  var PolyfillMap = function(opt_iterable) {
    this.data_ = {};
    this.head_ = createHead();
    this.size = 0;
    if (opt_iterable) {
      var iter = $jscomp.makeIterator(opt_iterable);
      var entry;
      while (!(entry = iter.next()).done) {
        var item = entry.value;
        this.set(item[0], item[1]);
      }
    }
  };
  PolyfillMap.prototype.set = function(key, value) {
    var r = maybeGetEntry(this, key);
    if (!r.list) {
      r.list = this.data_[r.id] = [];
    }
    if (!r.entry) {
      r.entry = {next:this.head_, previous:this.head_.previous, head:this.head_, key:key, value:value};
      r.list.push(r.entry);
      this.head_.previous.next = r.entry;
      this.head_.previous = r.entry;
      this.size++;
    } else {
      r.entry.value = value;
    }
    return this;
  };
  PolyfillMap.prototype['delete'] = function(key) {
    var r = maybeGetEntry(this, key);
    if (r.entry && r.list) {
      r.list.splice(r.index, 1);
      if (!r.list.length) {
        delete this.data_[r.id];
      }
      r.entry.previous.next = r.entry.next;
      r.entry.next.previous = r.entry.previous;
      r.entry.head = null;
      this.size--;
      return true;
    }
    return false;
  };
  PolyfillMap.prototype.clear = function() {
    this.data_ = {};
    this.head_ = this.head_.previous = createHead();
    this.size = 0;
  };
  PolyfillMap.prototype.has = function(key) {
    return !!maybeGetEntry(this, key).entry;
  };
  PolyfillMap.prototype.get = function(key) {
    var entry = maybeGetEntry(this, key).entry;
    return entry && entry.value;
  };
  PolyfillMap.prototype.entries = function() {
    return makeIterator(this, function(entry) {
      return [entry.key, entry.value];
    });
  };
  PolyfillMap.prototype.keys = function() {
    return makeIterator(this, function(entry) {
      return entry.key;
    });
  };
  PolyfillMap.prototype.values = function() {
    return makeIterator(this, function(entry) {
      return entry.value;
    });
  };
  PolyfillMap.prototype.forEach = function(callback, opt_thisArg) {
    var iter = this.entries();
    var item;
    while (!(item = iter.next()).done) {
      var entry = item.value;
      callback.call(opt_thisArg, entry[1], entry[0], this);
    }
  };
  PolyfillMap.prototype[Symbol.iterator] = PolyfillMap.prototype.entries;
  var maybeGetEntry = function(map, key) {
    var id = getId(key);
    var list = map.data_[id];
    if (list && $jscomp.owns(map.data_, id)) {
      for (var index = 0; index < list.length; index++) {
        var entry = list[index];
        if (key !== key && entry.key !== entry.key || key === entry.key) {
          return {id:id, list:list, index:index, entry:entry};
        }
      }
    }
    return {id:id, list:list, index:-1, entry:undefined};
  };
  var makeIterator = function(map, func) {
    var entry = map.head_;
    return $jscomp.iteratorPrototype(function() {
      if (entry) {
        while (entry.head != map.head_) {
          entry = entry.previous;
        }
        while (entry.next != entry.head) {
          entry = entry.next;
          return {done:false, value:func(entry)};
        }
        entry = null;
      }
      return {done:true, value:void 0};
    });
  };
  var createHead = function() {
    var head = {};
    head.previous = head.next = head.head = head;
    return head;
  };
  var mapIndex = 0;
  var getId = function(obj) {
    var type = obj && typeof obj;
    if (type == 'object' || type == 'function') {
      obj = obj;
      if (!idMap.has(obj)) {
        var id = '' + ++mapIndex;
        idMap.set(obj, id);
        return id;
      }
      return idMap.get(obj);
    }
    return 'p_' + obj;
  };
  return PolyfillMap;
}, 'es6', 'es3');
$jscomp.polyfill('Math.acosh', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    return Math.log(x + Math.sqrt(x * x - 1));
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.asinh', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    if (x === 0) {
      return x;
    }
    var y = Math.log(Math.abs(x) + Math.sqrt(x * x + 1));
    return x < 0 ? -y : y;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.log1p', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    if (x < 0.25 && x > -0.25) {
      var y = x;
      var d = 1;
      var z = x;
      var zPrev = 0;
      var s = 1;
      while (zPrev != z) {
        y *= x;
        s *= -1;
        z = (zPrev = z) + s * y / ++d;
      }
      return z;
    }
    return Math.log(1 + x);
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.atanh', function(orig) {
  if (orig) {
    return orig;
  }
  var log1p = Math.log1p;
  var polyfill = function(x) {
    x = Number(x);
    return (log1p(x) - log1p(-x)) / 2;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.cbrt', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    if (x === 0) {
      return x;
    }
    x = Number(x);
    var y = Math.pow(Math.abs(x), 1 / 3);
    return x < 0 ? -y : y;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.clz32', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x) >>> 0;
    if (x === 0) {
      return 32;
    }
    var result = 0;
    if ((x & 4294901760) === 0) {
      x <<= 16;
      result += 16;
    }
    if ((x & 4278190080) === 0) {
      x <<= 8;
      result += 8;
    }
    if ((x & 4026531840) === 0) {
      x <<= 4;
      result += 4;
    }
    if ((x & 3221225472) === 0) {
      x <<= 2;
      result += 2;
    }
    if ((x & 2147483648) === 0) {
      result++;
    }
    return result;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.cosh', function(orig) {
  if (orig) {
    return orig;
  }
  var exp = Math.exp;
  var polyfill = function(x) {
    x = Number(x);
    return (exp(x) + exp(-x)) / 2;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.expm1', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    if (x < .25 && x > -.25) {
      var y = x;
      var d = 1;
      var z = x;
      var zPrev = 0;
      while (zPrev != z) {
        y *= x / ++d;
        z = (zPrev = z) + y;
      }
      return z;
    }
    return Math.exp(x) - 1;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.hypot', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x, y, var_args) {
    x = Number(x);
    y = Number(y);
    var i, z, sum;
    var max = Math.max(Math.abs(x), Math.abs(y));
    for (i = 2; i < arguments.length; i++) {
      max = Math.max(max, Math.abs(arguments[i]));
    }
    if (max > 1e100 || max < 1e-100) {
      x = x / max;
      y = y / max;
      sum = x * x + y * y;
      for (i = 2; i < arguments.length; i++) {
        z = Number(arguments[i]) / max;
        sum += z * z;
      }
      return Math.sqrt(sum) * max;
    } else {
      sum = x * x + y * y;
      for (i = 2; i < arguments.length; i++) {
        z = Number(arguments[i]);
        sum += z * z;
      }
      return Math.sqrt(sum);
    }
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.imul', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(a, b) {
    a = Number(a);
    b = Number(b);
    var ah = a >>> 16 & 65535;
    var al = a & 65535;
    var bh = b >>> 16 & 65535;
    var bl = b & 65535;
    var lh = ah * bl + al * bh << 16 >>> 0;
    return al * bl + lh | 0;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.log10', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    return Math.log(x) / Math.LN10;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.log2', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    return Math.log(x) / Math.LN2;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.sign', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    return x === 0 || isNaN(x) ? x : x > 0 ? 1 : -1;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.sinh', function(orig) {
  if (orig) {
    return orig;
  }
  var exp = Math.exp;
  var polyfill = function(x) {
    x = Number(x);
    if (x === 0) {
      return x;
    }
    return (exp(x) - exp(-x)) / 2;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.tanh', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    if (x === 0) {
      return x;
    }
    var y = Math.exp(-2 * Math.abs(x));
    var z = (1 - y) / (1 + y);
    return x < 0 ? -z : z;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.trunc', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    if (isNaN(x) || x === Infinity || x === -Infinity || x === 0) {
      return x;
    }
    var y = Math.floor(Math.abs(x));
    return x < 0 ? -y : y;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Number.EPSILON', function(orig) {
  return Math.pow(2, -52);
}, 'es6', 'es3');
$jscomp.polyfill('Number.MAX_SAFE_INTEGER', function() {
  return 9007199254740991;
}, 'es6', 'es3');
$jscomp.polyfill('Number.MIN_SAFE_INTEGER', function() {
  return -9007199254740991;
}, 'es6', 'es3');
$jscomp.polyfill('Number.isFinite', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    if (typeof x !== 'number') {
      return false;
    }
    return !isNaN(x) && x !== Infinity && x !== -Infinity;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Number.isInteger', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    if (!Number.isFinite(x)) {
      return false;
    }
    return x === Math.floor(x);
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Number.isNaN', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    return typeof x === 'number' && isNaN(x);
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Number.isSafeInteger', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    return Number.isInteger(x) && Math.abs(x) <= Number.MAX_SAFE_INTEGER;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Object.assign', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, var_args) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      if (!source) {
        continue;
      }
      for (var key in source) {
        if ($jscomp.owns(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Object.entries', function(orig) {
  if (orig) {
    return orig;
  }
  var entries = function(obj) {
    var result = [];
    for (var key in obj) {
      if ($jscomp.owns(obj, key)) {
        result.push([key, obj[key]]);
      }
    }
    return result;
  };
  return entries;
}, 'es8', 'es3');
$jscomp.polyfill('Object.getOwnPropertySymbols', function(orig) {
  if (orig) {
    return orig;
  }
  return function() {
    return [];
  };
}, 'es6', 'es5');
$jscomp.polyfill('Reflect.ownKeys', function(orig) {
  if (orig) {
    return orig;
  }
  var symbolPrefix = 'jscomp_symbol_';
  function isSymbol(key) {
    return key.substring(0, symbolPrefix.length) == symbolPrefix;
  }
  var polyfill = function(target) {
    var keys = [];
    var names = Object.getOwnPropertyNames(target);
    var symbols = Object.getOwnPropertySymbols(target);
    for (var i = 0; i < names.length; i++) {
      (isSymbol(names[i]) ? symbols : keys).push(names[i]);
    }
    return keys.concat(symbols);
  };
  return polyfill;
}, 'es6', 'es5');
$jscomp.polyfill('Object.getOwnPropertyDescriptors', function(orig) {
  if (orig) {
    return orig;
  }
  var getOwnPropertyDescriptors = function(obj) {
    var result = {};
    var keys = Reflect.ownKeys(obj);
    for (var i = 0; i < keys.length; i++) {
      result[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return result;
  };
  return getOwnPropertyDescriptors;
}, 'es8', 'es5');
$jscomp.underscoreProtoCanBeSet = function() {
  var x = {a:true};
  var y = {};
  try {
    y.__proto__ = x;
    return y.a;
  } catch (e) {
  }
  return false;
};
$jscomp.setPrototypeOf = typeof Object.setPrototypeOf == 'function' ? Object.setPrototypeOf : $jscomp.underscoreProtoCanBeSet() ? function(target, proto) {
  target.__proto__ = proto;
  if (target.__proto__ !== proto) {
    throw new TypeError(target + ' is not extensible');
  }
  return target;
} : null;
$jscomp.polyfill('Object.setPrototypeOf', function(orig) {
  return orig || $jscomp.setPrototypeOf;
}, 'es6', 'es5');
$jscomp.polyfill('Object.values', function(orig) {
  if (orig) {
    return orig;
  }
  var values = function(obj) {
    var result = [];
    for (var key in obj) {
      if ($jscomp.owns(obj, key)) {
        result.push(obj[key]);
      }
    }
    return result;
  };
  return values;
}, 'es8', 'es3');
$jscomp.polyfill('Reflect.apply', function(orig) {
  if (orig) {
    return orig;
  }
  var apply = Function.prototype.apply;
  var polyfill = function(target, thisArg, argList) {
    return apply.call(target, thisArg, argList);
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.objectCreate = $jscomp.ASSUME_ES5 || typeof Object.create == 'function' ? Object.create : function(prototype) {
  var ctor = function() {
  };
  ctor.prototype = prototype;
  return new ctor;
};
$jscomp.construct = function() {
  function reflectConstructWorks() {
    function Base() {
    }
    function Derived() {
    }
    new Base;
    Reflect.construct(Base, [], Derived);
    return new Base instanceof Base;
  }
  if (typeof Reflect != 'undefined' && Reflect.construct) {
    if (reflectConstructWorks()) {
      return Reflect.construct;
    }
    var brokenConstruct = Reflect.construct;
    var patchedConstruct = function(target, argList, opt_newTarget) {
      var out = brokenConstruct(target, argList);
      if (opt_newTarget) {
        Reflect.setPrototypeOf(out, opt_newTarget.prototype);
      }
      return out;
    };
    return patchedConstruct;
  }
  function construct(target, argList, opt_newTarget) {
    if (opt_newTarget === undefined) {
      opt_newTarget = target;
    }
    var proto = opt_newTarget.prototype || Object.prototype;
    var obj = $jscomp.objectCreate(proto);
    var apply = Function.prototype.apply;
    var out = apply.call(target, obj, argList);
    return out || obj;
  }
  return construct;
}();
$jscomp.polyfill('Reflect.construct', function(orig) {
  return $jscomp.construct;
}, 'es6', 'es3');
$jscomp.polyfill('Reflect.defineProperty', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, propertyKey, attributes) {
    try {
      Object.defineProperty(target, propertyKey, attributes);
      var desc = Object.getOwnPropertyDescriptor(target, propertyKey);
      if (!desc) {
        return false;
      }
      return desc.configurable === (attributes.configurable || false) && desc.enumerable === (attributes.enumerable || false) && ('value' in desc ? desc.value === attributes.value && desc.writable === (attributes.writable || false) : desc.get === attributes.get && desc.set === attributes.set);
    } catch (err) {
      return false;
    }
  };
  return polyfill;
}, 'es6', 'es5');
$jscomp.polyfill('Reflect.deleteProperty', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, propertyKey) {
    if (!$jscomp.owns(target, propertyKey)) {
      return true;
    }
    try {
      return delete target[propertyKey];
    } catch (err) {
      return false;
    }
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Reflect.getOwnPropertyDescriptor', function(orig) {
  return orig || Object.getOwnPropertyDescriptor;
}, 'es6', 'es5');
$jscomp.polyfill('Reflect.getPrototypeOf', function(orig) {
  return orig || Object.getPrototypeOf;
}, 'es6', 'es5');
$jscomp.findDescriptor = function(target, propertyKey) {
  var obj = target;
  while (obj) {
    var property = Reflect.getOwnPropertyDescriptor(obj, propertyKey);
    if (property) {
      return property;
    }
    obj = Reflect.getPrototypeOf(obj);
  }
  return undefined;
};
$jscomp.polyfill('Reflect.get', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, propertyKey, opt_receiver) {
    if (arguments.length <= 2) {
      return target[propertyKey];
    }
    var property = $jscomp.findDescriptor(target, propertyKey);
    if (property) {
      return property.get ? property.get.call(opt_receiver) : property.value;
    }
    return undefined;
  };
  return polyfill;
}, 'es6', 'es5');
$jscomp.polyfill('Reflect.has', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, propertyKey) {
    return propertyKey in target;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Reflect.isExtensible', function(orig) {
  if (orig) {
    return orig;
  }
  if ($jscomp.ASSUME_ES5 || typeof Object.isExtensible == 'function') {
    return Object.isExtensible;
  }
  return function() {
    return true;
  };
}, 'es6', 'es3');
$jscomp.polyfill('Reflect.preventExtensions', function(orig) {
  if (orig) {
    return orig;
  }
  if (!($jscomp.ASSUME_ES5 || typeof Object.preventExtensions == 'function')) {
    return function() {
      return false;
    };
  }
  var polyfill = function(target) {
    Object.preventExtensions(target);
    return !Object.isExtensible(target);
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Reflect.set', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, propertyKey, value, opt_receiver) {
    var property = $jscomp.findDescriptor(target, propertyKey);
    if (!property) {
      if (Reflect.isExtensible(target)) {
        target[propertyKey] = value;
        return true;
      }
      return false;
    }
    if (property.set) {
      property.set.call(arguments.length > 3 ? opt_receiver : target, value);
      return true;
    } else {
      if (property.writable && !Object.isFrozen(target)) {
        target[propertyKey] = value;
        return true;
      }
    }
    return false;
  };
  return polyfill;
}, 'es6', 'es5');
$jscomp.polyfill('Reflect.setPrototypeOf', function(orig) {
  if (orig) {
    return orig;
  } else {
    if ($jscomp.setPrototypeOf) {
      var setPrototypeOf = $jscomp.setPrototypeOf;
      var polyfill = function(target, proto) {
        try {
          setPrototypeOf(target, proto);
          return true;
        } catch (e) {
          return false;
        }
      };
      return polyfill;
    } else {
      return null;
    }
  }
}, 'es6', 'es5');
$jscomp.polyfill('Set', function(NativeSet) {
  var isConformant = !$jscomp.ASSUME_NO_NATIVE_SET && function() {
    if (!NativeSet || !NativeSet.prototype.entries || typeof Object.seal != 'function') {
      return false;
    }
    try {
      NativeSet = NativeSet;
      var value = Object.seal({x:4});
      var set = new NativeSet($jscomp.makeIterator([value]));
      if (!set.has(value) || set.size != 1 || set.add(value) != set || set.size != 1 || set.add({x:4}) != set || set.size != 2) {
        return false;
      }
      var iter = set.entries();
      var item = iter.next();
      if (item.done || item.value[0] != value || item.value[1] != value) {
        return false;
      }
      item = iter.next();
      if (item.done || item.value[0] == value || item.value[0].x != 4 || item.value[1] != item.value[0]) {
        return false;
      }
      return iter.next().done;
    } catch (err) {
      return false;
    }
  }();
  if (isConformant) {
    return NativeSet;
  }
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  var PolyfillSet = function(opt_iterable) {
    this.map_ = new Map;
    if (opt_iterable) {
      var iter = $jscomp.makeIterator(opt_iterable);
      var entry;
      while (!(entry = iter.next()).done) {
        var item = entry.value;
        this.add(item);
      }
    }
    this.size = this.map_.size;
  };
  PolyfillSet.prototype.add = function(value) {
    this.map_.set(value, value);
    this.size = this.map_.size;
    return this;
  };
  PolyfillSet.prototype['delete'] = function(value) {
    var result = this.map_['delete'](value);
    this.size = this.map_.size;
    return result;
  };
  PolyfillSet.prototype.clear = function() {
    this.map_.clear();
    this.size = 0;
  };
  PolyfillSet.prototype.has = function(value) {
    return this.map_.has(value);
  };
  PolyfillSet.prototype.entries = function() {
    return this.map_.entries();
  };
  PolyfillSet.prototype.values = function() {
    return this.map_.values();
  };
  PolyfillSet.prototype.keys = PolyfillSet.prototype.values;
  PolyfillSet.prototype[Symbol.iterator] = PolyfillSet.prototype.values;
  PolyfillSet.prototype.forEach = function(callback, opt_thisArg) {
    var set = this;
    this.map_.forEach(function(value) {
      return callback.call(opt_thisArg, value, value, set);
    });
  };
  return PolyfillSet;
}, 'es6', 'es3');
$jscomp.checkStringArgs = function(thisArg, arg, func) {
  if (thisArg == null) {
    throw new TypeError("The 'this' value for String.prototype." + func + ' must not be null or undefined');
  }
  if (arg instanceof RegExp) {
    throw new TypeError('First argument to String.prototype.' + func + ' must not be a regular expression');
  }
  return thisArg + '';
};
$jscomp.polyfill('String.prototype.codePointAt', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(position) {
    var string = $jscomp.checkStringArgs(this, null, 'codePointAt');
    var size = string.length;
    position = Number(position) || 0;
    if (!(position >= 0 && position < size)) {
      return void 0;
    }
    position = position | 0;
    var first = string.charCodeAt(position);
    if (first < 55296 || first > 56319 || position + 1 === size) {
      return first;
    }
    var second = string.charCodeAt(position + 1);
    if (second < 56320 || second > 57343) {
      return first;
    }
    return (first - 55296) * 1024 + second + 9216;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('String.prototype.endsWith', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(searchString, opt_position) {
    var string = $jscomp.checkStringArgs(this, searchString, 'endsWith');
    searchString = searchString + '';
    if (opt_position === void 0) {
      opt_position = string.length;
    }
    var i = Math.max(0, Math.min(opt_position | 0, string.length));
    var j = searchString.length;
    while (j > 0 && i > 0) {
      if (string[--i] != searchString[--j]) {
        return false;
      }
    }
    return j <= 0;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('String.fromCodePoint', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(var_args) {
    var result = '';
    for (var i = 0; i < arguments.length; i++) {
      var code = Number(arguments[i]);
      if (code < 0 || code > 1114111 || code !== Math.floor(code)) {
        throw new RangeError('invalid_code_point ' + code);
      }
      if (code <= 65535) {
        result += String.fromCharCode(code);
      } else {
        code -= 65536;
        result += String.fromCharCode(code >>> 10 & 1023 | 55296);
        result += String.fromCharCode(code & 1023 | 56320);
      }
    }
    return result;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('String.prototype.includes', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(searchString, opt_position) {
    var string = $jscomp.checkStringArgs(this, searchString, 'includes');
    return string.indexOf(searchString, opt_position || 0) !== -1;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('String.prototype.repeat', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(copies) {
    var string = $jscomp.checkStringArgs(this, null, 'repeat');
    if (copies < 0 || copies > 1342177279) {
      throw new RangeError('Invalid count value');
    }
    copies = copies | 0;
    var result = '';
    while (copies) {
      if (copies & 1) {
        result += string;
      }
      if (copies >>>= 1) {
        string += string;
      }
    }
    return result;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.stringPadding = function(padString, padLength) {
  var padding = padString !== undefined ? String(padString) : ' ';
  if (!(padLength > 0) || !padding) {
    return '';
  }
  var repeats = Math.ceil(padLength / padding.length);
  return padding.repeat(repeats).substring(0, padLength);
};
$jscomp.polyfill('String.prototype.padEnd', function(orig) {
  if (orig) {
    return orig;
  }
  var padEnd = function(targetLength, opt_padString) {
    var string = $jscomp.checkStringArgs(this, null, 'padStart');
    var padLength = targetLength - string.length;
    return string + $jscomp.stringPadding(opt_padString, padLength);
  };
  return padEnd;
}, 'es8', 'es3');
$jscomp.polyfill('String.prototype.padStart', function(orig) {
  if (orig) {
    return orig;
  }
  var padStart = function(targetLength, opt_padString) {
    var string = $jscomp.checkStringArgs(this, null, 'padStart');
    var padLength = targetLength - string.length;
    return $jscomp.stringPadding(opt_padString, padLength) + string;
  };
  return padStart;
}, 'es8', 'es3');
$jscomp.polyfill('String.prototype.startsWith', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(searchString, opt_position) {
    var string = $jscomp.checkStringArgs(this, searchString, 'startsWith');
    searchString = searchString + '';
    var strLen = string.length;
    var searchLen = searchString.length;
    var i = Math.max(0, Math.min(opt_position | 0, string.length));
    var j = 0;
    while (j < searchLen && i < strLen) {
      if (string[i++] != searchString[j++]) {
        return false;
      }
    }
    return j >= searchLen;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.arrayFromIterator = function(iterator) {
  var i;
  var arr = [];
  while (!(i = iterator.next()).done) {
    arr.push(i.value);
  }
  return arr;
};
$jscomp.arrayFromIterable = function(iterable) {
  if (iterable instanceof Array) {
    return iterable;
  } else {
    return $jscomp.arrayFromIterator($jscomp.makeIterator(iterable));
  }
};
$jscomp.inherits = function(childCtor, parentCtor) {
  childCtor.prototype = $jscomp.objectCreate(parentCtor.prototype);
  childCtor.prototype.constructor = childCtor;
  if ($jscomp.setPrototypeOf) {
    var setPrototypeOf = $jscomp.setPrototypeOf;
    setPrototypeOf(childCtor, parentCtor);
  } else {
    for (var p in parentCtor) {
      if (p == 'prototype') {
        continue;
      }
      if (Object.defineProperties) {
        var descriptor = Object.getOwnPropertyDescriptor(parentCtor, p);
        if (descriptor) {
          Object.defineProperty(childCtor, p, descriptor);
        }
      } else {
        childCtor[p] = parentCtor[p];
      }
    }
  }
  childCtor.superClass_ = parentCtor.prototype;
};
$jscomp.polyfill('WeakSet', function(NativeWeakSet) {
  function isConformant() {
    if (!NativeWeakSet || !Object.seal) {
      return false;
    }
    try {
      var x = Object.seal({});
      var y = Object.seal({});
      var set = new NativeWeakSet([x]);
      if (!set.has(x) || set.has(y)) {
        return false;
      }
      set['delete'](x);
      set.add(y);
      return !set.has(x) && set.has(y);
    } catch (err) {
      return false;
    }
  }
  if (isConformant()) {
    return NativeWeakSet;
  }
  var PolyfillWeakSet = function(opt_iterable) {
    this.map_ = new WeakMap;
    if (opt_iterable) {
      $jscomp.initSymbol();
      $jscomp.initSymbolIterator();
      var iter = $jscomp.makeIterator(opt_iterable);
      var entry;
      while (!(entry = iter.next()).done) {
        var item = entry.value;
        this.add(item);
      }
    }
  };
  PolyfillWeakSet.prototype.add = function(elem) {
    this.map_.set(elem, true);
    return this;
  };
  PolyfillWeakSet.prototype.has = function(elem) {
    return this.map_.has(elem);
  };
  PolyfillWeakSet.prototype['delete'] = function(elem) {
    return this.map_['delete'](elem);
  };
  return PolyfillWeakSet;
}, 'es6', 'es3');
try {
  if (Array.prototype.values.toString().indexOf('[native code]') == -1) {
    delete Array.prototype.values;
  }
} catch (e) {
}
var Ext = Ext || {};
if (!Ext.classic) {
  Ext.classic = {};
}
if (!Ext.classic.toolbar) {
  Ext.classic.toolbar = {};
}
if (!Ext.dd) {
  Ext.dd = {};
}
if (!Ext.draw) {
  Ext.draw = {};
}
if (!Ext.draw.engine) {
  Ext.draw.engine = {};
}
if (!Ext.draw.engine.SvgContext) {
  Ext.draw.engine.SvgContext = {};
}
if (!Ext.draw.gradient) {
  Ext.draw.gradient = {};
}
if (!Ext.draw.modifier) {
  Ext.draw.modifier = {};
}
if (!Ext.draw.overrides) {
  Ext.draw.overrides = {};
}
if (!Ext.draw.overrides.hittest) {
  Ext.draw.overrides.hittest = {};
}
if (!Ext.draw.overrides.hittest.sprite) {
  Ext.draw.overrides.hittest.sprite = {};
}
if (!Ext.draw.plugin) {
  Ext.draw.plugin = {};
}
if (!Ext.draw.sprite) {
  Ext.draw.sprite = {};
}
if (!Ext.overrides) {
  Ext.overrides = {};
}
if (!Ext.overrides.app) {
  Ext.overrides.app = {};
}
if (!Ext.overrides.button) {
  Ext.overrides.button = {};
}
if (!Ext.overrides.container) {
  Ext.overrides.container = {};
}
if (!Ext.overrides.data) {
  Ext.overrides.data = {};
}
if (!Ext.overrides.data.proxy) {
  Ext.overrides.data.proxy = {};
}
if (!Ext.overrides.data.reader) {
  Ext.overrides.data.reader = {};
}
if (!Ext.overrides.dom) {
  Ext.overrides.dom = {};
}
if (!Ext.overrides.event) {
  Ext.overrides.event = {};
}
if (!Ext.overrides.form) {
  Ext.overrides.form = {};
}
if (!Ext.overrides.form.field) {
  Ext.overrides.form.field = {};
}
if (!Ext.overrides.grid) {
  Ext.overrides.grid = {};
}
if (!Ext.overrides.menu) {
  Ext.overrides.menu = {};
}
if (!Ext.overrides.panel) {
  Ext.overrides.panel = {};
}
if (!Ext.overrides.scroll) {
  Ext.overrides.scroll = {};
}
if (!Ext.overrides.util) {
  Ext.overrides.util = {};
}
if (!Ext.overrides.view) {
  Ext.overrides.view = {};
}
if (!Ext.theme) {
  Ext.theme = {};
}
if (!Ext.theme.classic) {
  Ext.theme.classic = {};
}
if (!Ext.theme.classic.grid) {
  Ext.theme.classic.grid = {};
}
if (!Ext.theme.classic.grid.column) {
  Ext.theme.classic.grid.column = {};
}
if (!Ext.theme.classic.grid.plugin) {
  Ext.theme.classic.grid.plugin = {};
}
if (!Ext.theme.gray) {
  Ext.theme.gray = {};
}
if (!Ext.ux) {
  Ext.ux = {};
}
if (!Ext.ux.colorpick) {
  Ext.ux.colorpick = {};
}
var MdsOverrides = MdsOverrides || {};
if (!MdsOverrides.overrides) {
  MdsOverrides.overrides = {};
}
if (!MdsOverrides.overrides.window) {
  MdsOverrides.overrides.window = {};
}
var PhotoID = PhotoID || {};
var SiteWalk360 = SiteWalk360 || {};
var accountShared = accountShared || {};
if (!accountShared.model) {
  accountShared.model = {};
}
if (!accountShared.view) {
  accountShared.view = {};
}
if (!accountShared.view.field) {
  accountShared.view.field = {};
}
var aconex = aconex || {};
if (!aconex.model) {
  aconex.model = {};
}
if (!aconex.view) {
  aconex.view = {};
}
if (!aconex.view.aconexwindow) {
  aconex.view.aconexwindow = {};
}
if (!aconex.view.cards) {
  aconex.view.cards = {};
}
if (!aconex.view.form) {
  aconex.view.form = {};
}
var analytics = analytics || {};
var bim360 = bim360 || {};
if (!bim360.model) {
  bim360.model = {};
}
if (!bim360.store) {
  bim360.store = {};
}
if (!bim360.view) {
  bim360.view = {};
}
if (!bim360.view.bim360window) {
  bim360.view.bim360window = {};
}
if (!bim360.view.cards) {
  bim360.view.cards = {};
}
var bluebeam = bluebeam || {};
if (!bluebeam.model) {
  bluebeam.model = {};
}
if (!bluebeam.view) {
  bluebeam.view = {};
}
if (!bluebeam.view.bluebeamwindow) {
  bluebeam.view.bluebeamwindow = {};
}
if (!bluebeam.view.cards) {
  bluebeam.view.cards = {};
}
var clientHelp = clientHelp || {};
if (!clientHelp.view) {
  clientHelp.view = {};
}
if (!clientHelp.view.helpsequence) {
  clientHelp.view.helpsequence = {};
}
if (!clientHelp.view.helpsequences) {
  clientHelp.view.helpsequences = {};
}
if (!clientHelp.view.newfeature) {
  clientHelp.view.newfeature = {};
}
if (!clientHelp.view.newfeatures) {
  clientHelp.view.newfeatures = {};
}
var clientNavigation = clientNavigation || {};
if (!clientNavigation.model) {
  clientNavigation.model = {};
}
if (!clientNavigation.view) {
  clientNavigation.view = {};
}
if (!clientNavigation.view.clientViewport) {
  clientNavigation.view.clientViewport = {};
}
if (!clientNavigation.view.companyandrole) {
  clientNavigation.view.companyandrole = {};
}
if (!clientNavigation.view.fileUploads) {
  clientNavigation.view.fileUploads = {};
}
var clientPhotoViewerNew = clientPhotoViewerNew || {};
if (!clientPhotoViewerNew.view) {
  clientPhotoViewerNew.view = {};
}
if (!clientPhotoViewerNew.view.main) {
  clientPhotoViewerNew.view.main = {};
}
var clientPunchlist = clientPunchlist || {};
if (!clientPunchlist.model) {
  clientPunchlist.model = {};
}
if (!clientPunchlist.store) {
  clientPunchlist.store = {};
}
if (!clientPunchlist.values) {
  clientPunchlist.values = {};
}
if (!clientPunchlist.view) {
  clientPunchlist.view = {};
}
if (!clientPunchlist.view.assignee) {
  clientPunchlist.view.assignee = {};
}
if (!clientPunchlist.view.assignee.assigneefield) {
  clientPunchlist.view.assignee.assigneefield = {};
}
if (!clientPunchlist.view.category) {
  clientPunchlist.view.category = {};
}
if (!clientPunchlist.view.components) {
  clientPunchlist.view.components = {};
}
if (!clientPunchlist.view.detailForm) {
  clientPunchlist.view.detailForm = {};
}
if (!clientPunchlist.view.fixMemberAccess) {
  clientPunchlist.view.fixMemberAccess = {};
}
if (!clientPunchlist.view.location) {
  clientPunchlist.view.location = {};
}
if (!clientPunchlist.view.punchlist) {
  clientPunchlist.view.punchlist = {};
}
if (!clientPunchlist.view.template) {
  clientPunchlist.view.template = {};
}
var comments = comments || {};
if (!comments.model) {
  comments.model = {};
}
if (!comments.view) {
  comments.view = {};
}
if (!comments.view.batchaddcomment) {
  comments.view.batchaddcomment = {};
}
if (!comments.view.comments) {
  comments.view.comments = {};
}
var customData = customData || {};
if (!customData.fields) {
  customData.fields = {};
}
var files = files || {};
if (!files.model) {
  files.model = {};
}
var filters = filters || {};
if (!filters.view) {
  filters.view = {};
}
var floorplanList = floorplanList || {};
if (!floorplanList.store) {
  floorplanList.store = {};
}
if (!floorplanList.view) {
  floorplanList.view = {};
}
var floorplanViewer = floorplanViewer || {};
if (!floorplanViewer.controller) {
  floorplanViewer.controller = {};
}
if (!floorplanViewer.model) {
  floorplanViewer.model = {};
}
if (!floorplanViewer.store) {
  floorplanViewer.store = {};
}
if (!floorplanViewer.view) {
  floorplanViewer.view = {};
}
if (!floorplanViewer.view.files) {
  floorplanViewer.view.files = {};
}
if (!floorplanViewer.view.files.fileViewer) {
  floorplanViewer.view.files.fileViewer = {};
}
if (!floorplanViewer.view.files.multivistaPhoto) {
  floorplanViewer.view.files.multivistaPhoto = {};
}
if (!floorplanViewer.view.files.photoFileViewer) {
  floorplanViewer.view.files.photoFileViewer = {};
}
if (!floorplanViewer.view.floorplanViewer) {
  floorplanViewer.view.floorplanViewer = {};
}
if (!floorplanViewer.view.punchlistLocation) {
  floorplanViewer.view.punchlistLocation = {};
}
if (!floorplanViewer.view.pushpinFlyout) {
  floorplanViewer.view.pushpinFlyout = {};
}
var formShared = formShared || {};
if (!formShared.model) {
  formShared.model = {};
}
if (!formShared.plugin) {
  formShared.plugin = {};
}
if (!formShared.view) {
  formShared.view = {};
}
if (!formShared.view.components) {
  formShared.view.components = {};
}
if (!formShared.view.grid) {
  formShared.view.grid = {};
}
if (!formShared.view.integrations) {
  formShared.view.integrations = {};
}
var mdsData = mdsData || {};
if (!mdsData.model) {
  mdsData.model = {};
}
if (!mdsData.store) {
  mdsData.store = {};
}
var mdsOverrides = mdsOverrides || {};
if (!mdsOverrides.overrides) {
  mdsOverrides.overrides = {};
}
if (!mdsOverrides.overrides.window) {
  mdsOverrides.overrides.window = {};
}
var mdsPreferences = mdsPreferences || {};
var mdsUtil = mdsUtil || {};
var mdsWidget = mdsWidget || {};
if (!mdsWidget.view) {
  mdsWidget.view = {};
}
var multiupload = multiupload || {};
var mvstr = mvstr || {};
var permissions = permissions || {};
if (!permissions.view) {
  permissions.view = {};
}
var photoActions = photoActions || {};
if (!photoActions.controller) {
  photoActions.controller = {};
}
if (!photoActions.model) {
  photoActions.model = {};
}
if (!photoActions.store) {
  photoActions.store = {};
}
if (!photoActions.view) {
  photoActions.view = {};
}
if (!photoActions.view.addPhotosToAlbum) {
  photoActions.view.addPhotosToAlbum = {};
}
if (!photoActions.view.photosettings) {
  photoActions.view.photosettings = {};
}
if (!photoActions.view.widget) {
  photoActions.view.widget = {};
}
var photoViewer = photoViewer || {};
if (!photoViewer.controller) {
  photoViewer.controller = {};
}
if (!photoViewer.dd) {
  photoViewer.dd = {};
}
if (!photoViewer.draw) {
  photoViewer.draw = {};
}
if (!photoViewer.draw.engine) {
  photoViewer.draw.engine = {};
}
if (!photoViewer.draw.layout) {
  photoViewer.draw.layout = {};
}
if (!photoViewer.model) {
  photoViewer.model = {};
}
if (!photoViewer.store) {
  photoViewer.store = {};
}
if (!photoViewer.view) {
  photoViewer.view = {};
}
if (!photoViewer.view.addphotostoalbum) {
  photoViewer.view.addphotostoalbum = {};
}
if (!photoViewer.view.annotations) {
  photoViewer.view.annotations = {};
}
if (!photoViewer.view.annotations.shapes) {
  photoViewer.view.annotations.shapes = {};
}
if (!photoViewer.view.annotations.sprites) {
  photoViewer.view.annotations.sprites = {};
}
if (!photoViewer.view.annotations.tools) {
  photoViewer.view.annotations.tools = {};
}
if (!photoViewer.view.annotations.widget) {
  photoViewer.view.annotations.widget = {};
}
if (!photoViewer.view.exif) {
  photoViewer.view.exif = {};
}
if (!photoViewer.view.mainpanel) {
  photoViewer.view.mainpanel = {};
}
if (!photoViewer.view.measurements) {
  photoViewer.view.measurements = {};
}
if (!photoViewer.view.pannellum) {
  photoViewer.view.pannellum = {};
}
if (!photoViewer.view.photo) {
  photoViewer.view.photo = {};
}
if (!photoViewer.view.photocontainer) {
  photoViewer.view.photocontainer = {};
}
if (!photoViewer.view.photomenu) {
  photoViewer.view.photomenu = {};
}
if (!photoViewer.view.photoviewer) {
  photoViewer.view.photoviewer = {};
}
if (!photoViewer.view.positioncontrols) {
  photoViewer.view.positioncontrols = {};
}
if (!photoViewer.view.sidepanel) {
  photoViewer.view.sidepanel = {};
}
if (!photoViewer.view.sidepanel.photoviewerannotationspane) {
  photoViewer.view.sidepanel.photoviewerannotationspane = {};
}
if (!photoViewer.view.sidepanel.photoviewermeasurementspane) {
  photoViewer.view.sidepanel.photoviewermeasurementspane = {};
}
if (!photoViewer.view.topbar) {
  photoViewer.view.topbar = {};
}
if (!photoViewer.view.webcam) {
  photoViewer.view.webcam = {};
}
var planGrid = planGrid || {};
if (!planGrid.model) {
  planGrid.model = {};
}
if (!planGrid.store) {
  planGrid.store = {};
}
if (!planGrid.view) {
  planGrid.view = {};
}
if (!planGrid.view.cards) {
  planGrid.view.cards = {};
}
if (!planGrid.view.form) {
  planGrid.view.form = {};
}
if (!planGrid.view.plangridwindow) {
  planGrid.view.plangridwindow = {};
}
var procore = procore || {};
if (!procore.model) {
  procore.model = {};
}
if (!procore.store) {
  procore.store = {};
}
if (!procore.view) {
  procore.view = {};
}
if (!procore.view.cards) {
  procore.view.cards = {};
}
if (!procore.view.cards.dailylogs) {
  procore.view.cards.dailylogs = {};
}
if (!procore.view.form) {
  procore.view.form = {};
}
if (!procore.view.procorefloorplanexport) {
  procore.view.procorefloorplanexport = {};
}
if (!procore.view.procorewindow) {
  procore.view.procorewindow = {};
}
var sharedLookup = sharedLookup || {};
if (!sharedLookup.model) {
  sharedLookup.model = {};
}
if (!sharedLookup.model.date) {
  sharedLookup.model.date = {};
}
if (!sharedLookup.store) {
  sharedLookup.store = {};
}
if (!sharedLookup.store.date) {
  sharedLookup.store.date = {};
}
if (!sharedLookup.view) {
  sharedLookup.view = {};
}
if (!sharedLookup.view.date) {
  sharedLookup.view.date = {};
}
if (!sharedLookup.view.follow) {
  sharedLookup.view.follow = {};
}
var siteWalk360 = siteWalk360 || {};
var viewerPhoto = viewerPhoto || {};
if (!viewerPhoto.model) {
  viewerPhoto.model = {};
}
var webcamShared = webcamShared || {};
if (!webcamShared.view) {
  webcamShared.view = {};
}
if (!webcamShared.view.PTZ) {
  webcamShared.view.PTZ = {};
}
Ext.define('Ext.overrides.Ajax', {override:'Ext.Ajax', timeout:60000, request:function(passedInOptions) {
  if (!passedInOptions) {
    passedInOptions = {};
  }
  if (passedInOptions.useDefaultXhrHeader === undefined) {
    passedInOptions.useDefaultXhrHeader = false;
  }
  if (passedInOptions.withCredentials === undefined) {
    passedInOptions.withCredentials = true;
  }
  if (passedInOptions.url && !passedInOptions.url.match(/:\/\//)) {
    passedInOptions.url = mdslink.server + passedInOptions.url;
  }
  if (!passedInOptions || !passedInOptions.successCallback && !passedInOptions.useDefaults) {
    return this.callParent(arguments);
  }
  var fOptions = {url:undefined, params:{}, successCallback:undefined, noResponseCallback:undefined, afterFailMessageCallback:undefined, disableCaching:true, timeout:Ext.Ajax.timeout};
  if (passedInOptions.mask) {
    if (typeof passedInOptions.mask == 'string') {
      Ext.getBody().mask(passedInOptions.mask);
    } else {
      Ext.getBody().mask();
    }
  }
  for (var key in passedInOptions) {
    if (passedInOptions.hasOwnProperty(key)) {
      fOptions[key] = passedInOptions[key];
    }
  }
  if (fOptions.successCallback && passedInOptions.scope) {
    fOptions.successCallback = Ext.bind(fOptions.successCallback, passedInOptions.scope);
  }
  if (fOptions.afterFailMessageCallback && passedInOptions.scope) {
    fOptions.afterFailMessageCallback = Ext.bind(fOptions.afterFailMessageCallback, passedInOptions.scope);
  }
  fOptions.callback = function(options, success, response) {
    if (passedInOptions.mask) {
      Ext.getBody().unmask();
    }
    try {
      var responseJSON = Ext.decode(response.responseText);
    } catch (e$4) {
      var message = response.responseText.match('Client Login') ? window.mvstr ? mvstr.G_LoginRequired : 'User login required.' : window.mvstr ? mvstr.G_UnexpectedError : 'An unexpected error has occurred.';
      if (!passedInOptions.noAlert) {
        Ext.Msg.alert(window.mvstr ? mvstr.G_Error : 'Error', message);
      }
      if (fOptions.afterFailMessageCallback) {
        fOptions.afterFailMessageCallback(null, message);
      }
      return;
    }
    if (responseJSON) {
      if (!responseJSON.success && responseJSON.success !== undefined) {
        if (responseJSON.message != '' && !passedInOptions.noAlert) {
          Ext.Msg.alert(' ', responseJSON.message);
        } else {
          if (!passedInOptions.noAlert) {
            Ext.Msg.alert(window.mvstr ? mvstr.G_Error : 'An unexpected error has occurred.', window.mvstr ? mvstr.G_UnexpectedError : 'An unexpected error has occurred.');
          }
        }
        if (fOptions.afterFailMessageCallback) {
          fOptions.afterFailMessageCallback(responseJSON.data, responseJSON.message);
        }
      } else {
        if (fOptions.successCallback) {
          fOptions.successCallback(responseJSON.data !== undefined ? responseJSON.data : responseJSON);
        }
      }
    } else {
      if (fOptions.noResponseCallback) {
        fOptions.noResponseCallback();
      }
    }
  };
  return this.callParent([fOptions]);
}, postFormData:function(url, data, submitOptions) {
  var form = Ext.create('Ext.form.Panel', {standardSubmit:true, url:url});
  for (var key in data) {
    form.add({xtype:'textfield', name:key, value:data[key]});
  }
  if (submitOptions === undefined) {
    submitOptions = {};
  }
  form.submit(submitOptions);
}});
Ext.define('Ext.overrides.event.Event', {override:'Ext.event.Event', getWheelDeltas:function() {
  var me = this, event = me.browserEvent, dx = 0, dy = 0;
  if (Ext.isDefined(event.wheelDeltaX)) {
    dx = event.wheelDeltaX;
    dy = event.wheelDeltaY;
  } else {
    if (event.wheelDelta) {
      dy = event.wheelDelta;
    } else {
      if (event.detail) {
        dy = -event.detail;
        if (dy > 100) {
          dy = 3;
        } else {
          if (dy < -100) {
            dy = -3;
          }
        }
        if (Ext.isDefined(event.axis) && event.axis === event.HORIZONTAL_AXIS) {
          dx = dy;
          dy = 0;
        }
      } else {
        if (event.deltaX || event.deltaY) {
          dx = event.deltaX * -1;
          dy = event.deltaY * -1;
        }
      }
    }
  }
  return {x:me.correctWheelDelta(dx), y:me.correctWheelDelta(dy)};
}});
Ext.define('Ext.overrides.util.MixedCollection', {override:'Ext.util.MixedCollection', add:function(key, obj) {
  if (arguments.length === 1 && typeof key == 'object' && key.isController) {
    return (arguments.callee.$previous || Ext.util.AbstractMixedCollection.prototype.add).call(this, key.$className, key);
  }
  return (arguments.callee.$previous || Ext.util.AbstractMixedCollection.prototype.add).apply(this, arguments);
}});
Ext.define('Ext.overrides.dom.Element', {override:'Ext.dom.Element', setStyle:function(prop, value) {
  if (!this.dom) {
    return;
  }
  return arguments.callee.$previous.apply(this, arguments);
}});
Ext.define('Ext.overrides.util.Format', {override:'Ext.util.Format', fileSize:function(size) {
  if (size == 0) {
    return '';
  }
  return this.callParent(arguments);
}, date:function(value, format) {
  if (format.substr(0, 5) == 'DATE_') {
    format = mvstr[format];
  }
  return this.callParent([value, format]);
}});
if (!window.config) {
  window.config = {};
}
config.ISARCHIVE = true;
Ext.cmd.derive('Ext.MDSLink', Ext.Base, {statics:{links:{adminCompanyMembersList:'/index.cfm?fuseaction\x3dcompanyadmin.memberlist\x26', adminMegaViewer:'/index.cfm?fuseaction\x3daAdminMegaViewer.home\x26', adminMembersList:'/index.cfm?fuseaction\x3dmemberadmin.list', adminProjectAdd:'/index.cfm?fuseaction\x3daAdmin.projectAdd', adminProjectGrid:'/index.cfm?fuseaction\x3daAdmin.projectgrid\x26', adminProjectList:'/index.cfm?fuseaction\x3daAdmin.projectlist\x26', adminProjectsMap:'/index.cfm?fuseaction\x3daAdmin.projectMaplist\x26', 
adminProjectMembersList:'/index.cfm?fuseaction\x3dmemberadmin.projectlist\x26', adminScheduler:'index.cfm?fuseaction\x3daAdmin.adminScheduler', adminSpecialPlans:'/index.cfm?fuseaction\x3daAdminPlan.admin\x26', adminVideo:'/index.cfm?fuseaction\x3daAdminVideo.home\x26', adminWebcamProjectGrid:'/index.cfm?fuseaction\x3daAdminWebcam.projectGrid\x26', adminWebcamGrid:'/index.cfm?fuseaction\x3daAdminWebcam.grid', adminWebcamThumb:'/index.cfm?fuseaction\x3daAdminWebcam.thumb', adminUserAdd:'/index.cfm?fuseaction\x3daAdmin.addUser', 
adminUserEdit:'/index.cfm?fuseaction\x3daAdmin.editUser\x26', client3DImmersive:'/index.cfm?fuseaction\x3daClient3DImmersive.home\x26', client3DImmersiveViewer:'/index.cfm?fuseaction\x3daClient3DImmersive.view\x26', clientAccount:'/index.cfm?fuseaction\x3daClientDashboard.home#account', clientNotifications:'/index.cfm?fuseaction\x3daClientDashboard.home#notifications', clientDashboard:'/index.cfm?fuseaction\x3daClientDashboard.home', clientFileManager:'/index.cfm?fuseaction\x3daClientFileManager.view\x26', 
clientFloorplanOverview:'/index.cfm?fuseaction\x3daClientFloorplanOverview.home\x26', clientFloorplanOverview_workingPlans:'/index.cfm?fuseaction\x3daClientFloorplanOverview.workingPlans\x26', clientPunchlistPlans:'/index.cfm?fuseaction\x3daClientPunchlist.plans\x26', clientFloorplanViewer:'/index.cfm?fuseaction\x3daClientFloorplanViewer.view\x26', clientFloorplanViewer_punchlistPlan:'/index.cfm?fuseaction\x3daClientFloorplanViewer.view\x26', clientMegaViewer:'/index.cfm?fuseaction\x3daClientMegaViewer.home\x26', 
clientPeopleOverview:'/index.cfm?fuseaction\x3daClientPeopleOverview.home\x26', clientPhotoList:'/index.cfm?fuseaction\x3daClientPhotoList.home\x26', clientPhotoViewer:'/index.cfm?fuseaction\x3daClientPhotoViewer.view\x26', clientPunchlistOverview_Base:'/index.cfm?fuseaction\x3daClientPunchlist.view\x26', clientPunchlistEntry:'/index.cfm?fuseaction\x3daClientPunchlist.entry\x26', clientTagSearch:'/index.cfm?fuseaction\x3daClientTagSearch.home\x26', clientUserAdd:'/index.cfm?fuseaction\x3daClientPeopleOverview.addUser\x26', 
clientVideo:'/index.cfm?fuseaction\x3daClientVideo.home\x26', clientWebcamLive:'/index.cfm?fuseaction\x3daClientWebcam.live\x26', clientWebcamGridView:'/index.cfm?fuseaction\x3daClientWebcam.grid\x26', clientWebcamOverview:'/index.cfm?fuseaction\x3daClientWebcam.home\x26', clientWebcamTimelapse:'/index.cfm?fuseaction\x3daClientWebcam.timelapse\x26', home:'/index.cfm?fuseaction\x3dhome.gateway', logout:'/index.cfm?fuseaction\x3dmember.logout', profile:'/index.cfm?fuseaction\x3dmember.profileform', 
projectAnalytics:'/index.cfm?fuseaction\x3dprojectadmin.analytics\x26', projectGateway:'/index.cfm?fuseaction\x3daClientNavigation.ProjectGateway\x26', projectEdit:'/index.cfm?fuseaction\x3dprojectadmin.navigation_tiled\x26', projectEditJump:'/index.cfm?fuseaction\x3daClientNavigation.adminEditJump\x26', projectView:'/index.cfm?fuseaction\x3daClientNavigation.adminviewjump\x26', publicWebcamEmbed:'/index.cfm?fuseaction\x3daPublicWebcam.embed\x26', publicWebcamPage:'/index.cfm?fuseaction\x3daPublicWebcam.page\x26', 
notificationLink:'/index.cfm?fuseaction\x3daNotifications.link\x26'}}, singleton:true, constructor:function() {
  this.callParent(arguments);
  window.mdslink = this.self.links;
  mdslink.server = '';
  if (window.config && config.ISARCHIVE) {
    mdslink.clientFileManager = 'fileManager.htm?';
    mdslink.clientFloorplanOverview = 'floorplanOverview.htm?';
    mdslink.clientFloorplanViewer = 'floorplanViewer.htm?';
    mdslink.clientVideo = 'clientVideo.htm?';
    mdslink.clientPeopleOverview = 'peopleOverview.htm?';
    mdslink.clientPhotoList = 'photoList.htm?';
    mdslink.clientPhotoViewer = 'photoViewerNew.htm?';
    mdslink.clientWebcamOverview = 'webcamOverview.htm?';
    mdslink.clientWebcamTimelapse = 'webcamTimelapse.htm?';
    mdslink.projectGateway = mdslink[config.GATEWAY];
    mdslink.home = '../index.htm';
  }
  mdslink.clientPunchlistOverview = mdslink.clientPunchlistOverview_Base + 'ListTypeID\x3d1\x26';
  mdslink.clientPunchlistOverview_QAQCList = mdslink.clientPunchlistOverview_Base + 'ListTypeID\x3d2\x26';
  mdslink.clientPunchlistOverview_FMList = mdslink.clientPunchlistOverview_Base + 'ListTypeID\x3d3\x26';
}}, 1, 0, 0, 0, 0, 0, [Ext, 'MDSLink'], 0);
Ext.cmd.derive('mdsOverrides.mvstr', Ext.Base, {'singleton':true, 'alternateClassName':'mvstr'}, 0, 0, 0, 0, 0, 0, [mdsOverrides, 'mvstr', 0, 'mvstr'], 0);
Ext.define('Ext.overrides.Template', {override:'Ext.Template', constructor:function(html) {
  arguments.callee.$previous.apply(this, arguments);
  var linkMatches = this.html.match(/\{mdslink_[^\{]+\}/g), translationMatches = this.html.match(/mvstr\[[^\]]+\]/g);
  if (linkMatches) {
    for (var i = 0; i < linkMatches.length; i++) {
      var linkMatch = linkMatches[i], linkName = linkMatch.match(/\{mdslink_([^\{]+)\}/)[1], linkValue = mdslink[linkName] ? mdslink[linkName] : '';
      this.html = this.html.replace(linkMatch, linkValue);
    }
  }
  if (translationMatches) {
    for (var i = 0; i < translationMatches.length; i++) {
      var referenceVar = translationMatches[i].match(/mvstr\[([^\]]+)\]/)[1];
      this.html = this.html.replace(translationMatches[i], mvstr[referenceVar]);
    }
  }
}});
Ext.define('Ext.overrides.scroll.Scroller', {override:'Ext.scroll.Scroller', privates:{restoreState:function() {
  if (!this.mvDisableRestoreState) {
    return arguments.callee.$previous.apply(this, arguments);
  }
}}});
Ext.define('Ext.theme.classic.Component', {override:'Ext.Component'}, function() {
  Ext.namespace('Ext.theme.is').Classic = true;
  Ext.theme.name = 'Classic';
});
Ext.define('Ext.theme.gray.Component', {override:'Ext.Component'}, function() {
  Ext.namespace('Ext.theme.is').Gray = true;
  Ext.theme.name = 'Gray';
});
Ext.define('Ext.overrides.Component', {override:'Ext.Component', privates:{applyBind:function(binds, currentBindings) {
  for (var prop in binds) {
    if (typeof binds[prop] == 'object') {
      continue;
    }
    var linkMatches = binds[prop].match(/\{mdslink_[^\{]+\}/g), translationMatches = binds[prop].match(/mvstr\[[^\]]+\]/g);
    if (translationMatches) {
      for (var i = 0; i < translationMatches.length; i++) {
        var referenceVar = translationMatches[i].match(/mvstr\[([^\]]+)\]/)[1];
        binds[prop] = binds[prop].replace(translationMatches[i], mvstr[referenceVar]);
      }
    }
    if (linkMatches) {
      for (var i = 0; i < linkMatches.length; i++) {
        var linkMatch = linkMatches[i], linkName = linkMatch.match(/\{mdslink_([^\{]+)\}/)[1], linkValue = mdslink[linkName] ? mdslink[linkName] : '';
        binds[prop] = binds[prop].replace(linkMatch, linkValue);
      }
    }
  }
  return arguments.callee.$previous.apply(this, arguments);
}}, config:{mvPreloadImages:null, loadMaskCls:null, maskCls:null}, removeCls:function() {
  var me = this, el = me.rendered ? me.el : me.protoEl;
  if (el) {
    el.removeCls.apply(el, arguments);
  }
  return me;
}, addCls:function(cls) {
  var me = this, el = me.rendered ? me.el : me.protoEl;
  if (el) {
    el.addCls.apply(el, arguments);
  }
  return me;
}, updateMvPreloadImages:function(preloadImages) {
  if (preloadImages) {
    for (var i = 0; i < preloadImages.length; i++) {
      var tempImage = new Image;
      tempImage.src = preloadImages[i];
    }
  }
}, setLoading:function() {
  var mask = arguments.callee.$previous.apply(this, arguments), loadMaskCls = this.getLoadMaskCls();
  if (mask && loadMaskCls) {
    mask.el.addCls(loadMaskCls);
  }
  return mask;
}, mask:function() {
  arguments.callee.$previous.apply(this, arguments);
  var maskCls = this.getMaskCls();
  if (maskCls) {
    var target = this.getMaskTarget() || this.el, data = target.getData(), maskEl = data.maskEl;
    maskEl.addCls(maskCls);
  }
}, constructor:function(config) {
  config = config || {};
  var localized = Ext.clone(this.config.localized) || Ext.clone(this.localized) || {};
  localized = Ext.merge(localized, config.localized || {});
  var me = this, translationKey, regex = /mvstr\[[^\]]+\]/g;
  if (Ext.isObject(localized)) {
    for (var prop in localized) {
      if (config[prop] !== undefined) {
        continue;
      }
      translationKey = localized[prop];
      if (translationKey && typeof translationKey == 'string') {
        if (mvstr[translationKey]) {
          config[prop] = mvstr[translationKey];
        } else {
          if (translationKey.match(regex)) {
            var matches = translationKey.match(regex);
            for (var i = 0; i < matches.length; i++) {
              var referenceVar = matches[i].match(/mvstr\[([^\]]+)\]/)[1];
              translationKey = translationKey.replace(matches[i], mvstr[referenceVar]);
            }
            config[prop] = translationKey;
          } else {
            console.error('Missing translation (' + mvstr.LanguageID + ") for key '" + translationKey + "'.");
          }
        }
      } else {
        if (typeof translationKey == 'object') {
          var value = translationKey[mvstr.LanguageID];
          if (value === undefined) {
            value = translationKey['default'];
          }
          if (value !== undefined) {
            config[prop] = value;
          }
        }
      }
    }
  }
  arguments.callee.$previous.call(this, config);
}});
Ext.define('Ext.overrides.data.Field', {override:'Ext.data.Field', constructor:function(config) {
  var fieldNames = ['ProjectUID', 'ListTypeID'];
  if (mdslink[config.name]) {
    config.defaultValue = mdslink[config.name];
  } else {
    if (Ext.Array.contains(fieldNames, config.name)) {
      var queryStringData = Ext.Object.fromQueryString(document.location.search);
      if (queryStringData[config.name]) {
        config.defaultValue = queryStringData[config.name];
      }
    }
  }
  arguments.callee.$previous.apply(this, arguments);
}});
Ext.define('Ext.overrides.data.Model', {override:'Ext.data.Model', privates:{statics:{initFields:function(data, cls, proto) {
  var me = this, idField;
  me.callParent(arguments);
  idField = proto.idField;
  idField.defaultValue = idField.convert ? undefined : null;
  idField.defaultValue = idField.calculate ? undefined : null;
}}}, save:function(options) {
  if (!options) {
    options = {};
  }
  var successCallback = options.success ? options.success : options.silentSuccess ? Ext.emptyFn : function() {
    Ext.Msg.alert(window.mvstr ? mvstr.G_Success : 'Success', window.mvstr ? mvstr.G_SuccessMsg : 'Changes were successfully saved.');
  }, afterFailMessageCallback = options.afterFailMessageCallback ? options.afterFailMessageCallback : Ext.emptyFn;
  if (options.scope) {
    successCallback = Ext.bind(successCallback, options.scope);
    afterFailMessageCallback = Ext.bind(afterFailMessageCallback, options.scope);
  }
  if (!options.failure) {
    options.failure = function(record, operation) {
      var message = window.mvstr ? mvstr.G_UnexpectedError : 'An unexpected error has occurred.';
      try {
        var responseMessage = Ext.JSON.decode(operation.getResponse().responseText).message;
        if (responseMessage) {
          message = responseMessage;
        }
      } catch (e$5) {
      }
      Ext.Msg.alert(window.mvstr ? mvstr.G_Error : 'Error', message);
      afterFailMessageCallback(record, operation);
    };
  }
  options.success = function(record, operation) {
    try {
      var data = Ext.JSON.decode(operation.getResponse().responseText).data;
    } catch (e$6) {
      options.failure(record, operation);
      return;
    }
    successCallback(record, operation, data);
  };
  arguments.callee.$previous.call(this, options);
}});
Ext.define('Ext.overrides.data.proxy.Ajax', {override:'Ext.data.proxy.Ajax', timeout:60000, config:{useDefaultXhrHeader:false, withCredentials:true, reader:{type:'json', messageProperty:'message'}, writer:{writeAllFields:true}}, constructor:function(config) {
  if (config && config.url && !config.url.match('^' + mdslink.server) && !config.url.match(/:\/\//)) {
    config.url = mdslink.server + config.url;
  }
  (arguments.callee.$previous || Ext.data.proxy.Server.prototype.constructor).apply(this, arguments);
}, processResponse:function() {
  var reader = this.getReader();
  if (reader && reader.mvMessage) {
    delete reader.mvMessage;
  }
  return (arguments.callee.$previous || Ext.data.proxy.Server.prototype.processResponse).apply(this, arguments);
}});
Ext.define('Ext.overrides.data.reader.Json', {override:'Ext.data.reader.Json', extractRecord:function(node, readOptions, entityType, includes, fieldExtractorInfo) {
  if (!this.getFields) {
    return (arguments.callee.$previous || Ext.data.reader.Reader.prototype.extractRecord).apply(this, arguments);
  }
  var record = (arguments.callee.$previous || Ext.data.reader.Reader.prototype.extractRecord).apply(this, arguments);
  var idProperty = this.getModel().idProperty, fields = this.getFields();
  for (var i = 0, j = fields.length; i < j; i++) {
    if (fields[i].name == idProperty) {
      var calculate = fields[i].calculate;
      if (calculate) {
        record.set(idProperty, calculate(record.getData()));
        return record;
      }
    }
  }
  return record;
}});
Ext.define('Ext.overrides.data.Store', {override:'Ext.data.Store', proxy:{type:'ajax', reader:{type:'json', transform:{fn:function(data) {
  this.mvMessage = data && data.message ? data.message : '';
  return data;
}}}}, constructor:function(config) {
  if (this.config && typeof this.config.proxy == 'string' || config && typeof config.proxy == 'string') {
    (arguments.callee.$previous || Ext.data.ProxyStore.prototype.constructor).apply(this, arguments);
    return;
  }
  var rootProperty = undefined, root = undefined, type = undefined;
  if (this.config && this.config.proxy && this.config.proxy.reader && this.config.proxy.reader.rootProperty !== undefined) {
    rootProperty = this.config.proxy.reader.rootProperty;
  }
  if (config && config.proxy && config.proxy.reader && config.proxy.reader.rootProperty !== undefined) {
    rootProperty = config.proxy.reader.rootProperty;
  }
  if (this.config && this.config.root) {
    root = this.config.root;
  }
  if (config && config.root) {
    root = config.root;
  }
  if (this.config && this.config.type) {
    type = this.config.type;
  }
  if (config && config.type) {
    type = config.type;
  }
  if (!root && rootProperty === undefined && type != 'tree') {
    if (!config) {
      config = {};
    }
    if (!config.proxy) {
      config.proxy = {};
    }
    if (!config.proxy.reader) {
      config.proxy.reader = {};
    }
    config.proxy.reader.rootProperty = 'data';
  }
  (arguments.callee.$previous || Ext.data.ProxyStore.prototype.constructor).call(this, config);
  if (config && config.mvCanAbort || this.config && this.mvCanAbort) {
    this.addListener('beforeload', function(store, operation) {
      store.mvLastOperation = operation;
    }, this);
  }
}, mvAbort:function() {
  if (this.loading && this.mvLastOperation) {
    var requests = Ext.Ajax.requests;
    for (var id in requests) {
      if (requests.hasOwnProperty(id) && requests[id].options.operation == this.mvLastOperation) {
        Ext.Ajax.abort(requests[id]);
        delete requests[id];
        return;
      }
    }
  }
}, sync:function(options) {
  if (!options) {
    options = {};
  }
  var silentSuccess = options.silentSuccess !== undefined ? options.silentSuccess : !!this.silentSuccess;
  if (!options.success && !silentSuccess && !options.noAlert) {
    options.success = function() {
      Ext.Msg.alert(window.mvstr ? mvstr.G_Success : 'Success', window.mvstr ? mvstr.G_SuccessMsg : 'Changes were successfully saved.');
    };
  }
  if (!options.failure) {
    options.failure = function(batch) {
      var mvMessage = batch.proxy.getReader().mvMessage, message = mvMessage ? mvMessage : window.mvstr ? mvstr.G_UnexpectedError : 'An unexpected error has occurred.', operation = batch.getOperations()[0];
      if (operation && operation.error && typeof operation.error === 'string') {
        message = operation.error;
      }
      if (!options.noAlert) {
        Ext.Msg.alert(window.mvstr ? mvstr.G_Error : 'Error', message);
      }
      if (options.afterFailMessageCallback) {
        options.afterFailMessageCallback.call(options.scope || window, batch, message);
      }
    };
  }
  var needsSync = this.getNewRecords().length || this.getUpdatedRecords().length || this.getRemovedRecords().length ? true : false;
  (arguments.callee.$previous || Ext.data.ProxyStore.prototype.sync).call(this, options);
  return needsSync;
}, refreshFilters:function() {
  var filtersArray = this.filters ? this.filters.getRange() : [];
  if (filtersArray.length == 0) {
    this.clearFilter(false);
    return;
  }
  this.clearFilter(true);
  for (var i = 0; i < filtersArray.length; i++) {
    this.addFilter(filtersArray[i]);
  }
}, reset:function() {
  this.clearFilter();
  this.removeAll(true);
  this.loadCount = 0;
}});
Ext.cmd.derive('mdsPreferences.Local', Ext.Base, {identification:null, initializeIdentification:Ext.emptyFn, showLog:false, getStorage:function(identification) {
  identification = this.getIdentification();
  var keys = Ext.Array.sort(Ext.Object.getKeys(identification)), idValues = [];
  for (var i = 0; i < keys.length; i++) {
    idValues.push(identification[keys[i]]);
  }
  var id = idValues.join('');
  if (!id) {
    throw 'Need to identify storage';
  }
  return Ext.util.LocalStorage.get(id);
}, getIdentification:function(identification) {
  if (!identification) {
    identification = this.identification;
  }
  if (!identification) {
    throw 'Need to identify storage';
  }
  return identification;
}, logActivity:function(action, keyName, data) {
  var showData = action != 'Removed';
}, getListValue:function(keyName, identification) {
  var storage = this.getStorage(this.getIdentification(identification)), data = storage.getItem(keyName);
  data = data ? data.split(',') : [];
  this.logActivity('Retrieved', keyName, data);
  storage.release();
  return data;
}, setListValue:function(keyName, dataArray, identification) {
  var storage = this.getStorage(this.getIdentification(identification)), data = dataArray.join(',');
  storage.setItem(keyName, data);
  this.logActivity('Set', keyName, data);
  storage.release();
}, getValue:function(keyName, identification) {
  var storage = this.getStorage(this.getIdentification(identification)), data = storage.getItem(keyName);
  this.logActivity('Retrieved', keyName, data);
  storage.release();
  return data;
}, setValue:function(keyName, data, identification) {
  var storage = this.getStorage(this.getIdentification(identification));
  storage.setItem(keyName, data);
  this.logActivity('Set', keyName, data);
  storage.release();
}, removeValue:function(keyName, identification) {
  var storage = this.getStorage(this.getIdentification(identification));
  storage.removeItem(keyName);
  this.logActivity('Removed', keyName);
  storage.release();
}, getNumericValue:function(keyName, identification) {
  var storage = this.getStorage(this.getIdentification(identification)), data = storage.getItem(keyName);
  data = data !== undefined ? Number(data) : undefined;
  this.logActivity('Retrieved', keyName, data);
  storage.release();
  return data;
}, getBooleanValue:function(keyName, identification) {
  var storage = this.getStorage(this.getIdentification(identification)), data = storage.getItem(keyName);
  data = data === null ? undefined : data == 'true' ? true : false;
  storage.release();
  return data;
}, setBooleanValue:function(keyName, data, identification) {
  this.setValue(keyName, data, identification);
}, getDateValue:function(keyName, identification, dateFormat) {
  var storage = this.getStorage(this.getIdentification(identification)), data = storage.getItem(keyName);
  dateFormat = dateFormat || 'Y-m-d';
  data = data === null ? undefined : Ext.Date.parse(data, dateFormat);
  storage.release();
  return data || null;
}, setDateValue:function(keyName, data, identification, dateFormat) {
  dateFormat = dateFormat || 'Y-m-d';
  this.setValue(keyName, Ext.Date.format(data, dateFormat), identification);
}, getObjectValue:function(keyName, identification) {
  var storage = this.getStorage(this.getIdentification(identification)), data = storage.getItem(keyName);
  try {
    data = Ext.decode(data);
  } catch (e$7) {
    data = {};
  }
  this.logActivity('Retrieved', keyName, data);
  storage.release();
  return data;
}, setObjectValue:function(keyName, data, identification) {
  var storage = this.getStorage(this.getIdentification(identification));
  storage.setItem(keyName, Ext.encode(data));
  this.logActivity('Set', keyName, data);
  storage.release();
}}, 0, 0, 0, 0, 0, 0, [mdsPreferences, 'Local'], 0);
Ext.cmd.derive('mdsPreferences.GlobalPreferences', mdsPreferences.Local, {singleton:true, getStorage:function(identification) {
  identification = identification || this.getIdentification();
  return Ext.util.LocalStorage.get(identification);
}, getIdentification:function() {
  return 'MDS';
}, getLang:function() {
  return this.getValue('lang');
}, setLang:function(lang) {
  this.setValue('lang', lang);
}, removeLang:function() {
  this.removeValue('lang');
}}, 0, 0, 0, 0, 0, 0, [mdsPreferences, 'GlobalPreferences'], 0);
Ext.define('Ext.overrides.app.Application', {override:'Ext.app.Application', onProfilesReady:function() {
  var me = this;
  if (me.mvInitLocale === undefined) {
    me.mvInitLocale = true;
  }
  if (!me.mvInitLocale || me.mvLanguageInitialized) {
    return arguments.callee.$previous.apply(this, arguments);
  } else {
    me.initLang().then(function() {
      me.mvLanguageInitialized = true;
      me.onProfilesReady();
    });
  }
}, getLang:function() {
  return new Ext.Promise(Ext.bind(function(resolve) {
    var defaultLang = 'en', isPublic = !!this.getName().match(/^public/), isAdmin = !!this.getName().match(/^admin/), isRender = !!this.getName().match(/^render/);
    if (isPublic || isAdmin || isRender) {
      resolve(defaultLang);
    }
    var langOverride = Ext.Object.fromQueryString(document.location.search).lang, lang = langOverride || mdsPreferences.GlobalPreferences.getLang();
    if (lang) {
      resolve(lang);
    } else {
      Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daClientNavigation.getLanguagePreference', scope:this, successCallback:function(data) {
        mdsPreferences.GlobalPreferences.setLang(data);
        resolve(data);
      }, failure:function() {
        mdsPreferences.GlobalPreferences.setLang(defaultLang);
        resolve(defaultLang);
      }, noAlert:true}, this);
    }
  }, this));
}, initLang:function() {
  return new Ext.Promise(Ext.bind(function(resolve) {
    this.getLang().then(function(lang) {
      if (window.moment) {
        moment.locale(lang);
      }
      var url = 'mds/locale/' + lang + '/ext-locale.js';
      Ext.Loader.loadScript({url:url});
      Ext.Loader.loadScript({url:'mds/locale/' + lang + '/translation.js'});
      Ext.Loader.onReady(resolve);
    });
  }, this));
}});
Ext.define('Ext.overrides.app.ViewController', {override:'Ext.app.ViewController'});
Ext.define('Ext.overrides.data.Batch', {override:'Ext.data.Batch', getError:function() {
  if (this.hasException) {
    return this.getExceptions()[0].getError();
  }
  return null;
}});
Ext.define('Ext.overrides.app.ViewModel', {override:'Ext.app.ViewModel', constructor:function(config) {
  var urlPropNames = ['ProjectUID', 'Model3DID', 'FloorplanUID', 'GetWorkingPlans', 'ListTypeID', 'ProjectID', 'SearchString', 'PunchItemID', 'PushpinUID', 'ClosedView', 'ListTypeID', 'PunchStatusID', 'HotspotID', 'SNID1', 'SNID2', 'SAID1', 'SAID2', 'DroneDeployPlanID', 'planID', 'CompanyUID'], queryStringData = Ext.Object.fromQueryString(document.location.search);
  if (!config) {
    config = {};
  }
  Ext.applyIf(config, this.config);
  if (!config.data) {
    config.data = {};
  }
  Ext.applyIf(config.data, this.config.data || {});
  if (!config.mvRecords) {
    config.mvRecords = {};
  }
  Ext.applyIf(config.mvRecords, this.config.mvRecords || {});
  if (!config.formulas) {
    config.formulas = {};
  }
  Ext.applyIf(config.formulas, this.config.formulas || {});
  if (!config.stores) {
    config.stores = {};
  }
  Ext.applyIf(config.stores, this.config.stores || {});
  for (var datumName in config.data) {
    var linkMatch = datumName.match(/^mdslink_(.+)$/);
    if (linkMatch) {
      config.data[datumName] = mdslink[linkMatch[1]];
    } else {
      if (typeof config.data[datumName] == 'object') {
        for (var propName in config.data[datumName]) {
          var linkMatch = propName.match(/^mdslink_(.+)$/);
          if (linkMatch) {
            config.data[datumName][propName] = mdslink[linkMatch[1]];
          }
        }
      } else {
        if (Ext.Array.contains(urlPropNames, datumName) && config.data[datumName] === '') {
          for (var queryStringName in queryStringData) {
            if (queryStringName.toLowerCase() == datumName.toLowerCase()) {
              config.data[datumName] = queryStringData[queryStringName];
              if (!isNaN(config.data[datumName])) {
                config.data[datumName] = Number(config.data[datumName]);
              }
              break;
            }
          }
        }
      }
    }
  }
  for (var mvRecConfigName in config.mvRecords) {
    var mvRecConfig = config.mvRecords[mvRecConfigName], key = mvRecConfigName, idName = mvRecConfig.idName, recordName = '_record' + key;
    if (typeof idName == 'string') {
      idName = [idName];
    }
    if (config.formulas[mvRecConfigName]) {
      continue;
    }
    config.data[recordName] = null;
    var bind = {record:'{' + recordName + '}', recordName:recordName, modelName:mvRecConfig.modelName, idName:idName};
    for (var i = 0; i < idName.length; i++) {
      bind['id' + i] = '{' + idName[i] + '}';
    }
    config.formulas[key] = {bind:bind, get:this.mvRecordFn};
  }
  if (!config.data) {
    config.data = {};
  }
  for (var storeName in config.stores) {
    if (config.stores[storeName].mvAutoLoadVars) {
      config.stores[storeName].name = storeName;
      if (!config.stores[storeName].listeners) {
        config.stores[storeName].listeners = {};
      }
      config.stores[storeName].listeners.load = {fn:this.mvAutoLoadVarOnLoad, scope:'controller'};
      config.stores[storeName].listeners.beforeload = {fn:this.mvAutoLoadVarBeforeLoad, scope:'controller'};
      config.data['_' + storeName + 'Loaded'] = false;
    }
    if (config.stores[storeName].mvAutoDataChangedVar) {
      config.stores[storeName].name = storeName;
      if (!config.stores[storeName].listeners) {
        config.stores[storeName].listeners = {};
      }
      config.stores[storeName].listeners.datachanged = {fn:this.mvAutoDataChangedVarOnDataChanged, scope:'controller'};
      config.data['_' + storeName + 'DataChanged'] = -1;
    }
  }
  arguments.callee.$previous.call(this, config);
}, mvRecordFn:function(data) {
  var record = data.record, params = {};
  if (record) {
    return record;
  }
  for (var i = 0; i < data.idName.length; i++) {
    if (!data['id' + i]) {
      return null;
    }
    params[data.idName[i]] = data['id' + i];
  }
  record = Ext.create(data.modelName);
  record.getProxy().setExtraParams(params);
  record.load({success:function() {
    if (!this.isDestroyed) {
      this.set(data.recordName, record);
    }
  }, scope:this});
}, mvAutoLoadVarOnLoad:function(store) {
  this.getViewModel().set('_' + store.name + 'Loaded', true);
}, mvAutoLoadVarBeforeLoad:function(store) {
  this.getViewModel().set('_' + store.name + 'Loaded', false);
}, mvAutoDataChangedVarOnDataChanged:function(store) {
  var datumName = '_' + store.name + 'DataChanged', viewModel = this.getViewModel();
  if (store.isLoaded() && viewModel.get(datumName) == -1) {
    viewModel.set(datumName, 0);
  } else {
    viewModel.set(datumName, (new Date).getTime());
  }
}, doArrayPush:function(arrName, pushArg) {
  var arr = this.get(arrName);
  arr.push(pushArg);
  this.set(arrName, Ext.Array.clone(arr));
}, doArrayPop:function(arrName) {
  var arr = this.get(arrName), val = arr.pop();
  this.set(arrName, Ext.Array.clone(arr));
  return val;
}, doArrayRemove:function(arrName) {
  var arr = this.get(arrName), val = arr.pop();
  this.set(arrName, Ext.Array.clone(arr));
  return val;
}});
Ext.define('Ext.overrides.ZIndexManager', {override:'Ext.ZIndexManager', privates:{showModalMask:function(comp) {
  var me = this, compEl = comp.el, maskParent = comp.maskParent || comp.floatParent, maskTarget = maskParent ? maskParent.getEl() : comp.container, mask = me.mask;
  if (!mask) {
    me.mask = mask = Ext.getBody().createChild({role:'presentation', cls:'x-mask x-border-box' + (comp.modalMaskCls ? ' ' + comp.modalMaskCls : ''), style:'height:0;width:0'});
    mask.setVisibilityMode(Ext.Element.DISPLAY);
    mask.on({mousedown:me.onMaskMousedown, click:me.onMaskClick, scope:me});
  } else {
    me.hideModalMask();
  }
  mask.maskTarget = maskTarget;
  maskTarget.saveTabbableState({excludeRoot:compEl});
  me.syncModalMask(comp);
}}});
Ext.define('Ext.overrides.container.Container', {override:'Ext.container.Container', privates:{repositionFloatingItems:function() {
  var floaters = this.floatingItems, floaterCount, i, floater;
  if (floaters) {
    floaters = floaters.items;
    floaterCount = floaters.length;
    for (i = 0; i < floaterCount; i++) {
      floater = floaters[i];
      if (floater.el && !floater.hidden && !floater.noRepositionFloatingItems) {
        floater.setPosition(floater.x, floater.y);
      }
    }
  }
}}, getComponent:function(comp) {
  if (Ext.isObject(comp)) {
    comp = comp.getItemId();
  }
  var c = this.items ? this.items.get(comp) : null, floaters = this.floatingItems;
  if (!c && floaters && typeof comp !== 'number') {
    c = floaters.get(comp);
  }
  return c;
}, getRefItems:function() {
  if (!this.items) {
    return [];
  }
  return arguments.callee.$previous.apply(this, arguments);
}});
Ext.define('Ext.overrides.button.Button', {override:'Ext.button.Button', focusCls:'', setUi:function(ui) {
  if (ui !== undefined) {
    this.setUI(ui);
  }
}, setUI:function(ui) {
  var me = this, activeUI = me.activeUI;
  if (me.scale && ui && !ui.match(me.scale)) {
    ui = ui + '-' + me.scale;
  }
  if (ui === activeUI) {
    return;
  }
  if (activeUI) {
    if (me.btnWrap) {
      me.btnWrap.removeCls(me._btnWrapCls + '-' + activeUI);
      me.btnWrap.addCls(me._btnWrapCls + '-' + ui);
    }
    if (me.btnEl) {
      me.btnEl.removeCls(me._btnCls + '-' + activeUI);
      me.btnEl.addCls(me._btnCls + '-' + ui);
    }
    if (me.btnIconEl) {
      me.btnIconEl.removeCls(me._baseIconCls + '-' + activeUI);
      me.btnIconEl.addCls(me._baseIconCls + '-' + ui);
    }
    if (me.btnInnerEl) {
      me.btnInnerEl.removeCls(me._innerCls + '-' + activeUI);
      me.btnInnerEl.addCls(me._innerCls + '-' + ui);
    }
  }
  (arguments.callee.$previous || Ext.Component.prototype.setUI).call(this, ui);
}, setCls:function(cls) {
  if (!this.el) {
    this.addListener('afterrender', Ext.bind(this.setCls, this, [cls]), this, {single:true});
    return;
  }
  if (this.cls) {
    this.el.removeCls(this.cls);
  }
  this.cls = cls;
  this.el.addCls(this.cls);
}, setTooltip:function(tooltip, initial) {
  if (tooltip && typeof tooltip == 'object') {
    var localized = tooltip.localized;
    if (localized) {
      var translationKey, regex = /mvstr\[[^\]]+\]/g;
      if (Ext.isObject(localized)) {
        for (var prop in localized) {
          if (tooltip[prop] !== undefined) {
            continue;
          }
          translationKey = localized[prop];
          if (translationKey && typeof translationKey == 'string') {
            if (mvstr[translationKey]) {
              tooltip[prop] = mvstr[translationKey];
            } else {
              if (translationKey.match(regex)) {
                var matches = translationKey.match(regex);
                for (var i = 0; i < matches.length; i++) {
                  var referenceVar = matches[i].match(/mvstr\[([^\]]+)\]/)[1];
                  translationKey = translationKey.replace(matches[i], mvstr[referenceVar]);
                }
                tooltip[prop] = translationKey;
              } else {
                console.error('Missing translation (' + mvstr.LanguageID + ") for key '" + translationKey + "'.");
              }
            }
          } else {
            if (typeof translationKey == 'object') {
              var value = translationKey[mvstr.LanguageID];
              if (value === undefined) {
                value = translationKey['default'];
              }
              if (value !== undefined) {
                tooltip[prop] = value;
              }
            }
          }
        }
      }
    }
  }
  arguments.callee.$previous.call(this, tooltip, initial);
}});
Ext.define('Ext.classic.toolbar.Toolbar', {override:'Ext.toolbar.Toolbar', defaultFieldUI:'toolbar'});
Ext.define('Ext.overrides.container.DockingContainer', {override:'Ext.container.DockingContainer', getDockedItems:function(selector, beforeBody) {
  if (!this.getComponentLayout().getDockedItems) {
    return [];
  }
  return arguments.callee.$previous.apply(this, arguments);
}});
Ext.define('Ext.overrides.panel.Panel', {override:'Ext.panel.Panel', constructor:function(config) {
  config = config || {};
  config.closeToolText = config.closeToolText || mvstr['G_Close panel'];
  (arguments.callee.$previous || Ext.container.Container.prototype.constructor).call(this, config);
}});
Ext.define('mdsOverrides.overrides.window.Window', {override:'Ext.window.Window', getDockedItems:function() {
  if (!this.getComponentLayout().getDockedItems) {
    return [];
  }
  return (arguments.callee.$previous || Ext.panel.Panel.prototype.getDockedItems).apply(this, arguments);
}, constructor:function() {
  var me = this;
  me.closeToolText = mvstr['G_Close Dialog'];
  (arguments.callee.$previous || Ext.panel.Panel.prototype.constructor).apply(this, arguments);
}});
Ext.define('Ext.overrides.form.field.Base', {override:'Ext.form.field.Base', publishValue:function() {
  var me = this;
  if (me.rendered && (!me.getErrors().length || me.mvPublishWithErrors)) {
    me.publishState('value', me.getValue());
  }
}, onRender:function() {
  var rv = this.callParent(arguments);
  if (this.config) {
    if (typeof this.config.tooltip === 'string' && this.config.tooltip) {
      this.config.tooltip = Ext.create('Ext.tip.ToolTip', {target:this, html:this.config.tooltip});
    }
    var autoComplete = this.config.autoComplete;
    if (this.inputEl && autoComplete === true || autoComplete === 'on') {
      this.inputEl.set({autocomplete:'on'});
    }
  }
  return rv;
}});
Ext.define('Ext.overrides.form.field.TextArea', {override:'Ext.form.field.TextArea', autoSize:function() {
  var me = this, inputEl, hideScroller, height, curWidth, value;
  if (me.grow && me.rendered && me.getSizeModel().height.auto) {
    inputEl = me.inputEl;
    curWidth = inputEl.getWidth(true);
    value = Ext.util.Format.htmlEncode(inputEl.dom.value) || '\x26#160;';
    value += me.growAppend;
    value = value.replace(/\n/g, '\x3cbr/\x3e');
    height = Ext.util.TextMetrics.measure(inputEl, value, curWidth).height + inputEl.getPadding('tb') + me.inputWrap.getBorderWidth('tb') + me.triggerWrap.getBorderWidth('tb');
    height = Math.min(Math.max(height, me.growMin), me.growMax);
    hideScroller = me.preventScrollbars || !me.growMax || height < me.growMax;
    inputEl.setStyle('overflow-y', hideScroller ? 'hidden' : 'auto');
    me.bodyEl.setHeight(height);
    me.updateLayout();
    me.fireEvent('autosize', me, height);
  }
}});
Ext.define('MdsOverrides.overrides.window.MessageBox', {override:'Ext.window.MessageBox', error:function(title, message, fn, scope) {
  if (Ext.isString(title) && message == null) {
    message = title;
    title = mvstr['G_Error'];
  }
  return this.showWithIcon(title, message, fn, scope, this.ERROR);
}, warn:function(title, message, fn, scope) {
  if (Ext.isString(title) && message == null) {
    message = title;
    title = 'Warning';
  }
  return this.showWithIcon(title, message, fn, scope, this.WARNING);
}, info:function(title, message, fn, scope) {
  return this.showWithIcon(title, message, fn, scope, this.INFO);
}, question:function(title, message, fn, scope) {
  return this.showWithIcon(title, message, fn, scope, this.QUESTION);
}, showWithIcon:function(title, message, fn, scope, icon) {
  if (Ext.isString(title)) {
    title = {title:title, message:message, buttons:this.OK, icon:icon, fn:fn, scope:scope};
  }
  this.on({boxready:{fn:function() {
    this.center();
  }, scope:this, single:true}});
  return this.show(title);
}});
Ext.define('Ext.overrides.form.Panel', {override:'Ext.form.Panel', getErrors:function() {
  var fields = this.form.getFields(), errors = [];
  fields.each(function(field) {
    if (!field.isValid()) {
      var fieldErrors = field.getErrors(), label = (field.getFieldLabel ? field.getFieldLabel() : '') || (field.getBoxLabel ? field.getBoxLabel() : '');
      for (var i = 0; i < fieldErrors.length; i++) {
        errors.push((label ? '\x3cb\x3e' + label + ':\x3c/b\x3e ' : '') + fieldErrors[i]);
      }
    }
  }, this);
  return errors;
}});
Ext.define('Ext.overrides.view.AbstractView', {override:'Ext.view.AbstractView', updateIndexes:function(startIndex, endIndex) {
  var nodes = this.all.elements, node, records = this.getViewRange(), i, myId = this.id;
  startIndex = startIndex || 0;
  endIndex = endIndex || (endIndex === 0 ? 0 : nodes.length - 1);
  for (i = startIndex; i <= endIndex; i++) {
    node = nodes[i];
    node.setAttribute('data-recordIndex', i);
    if (records[i]) {
      node.setAttribute('data-recordId', records[i].internalId);
    }
    node.setAttribute('data-boundView', myId);
  }
}, refresh:function() {
  var me = this, items = me.all, prevItemCount = items.getCount(), refreshCounter = me.refreshCounter, targetEl, records, selModel = me.getSelectionModel(), restoreFocus, scroller = refreshCounter && items.getCount() && me.preserveScrollOnRefresh && me.getScrollable(), bufferedRenderer = me.bufferedRenderer, scrollPos;
  if (!me.rendered || me.destroyed) {
    return;
  }
  if (!me.hasListeners.beforerefresh || me.fireEvent('beforerefresh', me) !== false) {
    me.el.dom.style.visibility = 'hidden';
    me.refreshing = true;
    if (me.saveFocusState) {
      restoreFocus = me.saveFocusState();
    }
    targetEl = me.getTargetEl();
    records = me.getViewRange();
    if (scroller) {
      scrollPos = scroller.getPosition();
      if (!(scrollPos.x || scrollPos.y)) {
        scrollPos = null;
      }
    }
    if (refreshCounter) {
      me.clearViewEl();
      me.refreshCounter++;
    } else {
      me.refreshCounter = 1;
    }
    me.tpl.append(targetEl, me.collectData(records, items.startIndex || 0));
    if (records.length < 1) {
      me.addEmptyText();
      items.clear();
    } else {
      me.collectNodes(targetEl.dom);
      me.updateIndexes(0);
    }
    if (me.groupField && me.groupTpl) {
      var currGroup = '';
      for (var i = 0; i < records.length; i++) {
        var rec = records[i], recGroup = rec.get(me.groupField);
        if (currGroup != recGroup) {
          currGroup = recGroup;
          if (me.getNode(rec)) {
            me.groupTpl.insertBefore(me.getNode(rec), rec.getData());
          }
        }
      }
    }
    me.el.dom.style.visibility = '';
    if (restoreFocus) {
      restoreFocus();
    }
    if (me.refreshSelmodelOnRefresh !== false) {
      selModel.refresh();
    }
    me.refreshNeeded = false;
    me.refreshSize(items.getCount() !== prevItemCount);
    me.fireItemMutationEvent('refresh', me, records);
    if (scroller) {
      scroller.scrollTo(scrollPos);
    }
    if (!me.viewReady) {
      me.viewReady = true;
      me.fireEvent('viewready', me);
    }
    me.refreshing = false;
    if (bufferedRenderer) {
      bufferedRenderer.refreshSize();
    }
    me.cleanupData();
  }
  if (!me.tabGuardEl) {
    me.tabGuardEl = me.el.createChild({cls:'x-tab-guard x-tab-guard-after', tabIndex:'0'}, null, true);
  }
}});
Ext.define('Ext.overrides.view.View', {override:'Ext.view.View', initComponent:function() {
  (arguments.callee.$previous || Ext.view.AbstractView.prototype.initComponent).call(this);
  if (this.groupTpl && (Ext.isArray(this.groupTpl) || Ext.isString(this.groupTpl))) {
    this.groupTpl = new Ext.XTemplate(this.groupTpl);
  }
}, addEmptyText:function() {
  var me = this, store = me.getStore();
  if (me.emptyText && !store.isLoading() && (!me.deferEmptyText || store.isLoaded())) {
    me.emptyEl = Ext.core.DomHelper.insertHtml('beforeEnd', me.getTargetEl().dom, "\x3cdiv class\x3d'empty-text'\x3e" + me.emptyText + '\x3c/div\x3e');
  }
}, setEmptyText:function(emptyText) {
  this.emptyText = emptyText;
}});
Ext.define('Ext.overrides.form.field.ComboBox', {override:'Ext.form.field.ComboBox', config:{enableKeySelect:false, enableKeyHighlight:false, keySelectDelay:750}, constructor:function(config) {
  config = this.setupKeySelectConfigs(config);
  (arguments.callee.$previous || Ext.form.field.Picker.prototype.constructor).apply(this, arguments);
}, setupKeySelectConfigs:function(config) {
  config = config || {};
  if (config.enableKeySelect) {
    config.enableKeyHighlight = true;
  }
  if (config.enableKeyHighlight !== false) {
    if (config.enableKeyHighlight === true) {
      config.editable = false;
      config.queryMode = 'local';
    } else {
      var editable = config.editable !== false && this.config.editable !== false;
      var queryMode = config.queryMode || this.config.queryMode;
      if (editable === false && queryMode === 'local') {
        config.enableKeyHighlight = true;
      }
    }
  }
  if (config.enableKeyHighlight) {
    config.enableKeyEvents = true;
    config.listeners = config.listeners || {};
    if (config.listeners.keyup) {
      var configKeyUpHandler = config.listeners.keyup;
      config.listeners.keyup = function(combo, event) {
        var rv = configKeyUpHandler.call(this, combo, event);
        this.keyupHandler(combo, event);
        return rv;
      }.bind(this);
    } else {
      config.listeners.keyup = this.keyupHandler.bind(this);
    }
  }
  return config;
}, keyupHandler:function(combo, event) {
  if (this.config.enableKeyHighlight) {
    var keyCode = event.keyCode;
    if (keyCode >= 32 && keyCode <= 126) {
      var char = String.fromCharCode(event.getKey()).toLowerCase();
      var searchString = this.getKeySelectSearchString(keyCode, char);
      var boundList = combo.getPicker();
      var store = boundList.getStore();
      var recordIndex = this.keySelectSearch(combo, store, searchString);
      this.keyHighlightIndex = recordIndex;
      if (recordIndex >= 0) {
        var record = store.getAt(recordIndex);
        boundList.highlightItem(boundList.getNode(record));
        boundList.getNavigationModel().setPosition(recordIndex);
        if (this.config.enableKeySelect) {
          boundList.getSelectionModel().select(record, false, true);
          combo.expand();
        }
      }
    }
  }
}, getKeySelectSearchString:function(keyCode, char) {
  if (this.keySelectString === undefined) {
    this.keySelectString = '';
    this.keySelectLastTime = 0;
    this.keyHighlightIndex = -1;
  }
  var now = (new Date).getTime();
  var delta = now - this.keySelectLastTime;
  this.keySelectLastTime = now;
  if (delta > this.config.keySelectDelay) {
    this.keySelectString = char;
  } else {
    this.keySelectString = this.keySelectString + char;
  }
  return this.keySelectString;
}, keySelectSearch:function(combo, store, searchString) {
  var recordIndex = -1;
  if (searchString.length > 1) {
    recordIndex = this.keySelectStoreFind(store, combo.displayField, searchString, 0, combo.anyMatch, combo.caseSensitive);
    searchString = searchString.charAt(0);
  }
  if (recordIndex === -1) {
    var startIndex = this.keyHighlightIndex + 1;
    recordIndex = this.keySelectStoreFind(store, combo.displayField, searchString, startIndex, combo.anyMatch, combo.caseSensitive);
  }
  return recordIndex;
}, keySelectStoreFind:function(store, property, value, startIndex, anyMatch, caseSensitive) {
  var index = store.find(property, value, startIndex, anyMatch, caseSensitive);
  if (index === -1 && startIndex > 0) {
    index = store.find(property, value, 0, anyMatch, caseSensitive);
  }
  return index;
}, setValue:function(value) {
  if (this.getStore() === null) {
    if (value !== null) {
      this.mvComboFixValue = value;
    }
    return this;
  }
  return (arguments.callee.$previous || Ext.form.field.Picker.prototype.setValue).apply(this, arguments);
}, setStore:function() {
  arguments.callee.$previous.apply(this, arguments);
  if (this.mvComboFixValue) {
    this.setValue(this.mvComboFixValue);
    this.mvComboFixValue = undefined;
  }
}});
Ext.define('Ext.overrides.form.field.Base', {override:'Ext.form.field.Date', config:{mvPickerUI:''}, createPicker:function() {
  var picker = (arguments.callee.$previous || Ext.form.field.Picker.prototype.createPicker).apply(this, arguments), mvPickerUI = this.getMvPickerUI();
  if (mvPickerUI) {
    picker.setUI(mvPickerUI);
  }
  return picker;
}});
Ext.define('Ext.overrides.grid.CellContext', {override:'Ext.grid.CellContext', onCellMouseDown:function(view, cell, cellIndex, record, row, recordIndex, mousedownEvent) {
  var targetComponent = Ext.Component.fromElement(mousedownEvent.target, cell), ac;
  if (view.actionableMode && (mousedownEvent.getTarget(null, null, true).isTabbable() || (ac = Ext.ComponentManager.getActiveComponent()) && ac.owns(mousedownEvent))) {
    return;
  }
  if (mousedownEvent.pointerType !== 'touch') {
    this.setPosition(mousedownEvent.position, null, mousedownEvent);
  }
  if (targetComponent && targetComponent.isFocusable && targetComponent.isFocusable()) {
    view.setActionableMode(true, mousedownEvent.position);
    targetComponent.focus();
  }
}, setPosition:function(row, col) {
  if (row !== null || col !== null) {
    return arguments.callee.$previous.apply(this, arguments);
  }
}});
Ext.define('Ext.overrides.grid.NavigationModel', {override:'Ext.grid.NavigationModel', onCellMouseDown:function(view, cell, cellIndex, record, row, recordIndex, mousedownEvent) {
  var targetComponent = Ext.Component.fromElement(mousedownEvent.target, cell), ac;
  if (view.actionableMode && (mousedownEvent.getTarget(null, null, true).isTabbable() || (ac = Ext.ComponentManager.getActiveComponent()) && ac.owns(mousedownEvent))) {
    return;
  }
  if (mousedownEvent.pointerType !== 'touch') {
    this.setPosition(mousedownEvent.position, null, mousedownEvent);
  }
  if (targetComponent && targetComponent.isFocusable && targetComponent.isFocusable()) {
    view.setActionableMode(true, mousedownEvent.position);
    targetComponent.focus();
  }
}});
Ext.define('Ext.theme.classic.grid.column.Widget', {override:'Ext.grid.column.Widget', config:{defaultWidgetUI:{button:'grid-cell', splitbutton:'grid-cell', cyclebutton:'grid-cell', textfield:'grid-cell', pickerfield:'grid-cell', combobox:'grid-cell', combo:'grid-cell', datefield:'grid-cell', timefield:'grid-cell', filefield:'grid-cell', fileuploadfield:'grid-cell', sliderwidget:'grid-cell'}}});
Ext.define('Ext.overrides.menu.Menu', {override:'Ext.menu.Menu', calculateConstrainedPosition:function(constrainTo, proposedPosition, local, proposedSize) {
  var me = this, fp = me.floatParent, parentNode = fp ? fp.getTargetEl() : null, parentCmp = parentNode ? Ext.getCmp(parentNode.id) : null;
  if (!constrainTo && parentCmp && parentCmp.isToolbar) {
    constrainTo = me.container;
  }
  (arguments.callee.$previous || Ext.panel.Panel.prototype.calculateConstrainedPosition).call(this, constrainTo, proposedPosition, local, proposedSize);
}});
Ext.define('Ext.theme.classic.grid.plugin.Editing', {override:'Ext.grid.plugin.Editing', defaultFieldUI:'grid-cell'});
Ext.cmd.derive('mdsPreferences.MemberPreferences', mdsPreferences.Local, {singleton:true, setIdentification:function(MemberUID) {
  this.identification = {MemberUID:MemberUID};
}, getTasklistSetting_alwaysCloneWhenDone:function(identification) {
  return this.getBooleanValue('tasklistSetting_alwaysCloneWhenDone', identification);
}, setTasklistSetting_alwaysCloneWhenDone:function(tasklistSetting_alwaysCloneWhenDone, identification) {
  this.setBooleanValue('tasklistSetting_alwaysCloneWhenDone', tasklistSetting_alwaysCloneWhenDone, identification);
}, getTasklistSetting_showConfirmationPrompt:function(identification) {
  return this.getBooleanValue('tasklistSetting_showConfirmationPrompt', identification);
}, setTasklistSetting_showConfirmationPrompt:function(tasklistSetting_showConfirmationPrompt, identification) {
  this.setBooleanValue('tasklistSetting_showConfirmationPrompt', tasklistSetting_showConfirmationPrompt, identification);
}, getTasklistSetting_includePhotos:function(identification) {
  return this.getBooleanValue('tasklistSetting_includePhotos', identification);
}, setTasklistSetting_includePhotos:function(tasklistSetting_includePhotos, identification) {
  this.setBooleanValue('tasklistSetting_includePhotos', tasklistSetting_includePhotos, identification);
}, getTasklistSetting_includePins:function(identification) {
  return this.getBooleanValue('tasklistSetting_includePins', identification);
}, setTasklistSetting_includePins:function(tasklistSetting_includePins, identification) {
  this.setBooleanValue('tasklistSetting_includePins', tasklistSetting_includePins, identification);
}, getTasklistSetting_includeFiles:function(identification) {
  return this.getBooleanValue('tasklistSetting_includeFiles', identification);
}, setTasklistSetting_includeFiles:function(tasklistSetting_includeFiles, identification) {
  this.setBooleanValue('tasklistSetting_includeFiles', tasklistSetting_includeFiles, identification);
}, getOnboardingSetting_LayoutTemplateID:function(identification) {
  return this.getValue('onboardingSetting_LayoutTemplateID', identification);
}, setOnboardingSetting_LayoutTemplateID:function(templateID, identification) {
  this.setValue('onboardingSetting_LayoutTemplateID', templateID, identification);
}, getOnboardingSetting_ContentTemplateID:function(identification) {
  return this.getValue('onboardingSetting_ContentTemplateID', identification);
}, setOnboardingSetting_ContentTemplateID:function(templateID, identification) {
  this.setValue('onboardingSetting_ContentTemplateID', templateID, identification);
}, getWebcamSetting_gridViewSelection:function(identification) {
  return this.getObjectValue('webcamSetting_gridViewSelection', identification);
}, setWebcamSetting_gridViewSelection:function(webcamSetting_gridViewSelection, identification) {
  this.setObjectValue('webcamSetting_gridViewSelection', webcamSetting_gridViewSelection, identification);
}, getAdminSetting_restrictedFeatureID:function(identification) {
  return this.getValue('adminSetting_restrictedFeatureID', identification);
}, setAdminSetting_restrictedFeatureID:function(restrictedFeatureID, identification) {
  this.setValue('adminSetting_restrictedFeatureID', restrictedFeatureID, identification);
}, getPhotoListCart:function(sessionDataID, ProjectUID) {
  var cart = this.getValue('photoListCart');
  if (cart) {
    cart = JSON.parse(cart);
    if (cart.sessionDataID != sessionDataID || cart.ProjectUID != ProjectUID) {
      this.removeValue('photoListCart');
      return [];
    }
  }
  return cart || [];
}, setPhotoListCart:function(photoListCart) {
  this.setValue('photoListCart', photoListCart);
}}, 0, 0, 0, 0, 0, 0, [mdsPreferences, 'MemberPreferences'], 0);
Ext.cmd.derive('mdsPreferences.ProjectPreferences', mdsPreferences.Local, {singleton:true, setIdentification:function(ProjectUID, MemberUID) {
  this.identification = {ProjectUID:ProjectUID, MemberUID:MemberUID};
}, getAlbumUIDArray:function(identification) {
  return this.getListValue('albums', identification);
}, setAlbumUIDArray:function(albumUIDArray, identification) {
  this.setListValue('albums', albumUIDArray, identification);
}, getShareTypeID:function(identification) {
  return this.getNumericValue('ShareTypeID', identification);
}, setShareTypeID:function(ShareTypeID, identification) {
  this.setValue('ShareTypeID', ShareTypeID, identification);
}, getShareMembersList:function(identification) {
  return this.getValue('ShareMembersList', identification);
}, setShareMembersList:function(memberList, identification) {
  this.setValue('ShareMembersList', memberList, identification);
}, getProcoreSetting_companyID:function(identification) {
  return this.getNumericValue('procoreSetting_companyID', identification);
}, setProcoreSetting_companyID:function(procoreSetting_companyID, identification) {
  this.setValue('procoreSetting_companyID', procoreSetting_companyID, identification);
}, getProcoreSetting_projectID:function(identification) {
  return this.getNumericValue('procoreSetting_projectID', identification);
}, setProcoreSetting_projectID:function(procoreSetting_projectID, identification) {
  this.setValue('procoreSetting_projectID', procoreSetting_projectID, identification);
}, getProcoreSetting_entityType:function(identification) {
  return this.getValue('procoreSetting_entityType', identification);
}, setProcoreSetting_entityType:function(procoreSetting_entityType, identification) {
  this.setValue('procoreSetting_entityType', procoreSetting_entityType, identification);
}, getProcoreSetting_attachAsPhoto:function(identification) {
  return this.getBooleanValue('procoreSetting_AttachAsPhoto', identification);
}, setProcoreSetting_attachAsPhoto:function(procoreSetting_AttachAsPhoto, identification) {
  this.setBooleanValue('procoreSetting_AttachAsPhoto', procoreSetting_AttachAsPhoto, identification);
}, getProcoreSetting_attachAs4View:function(identification) {
  return this.getBooleanValue('procoreSetting_AtachAs4View', identification);
}, setProcoreSetting_attachAs4View:function(procoreSetting_AtachAs4View, identification) {
  this.setBooleanValue('procoreSetting_AtachAs4View', procoreSetting_AtachAs4View, identification);
}, getProcoreSetting_dailyLogSubType:function(identification) {
  return this.getValue('procoreSetting_dailyLogSubType', identification);
}, setProcoreSetting_dailyLogSubType:function(procoreSetting_dailyLogSubType, identification) {
  this.setValue('procoreSetting_dailyLogSubType', procoreSetting_dailyLogSubType, identification);
}, getProcoreSetting_punchlistAction:function(identification) {
  return this.getValue('procoreSetting_punchlistAction', identification);
}, setProcoreSetting_punchlistAction:function(procoreSetting_punchlistAction, identification) {
  this.setValue('procoreSetting_punchlistAction', procoreSetting_punchlistAction, identification);
}, getProcoreSetting_observationAction:function(identification) {
  return this.getValue('procoreSetting_observationAction', identification);
}, setProcoreSetting_observationAction:function(procoreSetting_observationAction, identification) {
  this.setValue('procoreSetting_observationAction', procoreSetting_observationAction, identification);
}, getProcoreSetting_photoAction:function(identification) {
  return this.getValue('procoreSetting_photoAction', identification);
}, setProcoreSetting_photoAction:function(procoreSetting_photoAction, identification) {
  this.setValue('procoreSetting_photoAction', procoreSetting_photoAction, identification);
}, getProcoreSetting_photoCategoryID:function(identification) {
  return this.getNumericValue('procoreSetting_photoCategoryID', identification);
}, setProcoreSetting_photoCategoryID:function(procoreSetting_photoCategoryID, identification) {
  this.setValue('procoreSetting_photoCategoryID', procoreSetting_photoCategoryID, identification);
}, getProcoreSetting_rfiFilterValue:function(identification) {
  return this.getObjectValue('procoreSetting_rfiFilterValue', identification);
}, setProcoreSetting_rfiFilterValue:function(procoreSetting_rfiFilterValue, identification) {
  this.setObjectValue('procoreSetting_rfiFilterValue', procoreSetting_rfiFilterValue, identification);
}, getPlanGridSetting_projectID:function(identification) {
  return this.getValue('planGridSetting_projectID', identification);
}, setPlanGridSetting_projectID:function(planGridSetting_projectID, identification) {
  this.setValue('planGridSetting_projectID', planGridSetting_projectID, identification);
}, getPlanGridSetting_entityType:function(identification) {
  return this.getValue('planGridSetting_entityType', identification);
}, setPlanGridSetting_entityType:function(planGridSetting_entityType, identification) {
  this.setValue('planGridSetting_entityType', planGridSetting_entityType, identification);
}, getPlanGridSetting_attachAsPhoto:function(identification) {
  return this.getBooleanValue('planGridSetting_attachAsPhoto', identification);
}, setPlanGridSetting_attachAsPhoto:function(planGridSetting_attachAsPhoto, identification) {
  this.setBooleanValue('planGridSetting_attachAsPhoto', planGridSetting_attachAsPhoto, identification);
}, getPlanGridSetting_attachAs4View:function(identification) {
  return this.getBooleanValue('planGridSetting_attachAs4View', identification);
}, setPlanGridSetting_attachAs4View:function(planGridSetting_attachAs4View, identification) {
  this.setBooleanValue('planGridSetting_attachAs4View', planGridSetting_attachAs4View, identification);
}, getPlanGridSetting_rfiAssignee:function(identification) {
  return this.getValue('planGridSetting_rfiAssignee', identification);
}, setPlanGridSetting_rfiAssignee:function(planGridSetting_rfiAssignee, identification) {
  this.setValue('planGridSetting_rfiAssignee', planGridSetting_rfiAssignee, identification);
}, getAconexSetting_projectID:function(identification) {
  return this.getNumericValue('aconexSetting_projectID', identification);
}, setAconexSetting_projectID:function(aconexSetting_projectID, identification) {
  this.setValue('aconexSetting_projectID', aconexSetting_projectID, identification);
}, getAconexSetting_entityType:function(identification) {
  return this.getValue('aconexSetting_entityType', identification);
}, setAconexSetting_entityType:function(aconexSetting_entityType, identification) {
  this.setValue('aconexSetting_entityType', aconexSetting_entityType, identification);
}, getAconexSetting_attachAsPhoto:function(identification) {
  return this.getBooleanValue('aconexSetting_attachAsPhoto', identification);
}, setAconexSetting_attachAsPhoto:function(aconexSetting_attachAsPhoto, identification) {
  this.setBooleanValue('aconexSetting_attachAsPhoto', aconexSetting_attachAsPhoto, identification);
}, getAconexSetting_attachAs4View:function(identification) {
  return this.getBooleanValue('aconexSetting_attachAs4View', identification);
}, setAconexSetting_attachAs4View:function(aconexSetting_attachAs4View, identification) {
  this.setBooleanValue('aconexSetting_attachAs4View', aconexSetting_attachAs4View, identification);
}, getAconexSetting_rfiFilterValue:function(identification) {
  return this.getObjectValue('aconexSetting_rfiFilterValue', identification);
}, setAconexSetting_rfiFilterValue:function(aconexSetting_rfiFilterValue, identification) {
  this.setObjectValue('aconexSetting_rfiFilterValue', aconexSetting_rfiFilterValue, identification);
}, getBim360Setting_hubID:function(identification) {
  return this.getValue('bim360Setting_hubID', identification);
}, setBim360Setting_hubID:function(bim360Setting_hubID, identification) {
  this.setValue('bim360Setting_hubID', bim360Setting_hubID, identification);
}, getBim360Setting_projectID:function(identification) {
  return this.getValue('bim360Setting_projectID', identification);
}, setBim360Setting_projectID:function(bim360Setting_projectID, identification) {
  this.setValue('bim360Setting_projectID', bim360Setting_projectID, identification);
}, getBim360Setting_attachAsPhoto:function(identification) {
  return this.getBooleanValue('bim360Setting_attachAsPhoto', identification);
}, setBim360Setting_attachAsPhoto:function(bim360Setting_attachAsPhoto, identification) {
  this.setBooleanValue('bim360Setting_attachAsPhoto', bim360Setting_attachAsPhoto, identification);
}, getBim360Setting_attachAs4View:function(identification) {
  return this.getBooleanValue('bim360Setting_attachAs4View', identification);
}, setBim360Setting_attachAs4View:function(bim360Setting_attachAs4View, identification) {
  this.setBooleanValue('bim360Setting_attachAs4View', bim360Setting_attachAs4View, identification);
}, getBim360Setting_documentAction:function(identification) {
  return this.getValue('bim360Setting_documentAction', identification);
}, setBim360Setting_documentAction:function(bim360Setting_documentAction, identification) {
  this.setValue('bim360Setting_documentAction', bim360Setting_documentAction, identification);
}, getBim360Setting_folderID:function(identification) {
  return this.getValue('bim360Setting_folderID', identification);
}, setBim360Setting_folderID:function(bim360Setting_folderID, identification) {
  this.setValue('bim360Setting_folderID', bim360Setting_folderID, identification);
}, getBluebeamSetting_projectID:function(identification) {
  return this.getValue('bluebeamSetting_projectID', identification);
}, setBluebeamSetting_projectID:function(bluebeamSetting_projectID, identification) {
  this.setValue('bluebeamSetting_projectID', bluebeamSetting_projectID, identification);
}, getBluebeamSetting_entityType:function(identification) {
  return this.getValue('bluebeamSetting_entityType', identification);
}, setBluebeamSetting_entityType:function(bluebeamSetting_entityType, identification) {
  this.setValue('bluebeamSetting_entityType', bluebeamSetting_entityType, identification);
}, getBluebeamSetting_attachAsPhoto:function(identification) {
  return this.getBooleanValue('bluebeamSetting_attachAsPhoto', identification);
}, setBluebeamSetting_attachAsPhoto:function(bluebeamSetting_attachAsPhoto, identification) {
  this.setBooleanValue('bluebeamSetting_attachAsPhoto', bluebeamSetting_attachAsPhoto, identification);
}, getBluebeamSetting_attachAs4View:function(identification) {
  return this.getBooleanValue('bluebeamSetting_attachAs4View', identification);
}, setBluebeamSetting_attachAs4View:function(bluebeamSetting_attachAs4View, identification) {
  this.setBooleanValue('bluebeamSetting_attachAs4View', bluebeamSetting_attachAs4View, identification);
}, getBluebeamSetting_rfiFilterValue:function(identification) {
  return this.getObjectValue('bluebeamSetting_rfiFilterValue', identification);
}, setBluebeamSetting_rfiFilterValue:function(bluebeamSetting_rfiFilterValue, identification) {
  this.setObjectValue('bluebeamSetting_rfiFilterValue', bluebeamSetting_rfiFilterValue, identification);
}}, 0, 0, 0, 0, 0, 0, [mdsPreferences, 'ProjectPreferences'], 0);
Ext.define(null, {override:'Ext.view.DropZone', positionIndicator:function(node, data, e) {
  var me = this, view = me.view, pos = me.getPosition(e, node), overRecord = view.getRecord(node), draggingRecords = data.records, indicatorY, scrollable, scrollableEl, container, containerY;
  if (!Ext.Array.contains(draggingRecords, overRecord) && (pos === 'before' && !me.containsRecordAtOffset(draggingRecords, overRecord, -1) || pos === 'after' && !me.containsRecordAtOffset(draggingRecords, overRecord, 1))) {
    me.valid = true;
    if (me.overRecord !== overRecord || me.currentPosition !== pos) {
      scrollable = me.view.getScrollable();
      scrollableEl = scrollable && scrollable.getElement();
      container = scrollableEl && scrollableEl.isScrollable() ? scrollableEl : Ext.fly(view.getNodeContainer());
      containerY = container.getY();
      indicatorY = Ext.fly(node).getY() - containerY - 1;
      if (pos === 'after') {
        indicatorY += Ext.fly(node).getHeight();
      }
      me.getIndicator().setWidth(Ext.fly(view.el).getWidth()).showAt(0, indicatorY);
      me.overRecord = overRecord;
      me.currentPosition = pos;
    }
  } else {
    me.invalidateDrop();
  }
}});
Ext.cmd.derive('clientHelp.view.HtmlHelpHelper', Ext.Base, {FILE_NAMES:['aClientDashboard', 'aClientFileManager', 'aClientFloorplanOverview', 'aClientFloorplanViewer', 'aClientPeopleOverview', 'aClientPhotoList', 'aClientPhotoViewer', 'aClientTagSearch', 'aClientWebcam.live', 'aClientWebcamOverview', 'aClientPunchlist.view', 'aClientPunchlist.entry', 'aClientPunchlist.plans'], PROJECT_PREFERENCE_NAME:'xProjectPreference', fuseMap:{clientDashboard:'aClientDashboard', clientFileManager:'aClientFileManager', 
clientFloorplanOverview:'aClientFloorplanOverview', clientFloorplanViewer:'aClientFloorplanViewer', clientPeopleOverview:'aClientPeopleOverview', clientPhotoList:'aClientPhotoList', clientPhotoViewer:'aClientPhotoViewer', clientTagSearch:'aClientTagSearch', clientWebcamLive:'aClientWebcamLive', clientWebcamOverview:'aClientWebcamOverview', clientPunchlistOverview:'aClientPunchlist.view', clientPunchlistEntry:'aClientPunchlist.entry'}, constructor:function(cfg) {
  var me = this;
  me.context = cfg.context;
  me.defaultFileName = cfg.defaultFileName ? cfg.defaultFileName : 'defaultHelp';
  me.helpFileExtention = cfg.helpFileExtention ? cfg.helpFileExtention : 'html';
  me.helpDirectory = cfg.helpDirectory ? cfg.helpDirectory : 'mds/module/clientHelp/';
  me.helpIndex = 0;
  me.greetingId = 0;
  me.greetingIdProjectPreference = 0;
  me.projectpreference = '';
  me.callback = cfg.callback;
  me.helpDirectory = (mdslink.server ? mdslink.server + '/' : '') + me.helpDirectory;
  var search = Ext.Object.fromQueryString(document.location.search), fuse = window.location.pathname.match(/(\w+)\/?$/);
  if (fuse && fuse.length > 1 && this.fuseMap[fuse[1]]) {
    fuse = this.fuseMap[fuse[1]].toLowerCase();
  } else {
    fuse = '';
  }
  me.helpFile = me.defaultFileName;
  if (me.helpFile == 'defaultHelp') {
    me.fuse = search.fuseaction ? search.fuseaction.substr(0, search.fuseaction.indexOf('.')).toLowerCase() : fuse;
    for (var i = 0; i < me.FILE_NAMES.length; i++) {
      if (me.fuse == me.FILE_NAMES[i].toLowerCase()) {
        if (me.FILE_NAMES[i] == 'aClientPhotoViewer' && Ext.isDefined(search.WebcamUID)) {
          me.helpFile = 'aClientPhotoViewerWebcam';
        } else {
          me.helpFile = me.FILE_NAMES[i];
        }
        break;
      } else {
        if (search.fuseaction) {
          var fuseAction = search.fuseaction.toLowerCase();
          if (fuseAction == me.FILE_NAMES[i].toLowerCase()) {
            me.helpFile = me.FILE_NAMES[i];
            break;
          }
        }
      }
    }
  }
}, fuse:'', handleHtmlHelpHelper:function() {
  var me = this;
  me.makeSplashscreen();
  me.loadHelpHtml(me.makeFileURL());
}, handleGreetings:function(greetings) {
  var me = this;
  for (var i = 0; i < greetings.length; i++) {
    if (greetings[i].Name.toLowerCase() == me.fuse) {
      if (greetings[i].seen == false) {
        me.greetingId = greetings[i].GreetingID;
      }
      break;
    }
  }
  if (me.greetingId == 1) {
    me.helpIndex = -1;
    me.makeSplashscreen();
    var fileURL = me.helpDirectory + me.helpFile + '.greeting.' + me.helpFileExtention;
    me.loadHelpHtml(fileURL);
  } else {
    if ('aClientDashboard'.toLowerCase() != me.fuse && 'aClientPhotoViewer'.toLowerCase() != me.fuse) {
      for (var i = 0; i < greetings.length; i++) {
        if (greetings[i].Name.toLowerCase() == me.PROJECT_PREFERENCE_NAME.toLowerCase()) {
          if (greetings[i].seen == false) {
            me.greetingIdProjectPreference = greetings[i].GreetingID;
          }
          break;
        }
      }
    }
    if (me.greetingIdProjectPreference != 0) {
      me.helpIndex = -1;
      me.makeSplashscreen();
      var fileURL = me.helpDirectory + (me.greetingId == 0 ? 'projectpreference.close.' : 'projectpreference.next.') + me.helpFileExtention;
      me.loadHelpHtml(fileURL);
    } else {
      if (me.greetingId != 0) {
        me.helpIndex = 0;
        me.makeSplashscreen();
        var fileURL = me.makeFileURL();
        me.loadHelpHtml(fileURL);
      }
    }
  }
  if (me.greetingId !== 0) {
    if (window.localStorage.getItem('Multivista_ClientSession')) {
      var session = JSON.parse(window.localStorage.getItem('Multivista_ClientSession'));
      var len = session.greeting ? session.greeting.length : 0;
      for (var i = 0; i < len; ++i) {
        if (session.greeting[i].GreetingID == me.greetingId) {
          session.greeting[i].seen = true;
          window.localStorage.setItem('Multivista_ClientSession', JSON.stringify(session));
          break;
        }
      }
    }
  }
}, closeHelp:function() {
  this.helpIndex = 0;
  this.deleteHelpContent();
  this.splashscreen.destroy();
}, onHelpProgressBtnCloseClick:function(e, t) {
  var me = this;
  me.closeHelp(me);
}, onHelpProgressBtnNextClick:function(e, t) {
  var me = this;
  me.deleteHelpContent();
  me.helpIndex += 1;
  me.loadHelpHtml(me.makeFileURL());
}, onHelpProgressBtnPrevClick:function(e, t) {
  var me = this;
  me.deleteHelpContent();
  me.helpIndex -= 1;
  me.loadHelpHtml(me.makeFileURL());
}, onPreferenceProgressBtnCloseClick:function() {
  var me = this;
  me.updatePreference();
  me.onHelpProgressBtnCloseClick(arguments);
}, onPreferenceProgressBtnNextClick:function() {
  var me = this;
  me.updatePreference();
  me.onHelpProgressBtnNextClick(arguments);
}, updatePreference:function() {
  var me = this;
  node = me.helpContent.down('input[type\x3d"radio"]:checked');
  me.projectpreference = node.dom.value;
  me.context.fireEvent('updateProjectPreference');
}, makeFileURL:function() {
  var me = this;
  return me.helpDirectory + me.helpFile + '.' + me.helpIndex + '.' + me.helpFileExtention;
}, loadHelpHtml:function(fileURL) {
  var me = this;
  Ext.Ajax.request({url:fileURL, success:function(response) {
    me.helpContent = Ext.DomHelper.insertHtml('afterEnd', me.splashscreen.dom, response.responseText);
    me.helpContent = new Ext.dom.Element(me.helpContent);
    if (me.callback) {
      me.callback(me);
    }
    var node = me.helpContent.down('.closeModal');
    if (node) {
      node.on('click', function(e, t, eOpts) {
        me.onHelpProgressBtnCloseClick(e, t);
      });
    }
    node = me.helpContent.down('.helpProgressBtnClose');
    if (node) {
      node.on('click', function(e, t, eOpts) {
        me.onHelpProgressBtnCloseClick(e, t);
      });
    }
    node = me.helpContent.down('.helpProgressBtnNext');
    if (node) {
      node.on('click', function(e, t, eOpts) {
        me.onHelpProgressBtnNextClick(e, t);
      });
    }
    node = me.helpContent.down('.helpProgressBtnPrev');
    if (node) {
      node.on('click', function(e, t, eOpts) {
        me.onHelpProgressBtnPrevClick(e, t);
      });
    }
    node = me.helpContent.down('.preferenceBtnClose');
    if (node) {
      node.on('click', function(e, t, eOpts) {
        me.onPreferenceProgressBtnCloseClick(e, t);
      });
    }
    node = me.helpContent.down('.preferenceBtnNext');
    if (node) {
      node.on('click', function(e, t, eOpts) {
        me.onPreferenceProgressBtnNextClick(e, t);
      });
    }
  }});
}, deleteHelpContent:function() {
  var me = this;
  if (me.helpContent) {
    me.helpContent.destroy();
  }
}, makeSplashscreen:function() {
  var splashscreen = Ext.create('Ext.Component', {cls:'help-mask', width:'100%', height:'100%', renderTo:Ext.getBody(), floating:true, shadow:false, listeners:{click:{fn:Ext.bind(this.closeHelp, this), element:'el'}}});
  splashscreen.toFront();
  this.splashscreen = splashscreen.el;
  this.splashscreenCmp = splashscreen;
}}, 1, ['htmlhelphelper'], ['htmlhelphelper'], {'htmlhelphelper':true}, ['widget.htmlhelphelper'], 0, [clientHelp.view, 'HtmlHelpHelper'], 0);
Ext.cmd.derive('clientHelp.view.helpsequence.HelpSequenceModel', Ext.app.ViewModel, {data:{title:'My Title', body:'My Body', index:-1, retryGetComponent:false}, formulas:{maxIndex:function(get) {
  return get('pages').length - 1;
}, continueText:function(get) {
  return get('nextIndex') <= get('maxIndex') ? mvstr['G_Continue'] : mvstr['G_Done'];
}, nextIndex:function(get) {
  var maxIndex = get('maxIndex');
  for (var i = get('index') + 1; i <= maxIndex; i++) {
    var nextTarget = this.getView().lookupController().getComponentForIndex(i);
    if (nextTarget || get('retryGetComponent')) {
      return i;
    }
  }
  return maxIndex + 1;
}}}, 0, 0, 0, 0, ['viewmodel.helpsequence'], 0, [clientHelp.view.helpsequence, 'HelpSequenceModel'], 0);
Ext.cmd.derive('clientHelp.view.helpsequence.HelpSequenceController', Ext.app.ViewController, {retryGetComponent:false, init:function() {
  var existingHelp = Ext.ComponentQuery.query(this.getView().xtype)[0];
  if (existingHelp != this.getView()) {
    existingHelp.destroy();
  }
  this.getViewModel().bind('{index}', this.showHelpForIndex, this);
  this.parentDestroyListener = this.getView().getParentView().addListener('destroy', this.quit, this, {single:true, destroyable:true});
}, getAlignTarget:function(alignTargetString) {
  return this.getView().getParentView().down(alignTargetString);
}, showHelpForIndex:function(index, tries) {
  if (index == -1) {
    this.doContinue();
    return;
  }
  var view = this.getView(), viewModel = this.getViewModel(), page = viewModel.get('pages')[index], target = this.getComponentForIndex(index);
  if (!target) {
    if (!viewModel.get('retryGetComponent') || tries == 100) {
      this.quit();
    } else {
      if (!tries) {
        tries = 1;
      } else {
        tries++;
      }
      Ext.defer(function() {
        this.showHelpForIndex(index, tries);
      }, 100, this);
    }
    return;
  }
  view.anchor = page.anchor || 'top';
  view.defaultAlign = page.defaultAlign || 'bl-tl';
  view.setMargin(0);
  viewModel.set('title', this.getTitle(page));
  var paragraphs = [], i = 0;
  while (this.getParagraph(page, i)) {
    paragraphs.push('\x3cp\x3e' + this.getParagraph(page, i) + '\x3c/p\x3e');
    i++;
  }
  viewModel.set('body', paragraphs.join());
  var delay = page.delay || 0;
  Ext.defer(function() {
    var alignTarget = this.getAlignTarget(page.alignTarget);
    view.setStyle({opacity:0});
    view.showBy(alignTarget.el);
    var box = view.getBox(), startX = box.x, startY = box.y;
    if (page.offset) {
      startX += page.offset[0];
      startY += page.offset[1];
    }
    var endX = startX, endY = startY, animOffset = 37;
    if (view.anchor == 'top' || view.defaultAlign == 'c-c') {
      startY -= animOffset;
    } else {
      if (view.anchor == 'bottom') {
        startY += animOffset;
      } else {
        if (view.anchor == 'left') {
          startX -= animOffset;
        } else {
          if (view.anchor == 'right') {
            startX += animOffset;
          }
        }
      }
    }
    Ext.create('Ext.fx.Anim', {target:view, duration:1200, from:{opacity:0}, to:{opacity:1}});
    Ext.create('Ext.fx.Anim', {target:view, duration:750, easing:'bounceOut', from:{x:startX, y:startY}, to:{x:endX, y:endY}});
  }, delay, this);
}, getComponentForIndex:function(index) {
  var page = this.getViewModel().get('pages')[index];
  if (!page) {
    return null;
  }
  var component = this.getAlignTarget(page.alignTarget), el = component ? component.el : null;
  return el && el.isVisible() ? el : null;
}, getParagraph:function(page, index) {
  return mvstr[page.name + '_P' + index];
}, getTitle:function(page) {
  return mvstr[page.name + '_Title'];
}, doSkip:function() {
  this.quit();
}, doContinue:function() {
  this.getViewModel().set('index', this.getViewModel().get('nextIndex'));
}, quit:function() {
  this.getView().destroy();
}, beforeDestroy:function() {
  this.parentDestroyListener.destroy();
}}, 0, 0, 0, 0, ['controller.helpsequence'], 0, [clientHelp.view.helpsequence, 'HelpSequenceController'], 0);
Ext.cmd.derive('clientHelp.view.helpsequence.HelpSequence', Ext.panel.Panel, {viewModel:{type:'helpsequence'}, controller:'helpsequence', config:{pages:[], parentView:null, forceShow:false, alwaysOnTop:2}, floating:true, bind:{title:'{title}'}, width:260, modal:true, modalMaskCls:'modal-transparent', ui:'help', shadow:false, items:[{xtype:'component', bind:{html:'{body}'}}], dockedItems:[{xtype:'container', width:'100%', dock:'bottom', padding:'0 15 15 15', layout:{type:'hbox'}, items:[{xtype:'button', 
ui:'help', localized:{text:'G_Cancel'}, listeners:{click:'doSkip'}}, {xtype:'component', flex:1}, {xtype:'button', ui:'help', bind:{text:'{continueText}'}, listeners:{click:'doContinue'}}]}], constrainPosition:true, baseCls:'x-tip', focusOnToFront:false, defaultAlign:'bl-tl', alwaysOnTop:true, listeners:{beforedestroy:'beforeDestroy'}, initComponent:function() {
  var me = this;
  Ext.panel.Panel.prototype.initComponent.call(this);
  me.setTarget(me.target);
  me.currentTarget = new Ext.dom.Fly;
}, onRender:function(ct, position) {
  var me = this;
  Ext.panel.Panel.prototype.onRender.apply(this, arguments);
  me.anchorEl = me.el.createChild({role:'presentation', cls:'x-tip-anchor'});
}, show:function() {
  if (!this.currentTarget.dom && this.target) {
    return this.showBy(this.target);
  }
  Ext.panel.Panel.prototype.show.call(this);
}, setTarget:function(target) {
  var me = this;
  if (target) {
    me.target = target = Ext.get(target.el || target);
  } else {
    me.target = null;
  }
}, getAlignRegion:function() {
  var me = this, anchorEl = me.anchorEl, align = me.getAnchorAlign(), alignSpec, target;
  if (!me.anchorSize) {
    anchorEl.addCls('x-tip-anchor-top');
    anchorEl.show();
    me.anchorSize = new Ext.util.Offset(anchorEl.getWidth(false, true), anchorEl.getHeight(false, true));
    anchorEl.removeCls('x-tip-anchor-top');
    anchorEl.hide();
  }
  target = me.currentTarget.getRegion();
  alignSpec = {align:me.convertPositionSpec(align), axisLock:me.axisLock, target:target, offset:me.targetOffset, inside:me.constrainPosition ? me.constrainTo || Ext.getBody().getRegion().adjust(5, -5, -5, 5) : null};
  if (me.anchor) {
    alignSpec.anchorSize = me.anchorSize;
  }
  return me.getRegion().alignTo(alignSpec);
}, getAnchorAlign:function() {
  switch(this.anchor) {
    case 'top':
      return 'tl-bl';
    case 'left':
      return 'tl-tr';
    case 'right':
      return 'tr-tl';
    default:
      return this.defaultAlign;
  }
}, afterShow:function() {
  Ext.panel.Panel.prototype.afterShow.call(this);
  this.realignToTarget();
}, realignToTarget:function() {
  var me = this;
  me.doAlignment(me.getAlignRegion());
}, showBy:function(target) {
  var me = this;
  me.align = me.defaultAlign;
  if (target.isEvent) {
    me.currentTarget.attach(target.target);
    me.pointerEvent = target;
  } else {
    me.currentTarget.attach(Ext.getDom(target.el || target));
    me.triggerElement = me.currentTarget.dom;
  }
  if (me.isVisible()) {
    me.realignToTarget();
  } else {
    me.show();
  }
  return me;
}, doDestroy:function() {
  var me = this;
  Ext.destroy(me.anchorEl);
  Ext.panel.Panel.prototype.doDestroy.call(this);
}, doAlignment:function(newRegion) {
  var me = this, anchorEl = me.anchorEl, anchorRegion = newRegion.anchor;
  me.setPagePosition([newRegion.x, newRegion.y]);
  if (anchorEl) {
    anchorEl.removeCls(me.anchorCls);
    if (anchorRegion) {
      me.anchorCls = 'x-tip-anchor-' + anchorRegion.position;
      anchorEl.addCls(me.anchorCls);
      anchorEl.show();
      if (anchorRegion.align & 1) {
        anchorEl.setTop(newRegion.anchor.y - newRegion.y);
        anchorEl.dom.style.left = '';
      } else {
        anchorEl.setLeft(newRegion.anchor.x - newRegion.x);
        anchorEl.dom.style.top = '';
      }
    } else {
      anchorEl.hide();
    }
  }
}, convertPositionSpec:function(posSpec) {
  var result = Ext.panel.Panel.prototype.convertPositionSpec.apply(this, arguments);
  if (result.myEdge == 'c' && result.otherEdge == 'c') {
    result.position = 0;
  }
  return result;
}}, 0, 0, ['component', 'box', 'container', 'panel'], {'component':true, 'box':true, 'container':true, 'panel':true}, 0, 0, [clientHelp.view.helpsequence, 'HelpSequence'], 0);
Ext.cmd.derive('clientHelp.view.helpsequences.WebcamViewerHelpSequence', clientHelp.view.helpsequence.HelpSequence, {viewModel:{data:{pages:[{name:'HELPPV_WebcamViewToggle', alignTarget:'#photoViewerWebcamModeToggle', anchor:'top', offset:[0, 4]}, {name:'HELPPV_WebcamTitle', alignTarget:'photoviewertitle', anchor:'top'}, {name:'HELPPV_WebcamBottomBar', alignTarget:'#bottomBarExpandTab', anchor:'bottom'}, {name:'HELPPV_PTZControls', alignTarget:'streampositioncontrols', anchor:'left', offset:[0, 148]}, 
{name:'HELPPV_PTZPresets', alignTarget:'streampositioncontrols', anchor:'top', offset:[0, 4]}]}}}, 0, ['photoviewerhelpsequence'], ['component', 'box', 'container', 'panel', 'photoviewerhelpsequence'], {'component':true, 'box':true, 'container':true, 'panel':true, 'photoviewerhelpsequence':true}, ['widget.photoviewerhelpsequence'], 0, [clientHelp.view.helpsequences, 'WebcamViewerHelpSequence'], 0);
Ext.cmd.derive('clientHelp.view.helpsequences.PhotoViewerHelpSequence', clientHelp.view.helpsequence.HelpSequence, {viewModel:{data:{pages:[{name:'HELPPV_MainPhoto', alignTarget:'photocontainer', anchor:'bottom', defaultAlign:'c-c', offset:[0, -70]}, {name:'HELPPV_ViewToggle', alignTarget:'#photoViewerLayoutModeToggle'}, {name:'HELPPV_MainMenu', alignTarget:'photoactionsmenu'}, {name:'HELPPV_SideBar', alignTarget:'photoviewersidecontrols', anchor:'right'}, {name:'HELPPV_FloorplanWidget', alignTarget:'photoviewerflooplanview', 
anchor:'right'}, {name:'HELPPV_BottomBar', alignTarget:'#bottomBarExpandTab', anchor:'bottom'}]}}}, 0, ['photoviewerhelpsequence'], ['component', 'box', 'container', 'panel', 'photoviewerhelpsequence'], {'component':true, 'box':true, 'container':true, 'panel':true, 'photoviewerhelpsequence':true}, ['widget.photoviewerhelpsequence'], 0, [clientHelp.view.helpsequences, 'PhotoViewerHelpSequence'], 0);
Ext.cmd.derive('clientHelp.view.newfeature.NewFeatureModel', clientHelp.view.helpsequence.HelpSequenceModel, {data:{retryGetComponent:true}}, 0, 0, 0, 0, ['viewmodel.newfeature'], 0, [clientHelp.view.newfeature, 'NewFeatureModel'], 0);
Ext.cmd.derive('clientHelp.view.newfeature.NewFeatureController', clientHelp.view.helpsequence.HelpSequenceController, {confirmFeature:function() {
  var feature = this.getFeatureName();
  if (window.localStorage.getItem('Multivista_ClientSession')) {
    var session = JSON.parse(window.localStorage.getItem('Multivista_ClientSession'));
    var account = this.getViewModel().get('account');
    var index = account.newFeatureNotifications.indexOf(feature);
    if (index > -1) {
      account.newFeatureNotifications.splice(index, 1);
    }
    session.account = account;
    window.localStorage.setItem('Multivista_ClientSession', JSON.stringify(session));
  }
  Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daClientNavigation.acceptNewFeature\x26feature\x3d' + feature});
  this.quit();
}, getFeatureName:function() {
  return this.getView().xtype.split('_')[1];
}}, 0, 0, 0, 0, ['controller.newfeature'], 0, [clientHelp.view.newfeature, 'NewFeatureController'], 0);
Ext.cmd.derive('clientHelp.view.newfeature.NewFeature', clientHelp.view.helpsequence.HelpSequence, {viewModel:{type:'newfeature'}, controller:'newfeature', modal:false, dockedItems:[{xtype:'container', width:'100%', dock:'bottom', padding:'0 15 15 15', layout:{type:'hbox', pack:'middle'}, items:[{xtype:'button', ui:'help', text:'Got it!', listeners:{click:'confirmFeature'}}]}]}, 0, ['newfeature'], ['component', 'box', 'container', 'panel', 'newfeature'], {'component':true, 'box':true, 'container':true, 
'panel':true, 'newfeature':true}, ['widget.newfeature'], 0, [clientHelp.view.newfeature, 'NewFeature'], 0);
Ext.cmd.derive('clientHelp.view.newfeatures.clientUserAdd', clientHelp.view.newfeature.NewFeature, {statics:{isVisibleNotification:function(account) {
  return !!account.JoinedWithAddUserPermission;
}}, viewModel:{data:{pages:[{name:'NEWF_clientUserAdd', alignTarget:'navigationbar #peopleBtn', anchor:'top'}]}}}, 0, ['newfeature_clientUserAdd'], ['component', 'box', 'container', 'panel', 'newfeature', 'newfeature_clientUserAdd'], {'component':true, 'box':true, 'container':true, 'panel':true, 'newfeature':true, 'newfeature_clientUserAdd':true}, ['widget.newfeature_clientUserAdd'], 0, [clientHelp.view.newfeatures, 'clientUserAdd'], 0);
Ext.cmd.derive('customData.Util', Ext.Base, {singleton:true, uuidRegEx:/^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i, isUUID:function(id) {
  return this.uuidRegEx.test(id);
}, getTimeDescription:function(now, date) {
  if (!now) {
    now = new Date;
  }
  if (!date) {
    return '';
  }
  var seconds = Math.round((now.getTime() - date.getTime()) / 1000), minutes = Math.round(seconds / 60), hours = Math.round(minutes / 60), days = Math.round(hours / 24);
  if (days < 6) {
    return moment(date, now).from();
  }
  return Ext.Date.format(date, mvstr.DATE_Full || 'F j, Y');
}}, 0, 0, 0, 0, 0, 0, [customData, 'Util'], 0);
Ext.cmd.derive('customData.fields.tzadate', Ext.data.field.Date, {statics:{convertFn:function(value) {
  if (!value) {
    return null;
  }
  value = String(value);
  if (value.match(/^\d{4}-\d{2}-\d{2}$/)) {
    return Ext.Date.parse(value, 'Y-m-d');
  }
  var dsSplit = value.split(' ');
  if (dsSplit.length > 4) {
    dsSplit.pop();
  }
  return new Date(dsSplit.join(' '));
}}, convert:function(value) {
  return customData.fields.tzadate.convertFn(value);
}, depends:[]}, 0, 0, 0, 0, ['data.field.tzadate'], 0, [customData.fields, 'tzadate'], 0);
Ext.cmd.derive('mdsData.FloorplanValues', Ext.Base, {statics:{DEFAULT_ICON_SIZE:[33, 33], DEFAULT_ICON_ANCHOR:[5, 26], PUNCHPIN_ICON_ANCHOR:[16, 16], ICON_ANCHORS:{5:[17, 4], 6:[29, 17], 7:[17, 29], 8:[4, 17], 15:[24, 8], 16:[24, 24], 17:[8, 24], 18:[8, 8]}, iconTemplate:new Ext.XTemplate(['\x3cdiv class\x3d"plan-pin-icon {cls}" style\x3d"width: {width}px; height: {height}px; background-image: url(\'{PushpinSymbol}\')"\x3e', '\x3cspan class\x3d"text-overlay"\x3e{TextOverlay}\x3c/span\x3e', '\x3c/div\x3e'])}}, 
0, 0, 0, 0, 0, 0, [mdsData, 'FloorplanValues'], 0);
Ext.cmd.derive('mdsData.PreferenceValues', Ext.Base, {statics:{MEASURE_PREFERENCE_IMPERIAL:1, MEASURE_PREFERENCE_METRIC:2}}, 0, 0, 0, 0, 0, 0, [mdsData, 'PreferenceValues'], 0);
Ext.cmd.derive('mdsData.PunchlistValues', Ext.Base, {singleton:true, PUNCH_STATUS:{OPEN:1, CLOSED:2, ON_HOLD:3}, WORK_STATUS:{NOT_STARTED:1, IN_PROGRESS:2, COMPLETE:3, ON_HOLD:4}, LIST_DESC:{1:'Punch List', 2:'QA/QC List', 3:'FM List'}, LIST_DESC_LONG:{1:'Punch List', 2:'QA/QC List', 3:'FM List'}, LIST_ITEM_DESC:{1:'Punch Item', 2:'QA/QC Item', 3:'FM Item'}, ACTION_CHANGE_TO_IN_PROGRESS:1, ACTION_CHANGE_TO_ON_HOLD:2, ACTION_CHANGE_TO_COMPLETE:3, ACTION_CHANGE_TO_NOT_STARTED:4, ACTION_DELETE:5, ACTION_MOVE_TO_CLOSED:6, 
ACTION_MOVE_TO_OPEN:7, ACTION_PRINT:8, ACTION_SELECT_ALL:9, ACTION_PRINT_DETAILS:10, ACTION_TOGGLE_CLOSED:11, ACTION_CSV:12, ACTION_BATCH:13, ACTION_CLONE:14, SUBMENU_CHANGE_WORK_STATUS:1001, SUBMENU_EXPORT:1002, SUBMENU_CLONE:1003, SUBMENU_CLONE_SETTINGS:1004, isOverdue:function(data) {
  var hourDiff = Ext.Date.diff(new Date, data.DueDate, Ext.Date.HOUR);
  return hourDiff < 0 && hourDiff <= -24 && data.PunchStatusID != mdsData.PunchlistValues.PUNCH_STATUS.CLOSED;
}, constructor:function() {
  this.WORK_STATUS_LABELS = {};
  this.WORK_STATUS_LABELS[this.WORK_STATUS.NOT_STARTED] = 'Not Started';
  this.WORK_STATUS_LABELS[this.WORK_STATUS.IN_PROGRESS] = 'In Progress';
  this.WORK_STATUS_LABELS[this.WORK_STATUS.COMPLETE] = 'Complete';
  this.WORK_STATUS_LABELS[this.WORK_STATUS.ON_HOLD] = 'On Hold';
  this.WORK_STATUSES = [{WorkStatusID:this.WORK_STATUS.ON_HOLD, Label:this.WORK_STATUS_LABELS[this.WORK_STATUS.ON_HOLD]}, {WorkStatusID:this.WORK_STATUS.NOT_STARTED, Label:this.WORK_STATUS_LABELS[this.WORK_STATUS.NOT_STARTED]}, {WorkStatusID:this.WORK_STATUS.IN_PROGRESS, Label:this.WORK_STATUS_LABELS[this.WORK_STATUS.IN_PROGRESS]}, {WorkStatusID:this.WORK_STATUS.COMPLETE, Label:this.WORK_STATUS_LABELS[this.WORK_STATUS.COMPLETE]}];
  this.PUNCH_STATUS_LABELS = {};
  this.PUNCH_STATUS_LABELS[this.PUNCH_STATUS.OPEN] = 'Open';
  this.PUNCH_STATUS_LABELS[this.PUNCH_STATUS.CLOSED] = 'Closed';
  this.PUNCH_STATUS_LABELS[this.PUNCH_STATUS.ON_HOLD] = 'On Hold';
  this.PUNCH_STATUSES = [{PunchStatusID:this.PUNCH_STATUS.OPEN, Label:this.PUNCH_STATUS_LABELS[this.PUNCH_STATUS.OPEN]}, {PunchStatusID:this.PUNCH_STATUS.CLOSED, Label:this.PUNCH_STATUS_LABELS[this.PUNCH_STATUS.CLOSED]}, {PunchStatusID:this.PUNCH_STATUS.ON_HOLD, Label:this.PUNCH_STATUS_LABELS[this.PUNCH_STATUS.ON_HOLD]}];
}}, 1, 0, 0, 0, 0, 0, [mdsData, 'PunchlistValues'], 0);
Ext.cmd.derive('mdsData.model.File', Ext.data.Model, {fields:[{name:'DocumentUID', type:'string'}, {name:'DocumentID', type:'number', persist:false}, {name:'DocumentType', type:'number', persist:false}, {name:'DocumentParent', type:'number', persist:false}, {name:'DocumentSymbol', type:'string', persist:false}, {name:'DocumentShortName', type:'string', persist:false}, {name:'DocumentDescription', type:'string', persist:false}, {name:'DocumentFilename', type:'string', persist:false}, {name:'DocumentURL', 
type:'string', persist:false}, {name:'DocumentFileSize', type:'number', persist:false}, {name:'DocumentMimeType', type:'string', persist:false}, {name:'DocumentTypeName', type:'string', persist:false}, {name:'DocumentCreator', type:'number', persist:false}, {name:'DocumentCreatorName', type:'string', persist:false}, {name:'DocumentCreationDate', type:'date', persist:false}, {name:'DocumentLastEditedDate', type:'date', persist:false}, {name:'DocumentIsDeleted', type:'boolean', persist:false}, {name:'ShareTypeID', 
type:'int', persist:false}, {name:'MemberList', type:'string', persist:false}, {name:'expanded', type:'boolean', persist:false, convert:function(value, record) {
  return true;
}}, {name:'leaf', type:'boolean', persist:false, convert:function(value, record) {
  return !record.get('DocumentMimeType') == 'folder';
}}, {name:'isFolder', type:'boolean', persist:false, convert:function(value, record) {
  return record.get('DocumentMimeType') == 'folder';
}}, {name:'DocumentSymbolLarge', calculate:function(data) {
  return data.DocumentSymbol.replace('mds/module/clientFileManager/image/icons', 'mds/image/clientFileManager/icons/large');
}}], idProperty:'DocumentUID'}, 0, 0, 0, 0, 0, 0, [mdsData.model, 'File'], 0);
Ext.cmd.derive('mdsData.model.ListReport', Ext.data.Model, {fields:[{name:'ListTypeID', type:'int'}, {name:'ProjectFlagName', type:'string'}, {name:'PlanFlagName', type:'string'}, {name:'Label', type:'string'}, {name:'ProjectUID'}, {name:'url', calculate:function(data) {
  return mdslink.clientPunchlistOverview_Base + 'ProjectUID\x3d' + data.ProjectUID + '\x26ListTypeID\x3d' + data.ListTypeID;
}}, {name:'ItemLabel', calculate:function(data) {
  return 'List Item';
}}], idProperty:'ListTypeID'}, 0, 0, 0, 0, 0, 0, [mdsData.model, 'ListReport'], 0);
Ext.cmd.derive('mdsData.model.Location', Ext.data.Model, {fields:[{name:'Location'}], idProperty:'Location'}, 0, 0, 0, 0, 0, 0, [mdsData.model, 'Location'], 0);
Ext.cmd.derive('mdsData.model.Floorplan', Ext.data.Model, {fields:[{name:'FloorplanUID', mapping:'PunchlistPlanUID'}, 'ImageURL', 'ProjectShootTypeLabel', {name:'FloorplanDescription', mapping:'PunchlistPlanDescription'}, 'ProjectUID', 'ListTypeID', {name:'BaseURL', mapping:function(data) {
  return data.PunchlistPlanUID ? mdslink.clientFloorplanViewer_punchlistPlan : mdslink.clientFloorplanViewer;
}}, {name:'Pins', convert:function(v, rec) {
  if (!v || !v.length) {
    return [];
  }
  for (var i = 0; i < v.length; i++) {
    v[i].Cls = v[i].PushpinTypeName.toLowerCase().replace(/\W+/g, '');
  }
}}, {name:'CommentCount', type:'int', defaultValue:0, persist:false}, {name:'PushpinCount', type:'int', defaultValue:0, persist:false}], idProperty:'FloorplanUID'}, 0, 0, 0, 0, 0, 0, [mdsData.model, 'Floorplan'], 0);
Ext.cmd.derive('mdsData.model.Photo', Ext.data.Model, {fields:[{name:'ImageURL', type:'string', persist:false}, {name:'CreatorName', type:'string', persist:false, mapping:'UploadedBy'}, {name:'ImageURLThumb', type:'string', persist:false, mapping:'ThumbURL'}, {name:'ImageURLMedium', type:'string'}, {name:'Identifier', type:'string', mapping:'UDEFPhotoUID'}, {name:'PushpinUID', type:'string'}, {name:'FileName', type:'string', persist:false, mapping:'UDEFPhotoOriginalFileName'}, {name:'PhotoDate', 
mapping:function(data) {
  return data.PhotoDate || data.UDEFPhotoDate || data.UDEFPhotoUploadDate;
}, type:'tzadate', persist:false}, {name:'FileSize', persist:false, defaultValue:0, mapping:'UDEFPhotoFileSize'}, {name:'Type', defaultValue:'U'}, {name:'ImageURLUnaltered', type:'string', persist:false, calculate:function(data) {
  return data.ImageURL.replace('originals', 'unaltered');
}}, {name:'PhotoNumber'}, {name:'DescLine1', mapping:function(data) {
  if (data.FileName) {
    return data.FileName;
  }
  if (data.Description) {
    return data.Description;
  }
}}, {name:'DescLine2', mapping:function(data) {
  if (data.CreatorName) {
    return data.CreatorName;
  }
  if (data.Location) {
    return data.Location;
  }
}}, {name:'DescLine3', calculate:function(data) {
  var descs = [], type = data.Type, photoNumber = data.PhotoNumber, date = data.PhotoDate, desc = Ext.Date.format(date, type == 'W' ? mvstr['DATE_Medium2'] + ' g:i A' : mvstr['DATE_Medium2']);
  if (desc) {
    descs.push(desc);
  }
  if (photoNumber) {
    descs.push(mvstr['PV_Photo {x}'].replace('{x}', photoNumber));
  }
  return descs.join(' - ');
}}, {name:'LoadedImage', defaultValue:''}, {name:'PunchItemID', type:'int'}, {name:'Selected', type:'boolean', defaultValue:false, persist:false}, {name:'SelectedCls', calculate:function(data) {
  return data.Selected ? 'selected' : '';
}}, {name:'Active', defaultValue:false}, {name:'IsFavourite', type:'boolean', defaultValue:false}, {name:'FavouriteCls', calculate:function(data) {
  return data.IsFavourite ? 'favourite' : '';
}}, {name:'title', calculate:function(data) {
  var descs = [];
  if (data.DescLine1) {
    descs.push(data.DescLine1);
  }
  if (data.DescLine2) {
    descs.push(data.DescLine2);
  }
  if (data.DescLine3) {
    descs.push(data.DescLine3);
  }
  return descs.join(' - ');
}}, {name:'id', calculate:function(data) {
  return data.Type + data.Identifier;
}}, {name:'x', type:'int'}, {name:'y', type:'int'}, {name:'IsOwnedByUser', type:'boolean', defaultValue:false}, {name:'ShareTypeID', type:'int'}, {name:'MemberUIDs'}, {name:'HotspotID', mapping:'hotspotID'}, {name:'FloorplanUID', mapping:'floorplanUID'}, {name:'WebcamUID'}, {name:'CmiName'}, {name:'HasAnnotations', type:'boolean'}, {name:'HasMeasurements', type:'boolean'}, {name:'HasDrawables', calculate:function(data) {
  return !!(data.HasMeasurements || data.HasAnnotations);
}}, {name:'OriginalsWidth', type:'int'}, {name:'OriginalsHeight', type:'int'}, {name:'ShootUID'}, {name:'Orientation'}, {name:'MediumWidth', type:'int', defaultValue:0}, {name:'MediumHeight', type:'int', defaultValue:0}, {name:'IsInteriorPano', type:'boolean', defaultValue:false}, {name:'Is360Pano', type:'boolean', defaultValue:false}, {name:'CanSnapshot', type:'boolean', calculate:function(data) {
  return data.Is360Pano || data.IsInteriorPano;
}}, {name:'PhotoLatitude'}, {name:'PhotoLongitude'}, {name:'PhotoAltitude'}], idProperty:'Identifier', getPhotoEventProperties:function() {
  var type = 'Photo';
  if (this.get('IsInteriorPano')) {
    type = 'SW360';
    if (this.get('IsTruView')) {
      type = 'TruView';
    }
  } else {
    if (this.get('CmiName')) {
      type = 'BLK3D';
    } else {
      if (this.get('IsPano')) {
        type = 'UAVPano';
      } else {
        if (this.get('Type') === 'P' && this.get('Is360Pano')) {
          type = '360';
        } else {
          if (this.get('Type') === 'U') {
            if (this.get('Is360Pano')) {
              type = 'UDEF360';
            } else {
              type = 'UDEF';
            }
          } else {
            if (this.get('Type') === 'W') {
              type = 'Webcam';
            }
          }
        }
      }
    }
  }
  return {'Photo ID':this.get('Identifier'), 'Photo Type':type, 'Photo ID with Prefix':this.get('id')};
}}, 0, 0, 0, 0, 0, 0, [mdsData.model, 'Photo'], 0);
Ext.cmd.derive('mdsData.model.Pushpin', Ext.data.Model, {fields:[{name:'PushpinUID', type:'string'}, {name:'PushpinLabel', type:'string', persist:true}, {name:'PushpinType', type:'number'}, {name:'PushpinCreationDate', type:'date'}, {name:'PushpinXCoordinate', type:'number'}, {name:'PushpinYCoordinate', type:'number'}, {name:'PushpinSymbol', type:'string', persist:false}, {name:'ShareTypeID', type:'number'}, {name:'MemberList', type:'string'}, {name:'IsOwner', type:'boolean', persist:false}, {name:'PunchItemID', 
type:'string', persist:false}, {name:'floorplanImage', type:'string', persist:false}, {name:'LocationName', type:'string', persist:false}, {name:'TextOverlay', type:'string', persist:false}, {name:'FloorplanUID', type:'string'}, {name:'ListTypeID', type:'string', persist:false}, {name:'ProjectUID', type:'string'}, {name:'PunchPinOverviewURL', type:'string', calculate:function(data) {
  return mdslink.server + '/index.cfm?fuseaction\x3daClientPunchlist.getPinOverviewImage\x26ProjectUID\x3d' + data.ProjectUID + '\x26FloorplanUID\x3d' + data.FloorplanUID + '\x26PushpinXCoordinate\x3d' + data.PushpinXCoordinate + '\x26PushpinYCoordinate\x3d' + data.PushpinYCoordinate + '\x26showBorders\x3dtrue\x26PunchStatusID\x3d' + data.PunchStatusID + '\x26WorkStatusID\x3d' + data.WorkStatusID + '\x26DueDate\x3d' + Ext.Date.format(data.DueDate, 'Y-m-d') + '\x26TextOverlay\x3d' + data.TextOverlay;
}}, {name:'PunchPinZoomURL', type:'string', calculate:function(data) {
  return mdslink.server + '/index.cfm?fuseaction\x3daClientPunchlist.getPinZoomedImage\x26ProjectUID\x3d' + data.ProjectUID + '\x26FloorplanUID\x3d' + data.FloorplanUID + '\x26PushpinXCoordinate\x3d' + data.PushpinXCoordinate + '\x26PushpinYCoordinate\x3d' + data.PushpinYCoordinate + '\x26showBorders\x3dtrue\x26PunchStatusID\x3d' + data.PunchStatusID + '\x26WorkStatusID\x3d' + data.WorkStatusID + '\x26DueDate\x3d' + Ext.Date.format(data.DueDate, 'Y-m-d') + '\x26TextOverlay\x3d' + data.TextOverlay;
}}, {name:'PunchStatusID', type:'int'}, {name:'WorkStatusID', type:'int'}, {name:'DueDate', type:'date'}], idProperty:'PushpinUID', proxy:{type:'jsonp', reader:{type:'json', rootProperty:'data'}, api:{read:'index.cfm?fuseaction\x3daClientFloorplanViewer.getPushpin', update:'index.cfm?fuseaction\x3daClientFloorplanViewer.updatePushpin666', destroy:'index.cfm?fuseaction\x3daClientFloorplanViewer.deletePushpin666'}}}, 0, 0, 0, 0, 0, 0, [mdsData.model, 'Pushpin'], 0);
Ext.cmd.derive('mdsData.store.Files', Ext.data.Store, {model:'mdsData.model.File', sorters:[{property:'isFolder', direction:'DESC'}]}, 0, 0, 0, 0, ['store.files'], 0, [mdsData.store, 'Files'], 0);
Ext.cmd.derive('mdsData.store.ListReports', Ext.data.Store, {model:'mdsData.model.ListReport', proxy:{type:'jsonp', api:{read:'index.cfm?fuseaction\x3daClientPunchlist.getProjectAvailableListsAndReports'}}}, 0, 0, 0, 0, ['store.listreports'], 0, [mdsData.store, 'ListReports'], 0);
Ext.cmd.derive('mdsData.store.Locations', Ext.data.Store, {model:'mdsData.model.Location', proxy:{type:'memory'}, sorters:[{sorterFn:function(o1, o2) {
  var loc1 = o1.get('Location'), loc2 = o2.get('Location'), locAfterFirstNumber = /\s*\d.*/, firstNum = /([\d]+)/, firstWord1 = loc1.replace(locAfterFirstNumber, ''), firstWord2 = loc2.replace(locAfterFirstNumber, ''), order = loc1 == loc2 ? 0 : loc1 < loc2 ? -1 : 1;
  if (loc1 == 'All locations') {
    return 1;
  }
  if (loc2 == 'All locations') {
    return -1;
  }
  if (firstWord1 == firstWord2) {
    var num1 = 0, num2 = 0;
    while (num1 == num2) {
      if (firstNum.exec(loc1) === null) {
        return order;
      }
      num1 = Number(RegExp.$1);
      if (firstNum.exec(loc2) === null) {
        return order;
      }
      num2 = Number(RegExp.$1);
      if (num1 != num2) {
        return num1 < num2 ? 1 : -1;
      }
      loc1 = loc1.replace(num1, '');
      loc2 = loc2.replace(num2, '');
    }
  }
  return order;
}}], isLoaded:function() {
  return !!this.getCount();
}}, 0, 0, 0, 0, ['store.locations'], 0, [mdsData.store, 'Locations'], 0);
Ext.cmd.derive('sharedLookup.model.Follower', Ext.data.Model, {idProperty:'MemberUID', fields:[{name:'MemberUID', type:'string'}, {name:'IsCreator', type:'boolean', persist:false}, {name:'IsSubscriber', type:'boolean', persist:true}, {name:'IsFollower', type:'boolean', calculate:function(data) {
  return !!(data.IsCreator || data.IsSubscriber);
}}, {name:'NoAccess', type:'boolean'}, {name:'MemberFirstName', type:'string', persist:false}, {name:'MemberLastName', type:'string', persist:false}, {name:'MemberName', type:'string', persist:false, calculate:function(data) {
  return Ext.String.trim((data.MemberFirstName ? data.MemberFirstName : '') + ' ' + (data.MemberLastName ? data.MemberLastName : ''));
}}]}, 0, 0, 0, 0, 0, 0, [sharedLookup.model, 'Follower'], 0);
Ext.cmd.derive('sharedLookup.model.ProjectSelector', Ext.data.Model, {fields:[{name:'projectTitle', type:'string'}, {name:'projectListing', type:'string', convert:function(a, record) {
  if (record.get('ProjectID')) {
    return record.get('ProjectID') + ' - ' + record.get('projectTitle');
  }
  return record.get('projectTitle');
}}, {name:'projectAddress', type:'string'}, {name:'ProjectName', type:'string'}, {name:'ProjectAddress1', type:'string'}, {name:'ProjectAddress2', type:'string'}, {name:'ProjectLatitude', type:'float'}, {name:'ProjectLongitude', type:'float'}, {name:'ProjectUID', type:'string'}, {name:'lastUpdate', type:'string'}, {name:'imageURL', type:'string'}, {name:'image16URL', type:'string'}, {name:'image24URL', type:'string'}, {name:'image32URL', type:'string'}, {name:'image64URL', type:'string'}, {name:'companyLogoURL', 
type:'string', defaultValue:''}, {name:'projectLogoURL', type:'string', defaultValue:''}, {name:'isHidden', type:'bool'}, {name:'ProjectID', type:'int'}]}, 0, 0, 0, 0, 0, 0, [sharedLookup.model, 'ProjectSelector'], 0);
Ext.cmd.derive('sharedLookup.model.date.DateRange', Ext.data.Model, {fields:[{name:'Label', type:'string'}, {name:'StartDate', type:'date'}, {name:'EndDate', type:'date'}], idProperty:'Label'}, 0, 0, 0, 0, 0, 0, [sharedLookup.model.date, 'DateRange'], 0);
Ext.cmd.derive('sharedLookup.store.date.DateRanges', Ext.data.Store, {model:'sharedLookup.model.date.DateRange', proxy:{type:'memory'}, statics:{setDateToMidnight:function(date) {
  date.setHours(0);
  date.setMinutes(0);
  date.setSeconds(0);
  date.setMilliseconds(0);
  return date;
}, nDaysAgo:function(n) {
  return sharedLookup.store.date.DateRanges.setDateToMidnight(Ext.Date.add(new Date, Ext.Date.DAY, -1 * n));
}, startOfMonthNMonthsAgo:function(n) {
  var d = Ext.Date.add(new Date, Ext.Date.MONTH, -1 * n);
  d.setDate(1);
  return sharedLookup.store.date.DateRanges.setDateToMidnight(d);
}, endOfMonthNMonthsAgo:function(n) {
  return Ext.Date.add(sharedLookup.store.date.DateRanges.startOfMonthNMonthsAgo(n - 1), Ext.Date.DAY, -1);
}}, constructor:function(config) {
  config = config || {};
  config.data = [];
  config.data.push({Label:mvstr['GSL_Custom'], StartDate:null, EndDate:null});
  config.data.push({Label:mvstr['GSL_Last 30 Days'], StartDate:this.self.nDaysAgo(30), EndDate:new Date});
  config.data.push({Label:mvstr['GSL_Last 90 Days'], StartDate:this.self.nDaysAgo(90), EndDate:new Date});
  config.data.push({Label:mvstr['GSL_All Time'], StartDate:null, EndDate:null});
  Ext.data.Store.prototype.constructor.call(this, config);
}}, 1, 0, 0, 0, ['store.dateranges'], 0, [sharedLookup.store.date, 'DateRanges'], 0);
Ext.cmd.derive('sharedLookup.view.date.DatePicker', Ext.picker.Date, {config:{isStartDate:true}, showToday:false}, 0, ['photoGroupDatePicker'], ['component', 'box', 'datepicker', 'photoGroupDatePicker'], {'component':true, 'box':true, 'datepicker':true, 'photoGroupDatePicker':true}, ['widget.photoGroupDatePicker'], 0, [sharedLookup.view.date, 'DatePicker'], 0);
Ext.cmd.derive('sharedLookup.view.date.DatePickerWindow', Ext.window.Window, {title:'Custom Date Range', modal:true, layout:'vbox', closeAction:'hide', config:{viewport:null, callback:null}, items:[{reference:'startDatePicker', xtype:'photoGroupDatePicker'}, {reference:'endDatePicker', xtype:'photoGroupDatePicker', isStartDate:false}, {xtype:'container', defaultType:'button', width:176, defaults:{margin:3}, layout:{type:'hbox', pack:'center'}, items:[{text:'OK', listeners:{click:'onDateRangeConfirm'}}, 
{reference:'dateRangeCancel', text:'Cancel', listeners:{click:function() {
  this.up('window').hide();
}}}]}], listeners:{hide:'onDatePickerWindowHide'}}, 0, ['datepickerwindow'], ['component', 'box', 'container', 'panel', 'window', 'datepickerwindow'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true, 'datepickerwindow':true}, ['widget.datepickerwindow'], 0, [sharedLookup.view.date, 'DatePickerWindow'], 0);
Ext.cmd.derive('sharedLookup.view.date.DateSelector', Ext.form.field.ComboBox, {queryMode:'local', displayField:'Label', valueField:'Label', editable:false, setDateRange:function(dateRange) {
  var allTime = this.store.getById(mvstr['GSL_All Time']);
  allTime.set('StartDate', dateRange.startDate);
  allTime.set('EndDate', dateRange.endDate);
}, setFilterRange:function(filterRange) {
  if (!filterRange || filterRange && filterRange.dateSelection == mvstr['GSL_All Time']) {
    var allTime = this.store.getById(mvstr['GSL_All Time']);
    if (allTime) {
      this.setValue(allTime);
    }
    return;
  }
  var count = this.store.getCount();
  for (var i = count - 1; i >= 0; i--) {
    var dateRecord = this.store.getAt(i);
    if (this.dateMatches(dateRecord, filterRange)) {
      this.setValue(dateRecord.get('Label'));
      return;
    }
  }
  this.addCustomValue(filterRange.startDate, filterRange.endDate);
}, dateMatches:function(dateRecord, dateRange) {
  return Ext.Date.format(dateRecord.get('StartDate'), 'Y-m-d') == Ext.Date.format(dateRange.startDate, 'Y-m-d') && Ext.Date.format(dateRecord.get('EndDate'), 'Y-m-d') == Ext.Date.format(dateRange.endDate, 'Y-m-d');
}, getDateLabel:function(startDate, endDate) {
  return Ext.Date.format(startDate, 'd/m/Y') + ' - ' + Ext.Date.format(endDate, 'd/m/Y');
}, addCustomValue:function(startDate, endDate) {
  var label = this.getDateLabel(startDate, endDate), newDateChoice = Ext.create('sharedLookup.model.date.DateRange', {StartDate:startDate, EndDate:endDate, Label:label});
  this.store.add(newDateChoice);
  this.setValue(label);
}, listeners:{select:'onDateSelectorSelect'}}, 0, ['dateselector'], ['component', 'box', 'field', 'textfield', 'pickerfield', 'combobox', 'combo', 'dateselector'], {'component':true, 'box':true, 'field':true, 'textfield':true, 'pickerfield':true, 'combobox':true, 'combo':true, 'dateselector':true}, ['widget.dateselector'], 0, [sharedLookup.view.date, 'DateSelector'], 0);
Ext.cmd.derive('sharedLookup.view.date.DateSelectorController', Ext.app.ViewController, {init:function() {
  this.getViewModel().bind('{dateRange}', this.setDateRange, this);
}, setDateRange:function(dateRange) {
  this.setPickerRange(this.lookupReference('startDatePicker'), dateRange, true);
  this.setPickerRange(this.lookupReference('endDatePicker'), dateRange, false);
}, setPickerRange:function(picker, dateRange, isStartPicker) {
  if (!dateRange.startDate || !dateRange.endDate) {
    return;
  }
  var startDate = dateRange.startDate, endDate = dateRange.endDate, pickerDate = isStartPicker ? startDate : endDate, filterRange = this.getViewModel().get('filterRange'), dateSelector = this.lookupReference('dateSelector');
  picker.setMinDate(startDate);
  picker.setMaxDate(endDate);
  if (filterRange && filterRange.startDate && filterRange.endDate) {
    if (isStartPicker) {
      pickerDate = filterRange.startDate < startDate ? startDate : filterRange.startDate;
      pickerDate = pickerDate > endDate ? endDate : pickerDate;
    } else {
      pickerDate = filterRange.endDate > endDate ? endDate : filterRange.endDate;
      pickerDate = pickerDate < startDate ? startDate : pickerDate;
    }
  }
  picker.setValue(pickerDate);
}, onDateSelectorSelect:function(combo) {
  var dateSelection = combo.getValue(), dateStore = combo.getStore();
  if (dateSelection == mvstr['PUL_Custom']) {
    this.lookupReference('datePickerWindow').show();
    return;
  }
  var dateItem = dateStore.getById(dateSelection), startDate = dateItem.get('StartDate'), endDate = dateItem.get('EndDate'), range = {startDate:startDate, endDate:endDate, dateSelection:dateSelection};
  this.getViewModel().set('dateFilter.filterDateRange', range);
  this.getView().fireEvent('datechange', range, dateSelection);
}, onDateRangeConfirm:function() {
  var startDate = this.lookupReference('startDatePicker').getValue(), endDate = this.lookupReference('endDatePicker').getValue(), viewModel = this.getViewModel(), range = {startDate:startDate, endDate:endDate};
  viewModel.set('dateFilter.filterDateRange', range);
  this.lookupReference('datePickerWindow').hide();
  var combo = this.lookupReference('dateSelector');
  this.getView().fireEvent('datechange', range, combo.getDateLabel(startDate, endDate));
}, onDatePickerWindowHide:function() {
  var dateSelector = this.lookupReference('dateSelector');
  if (dateSelector) {
    dateSelector.setFilterRange(this.getViewModel().get('filterRange'));
  }
}}, 0, 0, 0, 0, ['controller.dateselector'], 0, [sharedLookup.view.date, 'DateSelectorController'], 0);
Ext.cmd.derive('sharedLookup.view.date.DateSelectorModel', Ext.app.ViewModel, {formulas:{dateRange:function(get) {
  var contextDateRange = get('dateFilter.contextDateRange'), overallDateRange = get('dateFilter.overallDateRange');
  return {startDate:contextDateRange.startDate || overallDateRange.startDate, endDate:contextDateRange.endDate || overallDateRange.endDate};
}, filterRange:function(get) {
  var overallDateRange = get('dateFilter.overallDateRange'), filterDateRange = get('dateFilter.filterDateRange'), dateRange = get('dateRange');
  if (!overallDateRange.startDate || !dateRange.startDate || !filterDateRange.startDate) {
    return null;
  }
  return {startDate:filterDateRange.startDate, endDate:filterDateRange.endDate, dateSelection:filterDateRange.dateSelection};
}}}, 0, 0, 0, 0, ['viewmodel.dateselector'], 0, [sharedLookup.view.date, 'DateSelectorModel'], 0);
Ext.cmd.derive('sharedLookup.view.date.DateSelectorWrapper', Ext.Container, {controller:'dateselector', layout:{type:'fit'}, viewModel:{type:'dateselector'}, initComponent:function() {
  var selectorConfig = Ext.merge(this.selectorConfig || {}, {xtype:'dateselector', reference:'dateSelector', bind:{filterRange:'{filterRange}', dateRange:'{dateRange}'}, defaultValue:mvstr['GSL_All Time'], store:Ext.create('sharedLookup.store.date.DateRanges')});
  this.items = [selectorConfig, {xtype:'datepickerwindow', reference:'datePickerWindow', renderTo:Ext.getBody()}];
  Ext.container.Container.prototype.initComponent.apply(this, arguments);
}, getSelector:function() {
  return this.down('dateselector');
}}, 0, ['dateselectorwrapper'], ['component', 'box', 'container', 'dateselectorwrapper'], {'component':true, 'box':true, 'container':true, 'dateselectorwrapper':true}, ['widget.dateselectorwrapper'], 0, [sharedLookup.view.date, 'DateSelectorWrapper'], 0);
Ext.cmd.derive('sharedLookup.view.follow.FollowerGrid', Ext.grid.Panel, {cls:'follower-list tasklist-member-grid', ui:'detail-popup', disableSelection:true, bind:{store:'{followers}'}, hideHeaders:true, columns:[{xtype:'checkcolumn', dataIndex:'IsFollower', width:50, listeners:{checkchange:function(checkcolumn, i, value, record) {
  record.set('IsSubscriber', value);
}}}, {dataIndex:'MemberName', flex:1}], tbar:[{xtype:'component', html:"Select users you'd like to follow this item"}, '-\x3e', {xtype:'button', height:25, minWidth:70, ui:'orange', scale:'small', textAlign:'left', bind:{isFollower:'{isFollower}', disabled:'{followDisabled}'}, setIsFollower:function(isFollower) {
  this.setText(isFollower ? 'Following' : 'Follow');
  this.setIconCls(isFollower ? 'follow-icon-check' : 'follow-icon-follow');
}, listeners:{click:'onFollowClick'}}], viewConfig:{getRowClass:function(record) {
  var classes = [];
  if (record.get('IsCreator')) {
    classes.push('disabled-row creator');
  }
  if (record.get('NoAccess')) {
    classes.push('no-access');
  }
  return classes.join(' ');
}}}, 0, ['followerGrid'], ['component', 'box', 'container', 'panel', 'tablepanel', 'gridpanel', 'grid', 'followerGrid'], {'component':true, 'box':true, 'container':true, 'panel':true, 'tablepanel':true, 'gridpanel':true, 'grid':true, 'followerGrid':true}, ['widget.followerGrid'], 0, [sharedLookup.view.follow, 'FollowerGrid'], 0);
Ext.cmd.derive('formShared.IntegrationsUtil', Ext.Base, {singleton:true, getDisplayDateString:function(data) {
  var date = Ext.Date.parse('00:00', 'H:i');
  date = Ext.Date.add(date, Ext.Date.HOUR, data.time_hour);
  date = Ext.Date.add(date, Ext.Date.MINUTE, data.time_minute);
  return Ext.Date.format(date, 'g:ia');
}}, 0, 0, 0, 0, 0, 0, [formShared, 'IntegrationsUtil'], 0);
Ext.cmd.derive('formShared.model.IntegrationEntityType', Ext.data.Model, {fields:[{name:'id', type:'string'}, {name:'name', type:'string'}, {name:'storeType', type:'string', defaultValue:null}, {name:'createAction', type:'string', defaultValue:null}, {name:'searchFields', defaultValue:null}, {name:'subCreateActions', defaultValue:null}, {name:'subSearchFields', defaultValue:null}, {name:'hasSubStores', defaultValue:false}]}, 0, 0, 0, 0, 0, 0, [formShared.model, 'IntegrationEntityType'], 0);
Ext.cmd.derive('formShared.view.grid.ManualRowEditor', Ext.grid.RowEditor, {startEdit:function(record, columnHeader) {
  var me = this, editingPlugin = me.editingPlugin, grid = editingPlugin.grid, context = me.context = editingPlugin.context, alreadyVisible = me.isVisible(), wrapEl = me.wrapEl;
  if (me._cachedNode) {
    me.clearCache();
  }
  Ext.suspendLayouts();
  if (!me.rendered) {
    me.width = me.getClientWidth();
    me.render(grid.el, grid.el.dom.firstChild);
    wrapEl = me.wrapEl = me.el.wrap();
    wrapEl.setVisibilityMode(3);
    wrapEl.addCls(me._wrapCls);
    me.getFloatingButtons().render(wrapEl);
    me.onViewScroll();
  }
  me.setLocalY(0);
  me.context = context;
  me.onGridResize();
  me.loadRecord(record);
  Ext.resumeLayouts(alreadyVisible);
  if (alreadyVisible) {
    me.reposition(true);
  } else {
    me.skipFocusScroll = true;
    me.show();
  }
}}, 0, ['manualroweditor'], ['component', 'box', 'container', 'panel', 'form', 'roweditor', 'manualroweditor'], {'component':true, 'box':true, 'container':true, 'panel':true, 'form':true, 'roweditor':true, 'manualroweditor':true}, ['widget.manualroweditor'], 0, [formShared.view.grid, 'ManualRowEditor'], 0);
Ext.cmd.derive('formShared.plugin.ManualEditing', Ext.grid.plugin.RowEditing, {initEditTriggers:Ext.emptyFn, initEditor:function() {
  return new formShared.view.grid.ManualRowEditor(this.initEditorConfig());
}}, 0, 0, 0, 0, ['plugin.manualediting'], 0, [formShared.plugin, 'ManualEditing'], 0);
Ext.cmd.derive('formShared.view.components.Combo', Ext.form.field.ComboBox, {cls:'detail-form-combo', ui:'detail-form', width:160, editable:false, queryMode:'local', labelAlign:'top', labelSeparator:'', constructor:function(config) {
  if (config && config.showRequiredText) {
    config.afterLabelTextTpl = new Ext.XTemplate('\x3cspan class\x3d"mvRequired"\x3e(mvstr[G_Required])\x3c/span\x3e');
  }
  Ext.form.field.ComboBox.prototype.constructor.apply(this, arguments);
}, listeners:{render:function() {
  if (this.labelEl) {
    this.labelEl.on('mousedown', function(e) {
      if (this.isExpanded) {
        e.stopEvent();
      }
    }.bind(this));
  }
}}}, 1, ['detailformcombo'], ['component', 'box', 'field', 'textfield', 'pickerfield', 'combobox', 'combo', 'detailformcombo'], {'component':true, 'box':true, 'field':true, 'textfield':true, 'pickerfield':true, 'combobox':true, 'combo':true, 'detailformcombo':true}, ['widget.detailformcombo'], 0, [formShared.view.components, 'Combo'], 0);
Ext.cmd.derive('formShared.view.components.ComboGrouped', formShared.view.components.Combo, {queryMode:'local', displayField:'name', valueField:'id', listConfig:{cls:'grouped-list'}, config:{grouperField:'category'}, initComponent:function() {
  var grouperField = this.getGrouperField();
  this.tpl = Ext.create('Ext.XTemplate', '{[this.currentKey \x3d null]}\x3ctpl for\x3d"."\x3e', '\x3ctpl if\x3d"this.shouldShowHeader(' + grouperField + ')"\x3e\x3cdiv class\x3d"group-header"\x3e{[this.showHeader(values.' + grouperField + ')]}\x3c/div\x3e\x3c/tpl\x3e\x3cdiv class\x3d"x-boundlist-item"\x3e{name}\x3c/div\x3e', '\x3c/tpl\x3e', {shouldShowHeader:function(key) {
    return this.currentKey != key;
  }, showHeader:function(key) {
    this.currentKey = key;
    return key;
  }});
  formShared.view.components.Combo.prototype.initComponent.apply(this, arguments);
}}, 0, ['detailformgroupedcombo'], ['component', 'box', 'field', 'textfield', 'pickerfield', 'combobox', 'combo', 'detailformcombo', 'detailformgroupedcombo'], {'component':true, 'box':true, 'field':true, 'textfield':true, 'pickerfield':true, 'combobox':true, 'combo':true, 'detailformcombo':true, 'detailformgroupedcombo':true}, ['widget.detailformgroupedcombo'], 0, [formShared.view.components, 'ComboGrouped'], 0);
Ext.cmd.derive('formShared.view.components.ComboMultiselect', Ext.form.field.Tag, {cls:'detail-form-multi-combo', ui:'detail-form', width:160, selectOnFocus:false, grow:false, queryMode:'local', labelAlign:'top', labelSeparator:'', listConfig:{cls:'detail-form-multi-combo', getInnerTpl:function(displayField) {
  return '\x3cimg src\x3d"' + Ext.BLANK_IMAGE_URL + '" class\x3d"checkbox" /\x3e {' + displayField + '}';
}}, listeners:{render:function() {
  if (this.labelEl) {
    this.labelEl.on('mousedown', function(e) {
      if (this.isExpanded) {
        e.stopEvent();
      }
    }.bind(this));
  }
}}}, 0, ['detailformmulticombo'], ['component', 'box', 'field', 'textfield', 'pickerfield', 'combobox', 'combo', 'tagfield', 'detailformmulticombo'], {'component':true, 'box':true, 'field':true, 'textfield':true, 'pickerfield':true, 'combobox':true, 'combo':true, 'tagfield':true, 'detailformmulticombo':true}, ['widget.detailformmulticombo'], 0, [formShared.view.components, 'ComboMultiselect'], 0);
Ext.cmd.derive('formShared.view.components.DateField', Ext.form.field.Date, {ui:'detail-form', labelAlign:'top', labelSeparator:'', cls:'with-icon', mvPickerUI:'mds-light'}, 0, ['detailformdatefield'], ['component', 'box', 'field', 'textfield', 'pickerfield', 'datefield', 'detailformdatefield'], {'component':true, 'box':true, 'field':true, 'textfield':true, 'pickerfield':true, 'datefield':true, 'detailformdatefield':true}, ['widget.detailformdatefield'], 0, [formShared.view.components, 'DateField'], 
0);
Ext.cmd.derive('formShared.view.components.MultiSelect', Ext.container.Container, {config:{layout:{type:'vbox'}, width:300, title:'', displayField:'text', valueField:'', viewConfig:{}, cls:{$value:['mds-multiselect'], merge:function(newValue, oldValue) {
  var val = [].concat(newValue, oldValue);
  return val;
}}}, initComponent:function() {
  var displayField = this.getDisplayField(), title = this.getTitle(), viewConfig = this.getViewConfig(), requiredHtml = this.config.required ? '\x3cspan class\x3d"mvRequired"\x3e(' + mvstr['TL_Required'] + ')\x3c/span\x3e' : '';
  this.setValueField(this.getValueField() || displayField);
  Ext.applyIf(this, {items:[{xtype:'container', width:'100%', layout:{type:'hbox', align:'middle'}, items:[{xtype:'label', cls:'x-form-item-label-detail-form', html:title + requiredHtml, flex:1}, {xtype:'button', itemId:'addButton', ui:'orange', text:'+', cls:'multiselect-add', width:18, height:18, textAlign:'center', listeners:{click:function() {
    this.up('multiselect').fireEvent('onaddclick');
  }}}]}, {xtype:'component', flex:1}, Ext.merge({xtype:'dataview', cls:'multiselect-view', width:this.config.width, height:105, minHeight:27, scrollable:{x:false, y:'auto'}, itemSelector:'.multiselect-item', tpl:new Ext.XTemplate('\x3ctpl for\x3d"."\x3e', '\x3cdiv class\x3d"multiselect-item"\x3e', '\x3cspan class\x3d"multiselect-value"\x3e{' + displayField + '}\x3c/span\x3e', '\x3cspan class\x3d"multiselect-remove"\x3e\x3c/span\x3e', '\x3c/div\x3e', '\x3c/tpl\x3e'), listeners:{itemclick:function(dataview, 
  record, item, index, e) {
    if (Ext.fly(e.getTarget()).hasCls('multiselect-remove')) {
      dataview.getStore().remove(record);
      this.up('multiselect').fireEvent('removerecord', record);
    }
  }}}, viewConfig)]});
  Ext.container.Container.prototype.initComponent.apply(this, arguments);
}, setReadOnly:function(readOnly) {
  if (readOnly) {
    this.el.removeCls('can-edit');
  } else {
    this.el.addCls('can-edit');
  }
}, setWidth:function(width) {
  var dataview = this.down('dataview');
  if (dataview) {
    dataview.setWidth(width);
  }
  (arguments.callee.$previous || Ext.container.Container.prototype.setWidth).apply(this, arguments);
}}, 0, ['multiselect'], ['component', 'box', 'container', 'multiselect'], {'component':true, 'box':true, 'container':true, 'multiselect':true}, ['widget.multiselect'], 0, [formShared.view.components, 'MultiSelect'], 0);
Ext.cmd.derive('formShared.view.components.NumberField', Ext.form.field.Number, {ui:'detail-form', labelAlign:'top', hideTrigger:true, labelSeparator:''}, 0, ['detailformnumberfield'], ['component', 'box', 'field', 'textfield', 'spinnerfield', 'numberfield', 'detailformnumberfield'], {'component':true, 'box':true, 'field':true, 'textfield':true, 'spinnerfield':true, 'numberfield':true, 'detailformnumberfield':true}, ['widget.detailformnumberfield'], 0, [formShared.view.components, 'NumberField'], 
0);
Ext.cmd.derive('formShared.view.components.PhotoSelectionThumb', Ext.Component, {viewModel:{formulas:{photoSrc:function(get) {
  var store = get('selectedPhotos');
  if (!store) {
    return 'mds/images/transparent.png';
  }
  return store.getAt(0).get('ImageURLMedium');
}, photoCount:function(get) {
  var store = get('selectedPhotos');
  if (!store) {
    return 0;
  }
  return store.getCount();
}, description:function(get) {
  var photoCount = get('photoCount');
  return photoCount + ' ' + (photoCount == 1 ? 'photo' : 'photos') + ' selected';
}}}, bind:{html:'\x3cdiv class\x3d"wrapper"\x3e\x3cimg src\x3d"{photoSrc}"\x3e\x3c/div\x3e\x3cdiv class\x3d"description"\x3e{description}\x3c/div\x3e'}, initComponent:function() {
  this.getViewModel().bind('{photoCount}', Ext.bind(function(photoCount) {
    if (photoCount == 1) {
      this.removeCls('multiple');
      this.addCls('single');
    } else {
      this.removeCls('single');
      this.addCls('multiple');
    }
  }, this));
  Ext.Component.prototype.initComponent.apply(this, arguments);
}}, 0, ['photoselectionthumb'], ['component', 'box', 'photoselectionthumb'], {'component':true, 'box':true, 'photoselectionthumb':true}, ['widget.photoselectionthumb'], 0, [formShared.view.components, 'PhotoSelectionThumb'], 0);
(function() {
  var img1 = new Image, img2 = new Image;
  img1.src = 'mds/image/component/photothumb-top.svg';
  img2.src = 'mds/image/component/photothumb-left.svg';
})();
Ext.cmd.derive('formShared.view.components.SaveButton', Ext.Container, {layout:{type:'absolute'}, config:{disabled:false, processing:false, done:false, width:62, height:30, localized:{text:'G_Done'}}, viewModel:{data:{disabled:false, processing:false, done:false, buttonWidth:62, localized:{buttonText:'G_Done'}}, formulas:{imageVisible:function(get) {
  return get('processing') || get('done');
}, imageCls:function(get) {
  if (get('done')) {
    return 'done';
  }
  if (get('processing')) {
    return 'processing';
  }
  return '';
}}}, setDisabled:function(disabled) {
  this.getViewModel().set('disabled', disabled);
}, updateProcessing:function(processing) {
  this.getViewModel().set('processing', processing);
}, updateDone:function(done) {
  this.getViewModel().set('done', done);
}, setWidth:function(width) {
  var rv = (arguments.callee.$previous || Ext.container.Container.prototype.setWidth).apply(this, arguments);
  this.getViewModel().set('buttonWidth', width);
  this.setIndicatorX(width + 10);
  return rv;
}, updateText:function(text) {
  this.getViewModel().set('buttonText', text);
}, setIndicatorX:function(x) {
  if (this.items && this.items.length > 0) {
    if (this.items[1]) {
      this.items[1].x = x;
    } else {
      if (this.items.items && this.items.items[1]) {
        this.items.items[1].setLocalX(x);
      }
    }
  }
}, items:[{xtype:'button', x:0, y:0, width:62, scale:'medium', ui:'green', localized:{text:'G_Done'}, bind:{disabled:'{disabled}', text:'{buttonText}', width:'{buttonWidth}'}, listeners:{click:function() {
  var saveBtn = this.up('savebutton');
  saveBtn.fireEvent('click', saveBtn);
}}}, {xtype:'component', x:72, y:0, width:30, height:30, hidden:true, cls:'save-button-indicator', setCls:function(cls) {
  this.removeCls('done');
  this.removeCls('processing');
  this.addCls(cls);
}, bind:{hidden:'{!imageVisible}', cls:'{imageCls}'}}]}, 0, ['savebutton'], ['component', 'box', 'container', 'savebutton'], {'component':true, 'box':true, 'container':true, 'savebutton':true}, ['widget.savebutton'], 0, [formShared.view.components, 'SaveButton'], 0);
Ext.cmd.derive('formShared.view.components.ScrollPageBoundList', Ext.view.BoundList, {preserveScrollOnReload:true, loadMask:false, createPagingToolbar:function() {
  var me = this;
  return new Ext.toolbar.Paging({id:me.id + '-paging-toolbar', pageSize:me.pageSize, store:me.dataSource, border:false, ownerCt:me, ownerLayout:me.getComponentLayout(), style:{display:'none'}});
}, onScroll:function(scroller, x, y) {
  var store = this.pagingToolbar.store;
  if (store.isLoading()) {
    return;
  }
  var maxY = scroller.getMaxPosition().y;
  if (maxY - y <= 0) {
    var total = this.pagingToolbar.getPageData().pageCount, next = store.currentPage + 1;
    if (next <= total) {
      this.up().loadPage(next, {addRecords:true});
    }
  }
}, listeners:{'viewready':{fn:function() {
  var scrollable = this.getScrollable();
  scrollable.addListener('scroll', this.onScroll, this, {buffer:20});
}, single:true}}}, 0, ['scrollpageboundlist'], ['component', 'box', 'dataview', 'boundlist', 'scrollpageboundlist'], {'component':true, 'box':true, 'dataview':true, 'boundlist':true, 'scrollpageboundlist':true}, ['widget.scrollpageboundlist'], 0, [formShared.view.components, 'ScrollPageBoundList'], 0);
Ext.cmd.derive('formShared.view.components.SearchField', Ext.form.field.Text, {ui:'searchfield', cls:'empty', triggers:{clear:{cls:'clear', hidden:true, handler:function() {
  this.setValue('');
}}}, listeners:{change:function(textField, newValue) {
  textField.getTriggers().clear.setHidden(!newValue);
  if (newValue) {
    textField.removeCls('empty');
    textField.fireEvent('search', newValue);
  } else {
    textField.addCls('empty');
    textField.fireEvent('clearsearch');
  }
}}}, 0, ['mvsearchfield'], ['component', 'box', 'field', 'textfield', 'mvsearchfield'], {'component':true, 'box':true, 'field':true, 'textfield':true, 'mvsearchfield':true}, ['widget.mvsearchfield'], 0, [formShared.view.components, 'SearchField'], 0);
Ext.cmd.derive('formShared.view.components.TextArea', Ext.form.field.TextArea, {ui:'detail-form', labelAlign:'top', labelSeparator:''}, 0, ['detailformtextarea'], ['component', 'box', 'field', 'textfield', 'textareafield', 'textarea', 'detailformtextarea'], {'component':true, 'box':true, 'field':true, 'textfield':true, 'textareafield':true, 'textarea':true, 'detailformtextarea':true}, ['widget.detailformtextarea'], 0, [formShared.view.components, 'TextArea'], 0);
Ext.cmd.derive('formShared.view.components.TextDateField', Ext.form.field.Number, {labelSeparator:'', height:17, hideTrigger:true, autoStripChars:true, validator:function() {
  var container = this.up(), day = container.down('#day').getValue(), month = container.down('#month').getValue(), year = container.down('#year').getValue();
  if (year == null && month == null && day == null || Ext.Date.isValid(year, month, day)) {
    return true;
  }
  return 'Please enter a valid date.';
}, listeners:{render:function(field) {
  field.el.select('input').elements[0].setAttribute('maxlength', field.maxLength);
}, change:{fn:function(field) {
  this.up().onFieldChange(field);
}}}}, 0, ['textdatefield'], ['component', 'box', 'field', 'textfield', 'spinnerfield', 'numberfield', 'textdatefield'], {'component':true, 'box':true, 'field':true, 'textfield':true, 'spinnerfield':true, 'numberfield':true, 'textdatefield':true}, ['widget.textdatefield'], 0, [formShared.view.components, 'TextDateField'], 0);
Ext.cmd.derive('formShared.view.components.TextDate', Ext.Container, {layout:'hbox', publishes:['date', 'valid', 'dirty', 'empty'], config:{date:null, valid:true, dirty:false, empty:true, initialDate:-1}, defaults:{xtype:'textdatefield', margin:'0 15 0 0'}, constructor:function(config) {
  config = config || {};
  config.items = [{itemId:'month', fieldLabel:'Month', minValue:1, maxValue:12, width:62, labelWidth:36, maxLength:2}, {itemId:'day', fieldLabel:'Day', minValue:1, maxValue:31, width:48, labelWidth:22, maxLength:2}, {itemId:'year', fieldLabel:'Year', minValue:1753, maxValue:9999, width:68, labelWidth:29, margin:0, maxLength:4}];
  this.empty = !(config.date || this.config.date);
  Ext.container.Container.prototype.constructor.apply(this, arguments);
}, onFieldChange:function() {
  var items = this.items.items, nEmpty = 0, valid = true;
  for (var i = 0; i < items.length; i++) {
    if (!items[i].validate()) {
      valid = false;
    }
    if (items[i].getValue() == null || items[i].getValue() == '') {
      nEmpty++;
    }
  }
  if (nEmpty == 1 || nEmpty == 2) {
    valid = false;
  }
  var day = this.down('#day').getValue(), month = this.down('#month').getValue(), year = this.down('#year').getValue();
  if (!Ext.Date.isValid(year, month, day)) {
    valid = false;
  }
  this.setValid(valid);
  var empty = !!(nEmpty == 3);
  this.setEmpty(empty);
  if (nEmpty == 0 && valid) {
    this.setDate(Ext.Date.parse(day + '-' + month + '-' + year, 'j-n-Y'));
  } else {
    this.setDate(null);
  }
}, getDateFromFields:function() {
  if (!this.getValid()) {
    return null;
  }
  var day = this.down('#day').getValue(), month = this.down('#month').getValue(), year = this.down('#year').getValue();
  return Ext.Date.parse(day + '-' + month + '-' + year, 'j-n-Y');
}, updateDate:function(date) {
  var currentDate = this.getDateFromFields();
  if (!Ext.Date.isEqual(currentDate, date)) {
    this.down('#day').setValue(Number(Ext.Date.format(date, 'j')));
    this.down('#month').setValue(Number(Ext.Date.format(date, 'n')));
    this.down('#year').setValue(Number(Ext.Date.format(date, 'Y')));
  }
  this.setDirty(!Ext.Date.isEqual(date, this.getInitialDate()));
}, updateInitialDate:function(initialDate) {
  this.setDirty(!Ext.Date.isEqual(initialDate, this.getDate()));
}}, 1, ['textdate'], ['component', 'box', 'container', 'textdate'], {'component':true, 'box':true, 'container':true, 'textdate':true}, ['widget.textdate'], 0, [formShared.view.components, 'TextDate'], 0);
Ext.cmd.derive('formShared.view.components.TextField', Ext.form.field.Text, {ui:'detail-form', labelAlign:'top', labelSeparator:'', constructor:function(config) {
  if (config && config.showRequiredText) {
    config.afterLabelTextTpl = new Ext.XTemplate('\x3cspan class\x3d"mvRequired"\x3e(mvstr[G_Required])\x3c/span\x3e');
  }
  Ext.form.field.Text.prototype.constructor.apply(this, arguments);
}}, 1, ['detailformtextfield'], ['component', 'box', 'field', 'textfield', 'detailformtextfield'], {'component':true, 'box':true, 'field':true, 'textfield':true, 'detailformtextfield':true}, ['widget.detailformtextfield'], 0, [formShared.view.components, 'TextField'], 0);
Ext.cmd.derive('formShared.view.integrations.FileSelectionBox', Ext.Container, {layout:{type:'hbox', align:'middle'}, cls:'file-selection-box noselect', width:202, height:51, padding:'0 0 0 10', listeners:{click:{fn:function(e, t) {
  if (t.type != 'checkbox') {
    var checkbox = Ext.getCmp(this.id).down('checkbox');
    checkbox.setValue(!checkbox.getValue());
  }
}, element:'el', scope:'this'}}}, 0, ['integrationfileselectionbox'], ['component', 'box', 'container', 'integrationfileselectionbox'], {'component':true, 'box':true, 'container':true, 'integrationfileselectionbox':true}, ['widget.integrationfileselectionbox'], 0, [formShared.view.integrations, 'FileSelectionBox'], 0);
Ext.cmd.derive('formShared.view.integrations.Attachment', Ext.Container, {layout:'vbox', width:'100%', constructor:function(config) {
  config = config || {};
  config.photoBinding = config.photoBinding || '{integrationAttachAsPhoto}';
  config.pdfBinding = config.pdfBinding || '{integrationAttachAs4View}';
  config.items = [{xtype:'label', cls:'instructions', localized:{html:'INT_SelectFiles'}, margin:'0 0 15 0', bind:{hidden:'{attachFloorplanOnly}'}}, {xtype:'container', layout:'hbox', width:'100%', items:[{xtype:'integrationfileselectionbox', items:[{xtype:'checkboxfield', inputValue:true, uncheckedValue:false, itemId:'attachPhoto', name:'attachAsPhoto', margin:'0 14 0 0', ui:'plain-16', bind:{value:config.photoBinding, disabled:'{attachFloorplanOnly}'}, isValid:function() {
    if (this.isDisabled()) {
      return true;
    }
    return !!(this.getValue() || this.up('integrationattachment').down('#attachDetails').getValue());
  }, getErrors:function() {
    return this.isValid() ? [] : [mvstr['INTMSG_NoAttachment']];
  }}, {xtype:'image', src:'mds/image/icon/photo.png', width:32, height:26, margin:'0 14 0 0'}, {xtype:'label', localized:{html:'INT_SelectFilesJPG'}, width:63}]}, {xtype:'component', flex:1}, {xtype:'integrationfileselectionbox', items:[{xtype:'checkboxfield', inputValue:true, uncheckedValue:false, itemId:'attachDetails', name:'attachAs4View', ui:'plain-16', margin:'0 14 0 0', bind:{value:config.pdfBinding, disabled:'{attachFloorplanOnly}'}, isValid:function() {
    if (this.isDisabled()) {
      return true;
    }
    return !!(this.getValue() || this.up('integrationattachment').down('#attachPhoto').getValue());
  }, getActiveErrors:function() {
    return this.isValid() ? [] : [mvstr['INTMSG_NoAttachment']];
  }}, {xtype:'image', src:'mds/image/icon/details.png', width:36, height:29, margin:'0 14 0 0'}, {xtype:'label', localized:{html:'INT_SelectFilesPDF'}, width:102}]}], bind:{hidden:'{attachFloorplanOnly}'}}, {xtype:'container', layout:'column', cls:'floorplan-export-attachment', items:[{xtype:'label', cls:'instructions', localized:{html:'INT_FloorplanInstructions'}, width:'100%', margin:'0 0 15 0'}, {xtype:'checkboxfield', name:'displayHeader', inputValue:true, uncheckedValue:false, ui:'plain-16', 
  localized:{boxLabel:'INT_FloorplanProjectNameTitle'}, itemId:'headerCheckbox', value:true, width:'100%', margin:'0 0 8 0'}, {xtype:'checkboxfield', name:'displayHotspots', inputValue:true, uncheckedValue:false, ui:'plain-16', localized:{boxLabel:'INT_FloorplanMVContent'}, itemId:'hotspotsCheckbox', value:true, width:202, margin:'0 28 0 0', hidden:true, bind:{hidden:'{!account.MultivistaContentPermission}'}}, {xtype:'checkboxfield', name:'displayPushpins', inputValue:true, uncheckedValue:false, 
  ui:'plain-16', localized:{boxLabel:'INT_FloorplanUDEFContent'}, itemId:'pushpinsCheckbox', value:true, width:202, hidden:true, bind:{hidden:'{!account.canRead}'}}], hidden:true, bind:{visible:'{attachFloorplanOnly}', disabled:'{!attachFloorplanOnly}'}}];
  Ext.container.Container.prototype.constructor.call(this, config);
}}, 1, ['integrationattachment'], ['component', 'box', 'container', 'integrationattachment'], {'component':true, 'box':true, 'container':true, 'integrationattachment':true}, ['widget.integrationattachment'], 0, [formShared.view.integrations, 'Attachment'], 0);
Ext.cmd.derive('formShared.view.integrations.Comments', formShared.view.components.TextArea, {localized:{fieldLabel:'INT_Comments'}, itemId:'comments', width:'100%', height:110, margin:'0 0 28 0', name:'comment'}, 0, ['integrationcomments'], ['component', 'box', 'field', 'textfield', 'textareafield', 'textarea', 'detailformtextarea', 'integrationcomments'], {'component':true, 'box':true, 'field':true, 'textfield':true, 'textareafield':true, 'textarea':true, 'detailformtextarea':true, 'integrationcomments':true}, 
['widget.integrationcomments'], 0, [formShared.view.integrations, 'Comments'], 0);
Ext.cmd.derive('formShared.view.integrations.Lookup', formShared.view.components.Combo, {name:'id', width:202, config:{entityType:null, noItemsAvailable:false}, itemId:'entities', editable:true, localized:{emptyText:'G_Select', fieldLabel:'INT_Item'}, queryMode:'local', displayField:'displayField', valueField:'id', disabled:true, forceSelection:true, listConfig:{loadMask:false}, bind:{value:'{entityID}', disabled:'{!projectsLoaded}', entityType:'{entityType}', store:'{entityStore}', emptyText:'{emptyText}', 
noItemsAvailable:'{noItemsAvailable}'}, updateNoItemsAvailable:function(noItemsAvailable) {
  if (noItemsAvailable) {
    this.addCls('no-items-available');
  } else {
    this.removeCls('no-items-available');
  }
}, getLookupFilter:function(value) {
  var entityType = this.getEntityType(), searchFields = entityType.get('searchFields') || entityType.get('subSearchFields')[this.lookupController().getViewModel().get('subType')], lcValue = value.toLowerCase(), matchFn = function(value) {
    return !!String(value).toLowerCase().match(lcValue);
  };
  return this.queryFilter = new Ext.util.Filter({id:this.id + '-filter', filterFn:function(rec) {
    for (var i = 0; i < searchFields.length; i++) {
      var recordValue = rec.get(searchFields[i]);
      if (typeof recordValue == 'object') {
        for (var key in recordValue) {
          if (matchFn(recordValue[key])) {
            return true;
          }
        }
      }
      if (matchFn(recordValue)) {
        return true;
      }
    }
    return false;
  }});
}, doLocalQuery:function(queryPlan) {
  var me = this, queryString = queryPlan.query, store = me.getStore(), value = queryString, filter;
  me.clearLocalFilter();
  if (queryString) {
    if (value !== null) {
      me.changingFilters = true;
      filter = me.queryFilter = me.getLookupFilter(value);
      store.addFilter(filter, true);
      me.changingFilters = false;
    }
  }
  if (me.store.getCount() || me.getPicker().emptyText) {
    me.getPicker().refresh();
    me.expand();
  } else {
    me.collapse();
  }
  me.afterQuery(queryPlan);
}, getErrors:function() {
  if (this.getValue()) {
    return [];
  }
  var store = this.getStore();
  if (store.isLoaded() && !store.getCount()) {
    return [mvstr['INTMSG_NoItems']];
  } else {
    return [mvstr['INTMSG_NoItem']];
  }
}}, 0, ['integrationlookup'], ['component', 'box', 'field', 'textfield', 'pickerfield', 'combobox', 'combo', 'detailformcombo', 'integrationlookup'], {'component':true, 'box':true, 'field':true, 'textfield':true, 'pickerfield':true, 'combobox':true, 'combo':true, 'detailformcombo':true, 'integrationlookup':true}, ['widget.integrationlookup'], 0, [formShared.view.integrations, 'Lookup'], 0);
Ext.cmd.derive('formShared.view.integrations.RemoteLookup', formShared.view.components.Combo, {width:202, config:{entityType:null, noItemsAvailable:false}, itemId:'entities', editable:true, fieldLabel:'Item', localized:{emptyText:'G_Select'}, queryMode:'remote', minChars:1, displayField:'displayField', valueField:'id', disabled:true, forceSelection:true, pageSize:25, autoSelect:false, clearFilterOnBlur:false, bind:{value:'{entityID}', disabled:'{!projectsLoaded}', entityType:'{entityType}', store:'{entityStore}', 
emptyText:'{emptyText}', noItemsAvailable:'{noItemsAvailable}'}, updateNoItemsAvailable:function(noItemsAvailable) {
  if (noItemsAvailable) {
    this.addCls('no-items-available');
  } else {
    this.removeCls('no-items-available');
  }
}, createPicker:function() {
  var me = this, picker, pickerCfg = Ext.apply({xtype:'scrollpageboundlist', id:me.id + '-picker', pickerField:me, selectionModel:me.pickerSelectionModel, floating:true, hidden:true, store:me.getPickerStore(), displayField:me.displayField, preserveScrollOnRefresh:true, pageSize:me.pageSize, tpl:me.tpl, ariaSelectable:me.ariaSelectable}, me.listConfig, me.defaultListConfig);
  picker = me.picker = Ext.widget(pickerCfg);
  if (me.pageSize) {
    picker.pagingToolbar.on('beforechange', me.onPageChange, me);
  }
  if (!picker.initialConfig.maxHeight) {
    picker.on({beforeshow:me.onBeforePickerShow, scope:me});
  }
  picker.getSelectionModel().on({beforeselect:me.onBeforeSelect, beforedeselect:me.onBeforeDeselect, focuschange:me.onFocusChange, scope:me});
  picker.getNavigationModel().navigateOnSpace = false;
  return picker;
}, afterQuery:function() {
  if (!this.store) {
    return;
  }
  formShared.view.components.Combo.prototype.afterQuery.apply(this, arguments);
}, onTriggerClick:function(field, trigger, e) {
  var me = this, oldAutoSelect;
  if (!me.readOnly && !me.disabled) {
    if (me.isExpanded) {
      me.collapse();
    } else {
      if (e && e.type === 'keydown' && e.altKey) {
        oldAutoSelect = me.autoSelect;
        me.autoSelect = false;
        me.expand();
        me.autoSelect = oldAutoSelect;
      } else {
        if (!me.lastQuery) {
          if (me.triggerAction === 'all') {
            me.doQuery(me.allQuery, true);
          } else {
            if (me.triggerAction === 'last') {
              me.doQuery(me.lastQuery, true);
            } else {
              me.doQuery(me.getRawValue(), false, true);
            }
          }
        } else {
          me.expand();
        }
      }
    }
  }
}, getErrors:function() {
  if (this.getValue()) {
    return [];
  }
  var store = this.getStore();
  if (store.isLoaded() && !store.getCount()) {
    return [mvstr['INTMSG_NoItems']];
  } else {
    return [mvstr['INTMSG_NoItem']];
  }
}}, 0, ['integrationremotelookup'], ['component', 'box', 'field', 'textfield', 'pickerfield', 'combobox', 'combo', 'detailformcombo', 'integrationremotelookup'], {'component':true, 'box':true, 'field':true, 'textfield':true, 'pickerfield':true, 'combobox':true, 'combo':true, 'detailformcombo':true, 'integrationremotelookup':true}, ['widget.integrationremotelookup'], 0, [formShared.view.integrations, 'RemoteLookup'], 0);
Ext.cmd.derive('formShared.view.integrations.SubType', formShared.view.components.Combo, {width:202, itemId:'subType', localized:{fieldLabel:'INT_Action', emptyText:'G_Select'}, queryMode:'local', displayField:'name', valueField:'id', editable:false, submitValue:false}, 0, ['integrationssubtype'], ['component', 'box', 'field', 'textfield', 'pickerfield', 'combobox', 'combo', 'detailformcombo', 'integrationssubtype'], {'component':true, 'box':true, 'field':true, 'textfield':true, 'pickerfield':true, 
'combobox':true, 'combo':true, 'detailformcombo':true, 'integrationssubtype':true}, ['widget.integrationssubtype'], 0, [formShared.view.integrations, 'SubType'], 0);
Ext.cmd.derive('formShared.view.integrations.Type', formShared.view.components.Combo, {width:202, localized:{fieldLabel:'INT_Type', emptyText:'G_Select'}, queryMode:'local', displayField:'name', valueField:'id', editable:false, disabled:true, bind:{value:'{integrationEntityType}', store:'{integrationEntityTypes}', disabled:'{!projectSelected}'}, submitValue:false}, 0, ['integrationtype'], ['component', 'box', 'field', 'textfield', 'pickerfield', 'combobox', 'combo', 'detailformcombo', 'integrationtype'], 
{'component':true, 'box':true, 'field':true, 'textfield':true, 'pickerfield':true, 'combobox':true, 'combo':true, 'detailformcombo':true, 'integrationtype':true}, ['widget.integrationtype'], 0, [formShared.view.integrations, 'Type'], 0);
Ext.cmd.derive('Ext.ux.IFrame', Ext.Component, {loadMask:'Loading...', src:'about:blank', renderTpl:['\x3ciframe src\x3d"{src}" id\x3d"{id}-iframeEl" data-ref\x3d"iframeEl" name\x3d"{frameName}" width\x3d"100%" height\x3d"100%" frameborder\x3d"0"\x3e\x3c/iframe\x3e'], childEls:['iframeEl'], initComponent:function() {
  Ext.Component.prototype.initComponent.call(this);
  this.frameName = this.frameName || this.id + '-frame';
}, initEvents:function() {
  var me = this;
  Ext.Component.prototype.initEvents.call(this);
  me.iframeEl.on('load', me.onLoad, me);
}, initRenderData:function() {
  return Ext.apply(Ext.Component.prototype.initRenderData.call(this), {src:this.src, frameName:this.frameName});
}, getBody:function() {
  var doc = this.getDoc();
  return doc.body || doc.documentElement;
}, getDoc:function() {
  try {
    return this.getWin().document;
  } catch (ex) {
    return null;
  }
}, getWin:function() {
  var me = this, name = me.frameName, win = Ext.isIE ? me.iframeEl.dom.contentWindow : window.frames[name];
  return win;
}, getFrame:function() {
  var me = this;
  return me.iframeEl.dom;
}, onLoad:function() {
  var me = this, doc = me.getDoc();
  if (doc) {
    this.el.unmask();
    this.fireEvent('load', this);
  } else {
    if (me.src) {
      this.el.unmask();
      this.fireEvent('error', this);
    }
  }
}, load:function(src) {
  var me = this, text = me.loadMask, frame = me.getFrame();
  if (me.fireEvent('beforeload', me, src) !== false) {
    if (text && me.el) {
      me.el.mask(text);
    }
    frame.src = me.src = src || me.src;
  }
}}, 0, ['uxiframe'], ['component', 'box', 'uxiframe'], {'component':true, 'box':true, 'uxiframe':true}, ['widget.uxiframe'], 0, [Ext.ux, 'IFrame'], 0);
Ext.cmd.derive('Ext.ux.colorpick.Selection', Ext.Base, {mixinId:'colorselection', config:{format:'hex6', value:'FF0000', color:null, previousColor:null}, applyColor:function(color) {
  var c = color;
  if (Ext.isString(c)) {
    c = Ext.ux.colorpick.ColorUtils.parseColor(color);
  }
  return c;
}, applyValue:function(color) {
  var c = Ext.ux.colorpick.ColorUtils.parseColor(color || '#000000');
  return this.formatColor(c);
}, formatColor:function(color) {
  return Ext.ux.colorpick.ColorUtils.formats[this.getFormat()](color);
}, updateColor:function(color) {
  var me = this;
  if (!me.syncing) {
    me.syncing = true;
    me.setValue(me.formatColor(color));
    me.syncing = false;
  }
}, updateValue:function(value, oldValue) {
  var me = this;
  if (!me.syncing) {
    me.syncing = true;
    me.setColor(value);
    me.syncing = false;
  }
  this.fireEvent('change', me, value, oldValue);
}}, 0, 0, 0, 0, 0, 0, [Ext.ux.colorpick, 'Selection'], 0);
Ext.cmd.derive('Ext.ux.colorpick.ColorUtils', Ext.Base, function(ColorUtils) {
  var oldIE = Ext.isIE && Ext.ieVersion < 10;
  return {singleton:true, constructor:function() {
    ColorUtils = this;
  }, backgroundTpl:oldIE ? "filter: progid:DXImageTransform.Microsoft.gradient(GradientType\x3d0, startColorstr\x3d'#{alpha}{hex}', endColorstr\x3d'#{alpha}{hex}');" : 'background: {rgba};', setBackground:oldIE ? function(el, color) {
    if (el) {
      var tpl = Ext.XTemplate.getTpl(ColorUtils, 'backgroundTpl'), data = {hex:ColorUtils.rgb2hex(color.r, color.g, color.b), alpha:Math.floor(color.a * 255).toString(16)}, bgStyle = tpl.apply(data);
      el.applyStyles(bgStyle);
    }
  } : function(el, color) {
    if (el) {
      var tpl = Ext.XTemplate.getTpl(ColorUtils, 'backgroundTpl'), data = {rgba:ColorUtils.getRGBAString(color)}, bgStyle = tpl.apply(data);
      el.applyStyles(bgStyle);
    }
  }, formats:{HEX6:function(colorO) {
    return ColorUtils.rgb2hex(colorO.r, colorO.g, colorO.b);
  }, HEX8:function(colorO) {
    var hex = ColorUtils.rgb2hex(colorO.r, colorO.g, colorO.b), opacityHex = Math.round(colorO.a * 255).toString(16);
    if (opacityHex.length < 2) {
      hex += '0';
    }
    hex += opacityHex.toUpperCase();
    return hex;
  }}, hexRe:/^#?([0-9a-f]{3,8})$/i, rgbaAltRe:/^rgba\(\s*([\w#\d]+)\s*,\s*([\d\.]+)\s*\)$/, rgbaRe:/^rgba\(\s*([\d\.]+)\s*,\s*([\d\.]+)\s*,\s*([\d\.]+)\s*,\s*([\d\.]+)\s*\)$/, rgbRe:/^rgb\(\s*([\d\.]+)\s*,\s*([\d\.]+)\s*,\s*([\d\.]+)\s*\)$/, parseColor:function(color) {
    if (!color) {
      return null;
    }
    var me = this, rgb = me.colorMap[color], match, ret, hsv;
    if (rgb) {
      ret = {r:rgb[0], g:rgb[1], b:rgb[2], a:1};
    } else {
      if (color === 'transparent') {
        ret = {r:0, g:0, b:0, a:0};
      } else {
        match = me.hexRe.exec(color);
        if (match) {
          match = match[1];
          switch(match.length) {
            default:
              return null;
            case 3:
              ret = {r:parseInt(match[0] + match[0], 16), g:parseInt(match[1] + match[1], 16), b:parseInt(match[2] + match[2], 16), a:1};
              break;
            case 6:
            case 8:
              ret = {r:parseInt(match.substr(0, 2), 16), g:parseInt(match.substr(2, 2), 16), b:parseInt(match.substr(4, 2), 16), a:parseInt(match.substr(6, 2) || 'ff', 16) / 255};
              break;
          }
        } else {
          match = me.rgbaRe.exec(color);
          if (match) {
            ret = {r:parseFloat(match[1]), g:parseFloat(match[2]), b:parseFloat(match[3]), a:parseFloat(match[4])};
          } else {
            match = me.rgbaAltRe.exec(color);
            if (match) {
              ret = me.parseColor(match[1]);
              ret.a = parseFloat(match[2]);
              return ret;
            }
            match = me.rgbRe.exec(color);
            if (match) {
              ret = {r:parseFloat(match[1]), g:parseFloat(match[2]), b:parseFloat(match[3]), a:1};
            } else {
              return null;
            }
          }
        }
      }
    }
    hsv = this.rgb2hsv(ret.r, ret.g, ret.b);
    return Ext.apply(ret, hsv);
  }, getRGBAString:function(rgba) {
    return 'rgba(' + rgba.r + ',' + rgba.g + ',' + rgba.b + ',' + rgba.a + ')';
  }, getRGBString:function(rgb) {
    return 'rgb(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ')';
  }, hsv2rgb:function(h, s, v) {
    h = h * 360;
    if (h === 360) {
      h = 0;
    }
    var c = v * s;
    var hprime = h / 60;
    var x = c * (1 - Math.abs(hprime % 2 - 1));
    var rgb = [0, 0, 0];
    switch(Math.floor(hprime)) {
      case 0:
        rgb = [c, x, 0];
        break;
      case 1:
        rgb = [x, c, 0];
        break;
      case 2:
        rgb = [0, c, x];
        break;
      case 3:
        rgb = [0, x, c];
        break;
      case 4:
        rgb = [x, 0, c];
        break;
      case 5:
        rgb = [c, 0, x];
        break;
      default:
        break;
    }
    var m = v - c;
    rgb[0] += m;
    rgb[1] += m;
    rgb[2] += m;
    rgb[0] = Math.round(rgb[0] * 255);
    rgb[1] = Math.round(rgb[1] * 255);
    rgb[2] = Math.round(rgb[2] * 255);
    return {r:rgb[0], g:rgb[1], b:rgb[2]};
  }, rgb2hsv:function(r, g, b) {
    r = r / 255;
    g = g / 255;
    b = b / 255;
    var M = Math.max(r, g, b);
    var m = Math.min(r, g, b);
    var c = M - m;
    var hprime = 0;
    if (c !== 0) {
      if (M === r) {
        hprime = (g - b) / c % 6;
      } else {
        if (M === g) {
          hprime = (b - r) / c + 2;
        } else {
          if (M === b) {
            hprime = (r - g) / c + 4;
          }
        }
      }
    }
    var h = hprime * 60;
    if (h === 360) {
      h = 0;
    }
    var v = M;
    var s = 0;
    if (c !== 0) {
      s = c / v;
    }
    h = h / 360;
    if (h < 0) {
      h = h + 1;
    }
    return {h:h, s:s, v:v};
  }, rgb2hex:function(r, g, b) {
    r = r.toString(16);
    g = g.toString(16);
    b = b.toString(16);
    if (r.length < 2) {
      r = '0' + r;
    }
    if (g.length < 2) {
      g = '0' + g;
    }
    if (b.length < 2) {
      b = '0' + b;
    }
    return (r + g + b).toUpperCase();
  }, colorMap:{aliceblue:[240, 248, 255], antiquewhite:[250, 235, 215], aqua:[0, 255, 255], aquamarine:[127, 255, 212], azure:[240, 255, 255], beige:[245, 245, 220], bisque:[255, 228, 196], black:[0, 0, 0], blanchedalmond:[255, 235, 205], blue:[0, 0, 255], blueviolet:[138, 43, 226], brown:[165, 42, 42], burlywood:[222, 184, 135], cadetblue:[95, 158, 160], chartreuse:[127, 255, 0], chocolate:[210, 105, 30], coral:[255, 127, 80], cornflowerblue:[100, 149, 237], cornsilk:[255, 248, 220], crimson:[220, 
  20, 60], cyan:[0, 255, 255], darkblue:[0, 0, 139], darkcyan:[0, 139, 139], darkgoldenrod:[184, 132, 11], darkgray:[169, 169, 169], darkgreen:[0, 100, 0], darkgrey:[169, 169, 169], darkkhaki:[189, 183, 107], darkmagenta:[139, 0, 139], darkolivegreen:[85, 107, 47], darkorange:[255, 140, 0], darkorchid:[153, 50, 204], darkred:[139, 0, 0], darksalmon:[233, 150, 122], darkseagreen:[143, 188, 143], darkslateblue:[72, 61, 139], darkslategray:[47, 79, 79], darkslategrey:[47, 79, 79], darkturquoise:[0, 
  206, 209], darkviolet:[148, 0, 211], deeppink:[255, 20, 147], deepskyblue:[0, 191, 255], dimgray:[105, 105, 105], dimgrey:[105, 105, 105], dodgerblue:[30, 144, 255], firebrick:[178, 34, 34], floralwhite:[255, 255, 240], forestgreen:[34, 139, 34], fuchsia:[255, 0, 255], gainsboro:[220, 220, 220], ghostwhite:[248, 248, 255], gold:[255, 215, 0], goldenrod:[218, 165, 32], gray:[128, 128, 128], green:[0, 128, 0], greenyellow:[173, 255, 47], grey:[128, 128, 128], honeydew:[240, 255, 240], hotpink:[255, 
  105, 180], indianred:[205, 92, 92], indigo:[75, 0, 130], ivory:[255, 255, 240], khaki:[240, 230, 140], lavender:[230, 230, 250], lavenderblush:[255, 240, 245], lawngreen:[124, 252, 0], lemonchiffon:[255, 250, 205], lightblue:[173, 216, 230], lightcoral:[240, 128, 128], lightcyan:[224, 255, 255], lightgoldenrodyellow:[250, 250, 210], lightgray:[211, 211, 211], lightgreen:[144, 238, 144], lightgrey:[211, 211, 211], lightpink:[255, 182, 193], lightsalmon:[255, 160, 122], lightseagreen:[32, 178, 170], 
  lightskyblue:[135, 206, 250], lightslategray:[119, 136, 153], lightslategrey:[119, 136, 153], lightsteelblue:[176, 196, 222], lightyellow:[255, 255, 224], lime:[0, 255, 0], limegreen:[50, 205, 50], linen:[250, 240, 230], magenta:[255, 0, 255], maroon:[128, 0, 0], mediumaquamarine:[102, 205, 170], mediumblue:[0, 0, 205], mediumorchid:[186, 85, 211], mediumpurple:[147, 112, 219], mediumseagreen:[60, 179, 113], mediumslateblue:[123, 104, 238], mediumspringgreen:[0, 250, 154], mediumturquoise:[72, 
  209, 204], mediumvioletred:[199, 21, 133], midnightblue:[25, 25, 112], mintcream:[245, 255, 250], mistyrose:[255, 228, 225], moccasin:[255, 228, 181], navajowhite:[255, 222, 173], navy:[0, 0, 128], oldlace:[253, 245, 230], olive:[128, 128, 0], olivedrab:[107, 142, 35], orange:[255, 165, 0], orangered:[255, 69, 0], orchid:[218, 112, 214], palegoldenrod:[238, 232, 170], palegreen:[152, 251, 152], paleturquoise:[175, 238, 238], palevioletred:[219, 112, 147], papayawhip:[255, 239, 213], peachpuff:[255, 
  218, 185], peru:[205, 133, 63], pink:[255, 192, 203], plum:[221, 160, 203], powderblue:[176, 224, 230], purple:[128, 0, 128], red:[255, 0, 0], rosybrown:[188, 143, 143], royalblue:[65, 105, 225], saddlebrown:[139, 69, 19], salmon:[250, 128, 114], sandybrown:[244, 164, 96], seagreen:[46, 139, 87], seashell:[255, 245, 238], sienna:[160, 82, 45], silver:[192, 192, 192], skyblue:[135, 206, 235], slateblue:[106, 90, 205], slategray:[119, 128, 144], slategrey:[119, 128, 144], snow:[255, 255, 250], springgreen:[0, 
  255, 127], steelblue:[70, 130, 180], tan:[210, 180, 140], teal:[0, 128, 128], thistle:[216, 191, 216], tomato:[255, 99, 71], turquoise:[64, 224, 208], violet:[238, 130, 238], wheat:[245, 222, 179], white:[255, 255, 255], whitesmoke:[245, 245, 245], yellow:[255, 255, 0], yellowgreen:[154, 205, 5]}};
}, 1, 0, 0, 0, 0, 0, [Ext.ux.colorpick, 'ColorUtils'], function(ColorUtils) {
  var formats = ColorUtils.formats, lowerized = {};
  formats['#HEX6'] = function(color) {
    return '#' + formats.HEX6(color);
  };
  formats['#HEX8'] = function(color) {
    return '#' + formats.HEX8(color);
  };
  Ext.Object.each(formats, function(name, fn) {
    lowerized[name.toLowerCase()] = function(color) {
      var ret = fn(color);
      return ret.toLowerCase();
    };
  });
  Ext.apply(formats, lowerized);
});
Ext.cmd.derive('Ext.ux.colorpick.ColorMapController', Ext.app.ViewController, {onFirstBoxReady:function() {
  var me = this, colorMap = me.getView(), dragHandle = colorMap.down('#dragHandle'), dd = dragHandle.dd;
  dd.constrain = true;
  dd.constrainTo = colorMap.getEl();
  dd.initialConstrainTo = dd.constrainTo;
  dd.on('drag', Ext.bind(me.onHandleDrag, me));
  me.mon(colorMap.getEl(), {mousedown:me.onMouseDown, dragstart:me.onDragStart, scope:me});
}, onHandleDrag:function(componentDragger, e) {
  var me = this, container = me.getView(), dragHandle = container.down('#dragHandle'), x = dragHandle.getX() - container.getX(), y = dragHandle.getY() - container.getY(), containerEl = container.getEl(), containerWidth = containerEl.getWidth(), containerHeight = containerEl.getHeight(), xRatio = x / containerWidth, yRatio = y / containerHeight;
  if (xRatio > 0.99) {
    xRatio = 1;
  }
  if (yRatio > 0.99) {
    yRatio = 1;
  }
  container.fireEvent('handledrag', xRatio, yRatio);
}, onMouseDown:function(e) {
  var me = this, container = me.getView(), dragHandle = container.down('#dragHandle');
  dragHandle.setY(e.getY());
  dragHandle.setX(e.getX());
  me.onHandleDrag();
  dragHandle.dd.onMouseDown(e, dragHandle.dd.el);
}, onDragStart:function(e) {
  var me = this, container = me.getView(), dragHandle = container.down('#dragHandle');
  dragHandle.dd.onDragStart(e, dragHandle.dd.el);
}, onMapClick:function(e) {
  var me = this, container = me.getView(), dragHandle = container.down('#dragHandle'), cXY = container.getXY(), eXY = e.getXY(), left, top;
  left = eXY[0] - cXY[0];
  top = eXY[1] - cXY[1];
  dragHandle.getEl().setStyle({left:left + 'px', top:top + 'px'});
  me.onHandleDrag();
}, onColorBindingChanged:function(selectedColor) {
  var me = this, vm = me.getViewModel(), rgba = vm.get('selectedColor'), hsv, container = me.getView(), dragHandle = container.down('#dragHandle'), containerEl = container.getEl(), containerWidth = containerEl.getWidth(), containerHeight = containerEl.getHeight(), xRatio, yRatio, left, top;
  hsv = Ext.ux.colorpick.ColorUtils.rgb2hsv(rgba.r, rgba.g, rgba.b);
  xRatio = hsv.s;
  left = containerWidth * xRatio;
  yRatio = 1 - hsv.v;
  top = containerHeight * yRatio;
  dragHandle.getEl().setStyle({left:left + 'px', top:top + 'px'});
}, onHueBindingChanged:function(hue) {
  var me = this, vm = me.getViewModel(), fullColorRGB, hex;
  fullColorRGB = Ext.ux.colorpick.ColorUtils.hsv2rgb(hue, 1, 1);
  hex = Ext.ux.colorpick.ColorUtils.rgb2hex(fullColorRGB.r, fullColorRGB.g, fullColorRGB.b);
  me.getView().getEl().applyStyles({'background-color':'#' + hex});
}}, 0, 0, 0, 0, ['controller.colorpickercolormapcontroller'], 0, [Ext.ux.colorpick, 'ColorMapController'], 0);
Ext.cmd.derive('Ext.ux.colorpick.ColorMap', Ext.container.Container, {controller:'colorpickercolormapcontroller', cls:'x-colorpicker-colormap', items:[{xtype:'component', cls:'x-colorpicker-colormap-draghandle-container', itemId:'dragHandle', width:1, height:1, draggable:true, html:'\x3cdiv class\x3d"x-colorpicker-colormap-draghandle"\x3e\x3c/div\x3e'}], listeners:{boxready:{single:true, fn:'onFirstBoxReady', scope:'controller'}, colorbindingchanged:{fn:'onColorBindingChanged', scope:'controller'}, 
huebindingchanged:{fn:'onHueBindingChanged', scope:'controller'}}, afterRender:function() {
  var me = this, src = me.mapGradientUrl, el = me.el;
  Ext.container.Container.prototype.afterRender.call(this);
  if (!src) {
    src = el.getStyle('background-image');
    src = src.substring(4, src.length - 1);
    if (src.indexOf('"') === 0) {
      src = src.substring(1, src.length - 1);
    }
    Ext.ux.colorpick.ColorMap.prototype.mapGradientUrl = src;
  }
  el.setStyle('background-image', 'none');
  el = me.layout.getElementTarget();
  el.createChild({tag:'img', cls:'x-colorpicker-colormap-blender', src:src});
}, setPosition:function(data) {
  var me = this, dragHandle = me.down('#dragHandle');
  if (!dragHandle.dd || !dragHandle.dd.constrain) {
    return;
  }
  if (typeof dragHandle.dd.dragEnded !== 'undefined' && !dragHandle.dd.dragEnded) {
    return;
  }
  me.fireEvent('colorbindingchanged', data);
}, setHue:function(hue) {
  var me = this;
  if (!me.getEl()) {
    return;
  }
  me.fireEvent('huebindingchanged', hue);
}}, 0, ['colorpickercolormap'], ['component', 'box', 'container', 'colorpickercolormap'], {'component':true, 'box':true, 'container':true, 'colorpickercolormap':true}, ['widget.colorpickercolormap'], 0, [Ext.ux.colorpick, 'ColorMap'], 0);
Ext.cmd.derive('Ext.ux.colorpick.SelectorModel', Ext.app.ViewModel, {data:{selectedColor:{r:255, g:255, b:255, h:0, s:1, v:1, a:1}, previousColor:{r:0, g:0, b:0, h:0, s:1, v:1, a:1}}, formulas:{hex:{get:function(get) {
  var r = get('selectedColor.r').toString(16), g = get('selectedColor.g').toString(16), b = get('selectedColor.b').toString(16), result;
  result = Ext.ux.colorpick.ColorUtils.rgb2hex(r, g, b);
  return '#' + result;
}, set:function(hex) {
  var rgb = Ext.ux.colorpick.ColorUtils.hex2rgb(hex);
  this.changeRGB(rgb);
}}, red:{get:function(get) {
  return get('selectedColor.r');
}, set:function(r) {
  this.changeRGB({r:r});
}}, green:{get:function(get) {
  return get('selectedColor.g');
}, set:function(g) {
  this.changeRGB({g:g});
}}, blue:{get:function(get) {
  return get('selectedColor.b');
}, set:function(b) {
  this.changeRGB({b:b});
}}, hue:{get:function(get) {
  return get('selectedColor.h') * 360;
}, set:function(hue) {
  this.changeHSV({h:hue / 360});
}}, saturation:{get:function(get) {
  return get('selectedColor.s') * 100;
}, set:function(saturation) {
  this.changeHSV({s:saturation / 100});
}}, value:{get:function(get) {
  var v = get('selectedColor.v');
  return v * 100;
}, set:function(value) {
  this.changeHSV({v:value / 100});
}}, alpha:{get:function(data) {
  var a = data('selectedColor.a');
  return a * 100;
}, set:function(alpha) {
  this.set('selectedColor', Ext.applyIf({a:alpha / 100}, this.data.selectedColor));
}}}, changeHSV:function(hsv) {
  Ext.applyIf(hsv, this.data.selectedColor);
  var rgb = Ext.ux.colorpick.ColorUtils.hsv2rgb(hsv.h, hsv.s, hsv.v);
  hsv.r = rgb.r;
  hsv.g = rgb.g;
  hsv.b = rgb.b;
  this.set('selectedColor', hsv);
}, changeRGB:function(rgb) {
  Ext.applyIf(rgb, this.data.selectedColor);
  var hsv = Ext.ux.colorpick.ColorUtils.rgb2hsv(rgb.r, rgb.g, rgb.b);
  rgb.h = hsv.h;
  rgb.s = hsv.s;
  rgb.v = hsv.v;
  this.set('selectedColor', rgb);
}}, 0, 0, 0, 0, ['viewmodel.colorpick-selectormodel'], 0, [Ext.ux.colorpick, 'SelectorModel'], 0);
Ext.cmd.derive('Ext.ux.colorpick.SelectorController', Ext.app.ViewController, {destroy:function() {
  var me = this, view = me.getView(), childViewModel = view.childViewModel;
  if (childViewModel) {
    childViewModel.destroy();
    view.childViewModel = null;
  }
  Ext.app.ViewController.prototype.destroy.call(this);
}, changeHSV:function(hsv) {
  var view = this.getView(), color = view.getColor(), rgb;
  Ext.applyIf(hsv, color);
  rgb = Ext.ux.colorpick.ColorUtils.hsv2rgb(hsv.h, hsv.s, hsv.v);
  Ext.apply(hsv, rgb);
  view.setColor(hsv);
}, onColorMapHandleDrag:function(xPercent, yPercent) {
  this.changeHSV({s:xPercent, v:1 - yPercent});
}, onValueSliderHandleDrag:function(yPercent) {
  this.changeHSV({v:1 - yPercent});
}, onSaturationSliderHandleDrag:function(yPercent) {
  this.changeHSV({s:1 - yPercent});
}, onHueSliderHandleDrag:function(yPercent) {
  this.changeHSV({h:1 - yPercent});
}, onAlphaSliderHandleDrag:function(yPercent) {
  var view = this.getView(), color = view.getColor(), newColor = Ext.applyIf({a:1 - yPercent}, color);
  view.setColor(newColor);
  view.el.repaint();
}, onPreviousColorSelected:function(comp, color) {
  var view = this.getView();
  view.setColor(color);
}, onOK:function() {
  var me = this, view = me.getView();
  view.fireEvent('ok', view, view.getValue());
}, onCancel:function() {
  this.fireViewEvent('cancel', this.getView());
}, onResize:function() {
  var me = this, view = me.getView(), vm = view.childViewModel, refs = me.getReferences(), h, s, v, a;
  if (!me.hasResizedOnce) {
    me.hasResizedOnce = true;
    return;
  }
  h = vm.get('hue');
  s = vm.get('saturation');
  v = vm.get('value');
  a = vm.get('alpha');
  refs.colorMap.setPosition(vm.getData());
  refs.hueSlider.setHue(h);
  refs.satSlider.setSaturation(s);
  refs.valueSlider.setValue(v);
  refs.alphaSlider.setAlpha(a);
}}, 0, 0, 0, 0, ['controller.colorpick-selectorcontroller'], 0, [Ext.ux.colorpick, 'SelectorController'], 0);
Ext.cmd.derive('Ext.ux.colorpick.ColorPreview', Ext.Component, {style:'position: relative', html:'\x3cdiv class\x3d"x-colorpreview-filter" style\x3d"height:100%; width:100%; position: absolute;"\x3e\x3c/div\x3e\x3ca class\x3d"btn" style\x3d"height:100%; width:100%; position: absolute;"\x3e\x3c/a\x3e', cls:'x-colorpreview', height:256, onRender:function() {
  var me = this;
  Ext.Component.prototype.onRender.apply(this, arguments);
  me.mon(me.el.down('.btn'), 'click', me.onClick, me);
}, onClick:function() {
  this.fireEvent('click', this, this.color);
}, setColor:function(color) {
  var me = this, el = me.getEl();
  if (!el) {
    return;
  }
  me.color = color;
  me.applyBgStyle(color);
}, bgStyleTpl:Ext.create('Ext.XTemplate', Ext.isIE && Ext.ieVersion < 10 ? "filter: progid:DXImageTransform.Microsoft.gradient(GradientType\x3d0, startColorstr\x3d'#{hexAlpha}{hex}', endColorstr\x3d'#{hexAlpha}{hex}');" : 'background: {rgba};'), applyBgStyle:function(color) {
  var me = this, colorUtils = Ext.ux.colorpick.ColorUtils, filterSelector = '.x-colorpreview-filter', el = me.getEl().down(filterSelector), hex, alpha, rgba, bgStyle;
  hex = colorUtils.rgb2hex(color.r, color.g, color.b);
  alpha = Ext.util.Format.hex(Math.floor(color.a * 255), 2);
  rgba = colorUtils.getRGBAString(color);
  bgStyle = this.bgStyleTpl.apply({hex:hex, hexAlpha:alpha, rgba:rgba});
  el.applyStyles(bgStyle);
}}, 0, ['colorpickercolorpreview'], ['component', 'box', 'colorpickercolorpreview'], {'component':true, 'box':true, 'colorpickercolorpreview':true}, ['widget.colorpickercolorpreview'], 0, [Ext.ux.colorpick, 'ColorPreview'], 0);
Ext.cmd.derive('Ext.ux.colorpick.SliderController', Ext.app.ViewController, {boxReady:function(view) {
  var me = this, container = me.getDragContainer(), dragHandle = me.getDragHandle(), dd = dragHandle.dd;
  dd.constrain = true;
  dd.constrainTo = container.getEl();
  dd.initialConstrainTo = dd.constrainTo;
  dd.on('drag', me.onHandleDrag, me);
}, getDragHandle:function() {
  return this.view.lookupReference('dragHandle');
}, getDragContainer:function() {
  return this.view.lookupReference('dragHandleContainer');
}, onHandleDrag:function(e) {
  var me = this, view = me.getView(), container = me.getDragContainer(), dragHandle = me.getDragHandle(), y = dragHandle.getY() - container.getY(), containerEl = container.getEl(), containerHeight = containerEl.getHeight(), yRatio = y / containerHeight;
  if (yRatio > 0.99) {
    yRatio = 1;
  }
  view.fireEvent('handledrag', yRatio);
}, onMouseDown:function(e) {
  var me = this, dragHandle = me.getDragHandle(), y = e.getY();
  dragHandle.setY(y);
  me.onHandleDrag();
  dragHandle.el.repaint();
  dragHandle.dd.onMouseDown(e, dragHandle.dd.el);
}, onDragStart:function(e) {
  var me = this, dragHandle = me.getDragHandle();
  dragHandle.dd.onDragStart(e, dragHandle.dd.el);
}, onMouseUp:function() {
  var dragHandle = this.getDragHandle();
  dragHandle.dd.dragEnded = true;
}}, 0, 0, 0, 0, ['controller.colorpick-slidercontroller'], 0, [Ext.ux.colorpick, 'SliderController'], 0);
Ext.cmd.derive('Ext.ux.colorpick.Slider', Ext.container.Container, {controller:'colorpick-slidercontroller', afterRender:function() {
  Ext.container.Container.prototype.afterRender.apply(this, arguments);
  var width = this.width, dragCt = this.lookupReference('dragHandleContainer'), dragWidth = dragCt.getWidth();
  dragCt.el.setStyle('left', (width - dragWidth) / 2 + 'px');
}, baseCls:'x-colorpicker-slider', referenceHolder:true, listeners:{element:'el', mousedown:'onMouseDown', mouseup:'onMouseUp', dragstart:'onDragStart'}, items:{xtype:'container', cls:'x-colorpicker-draghandle-container', reference:'dragHandleContainer', height:'100%', items:{xtype:'component', cls:'x-colorpicker-draghandle-outer', reference:'dragHandle', width:'100%', height:1, draggable:true, html:'\x3cdiv class\x3d"x-colorpicker-draghandle"\x3e\x3c/div\x3e'}}, getDragHandle:function() {
  return this.lookupReference('dragHandle');
}, getDragContainer:function() {
  return this.lookupReference('dragHandleContainer');
}}, 0, ['colorpickerslider'], ['component', 'box', 'container', 'colorpickerslider'], {'component':true, 'box':true, 'container':true, 'colorpickerslider':true}, ['widget.colorpickerslider'], 0, [Ext.ux.colorpick, 'Slider'], 0);
Ext.cmd.derive('Ext.ux.colorpick.SliderAlpha', Ext.ux.colorpick.Slider, {cls:'x-colorpicker-alpha', gradientStyleTpl:Ext.create('Ext.XTemplate', Ext.isIE && Ext.ieVersion < 10 ? "filter: progid:DXImageTransform.Microsoft.gradient(GradientType\x3d0, startColorstr\x3d'#FF{hex}', endColorstr\x3d'#00{hex}');" : 'background: -moz-linear-gradient(top, rgba({r}, {g}, {b}, 1) 0%, rgba({r}, {g}, {b}, 0) 100%);background: -webkit-linear-gradient(top,rgba({r}, {g}, {b}, 1) 0%, rgba({r}, {g}, {b}, 0) 100%);background: -o-linear-gradient(top, rgba({r}, {g}, {b}, 1) 0%, rgba({r}, {g}, {b}, 0) 100%);background: -ms-linear-gradient(top, rgba({r}, {g}, {b}, 1) 0%, rgba({r}, {g}, {b}, 0) 100%);background: linear-gradient(to bottom, rgba({r}, {g}, {b}, 1) 0%, rgba({r}, {g}, {b}, 0) 100%);'), 
setAlpha:function(value) {
  var me = this, container = me.getDragContainer(), dragHandle = me.getDragHandle(), containerEl = container.getEl(), containerHeight = containerEl.getHeight(), el, top;
  if (!dragHandle.dd || !dragHandle.dd.constrain) {
    return;
  }
  if (typeof dragHandle.dd.dragEnded !== 'undefined' && !dragHandle.dd.dragEnded) {
    return;
  }
  top = containerHeight * (1 - value / 100);
  el = dragHandle.getEl();
  el.setStyle({top:top + 'px'});
}, setColor:function(color) {
  var me = this, container = me.getDragContainer(), hex, el;
  if (!me.getEl()) {
    return;
  }
  hex = Ext.ux.colorpick.ColorUtils.rgb2hex(color.r, color.g, color.b);
  el = container.getEl().first();
  el.applyStyles(me.gradientStyleTpl.apply({hex:hex, r:color.r, g:color.g, b:color.b}));
}}, 0, ['colorpickerslideralpha'], ['component', 'box', 'container', 'colorpickerslider', 'colorpickerslideralpha'], {'component':true, 'box':true, 'container':true, 'colorpickerslider':true, 'colorpickerslideralpha':true}, ['widget.colorpickerslideralpha'], 0, [Ext.ux.colorpick, 'SliderAlpha'], 0);
Ext.cmd.derive('Ext.ux.colorpick.SliderSaturation', Ext.ux.colorpick.Slider, {cls:'x-colorpicker-saturation', gradientStyleTpl:Ext.create('Ext.XTemplate', Ext.isIE && Ext.ieVersion < 10 ? "filter: progid:DXImageTransform.Microsoft.gradient(GradientType\x3d0, startColorstr\x3d'#{hex}', endColorstr\x3d'#ffffff');" : 'background: -mox-linear-gradient(top, #{hex} 0%, #ffffff 100%);background: -webkit-linear-gradient(top, #{hex} 0%,#ffffff 100%);background: -o-linear-gradient(top, #{hex} 0%,#ffffff 100%);background: -ms-linear-gradient(top, #{hex} 0%,#ffffff 100%);background: linear-gradient(to bottom, #{hex} 0%,#ffffff 100%);'), 
setSaturation:function(saturation) {
  var me = this, container = me.getDragContainer(), dragHandle = me.getDragHandle(), containerEl = container.getEl(), containerHeight = containerEl.getHeight(), yRatio, top;
  if (!dragHandle.dd || !dragHandle.dd.constrain) {
    return;
  }
  if (typeof dragHandle.dd.dragEnded !== 'undefined' && !dragHandle.dd.dragEnded) {
    return;
  }
  yRatio = 1 - saturation / 100;
  top = containerHeight * yRatio;
  dragHandle.getEl().setStyle({top:top + 'px'});
}, setHue:function(hue) {
  var me = this, container = me.getDragContainer(), rgb, hex;
  if (!me.getEl()) {
    return;
  }
  rgb = Ext.ux.colorpick.ColorUtils.hsv2rgb(hue, 1, 1);
  hex = Ext.ux.colorpick.ColorUtils.rgb2hex(rgb.r, rgb.g, rgb.b);
  container.getEl().applyStyles(me.gradientStyleTpl.apply({hex:hex}));
}}, 0, ['colorpickerslidersaturation'], ['component', 'box', 'container', 'colorpickerslider', 'colorpickerslidersaturation'], {'component':true, 'box':true, 'container':true, 'colorpickerslider':true, 'colorpickerslidersaturation':true}, ['widget.colorpickerslidersaturation'], 0, [Ext.ux.colorpick, 'SliderSaturation'], 0);
Ext.cmd.derive('Ext.ux.colorpick.SliderValue', Ext.ux.colorpick.Slider, {cls:'x-colorpicker-value', gradientStyleTpl:Ext.create('Ext.XTemplate', Ext.isIE && Ext.ieVersion < 10 ? "filter: progid:DXImageTransform.Microsoft.gradient(GradientType\x3d0, startColorstr\x3d'#{hex}', endColorstr\x3d'#000000');" : 'background: -mox-linear-gradient(top, #{hex} 0%, #000000 100%);background: -webkit-linear-gradient(top, #{hex} 0%,#000000 100%);background: -o-linear-gradient(top, #{hex} 0%,#000000 100%);background: -ms-linear-gradient(top, #{hex} 0%,#000000 100%);background: linear-gradient(to bottom, #{hex} 0%,#000000 100%);'), 
setValue:function(value) {
  var me = this, container = me.getDragContainer(), dragHandle = me.getDragHandle(), containerEl = container.getEl(), containerHeight = containerEl.getHeight(), yRatio, top;
  if (!dragHandle.dd || !dragHandle.dd.constrain) {
    return;
  }
  if (typeof dragHandle.dd.dragEnded !== 'undefined' && !dragHandle.dd.dragEnded) {
    return;
  }
  yRatio = 1 - value / 100;
  top = containerHeight * yRatio;
  dragHandle.getEl().setStyle({top:top + 'px'});
}, setHue:function(hue) {
  var me = this, container = me.getDragContainer(), rgb, hex;
  if (!me.getEl()) {
    return;
  }
  rgb = Ext.ux.colorpick.ColorUtils.hsv2rgb(hue, 1, 1);
  hex = Ext.ux.colorpick.ColorUtils.rgb2hex(rgb.r, rgb.g, rgb.b);
  container.getEl().applyStyles(me.gradientStyleTpl.apply({hex:hex}));
}}, 0, ['colorpickerslidervalue'], ['component', 'box', 'container', 'colorpickerslider', 'colorpickerslidervalue'], {'component':true, 'box':true, 'container':true, 'colorpickerslider':true, 'colorpickerslidervalue':true}, ['widget.colorpickerslidervalue'], 0, [Ext.ux.colorpick, 'SliderValue'], 0);
Ext.cmd.derive('Ext.ux.colorpick.SliderHue', Ext.ux.colorpick.Slider, {cls:'x-colorpicker-hue', afterRender:function() {
  var me = this, src = me.gradientUrl, el = me.el;
  Ext.ux.colorpick.Slider.prototype.afterRender.call(this);
  if (!src) {
    src = el.getStyle('background-image');
    src = src.substring(4, src.length - 1);
    if (src.indexOf('"') === 0) {
      src = src.substring(1, src.length - 1);
    }
    Ext.ux.colorpick.SliderHue.prototype.gradientUrl = src;
  }
  el.setStyle('background-image', 'none');
  el = me.getDragContainer().layout.getElementTarget();
  el.createChild({tag:'img', cls:'x-colorpicker-hue-gradient', src:src});
}, setHue:function(hue) {
  var me = this, container = me.getDragContainer(), dragHandle = me.getDragHandle(), containerEl = container.getEl(), containerHeight = containerEl.getHeight(), el, top;
  if (!dragHandle.dd || !dragHandle.dd.constrain) {
    return;
  }
  if (typeof dragHandle.dd.dragEnded !== 'undefined' && !dragHandle.dd.dragEnded) {
    return;
  }
  top = containerHeight * (1 - hue);
  el = dragHandle.getEl();
  el.setStyle({top:top + 'px'});
}}, 0, ['colorpickersliderhue'], ['component', 'box', 'container', 'colorpickerslider', 'colorpickersliderhue'], {'component':true, 'box':true, 'container':true, 'colorpickerslider':true, 'colorpickersliderhue':true}, ['widget.colorpickersliderhue'], 0, [Ext.ux.colorpick, 'SliderHue'], 0);
Ext.cmd.derive('Ext.ux.colorpick.Selector', Ext.container.Container, {controller:'colorpick-selectorcontroller', width:580, height:337, cls:'x-colorpicker', padding:10, layout:{type:'hbox', align:'stretch'}, defaultBindProperty:'value', twoWayBindable:['value'], fieldWidth:50, fieldPad:5, showPreviousColor:false, showOkCancelButtons:false, listeners:{resize:'onResize'}, constructor:function(config) {
  var me = this, childViewModel = Ext.Factory.viewModel('colorpick-selectormodel');
  me.childViewModel = childViewModel;
  me.items = [me.getMapAndHexRGBFields(childViewModel), me.getSliderAndHField(childViewModel), me.getSliderAndSField(childViewModel), me.getSliderAndVField(childViewModel), me.getSliderAndAField(childViewModel), me.getPreviewAndButtons(childViewModel, config)];
  me.childViewModel.bind('{selectedColor}', function(color) {
    me.setColor(color);
  });
  Ext.container.Container.prototype.constructor.apply(this, arguments);
}, updateColor:function(color) {
  var me = this;
  me.mixins.colorselection.updateColor.call(me, color);
  me.childViewModel.set('selectedColor', color);
}, updatePreviousColor:function(color) {
  this.childViewModel.set('previousColor', color);
}, getMapAndHexRGBFields:function(childViewModel) {
  var me = this, fieldMargin = {top:0, right:me.fieldPad, bottom:0, left:0}, fieldWidth = me.fieldWidth;
  return {xtype:'container', viewModel:childViewModel, cls:'x-colorpicker-escape-overflow', flex:1, layout:{type:'vbox', align:'stretch'}, margin:'0 10 0 0', items:[{xtype:'colorpickercolormap', reference:'colorMap', flex:1, bind:{position:{bindTo:'{selectedColor}', deep:true}, hue:'{selectedColor.h}'}, listeners:{handledrag:'onColorMapHandleDrag'}}, {xtype:'container', layout:'hbox', defaults:{labelAlign:'top', labelSeparator:'', allowBlank:false, onChange:function() {
    if (this.isValid()) {
      Ext.form.field.Base.prototype.onChange.apply(this, arguments);
    }
  }}, items:[{xtype:'textfield', fieldLabel:'HEX', flex:1, bind:'{hex}', margin:fieldMargin, readOnly:true}, {xtype:'numberfield', fieldLabel:'R', bind:'{red}', width:fieldWidth, hideTrigger:true, maxValue:255, minValue:0, margin:fieldMargin}, {xtype:'numberfield', fieldLabel:'G', bind:'{green}', width:fieldWidth, hideTrigger:true, maxValue:255, minValue:0, margin:fieldMargin}, {xtype:'numberfield', fieldLabel:'B', bind:'{blue}', width:fieldWidth, hideTrigger:true, maxValue:255, minValue:0, margin:0}]}]};
}, getSliderAndHField:function(childViewModel) {
  var me = this, fieldWidth = me.fieldWidth;
  return {xtype:'container', viewModel:childViewModel, cls:'x-colorpicker-escape-overflow', width:fieldWidth, layout:{type:'vbox', align:'stretch'}, items:[{xtype:'colorpickersliderhue', reference:'hueSlider', flex:1, bind:{hue:'{selectedColor.h}'}, width:fieldWidth, listeners:{handledrag:'onHueSliderHandleDrag'}}, {xtype:'numberfield', fieldLabel:'H', labelAlign:'top', labelSeparator:'', bind:'{hue}', hideTrigger:true, maxValue:360, minValue:0, allowBlank:false, margin:0}]};
}, getSliderAndSField:function(childViewModel) {
  var me = this, fieldWidth = me.fieldWidth;
  return {xtype:'container', viewModel:childViewModel, cls:'x-colorpicker-escape-overflow', width:fieldWidth, layout:{type:'vbox', align:'stretch'}, margin:{right:me.fieldPad, left:me.fieldPad}, items:[{xtype:'colorpickerslidersaturation', reference:'satSlider', flex:1, bind:{saturation:'{saturation}', hue:'{selectedColor.h}'}, width:fieldWidth, listeners:{handledrag:'onSaturationSliderHandleDrag'}}, {xtype:'numberfield', fieldLabel:'S', labelAlign:'top', labelSeparator:'', bind:'{saturation}', hideTrigger:true, 
  maxValue:100, minValue:0, allowBlank:false, margin:0}]};
}, getSliderAndVField:function(childViewModel) {
  var me = this, fieldWidth = me.fieldWidth;
  return {xtype:'container', viewModel:childViewModel, cls:'x-colorpicker-escape-overflow', width:fieldWidth, layout:{type:'vbox', align:'stretch'}, items:[{xtype:'colorpickerslidervalue', reference:'valueSlider', flex:1, bind:{value:'{value}', hue:'{selectedColor.h}'}, width:fieldWidth, listeners:{handledrag:'onValueSliderHandleDrag'}}, {xtype:'numberfield', fieldLabel:'V', labelAlign:'top', labelSeparator:'', bind:'{value}', hideTrigger:true, maxValue:100, minValue:0, allowBlank:false, margin:0}]};
}, getSliderAndAField:function(childViewModel) {
  var me = this, fieldWidth = me.fieldWidth;
  return {xtype:'container', viewModel:childViewModel, cls:'x-colorpicker-escape-overflow', width:fieldWidth, layout:{type:'vbox', align:'stretch'}, margin:{left:me.fieldPad}, items:[{xtype:'colorpickerslideralpha', reference:'alphaSlider', flex:1, bind:{alpha:'{alpha}', color:{bindTo:'{selectedColor}', deep:true}}, width:fieldWidth, listeners:{handledrag:'onAlphaSliderHandleDrag'}}, {xtype:'numberfield', fieldLabel:'A', labelAlign:'top', labelSeparator:'', bind:'{alpha}', hideTrigger:true, maxValue:100, 
  minValue:0, allowBlank:false, margin:0}]};
}, getPreviewAndButtons:function(childViewModel, config) {
  var items = [{xtype:'colorpickercolorpreview', flex:1, bind:{color:{bindTo:'{selectedColor}', deep:true}}}];
  if (config.showPreviousColor) {
    items.push({xtype:'colorpickercolorpreview', flex:1, bind:{color:{bindTo:'{previousColor}', deep:true}}, listeners:{click:'onPreviousColorSelected'}});
  }
  if (config.showOkCancelButtons) {
    items.push({xtype:'button', text:'OK', margin:'10 0 0 0', handler:'onOK'}, {xtype:'button', text:'Cancel', margin:'10 0 0 0', handler:'onCancel'});
  }
  return {xtype:'container', viewModel:childViewModel, width:70, margin:'0 0 0 10', items:items, layout:{type:'vbox', align:'stretch'}};
}}, 1, ['colorselector'], ['component', 'box', 'container', 'colorselector'], {'component':true, 'box':true, 'container':true, 'colorselector':true}, ['widget.colorselector'], [[Ext.ux.colorpick.Selection.prototype.mixinId || Ext.ux.colorpick.Selection.$className, Ext.ux.colorpick.Selection]], [Ext.ux.colorpick, 'Selector'], 0);
Ext.cmd.derive('Ext.ux.colorpick.ButtonController', Ext.app.ViewController, {afterRender:function(view) {
  view.updateColor(view.getColor());
}, destroy:function() {
  var view = this.getView(), colorPickerWindow = view.colorPickerWindow;
  if (colorPickerWindow) {
    colorPickerWindow.destroy();
    view.colorPickerWindow = view.colorPicker = null;
  }
  Ext.app.ViewController.prototype.destroy.call(this);
}, getPopup:function() {
  var view = this.getView(), popup = view.colorPickerWindow, selector;
  if (!popup) {
    popup = Ext.create(view.getPopup());
    view.colorPickerWindow = popup;
    popup.colorPicker = view.colorPicker = selector = popup.lookupReference('selector');
    selector.setFormat(view.getFormat());
    selector.on({ok:'onColorPickerOK', cancel:'onColorPickerCancel', scope:this});
    popup.on({close:'onColorPickerCancel', scope:this});
  }
  return popup;
}, onClick:function() {
  var me = this, view = me.getView(), color = view.getColor(), popup = me.getPopup(), colorPicker = popup.colorPicker;
  colorPicker.setColor(color);
  colorPicker.setPreviousColor(color);
  popup.showBy(view, 'tl-br?');
}, onColorPickerOK:function(picker) {
  var view = this.getView(), color = picker.getColor(), cpWin = view.colorPickerWindow;
  cpWin.hide();
  view.setColor(color);
}, onColorPickerCancel:function() {
  var view = this.getView(), cpWin = view.colorPickerWindow;
  cpWin.hide();
}, syncColor:function(color) {
  var view = this.getView();
  Ext.ux.colorpick.ColorUtils.setBackground(view.filterEl, color);
}}, 0, 0, 0, 0, ['controller.colorpick-buttoncontroller'], 0, [Ext.ux.colorpick, 'ButtonController'], 0);
Ext.cmd.derive('Ext.ux.colorpick.Button', Ext.Component, {controller:'colorpick-buttoncontroller', baseCls:'x-colorpicker-button', width:20, height:20, childEls:['btnEl', 'filterEl'], config:{popup:{lazy:true, $value:{xtype:'window', closeAction:'hide', referenceHolder:true, minWidth:540, minHeight:200, layout:'fit', header:false, resizable:true, items:{xtype:'colorselector', reference:'selector', showPreviousColor:true, showOkCancelButtons:true}}}}, defaultBindProperty:'value', twoWayBindable:'value', 
renderTpl:'\x3cdiv id\x3d"{id}-filterEl" data-ref\x3d"filterEl" style\x3d"height:100%; width:100%; position: absolute;"\x3e\x3c/div\x3e\x3ca id\x3d"{id}-btnEl" data-ref\x3d"btnEl" style\x3d"height:100%; width:100%; position: absolute;"\x3e\x3c/a\x3e', listeners:{click:'onClick', element:'btnEl'}, updateColor:function(color) {
  var me = this, cp = me.colorPicker;
  me.mixins.colorselection.updateColor.call(me, color);
  Ext.ux.colorpick.ColorUtils.setBackground(me.filterEl, color);
  if (cp) {
    cp.setColor(color);
  }
}, updateFormat:function(format) {
  var cp = this.colorPicker;
  if (cp) {
    cp.setFormat(format);
  }
}}, 0, ['colorbutton'], ['component', 'box', 'colorbutton'], {'component':true, 'box':true, 'colorbutton':true}, ['widget.colorbutton'], [[Ext.ux.colorpick.Selection.prototype.mixinId || Ext.ux.colorpick.Selection.$className, Ext.ux.colorpick.Selection]], [Ext.ux.colorpick, 'Button'], 0);
Ext.cmd.derive('SiteWalk360.FloorplanPanoUtil', Ext.Base, {config:{panoScanLayer:null, directionArrow:null}, getMarkerElement:function(marker) {
  if (marker && marker._container) {
    return marker._container;
  } else {
    if (marker && marker._bgLayer && marker._bgLayer._container) {
      return marker._bgLayer._container;
    } else {
      if (marker && marker._icon) {
        return marker._icon;
      }
    }
  }
  return null;
}, addMarkerClass:function(marker, cls) {
  var el = this.getMarkerElement(marker);
  if (el && el.classList) {
    el.classList.add(cls);
  }
}, removeMarkerClass:function(marker, cls) {
  var el = this.getMarkerElement(marker);
  if (el && el.classList) {
    el.classList.remove(cls);
  }
}, createPanoLayer:function() {
  if (this.getPanoScanLayer() == null) {
    var leaflet = MVLeaflet || L;
    this.setPanoScanLayer(new leaflet.layerGroup);
    this.map.addLayer(this.getPanoScanLayer());
    this.mapZoomHandler = this.mapZoomEndHandler.bind(this);
    this.map.on('zoomend', this.mapZoomHandler);
  } else {
    this.removeDirectionMarker();
    this.getPanoScanLayer().clearLayers();
  }
  return this.getPanoScanLayer();
}, removePanoLayer:function() {
  this.removeDirectionMarker();
  if (this.getPanoScanLayer()) {
    this.getPanoScanLayer().eachLayer(function(layer) {
      layer.clearAllEventListeners();
    });
    this.getPanoScanLayer().clearLayers();
    if (this.map) {
      this.map.removeLayer(this.getPanoScanLayer());
      this.map.off('zoomend', this.mapZoomHandler);
      mapZoomHandler = null;
    }
    this.setPanoScanLayer(null);
  }
}, mapZoomEndHandler:function(e) {
  var zoom = e.target.getZoom();
  var radius = this.getPanoMarkerRadius();
  var markersMap = this.getPanoMarkersMap();
  for (var uuid in markersMap) {
    var marker = markersMap[uuid];
    marker.setRadius(radius);
  }
  var arrow = this.getDirectionArrow();
  if (arrow && arrow.classList) {
    if (zoom == 0) {
      arrow.classList.add('small');
    } else {
      arrow.classList.remove('small');
    }
  }
  this.updateDirectionMarkerOnFloorplan();
}, getPanoMarkerRadius:function(hover) {
  var radius = Math.min(15, 6 + this.map.getZoom() * 3);
  if (hover === true) {
    radius = Math.round(radius * 1.2);
  }
  return radius;
}, removeDirectionMarker:function() {
  var directionMarker = this.getDirectionMarker();
  if (directionMarker && this.getPanoScanLayer()) {
    this.getPanoScanLayer().removeLayer(directionMarker);
  }
  this.setDirectionMarker(null);
  this.setDirectionArrow(null);
}, updateDirectionMarkerOnFloorplan:function() {
  if (!this.getViewerReady()) {
    return;
  }
  var rotation = this.getCurrentRotation();
  if (!rotation) {
    return;
  }
  try {
    var directionMarker = this.getDirectionMarker();
    var pano = this.getActivePano();
    if (!pano || !this.getPanoScanLayer() || pano.hidden) {
      this.removeDirectionMarker();
      return;
    }
    if (!directionMarker) {
      directionMarker = this.addCustomIconMarker(this.getPanoScanLayer(), pano.x, pano.y, {className:'matterportDirectionMarker', div:true, html:'\x3cdiv class\x3d"matterportDirectionArrow' + (this.map.getZoom() == 0 ? ' small' : '') + '"\x3e\x3c/div\x3e'});
      this.setDirectionMarker(directionMarker);
      this.setDirectionArrow(directionMarker._icon.firstChild);
    } else {
      var latlng = directionMarker.getLatLng();
      latlng.lat = pano.y;
      latlng.lng = pano.x;
      directionMarker.setLatLng(latlng);
    }
    var angle = 0 - Math.round(rotation.y) - this.getFloorplanTheta();
    while (angle < 0) {
      angle += 360;
    }
    var arrow = this.getDirectionArrow();
    if (arrow) {
      var transform = 'rotate(' + angle + 'deg)';
      if (transform != arrow.style.transform) {
        arrow.style.transform = transform;
        var radius = 15;
        var marginLeft = Math.round(radius * Math.sin(this.toRadians(angle)));
        var marginTop = Math.round(-radius * Math.cos(this.toRadians(angle)) + radius);
        arrow.style.marginLeft = marginLeft + 'px';
        arrow.style.marginTop = marginTop + 'px';
      }
    }
  } catch (ex) {
    this.error('Error placing direction marker on floorplan');
    this.error(ex.message);
  }
}, addPanoScanMarker:function(layer, x, y, markerOptions) {
  markerOptions = Ext.applyIf(markerOptions || {}, {radius:12, weight:4, fixedWeight:true, opacity:1, fillOpacity:1, fill:true, clickable:true});
  var leaflet = MVLeaflet || L;
  var marker = leaflet.panoScanMarker({lng:x, lat:y}, markerOptions);
  layer.addLayer(marker);
  return marker;
}, addPanoHotspotMarker:function(layer, x, y, markerOptions) {
  markerOptions = Ext.applyIf(markerOptions || {}, {radius:12, color:'#E65E25'});
  var leaflet = MVLeaflet || L;
  var marker = leaflet.panoMarker({lng:x, lat:y}, markerOptions);
  layer.addLayer(marker);
  return marker;
}, addCustomIconMarker:function(layer, x, y, iconOptions) {
  iconOptions = iconOptions || {div:false};
  var leaflet = MVLeaflet || L;
  var icon = iconOptions.div ? leaflet.divIcon(iconOptions) : leaflet.icon(iconOptions);
  var iconMarker = leaflet.marker({lng:x, lat:y}, {clickable:false, icon:icon});
  layer.addLayer(iconMarker);
  return iconMarker;
}, panToMarker:function(x, y, animate) {
  if (this.map) {
    this.map.panTo({lng:x, lat:y}, {animate:!!animate});
  }
}}, 0, 0, 0, 0, 0, 0, [SiteWalk360, 'FloorplanPanoUtil'], 0);
Ext.cmd.derive('siteWalk360.SW360Util', Ext.Base, {config:{isDebug:window.location.href.indexOf('debug\x3dtrue') != -1}, fixedFloat:function(num, digits) {
  return parseFloat(num.toFixed(digits));
}, toDegrees:function(radians) {
  return 180 * radians / Math.PI;
}, toRadians:function(degrees) {
  return Math.PI * degrees / 180;
}, constrainAngle:function(degrees) {
  var angle = degrees % 360;
  while (angle < 0) {
    angle += 360;
  }
  return angle;
}, min:function(a, b) {
  return isNaN(a) ? b : Math.min(a, b);
}, max:function(a, b) {
  return isNaN(a) ? b : Math.max(a, b);
}, normalize:function(num, min, max) {
  return (num - min) / (max - min);
}, quaternionToEulerAngles:function(x, y, z, w) {
  if (typeof x == 'object') {
    y = x.y;
    z = x.z;
    w = x.w;
    x = x.x;
  }
  var heading, attitude, bank;
  var test = x * y + z * w;
  if (test > 0.499) {
    heading = 2 * Math.atan2(x, w);
    attitude = Math.PI / 2;
    bank = 0;
  } else {
    if (test < -0.499) {
      heading = -2 * Math.atan2(x, w);
      attitude = -Math.PI / 2;
      bank = 0;
    } else {
      var sqx = x * x;
      var sqy = y * y;
      var sqz = z * z;
      heading = Math.atan2(2 * y * w - 2 * x * z, 1 - 2 * sqy - 2 * sqz);
      attitude = Math.asin(2 * test);
      bank = Math.atan2(2 * x * w - 2 * y * z, 1 - 2 * sqx - 2 * sqz);
    }
  }
  return {x:this.toDegrees(bank), y:this.toDegrees(heading), z:this.toDegrees(attitude)};
}, eulerAnglesToQuaternion:function(bank, heading, attitude, decimalDigits) {
  if (typeof bank == 'object') {
    if (decimalDigits === undefined && heading != null) {
      decimalDigits = heading;
    }
    if (bank.hasOwnProperty('bank')) {
      heading = bank.heading;
      attitude = bank.attitude;
      bank = bank.bank;
    } else {
      if (bank.hasOwnProperty('x')) {
        heading = bank.y;
        attitude = bank.z;
        bank = bank.x;
      } else {
        console.error("Invalid input object - must have 'heading|attitude|bank' or 'x|y|z' properties");
        return null;
      }
    }
  }
  heading = this.toRadians(heading);
  attitude = this.toRadians(attitude);
  bank = this.toRadians(bank);
  var c1 = Math.cos(heading * 0.5);
  var c2 = Math.cos(attitude * 0.5);
  var c3 = Math.cos(bank * 0.5);
  var s1 = Math.sin(heading * 0.5);
  var s2 = Math.sin(attitude * 0.5);
  var s3 = Math.sin(bank * 0.5);
  var w = c1 * c2 * c3 - s1 * s2 * s3;
  var x = s1 * s2 * c3 + c1 * c2 * s3;
  var y = s1 * c2 * c3 + c1 * s2 * s3;
  var z = c1 * s2 * c3 - s1 * c2 * s3;
  if (decimalDigits != null && !isNaN(decimalDigits) && decimalDigits >= 0) {
    x = this.fixedFloat(x, decimalDigits);
    y = this.fixedFloat(y, decimalDigits);
    z = this.fixedFloat(z, decimalDigits);
    w = this.fixedFloat(w, decimalDigits);
  }
  if (isNaN(x) || isNaN(y) || isNaN(z) || isNaN(w)) {
    console.error('Unable to calculate quaternion x,y,z,w values', arguments, bank, heading, attitude, x, y, z, w);
    return null;
  }
  return {x:x, y:y, z:z, w:w};
}, distanceBetween:function(x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  return Math.sqrt(dx * dx + dy * dy);
}, panoDistance:function(p1, p2) {
  return this.distanceBetween(p1.x, p1.y, p2.x, p2.y);
}, findNearestPano:function(pt, panos) {
  var minDist = 0;
  var minIndex = -1;
  for (var i = 0; i < panos.length; i++) {
    var dist = this.panoDistance(pt, panos[i]);
    if (i === 0 || dist < minDist) {
      minDist = dist;
      minIndex = i;
    }
    if (dist === 0) {
      break;
    }
  }
  return minIndex >= 0 ? panos[minIndex] : null;
}, findDistanceToNearestPano:function(pt, panos) {
  var minDist = NaN;
  for (var i = 0; i < panos.length; i++) {
    var dist = this.panoDistance(pt, panos[i]);
    if (i === 0 || dist < minDist) {
      minDist = dist;
    }
    if (dist === 0) {
      break;
    }
  }
  return minDist;
}, debug:function() {
  if (this.getIsDebug()) {
    if (arguments.length && typeof arguments[0] == 'string') {
      arguments[0] = '[SiteWalk360] ' + arguments[0];
    } else {
      Array.prototype.unshift.call(arguments, '[SiteWalk360]');
    }
    console.log.apply(null, arguments);
  }
}, error:function() {
  if (arguments.length && typeof arguments[0] == 'string') {
    arguments[0] = '[SiteWalk360] ' + arguments[0];
  } else {
    Array.prototype.unshift.call(arguments, '[SiteWalk360]');
  }
  console.error.apply(null, arguments);
}}, 0, 0, 0, 0, 0, 0, [siteWalk360, 'SW360Util'], 0);
Ext.cmd.derive('siteWalk360.MatterportShowcaseSDK', Ext.Base, {config:{showcase:null, applicationKey:window.location.hostname.indexOf('multivista.com') != -1 ? '579a5d5b-72a1-4c71-a7c1-b38e1219ffac' : 'c4a11c55-dfc3-4b41-9df3-f2a466927a89'}, constructor:function(config) {
  this.initConfig(config);
  this.mixins.observable.constructor.call(this, config);
}, clear:function() {
  if (this.getShowcase()) {
    this.setShowcase(null);
    this.fireEvent('showcaseconnected', false);
  }
}, hasShowcase:function() {
  return this.getShowcase() != null;
}, addInteriorPanoIframeLoadListener:function(iframe) {
  this.iframe = iframe;
  if (typeof iframe.addEventListener == 'function') {
    var me = this;
    var loadCallback = function() {
      me.debug('InteriorPano \x3ciframe\x3e load event');
      iframe.removeEventListener('load', loadCallback);
      iframe.focus();
      setTimeout(function() {
        me.addShowcaseEventListeners();
      }, 500);
    };
    iframe.addEventListener('load', loadCallback);
  } else {
    iframe.focus();
  }
}, connectToShowcase:function(retryCount, timeout, maxRetry) {
  retryCount = retryCount || 0;
  timeout = timeout || 1000;
  maxRetry = maxRetry === undefined ? 10 : maxRetry;
  var me = this;
  var existingShowcase = this.getShowcase();
  if (existingShowcase != null) {
    return new Promise(function(resolve, reject) {
      resolve(existingShowcase);
    });
  }
  this.debug('Connecting to Showcase SDK (timeout\x3d' + timeout + 'ms)' + (retryCount > 0 ? ' (retry #' + retryCount + ')...' : '...'));
  if (retryCount >= maxRetry) {
    return new Promise(function(resolve, reject) {
      var err = 'Tried to connect to Showcase SDK ' + maxRetry + ' times, aborting';
      me.error(err);
      reject(err);
    });
  }
  return this.connectToShowcaseWithTimeout(timeout).then(function(showcase) {
    if (typeof showcase === 'string') {
      me.error('Error connecting to showcase: ' + showcase);
      return null;
    }
    me.setShowcase(showcase);
    me.fireEvent('showcaseconnected', true);
    window.showcase = showcase;
    window.mpsdk = me;
    me.debug('Showcase connected');
    return showcase;
  }, function(error) {
    me.debug('Retrying...', error, arguments);
    return me.connectToShowcase(retryCount + 1, timeout, maxRetry);
  });
}, connectToShowcaseWithTimeout:function(timeout) {
  var key = this.getApplicationKey();
  var iframe = this.iframe;
  if (!this.iframe) {
    console.warn('No iframe set');
    return new Promise(function(resolve, reject) {
      reject('No iframe set');
    });
  }
  var connectPromise = window.SHOWCASE_SDK.connect(iframe, key, '3.0');
  var timeoutPromise = new Promise(function(resolve, reject) {
    setTimeout(reject, timeout);
  });
  return Promise.race([connectPromise, timeoutPromise]);
}, addShowcaseEventListeners:function() {
  this.removeShowcaseEventListeners();
  var me = this;
  this.connectToShowcase().then(function(showcase) {
    if (showcase) {
      me.showcaseEventEnterPanoRef = me.showcaseEventEnterPano.bind(me);
      showcase.on(showcase.Sweep.Event.ENTER, me.showcaseEventEnterPanoRef);
      me.showcaseEventMoveRef = me.showcaseEventMove.bind(me);
      showcase.on(showcase.Camera.Event.MOVE, me.showcaseEventMoveRef);
      showcase.Model.getData().then(function(data) {
        if (data && data.sweeps && data.sweeps.length) {
          me.showcaseEventModelLoaded({panos:data.sweeps});
        } else {
          console.warn('No panos found in data', data);
        }
      });
      me.debug('Added showcase event listeners');
    }
    return showcase;
  });
}, removeShowcaseEventListeners:function() {
  var showcase = this.getShowcase();
  if (showcase) {
    if (this.showcaseEventEnterPanoRef) {
      showcase.off(showcase.Sweep.Event.ENTER, this.showcaseEventEnterPanoRef);
      delete this.showcaseEventEnterPanoRef;
    }
    if (this.showcaseEventMoveRef) {
      showcase.off(showcase.Camera.Event.MOVE, this.showcaseEventMoveRef);
      delete this.showcaseEventMoveRef;
    }
    if (this.showcaseEventModelLoadedRef) {
      delete this.showcaseEventModelLoadedRef;
    }
    this.debug('Removed showcase event listeners');
  }
}, showcaseEventEnterPano:function(oldPanoUuid, newPanoUuid) {
  this.debug('PANO ' + oldPanoUuid + ' -\x3e ' + newPanoUuid);
  this.fireEvent('panoselect', newPanoUuid);
}, showcaseEventMove:function(state) {
  var newPano = state.sweep;
  this.fireEvent('rotationchange', state.rotation, newPano);
}, showcaseEventModelLoaded:function(metadata) {
  this.debug('Matterport model metadata loaded');
  var matterportPanos = [];
  metadata.panos.forEach(function(pano, index) {
    if (pano.position) {
      var pos = pano.position;
      var p = {uuid:pano.uuid, xo:pos.x, yo:pos.z, zo:pos.y, sx:pos.x, sy:pos.y, sz:pos.z, num:index + 1};
      matterportPanos.push(p);
    }
  }.bind(this));
  this.fireEvent('initialpanosload', matterportPanos);
}, moveToPano:function(uuid, rotation, transition) {
  var me = this;
  this.connectToShowcase().then(function(showcase) {
    if (showcase) {
      var action = {};
      if (rotation != null) {
        action.rotation = rotation;
      }
      if (transition != null) {
        action.transition = transition;
      }
      showcase.off(showcase.App.Event.PHASE_CHANGE, function() {
        me.moveToPano(uuid, rotation, transition);
      });
      showcase.App.getState().then(function(state) {
        if (state.phase != showcase.App.Phase.PLAYING) {
          me.debug('Cannot move to pano. Retrying on phase change.', state);
          showcase.on(showcase.App.Event.PHASE_CHANGE, function() {
            me.moveToPano(uuid, rotation, transition);
          });
          return;
        } else {
          var addMoveListener = false;
          if (me.showcaseEventMoveRef) {
            showcase.off(showcase.Camera.Event.MOVE, me.showcaseEventMoveRef);
            addMoveListener = true;
          }
          return showcase.Sweep.moveTo(uuid, action).then(function(uuid) {
            me.debug('Success moving to pano', uuid, action);
            if (addMoveListener && me.showcaseEventMoveRef) {
              showcase.on(showcase.Camera.Event.MOVE, me.showcaseEventMoveRef);
            }
            return uuid;
          }, function(error) {
            me.error('Error moving to pano', uuid, error, action);
            if (addMoveListener && me.showcaseEventMoveRef) {
              showcase.on(showcase.Camera.Event.MOVE, me.showcaseEventMoveRef);
            }
            return error;
          });
        }
      })['catch'](function(error) {
        me.error('Error moving to pano', uuid, error, action);
      });
    }
    return showcase;
  });
}, getInstantTransition:function() {
  return 'transition.instant';
}, takeScreenShot:function(resolutionOptions, visibilityOptions) {
  if (resolutionOptions == null && window.resolutionOptions) {
    resolutionOptions = window.resolutionOptions;
  }
  if (visibilityOptions == null && window.visibilityOptions) {
    visibilityOptions = window.visibilityOptions;
  }
  this.debug('takeSnapshot', resolutionOptions, visibilityOptions);
  var me = this;
  return this.connectToShowcase().then(function(showcase) {
    if (showcase) {
      return showcase.Renderer.takeScreenShot(resolutionOptions, visibilityOptions).then(function(snapshotUrl) {
        me.debug('Success taking snapshot', snapshotUrl ? snapshotUrl.length : -1);
        return snapshotUrl;
      }, function(error) {
        me.debug('Error taking snapshot', arguments);
        return error;
      });
    }
    return showcase;
  });
}, getPose:function() {
  var me = this;
  return this.connectToShowcase().then(function(showcase) {
    return showcase.Camera.getPose().then(function(pose) {
      me.debug('Pose', pose);
      return pose;
    }, function(error) {
      me.debug('Error getting pose', arguments);
      return error;
    });
  });
}}, 1, 0, 0, 0, 0, [[Ext.mixin.Observable.prototype.mixinId || Ext.mixin.Observable.$className, Ext.mixin.Observable], [siteWalk360.SW360Util.prototype.mixinId || siteWalk360.SW360Util.$className, siteWalk360.SW360Util]], [siteWalk360, 'MatterportShowcaseSDK'], 0);
Ext.cmd.derive('siteWalk360.TruViewSDK', Ext.Base, {config:{siteMap:null, scanViewer:null, tvcUrl:'https://multivista.truview-cloud.com', currentSiteId:null, currentScanId:null, currentRotation:null}, SETUP_REGEX:/_Setup(\d+)$/i, constructor:function(config) {
  this.initConfig(config);
  this.mixins.observable.constructor.call(this, config);
}, clear:function() {
  this.disposeScanViewer();
  this.disposeSiteMap();
  this.setCurrentSiteId(null);
  this.setCurrentScanId(null);
  this.setCurrentRotation(null);
}, hasSiteMap:function() {
  return this.getSiteMap() != null;
}, hasScanViewer:function() {
  return this.getScanViewer() != null;
}, disposeSiteMap:function() {
  var sitemap = this.getSiteMap();
  if (sitemap) {
    this.setSiteMap(null);
    this.setupSiteMapEventListeners(sitemap, false);
  }
}, showSiteMap:function(elementId, siteId) {
  this.setCurrentSiteId(siteId);
  window.tvsdk = this;
  this.disposeSiteMap();
  tvgmap({id:'tvgsitemap', server:this.getTvcUrl(), siteid:siteId, containerid:elementId}, function(err, sitemap) {
    if (err) {
      console.error('Error loading site map: ', err.message, err);
      if (err.message.indexOf('Remote GET request failed')) {
        Ext.Msg.error('Unable to load TruView Site Map - it is probably private.\x3cbr\x3eTry making the site public and try again.\x3cbr\x3e\x3cbr\x3eFind the site in \x3ca href\x3d"' + this.getTvcUrl() + '/locations" target\x3d"TruViewWindow"\x3ethis list\x3c/a\x3e, select the row, and click on the share icon (\x3ci class\x3d"fa fa-share-alt"\x3e\x3c/i\x3e).');
      }
    } else {
      console.log('Site map loaded: ' + sitemap.name, sitemap);
      this.setSiteMap(sitemap);
      this.setupSiteMapEventListeners(sitemap, true);
      window.tvsm = sitemap;
    }
    sitemap.oldScans = sitemap.scans;
    sitemap.scans = function() {
      var index = this.getActiveIndex();
      return index < 0 ? [] : this.getMap(index).scans;
    }.bind(sitemap._map._sitemap);
    this.fireEvent('sitemapready', sitemap, err);
    this.loadSiteScans(siteId, function(scans, err) {
      var truViewPanos = [];
      if (scans) {
        if (scans.length === 0) {
          scans = sitemap.scans();
          console.log('Using sitemap scans', scans);
          for (var i = 0; i < scans.length; i++) {
            var scan = scans[i];
            scan.position = {x:scan.coords.x, y:-scan.coords.y, z:0};
          }
        }
        scans.forEach(function(scan, index) {
          var pos = scan.position;
          var num = index + 1;
          var match = this.SETUP_REGEX.exec(scan.name);
          if (match && match[1]) {
            num = parseInt(match[1]);
            if (isNaN(num)) {
              num = index + 1;
            }
          }
          var p = {uuid:scan.id, num:num, name:scan.name, xo:pos.x, yo:-pos.y, zo:pos.z, sx:pos.x, sy:-pos.y, sz:pos.z};
          truViewPanos.push(p);
        }.bind(this));
      } else {
        Ext.Msg.error('Failed to load site scans:\x3cbr\x3e' + err);
        console.error('Failed to load site scans: ', err);
      }
      this.debug('TruView panos', truViewPanos);
      this.fireEvent('initialpanosload', truViewPanos);
    }.bind(this));
  }.bind(this));
}, setupSiteMapEventListeners:function(sitemap, on) {
  if (on) {
    this.smClickHandler = this.siteMapClickHandler.bind(this);
    sitemap.addListener('click', this.smClickHandler);
  } else {
    sitemap.removeListener('click', this.smClickHandler);
    delete this.smClickHandler;
  }
}, siteMapClickHandler:function(scan) {
  if (scan && scan.id) {
    this.fireEvent('sitemappanoselect', scan.id);
  }
}, siteMapSelectScan:function(elementId, scanId) {
  var sitemap = this.getSiteMap();
  if (sitemap && scanId) {
  }
}, disposeScanViewer:function() {
  var scanViewer = this.getScanViewer();
  if (scanViewer) {
    this.setupViewerEventListeners(scanViewer, false);
    scanViewer.dispose();
  }
  this.setScanViewer(null);
}, showScanViewer:function(elementId, scanId, initialRotation, imperial) {
  this.imperial = imperial;
  if (elementId) {
    this.lastElementId = elementId;
  } else {
    elementId = this.lastElementId;
  }
  if (!elementId) {
    this.error('Must specify an html element');
    return;
  }
  if (!scanId) {
    this.error('Invalid scan id');
    return;
  }
  if (scanId == this.getCurrentScanId()) {
    console.log('Scan ' + scanId + ' already loaded');
    if (initialRotation && initialRotation != this.getCurrentRotation()) {
      this.setInitialCameraAngle(this.getScanViewer(), initialRotation);
    }
    return;
  }
  this.disposeScanViewer();
  this.setCurrentScanId(scanId);
  this.fireEvent('panoselect', scanId);
  this.toggleViewerLoading(true);
  tvgviewer({id:scanId, server:this.getTvcUrl(), scanid:scanId, containerid:elementId, locale:mvstr.LanguageID.split('_')[0] || 'en', sidebar:true, minimap:false, neighbors:true, disablemodeselect:true, hidetools:{layers:false, snapshots:true, measure:false, neighbors:true, geotags:true, minimap:true}}, function(err, viewer) {
    if (err) {
      console.error('** tvgviewer error:', err);
      Ext.Msg.error('Failed to connect to TruView');
    }
    this.setScanViewer(viewer);
    window.tvg = viewer;
    if (viewer && !err) {
      viewer.setProps({units:imperial ? 'in' : 'mm', neighbors:{max:5, showLabels:false, showPosition:true}});
      viewer.setMarkerScaleFactor(0.25);
      viewer.setMarkerColor(233, 92, 19, 1);
      viewer.enableCameraMouse(2);
      this.setInitialCameraAngle(viewer, initialRotation);
      this.setupViewerEventListeners(viewer, true);
    }
    this.fireEvent('scanviewerready', viewer, err);
    this.toggleViewerLoading(false);
  }.bind(this));
}, toggleViewerLoading:function(loading) {
  var photoViewer = Ext.ComponentQuery.query('photoviewer')[0];
  if (!photoViewer) {
    return;
  }
  var vm = photoViewer.lookupViewModel();
  loading = !!loading;
  photoViewer.setLoading(loading);
  vm.set('forceHideInteriorPano', loading);
}, setInitialCameraAngle:function(viewer, rotation) {
  var cameraAngle = 0;
  if (!rotation) {
    rotation = this.getCurrentRotation();
  }
  if (rotation) {
    cameraAngle = this.toRadians(rotation.y);
  }
  try {
    var camera = viewer.getCamera();
    if (cameraAngle != null && cameraAngle !== 0) {
      this.debug('TVG set initial camera ' + cameraAngle + ' (' + this.toDegrees(cameraAngle) + ' °), was ' + camera.longitude + ' (' + this.toDegrees(camera.longitude) + ' °)');
      viewer.setCamera(camera.altitude, cameraAngle, camera.aperture);
    } else {
      this.debug('TVG initial camera', camera);
      this.tvgCameraChange(camera.altitude, camera.longitude, camera.aperture);
    }
  } catch (ex) {
    this.error('Failed to set initial angle');
  }
}, setupViewerEventListeners:function(viewer, on) {
  if (on) {
    this.tvgLoadCompleteHandler = this.tvgLoadComplete.bind(this);
    this.tvgCameraChangeHandler = this.tvgCameraChange.bind(this);
    this.tvgMouseClickHandler = this.tvgMouseClick.bind(this);
  }
  viewer.loadComplete(this.tvgLoadCompleteHandler, on);
  viewer.cameraChange(this.tvgCameraChangeHandler, on);
  viewer.mouseClick(this.tvgMouseClickHandler, on);
  if (!on) {
    delete this.tvgLoadCompleteHandler;
    delete this.tvgCameraChangeHandler;
    delete this.tvgMouseClickHandler;
  }
}, tvgLoadComplete:function() {
  this.debug('TVG loadComplete', arguments);
}, tvgCameraChange:function(el, az, fov) {
  var elDegrees = this.toDegrees(el);
  var azDegrees = this.toDegrees(az);
  this.setCurrentRotation({x:elDegrees, y:azDegrees});
  this.fireEvent('rotationchange', this.getCurrentRotation(), this.getCurrentScanId());
}, tvgMouseClick:function(scan) {
  if (scan && scan.guid) {
    this.tvgMoveToScanPosition(scan.guid);
  } else {
  }
  return false;
}, tvgMoveToScanPosition:function(scanId) {
  Ext.defer(function() {
    this.showScanViewer(null, scanId, null, this.imperial);
  }, 100, this);
}, createSnapShot:function() {
  var viewer = this.getScanViewer();
  if (!viewer) {
    return new Promise(function(resolve, reject) {
      reject('No viewer');
    });
  }
  return new Promise(function(resolve, reject) {
    viewer.createView('TestView' + (new Date).getTime(), function(err, view) {
      if (err) {
        console.error('Error creating view', err);
        reject('Error creating view: ' + err);
      } else {
        console.log('View created');
        resolve(view);
      }
    });
  });
}, takeScreenShot:function() {
  var viewer = this.getScanViewer();
  return viewer.getPictureDataURL();
}, loadSiteScans:function(siteId, callback, serverUrl) {
  if (!serverUrl) {
    serverUrl = this.getTvcUrl();
  }
  var url = serverUrl + '/site/scans/' + siteId + '?count\x3d1000';
  this.debug('Loading site scans...', url);
  this.tvgRestApiCall(url, function(json, err) {
    var scans = [];
    if (json && json.scans && json.scans.length) {
      this.debug('Loaded ' + json.total + ' scans');
      for (var i = 0; i < json.scans.length; i++) {
        var scan = json.scans[i];
        if (scan.id && scan.name && scan.position && scan.position.length) {
          if (scan.position.length < 3) {
            err = "Scans don't contain x, y, z values";
            console.warn("Warning - scan position doesn't contain x, y, z", scan);
            break;
          }
          scans.push({id:scan.id, name:scan.name, position:{x:scan.position[0], y:scan.position[1], z:scan.position[2]}});
        }
      }
    } else {
      if (!err) {
        err = 'No scans returned for ' + siteId;
      }
    }
    if (callback) {
      callback.call(this, scans, err);
    }
  }.bind(this));
}, tvgRestApiCall:function(url, callback) {
  if (callback === undefined) {
    callback = Ext.emptyFn;
  }
  Ext.Ajax.request({url:url, method:'GET', headers:{'Content-Type':'application/json', 'Accept':'application/json'}, withCredentials:false, success:function(response, opts) {
    console.log('TVG Rest API response', response);
    try {
      var obj = Ext.JSON.decode(response.responseText);
      callback(obj);
    } catch (ex) {
      console.error('Failed to parse json response', ex);
      callback(null, 'Failed to parse json response');
    }
  }, failure:function(response, opts) {
    console.error('Rest API call failed', response);
    callback(null, 'Rest API call failed');
  }});
}}, 1, 0, 0, 0, 0, [[Ext.mixin.Observable.prototype.mixinId || Ext.mixin.Observable.$className, Ext.mixin.Observable], [siteWalk360.SW360Util.prototype.mixinId || siteWalk360.SW360Util.$className, siteWalk360.SW360Util]], [siteWalk360, 'TruViewSDK'], 0);
Ext.cmd.derive('mdsUtil.Browser', Ext.Base, {singleton:true, isMouseEventSupported:function(eventName) {
  var el = document.createElement('div');
  eventName = 'on' + eventName;
  var isSupported = eventName in el;
  if (!isSupported) {
    el.setAttribute(eventName, 'return;');
    isSupported = typeof el[eventName] == 'function';
  }
  el = null;
  return isSupported;
}}, 0, 0, 0, 0, 0, 0, [mdsUtil, 'Browser'], 0);
Ext.cmd.derive('permissions.Values', Ext.Base, {statics:{PUBLIC:1, PRIVATE:2, CUSTOM:3, getPermissionEventProperties:function(ShareTypeID) {
  return {'Permission Level':{1:'Project Team', 2:'Only Me', 3:'Custom'}[ShareTypeID], 'Share Type ID':ShareTypeID};
}}}, 0, 0, 0, 0, 0, 0, [permissions, 'Values'], 0);
Ext.cmd.derive('permissions.view.ShareWindow', Ext.window.Window, {layout:'fit', localized:{title:'GSS_Select Members to Sha'}, modal:true, disabled:false, width:400, height:300, closeAction:'hide', config:{parentButton:null}, items:[{xtype:'gridpanel', reference:'memberGrid', bind:'{people}', sortOnLoad:true, rowLines:true, selModel:{selType:'checkboxmodel', mode:'SIMPLE', injectCheckbox:'last', allowDeselect:true}, columns:[{localized:{text:'GSS_First Name'}, dataIndex:'MemberFirstName', flex:1}, 
{localized:{text:'GSS_Last Name'}, dataIndex:'MemberLastName', flex:1}], viewConfig:{listeners:{refresh:{fn:function(grid) {
  grid.addListener('refresh', function(grid) {
    var button = grid.up('shareMemberWindow').getParentButton();
    button.madeChanges = false;
    var viewModel = button.getViewModel(), memberList = viewModel.get('selectedMemberList'), store = grid.getStore();
    if (!memberList) {
      memberList = '';
    }
    var memberUIDArray = memberList.split(','), memberRecordArray = [];
    for (var i = 0; i < memberUIDArray.length; i++) {
      var memberRecord = store.getById(memberUIDArray[i]);
      if (memberRecord) {
        memberRecordArray.push(memberRecord);
      }
    }
    grid.select(memberRecordArray);
    grid.gridReady = true;
  }, grid, {single:true});
}, single:true}, selectionchange:function(grid) {
  var shareWindow = this.up('shareMemberWindow');
  if (this.gridReady) {
    shareWindow.getParentButton().madeChanges = true;
    shareWindow.madeChanges = true;
  }
}}}}], bbar:['-\x3e', {xtype:'button', localized:{text:'G_Done'}, listeners:{click:function(button) {
  var shareWindow = button.up('shareMemberWindow'), selection = shareWindow.getSelection(), selectionIds = [];
  for (var i = 0; i < selection.length; i++) {
    selectionIds.push(selection[i].getId());
  }
  analytics.Ctrl.log('Confirmed Members to Share With', {'Member UIDs':selectionIds.join(','), 'Made Changes':!!shareWindow.madeChanges}, ['Object Type', 'Context']);
  shareWindow.hide();
}}}], setSelectedMemberList:Ext.emptyFn, getSelection:function() {
  return this.down('grid').getSelection();
}, listeners:{hide:function(shareWindow) {
  var button = shareWindow.getParentButton();
  if (!button.madeChanges) {
    return;
  }
  var grid = shareWindow.down('grid'), store = grid.getStore(), selection = shareWindow.getSelection();
  if (!selection.length) {
    button.setNewShareType(permissions.Values.PRIVATE);
  } else {
    if (selection.length == store.getCount()) {
      button.setNewShareType(permissions.Values.PUBLIC);
    } else {
      button.setNewShareType(permissions.Values.CUSTOM, button.getMemberListFromArray(selection));
    }
  }
  shareWindow.destroy();
}}}, 0, ['shareMemberWindow'], ['component', 'box', 'container', 'panel', 'window', 'shareMemberWindow'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true, 'shareMemberWindow':true}, ['widget.shareMemberWindow'], 0, [permissions.view, 'ShareWindow'], 0);
Ext.cmd.derive('permissions.view.ShareWithButton', Ext.button.Button, {config:{owner:'', parentView:null, iconSize:'small'}, viewModel:{data:{initialShareTypeID:null, initalShareMemberList:null, shareGridReady:false}, formulas:{selectedShareType:function(get) {
  var initialShareTypeID = get('initialShareTypeID'), selectedShareTypeID = get('selectedShareTypeID');
  return initialShareTypeID !== null ? initialShareTypeID : selectedShareTypeID;
}, selectedMemberList:function(get) {
  var initalShareMemberList = get('initalShareMemberList');
  return initalShareMemberList !== null ? initalShareMemberList : get('selectedShareMemberUIDList');
}, shareIcon:function(get) {
  var shareTypeID = get('selectedShareType'), view = permissions.view.ShareWithButton, icons = view['icons' + Ext.String.capitalize(this.getView().iconSize)];
  return icons[shareTypeID] ? icons[shareTypeID] : icons['default'];
}, shareTooltip:function(get) {
  var shareTypeID = get('selectedShareType');
  return mvstr['GSS_Shared_with_' + shareTypeID] ? mvstr['GSS_Shared_with_' + shareTypeID] : mvstr['GSS_Shared_with_default'];
}}}, bind:{selectedShareType:'{selectedShareType}', selectedMemberList:'{selectedMemberList}', icon:'{shareIcon}', tooltip:'{shareTooltip}'}, mvPreloadImages:['mds/image/icon/VisibleAllSmall.png', 'mds/image/icon/VisibleMeSmall.png', 'mds/image/icon/VisibleSelectedSmall.png'], menu:{items:[{localized:{text:'GSS_Project Team'}, action:'all', icon:'mds/image/icon/VisibleAllSmall.png'}, {localized:{text:'GSS_Only Me'}, action:'me', icon:'mds/image/icon/VisibleMeSmall.png'}, {localized:{text:'GSS_Custom'}, 
action:'custom', icon:'mds/image/icon/VisibleSelectedSmall.png'}], listeners:{click:function(menu, item, e, eOpts) {
  if (!item) {
    return;
  }
  var button = this.up('shareWithButton'), shareTypeID;
  switch(item.action) {
    case 'all':
      button.setNewShareType(permissions.Values.PUBLIC);
      shareTypeID = permissions.Values.PUBLIC;
      break;
    case 'me':
      button.setNewShareType(permissions.Values.PRIVATE);
      shareTypeID = permissions.Values.PRIVATE;
      break;
    case 'custom':
      button.showShareWindow();
      shareTypeID = permissions.Values.CUSTOM;
  }
  analytics.Ctrl.log('Set Permission Level', permissions.Values.getPermissionEventProperties(shareTypeID), ['Object Type', 'Context']);
}}}, constructor:function(config) {
  permissions.view.ShareWithButton.iconsSmall = {1:'mds/image/icon/VisibleAllSmall.png', 2:'mds/image/icon/VisibleMeSmall.png', 3:'mds/image/icon/VisibleSelectedSmall.png', 'default':'mds/image/icon/VisibleUnknownSmall.png'};
  permissions.view.ShareWithButton.iconsMedium = {1:'mds/image/icon/VisibleAllMedium.png', 2:'mds/image/icon/VisibleMeMedium.png', 3:'mds/image/icon/VisibleSelectedMedium.png', 'default':'mds/image/icon/VisibleUnknownMedium.png'};
  Ext.button.Button.prototype.constructor.apply(this, arguments);
  if (!config.parentView && this.getViewModel().getParent()) {
    this.setParentView(this.getViewModel().getParent().getView());
  }
  if (config.selectedShareType) {
    this.initialize(config.selectedShareType, config.selectedMemberList);
  }
  if (config.menuUi) {
    this.menu.ui = config.menuUi;
  }
}, loadStore:function() {
  var store = this.lookupViewModel().get('people');
  if (!store) {
    setTimeout(Ext.bind(this.loadStore, this), 1);
    return;
  }
  if (!store.isLoaded() && !store.isLoading()) {
    store.load();
  }
}, showShareWindow:function() {
  this.shareWindow = this.getParentView().add({xtype:'shareMemberWindow', parentButton:this, renderTo:Ext.getBody()});
  this.shareWindow.showBy(Ext.getBody(), 'c-c?');
}, initialize:function(ShareTypeID, ShareMemberArrayOrList) {
  var viewModel = this.getViewModel(), memberList = ShareMemberArrayOrList;
  if (typeof ShareMemberArrayOrList == 'object') {
    memberList = this.getMemberListFromArray(ShareMemberArrayOrList);
  }
  if (!memberList || ShareTypeID != permissions.Values.CUSTOM) {
    memberList = '';
  }
  viewModel.set('initialShareTypeID', ShareTypeID);
  viewModel.set('initalShareMemberList', memberList);
}, fireChangeEvent:function() {
  var viewModel = this.getViewModel();
  this.fireEvent('selectionChange', {owner:this.owner, selectedShareType:this.private_ShareTypeID, selectedMemberList:this.private_ShareMemberList, button:this});
}, setNewShareType:function(value, memberList) {
  if (!memberList) {
    memberList = '';
  }
  this.private_ShareTypeID = value;
  this.private_ShareMemberList = memberList;
  var viewModel = this.getViewModel();
  this.getViewModel().getParent().set('selectedShareTypeID', value);
  viewModel.set('initialShareTypeID', null);
  this.setNewSelectedMemberList(memberList);
}, setNewSelectedMemberList:function(value) {
  var viewModel = this.getParentView().lookupViewModel();
  viewModel.set('selectedShareMemberUIDList', value);
  viewModel.set('initalShareMemberList', null);
  this.fireChangeEvent();
}, getSelectedMemberList:function() {
  return this.getViewModel().get('selectedShareMemberUIDList');
}, getSelectedMemberArray:function() {
  var list = this.getSelectedMemberList();
  return list ? list.split(',') : [];
}, setSelectedMemberArray:function(memberArray) {
  this.setSelectedMemberList(this.getMemberListFromArray(memberArray));
}, getSelectedShareType:function() {
  return this.getViewModel().get('selectedShareType');
}, getSelectedShareTypeStr:function(shareTypeID) {
  var str = '';
  switch(shareTypeID) {
    case permissions.Values.PUBLIC:
      str = 'public';
      break;
    case permissions.Values.PRIVATE:
      str = 'private';
      break;
    case permissions.Values.CUSTOM:
      str = 'custom';
  }
  return str;
}, setIcon:function(icon) {
  if (!this.el || !this.el.dom) {
    return;
  }
  Ext.button.Button.prototype.setIcon.apply(this, arguments);
}, setTooltip:function(icon) {
  if (!this.el || !this.el.dom) {
    return;
  }
  Ext.button.Button.prototype.setTooltip.apply(this, arguments);
}, setSelectedMemberList:Ext.emptyFn, setSelectedShareType:Ext.emptyFn, getMemberListFromArray:function(memberArray) {
  var memberUIDArray = [];
  for (var i = 0; i < memberArray.length; i++) {
    var member = memberArray[i];
    if (typeof member == 'string') {
      memberUIDArray.push(member);
    } else {
      memberUIDArray.push(member.get('MemberUID'));
    }
  }
  return memberUIDArray.join(',');
}, listeners:{destroy:function(button) {
  if (button.shareWindow) {
    button.shareWindow.destroy();
  }
}}}, 1, ['shareWithButton'], ['component', 'box', 'button', 'shareWithButton'], {'component':true, 'box':true, 'button':true, 'shareWithButton':true}, ['widget.shareWithButton'], 0, [permissions.view, 'ShareWithButton'], 0);
Ext.cmd.derive('mdsWidget.view.SimpleColorWidget', Ext.ux.colorpick.Button, {width:12, height:12, baseCls:'x-simplecolorwidget', constructor:function(config) {
  config = config || {};
  config.popup = {xtype:'window', referenceHolder:true, minWidth:173, minHeight:8 * 20 + 35, layout:'fit', title:'Annotation color', header:true, closable:true, closeAction:'hide', cls:'simple-color-widget-window', ui:config.popupUi || 'default', shadow:config.popupShadow === undefined ? true : false, alwaysOnTop:2, listeners:{show:{fn:function(popup) {
    var parentZIndex = this.up().el.getZIndex();
    if (!isNaN(parentZIndex)) {
      popup.el.setZIndex(parentZIndex + 1);
    }
  }, scope:this}, focusLeave:{fn:function(popup) {
    popup.hide();
  }}}, items:{xtype:'colorpicker', reference:'selector', allowReselect:true, colors:['FF8080', 'FFFF80', '80FF80', '00FF80', '80FFFF', '0080FF', 'FF80C0', 'FF80FF', 'FF0000', 'FFFF00', '80FF00', '00FF40', '00FFFF', '0080C0', '8080C0', 'FF00FF', '804040', 'FF8040', '00FF00', '008080', '004080', '8080FF', '800040', 'FF0080', 'C02020', 'C08040', '20C080', '008040', '2040A0', '336699', '204080', 'C080FF', 'A04020', 'FF4040', 'A0FFA0', '40FF40', '4000C0', '4040FF', '4080C0', '8020A0', '800000', 'FF8000', 
  '008000', '40A040', '0000FF', '0000A0', '800080', '8000FF', '400000', '804000', '004000', '004040', '000080', '000040', '400040', '400080', '000000', '202020', '404040', '808080', 'A0A0A0', 'C0C0C0', 'E0E0E0', 'FFFFFF'], handler:function(picker, color) {
    this.fireEvent('ok', picker, color);
  }, setValue:function(color) {
    if (typeof color === 'object' && color != null && color.hasOwnProperty('r')) {
      color = Ext.ux.colorpick.ColorUtils.rgb2hex(color.r, color.g, color.b);
    }
    if (color) {
      color = color.toUpperCase();
      if (this.colors.indexOf(color) === -1) {
        this.colors.push(color);
        var rows = Math.ceil(this.colors.length / 8);
        this.up('window').minHeight = rows * 20 + 35;
      }
    }
    if (color !== this.value) {
      try {
        this.select(color, true);
      } catch (ex) {
        console.log(ex.message);
      }
    }
  }, getColor:function() {
    var value = this.getValue();
    return value ? value.toUpperCase() : null;
  }, setColor:function(color) {
    this.setValue(color);
  }, getPreviousColor:function() {
    return this.previousColor;
  }, setPreviousColor:function(color) {
    this.previousColor = color;
  }, getFormat:function() {
    return this.format;
  }, setFormat:function(format) {
    this.format = format;
  }, listeners:{afterrender:function(comp) {
    var win = this.up('window');
  }}}};
  Ext.ux.colorpick.Button.prototype.constructor.call(this, config);
}, listeners:{click:{fn:function(ev) {
  ev.stopEvent();
  if (window.openColorPicker && window.openColorPicker !== this) {
    if (window.openColorPicker.component && window.openColorPicker.component.colorPickerWindow) {
      window.openColorPicker.component.colorPickerWindow.close();
    }
  }
  window.openColorPicker = this;
}, element:'btnEl'}}}, 1, ['simplecolorwidget'], ['component', 'box', 'colorbutton', 'simplecolorwidget'], {'component':true, 'box':true, 'colorbutton':true, 'simplecolorwidget':true}, ['widget.simplecolorwidget'], 0, [mdsWidget.view, 'SimpleColorWidget'], 0);
Ext.cmd.derive('mdsWidget.view.AnnotationsGrid', Ext.grid.Panel, {config:{typeHidden:false, removeImportExport:false, removeCopy:false, tooltipConfig:null, showVisibilityHeaderToggle:false, titleHeaderLabel:''}, scrollable:'y', selModel:'rowmodel', emptyText:'There are no annotations for this plan', ui:'annotationsgrid', rowLines:false, minHeight:120, plugins:{ptype:'cellediting', clicksToEdit:2}, bind:{selection:'{selectedAnnotation}', store:'{annotationStore}'}, viewConfig:{markDirty:false, getRowClass:function(record) {
  return record.get('Visible') ? 'visible' : '';
}}, listeners:{colorbuttonchange:'annotationColorButtonChange', beforeselect:'annotationGridBeforeSelectionChanged', select:'annotationGridSelectionChanged', beforerowclick:'annotationGridBeforeRowClick', rowclick:'annotationGridRowClick', beforecelldblclick:'annotationGridCellEdit', cellclick:function(cmp, td, cellIndex, record, tr, rowIndex) {
  console.log('click old');
  if (cellIndex == 4) {
    var visible = record.get('Visible');
    record.set('Visible', visible == 0 ? 1 : 0);
    this.fireEvent('visibilitychanged', record);
    return false;
  }
  if (cellIndex == 5) {
    if (record.get('CanEdit')) {
      var oldValue = record.get('ShareTypeID');
      var newValue = oldValue === 1 ? 2 : 1;
      record.set('ShareTypeID', newValue);
      this.fireEvent('sharetypechanged', record, newValue, oldValue);
    }
  }
}, visibilitychanged:'annotationVisibilityChanged', sharetypechanged:'annotationShareTypeChanged', edit:'annotationGridEdit', itemmousedown:function(view, record, item, index) {
  if (window.openColorPicker && window.openColorPicker.component && window.openColorPicker.component.colorPickerWindow) {
    window.openColorPicker.component.colorPickerWindow.close();
    delete window.openColorPicker;
  }
}, beforeitemkeydown:function(me, record, item, index, e, eOpts) {
  if (e.event.code === 'Delete') {
    this.fireEvent('deleteKeyPressed');
  }
}, deleteKeyPressed:'removeButtonClick'}, initComponent:function() {
  if (this.getTitleHeaderLabel() == '') {
    this.setTitleHeaderLabel(mvstr['MVTI_Title']);
  }
  var showVisibilityHeaderToggle = this.getShowVisibilityHeaderToggle();
  this.columns = [{text:'', dataIndex:'Color', width:31, xtype:'widgetcolumn', resizable:false, sortable:true, menuDisabled:true, widget:{xtype:'simplecolorwidget', width:12, height:12, listeners:{beforerender:function(button) {
    button.setDisabled(!button.getWidgetRecord().get('CanEdit') || !button.lookupViewModel().get('projectMapEditable'));
  }, change:function(cmp, color, previousColor) {
    if (previousColor == undefined) {
      return;
    }
    var record = cmp.getWidgetRecord();
    if (record == undefined) {
      return;
    }
    if (Number('0x' + record.get('Color').split('#')[1]) == Number('0x' + color)) {
      return;
    }
    var grid = this.up('annotationsgrid');
    grid.fireEvent('colorbuttonchange', '#' + color.toUpperCase(), record);
  }}}}, {text:this.getTitleHeaderLabel(), dataIndex:'Title', flex:1, editor:'textfield', resizable:false, menuDisabled:true, renderer:function(value, metadata, record) {
    return record.get('TitleDisplayValue');
  }}, {localized:{text:'MVTI_Owner', tooltip:'MVTI_Owner'}, dataIndex:'MemberInitials', width:this.getTypeHidden() ? 60 : 50, align:'center', resizable:false, menuDisabled:true, renderer:function(value, metadata, record) {
    return '\x3cspan title\x3d"' + record.get('MemberName') + '"\x3e' + value + '\x3c/span\x3e';
  }}, {localized:{text:'MVTI_Type'}, dataIndex:'TypeLabelShort', width:50, align:'center', resizable:false, menuDisabled:true, hidden:this.getTypeHidden()}, {text:showVisibilityHeaderToggle ? '' : mvstr['MVTI_Vis'], tooltip:showVisibilityHeaderToggle ? undefined : mvstr['MVFPO_Visibility'], sortable:!showVisibilityHeaderToggle, focusCls:showVisibilityHeaderToggle ? '' : 'focus', cls:showVisibilityHeaderToggle ? 'visibility-toggle' : '', padding:0, dataIndex:'Visible', localized:{width:{zh_CN:36, 
  'default':30}}, align:'center', resizable:false, menuDisabled:true, renderer:function(value, metadata, record) {
    return '\x3cspan class\x3d"mapping-visible-icon' + (value ? '' : ' hidden') + '"\x3e\x3c/span\x3e';
  }, listeners:{render:{fn:function(column) {
    if (showVisibilityHeaderToggle) {
      this.visibilityToggle = Ext.create('Ext.button.Button', {ui:'plain', cls:'annotation-visible-icon', renderTo:column.el, height:20, padding:4, width:30, enableToggle:true, pressedCls:'hidden', listeners:{click:{fn:'onToggleAllVisibilityClick', scope:this.lookupController()}}});
    }
  }, scope:this}}}, {text:'', dataIndex:'ShareTypeID', width:30, align:'center', resizable:false, menuDisabled:true, bind:{hidden:'{!projectMapEditable}'}, renderer:function(value, metadata, record) {
    var sharetype = ['team', 'private'];
    var canEditCss = record.get('CanEdit') ? '' : ' disabled';
    return '\x3cdiv class\x3d"mapping-permission-icon ' + sharetype[value - 1] + canEditCss + '"\x3e\x3c/div\x3e';
  }}];
  var tooltipConfig = this.getTooltipConfig(), dockButtons = ['-\x3e', {xtype:'button', tooltip:tooltipConfig ? Ext.merge({text:mvstr['GABTT_Delete']}, tooltipConfig) : mvstr['GABTT_Delete'], ui:'annotationfooterbutton', iconCls:'annotationFooterIcon remove', disabled:true, bind:{disabled:'{deleteAnnotationBtnDisabled}'}, listeners:{click:'removeButtonClick'}}];
  if (!this.getRemoveCopy()) {
    Ext.Array.insert(dockButtons, 1, [{xtype:'button', tooltip:tooltipConfig ? Ext.merge({text:mvstr['GABTT_Copy']}, tooltipConfig) : mvstr['GABTT_Copy'], ui:'annotationfooterbutton', iconCls:'annotationFooterIcon copy', disabled:false, bind:{disabled:'{copyAnnotationBtnDisabled}'}, listeners:{click:'copyButtonClick'}}, '-']);
  }
  if (!this.getRemoveImportExport()) {
    Ext.Array.insert(dockButtons, 1, [{xtype:'button', localized:{tooltip:'GABTT_Import'}, ui:'annotationfooterbutton', iconCls:'annotationFooterIcon import', listeners:{click:'importButtonClick'}}, '-', {xtype:'button', localized:{tooltip:'GABTT_Export'}, ui:'annotationfooterbutton', iconCls:'annotationFooterIcon export', listeners:{click:'exportButtonClick'}}, '-']);
  }
  this.dockedItems = {xtype:'toolbar', dock:'bottom', ui:'toolbar', hidden:true, bind:{hidden:'{!projectMapEditable}'}, cls:'annotationGridFooter', items:dockButtons};
  Ext.grid.Panel.prototype.initComponent.apply(this, arguments);
}}, 0, ['annotationsgrid'], ['component', 'box', 'container', 'panel', 'tablepanel', 'gridpanel', 'grid', 'annotationsgrid'], {'component':true, 'box':true, 'container':true, 'panel':true, 'tablepanel':true, 'gridpanel':true, 'grid':true, 'annotationsgrid':true}, ['widget.annotationsgrid'], 0, [mdsWidget.view, 'AnnotationsGrid'], 0);
Ext.cmd.derive('mdsWidget.view.ExpandTab', Ext.button.Button, {ui:'expandtab', scale:'medium', width:17, height:89, config:{lhs:false}, initComponent:function() {
  if (this.scale == 'small') {
    this.setWidth(21);
    this.setHeight(32);
  }
  Ext.button.Button.prototype.initComponent.apply(this, arguments);
  this.setIconCls(this.getEffectiveIconCls('collapse'));
  if (this.getLhs()) {
    this.addCls('lhs');
  }
}, getEffectiveIconCls:function(state) {
  return state == 'collapse' && !this.getLhs() || state != 'collapse' && this.getLhs() ? 'collapse' : 'expand';
}, listeners:{click:function() {
  if (this.getEffectiveIconCls(this.iconCls) == 'collapse') {
    this.setIconCls(this.getEffectiveIconCls('expand'));
    this.fireEvent('collapse');
  } else {
    this.setIconCls(this.getEffectiveIconCls('collapse'));
    this.fireEvent('expand');
  }
}}}, 0, ['expandtab'], ['component', 'box', 'button', 'expandtab'], {'component':true, 'box':true, 'button':true, 'expandtab':true}, ['widget.expandtab'], 0, [mdsWidget.view, 'ExpandTab'], 0);
Ext.cmd.derive('mdsWidget.view.ShootLockToggle', Ext.button.Button, {scale:'small', ui:'plain', config:{menuConfig:[{localized:{text:'PT_Same Day'}, itemId:'lockToShootDate'}, {localized:{text:'PT_Same Location'}, itemId:'lockToHotspot'}], lockMode:'lockToShootDate'}, publishes:'lockMode', padding:'3 6 0 6', width:116, textAlign:'left', initComponent:function() {
  var items = this.getMenuConfig();
  for (var i = 0; i < items.length; i++) {
    items[i].listeners = {click:{fn:this.onMenuButtonClick, scope:this}};
    if (items[i].itemId == this.getLockMode()) {
      this.setText(mvstr[items[i].localized.text]);
      items[i].cls = 'selected';
    }
    items[i].height = 21;
  }
  this.setMenu({ui:'dark2', showSeparator:false, shadow:false, cls:'shoot-lock-menu', defaultMinWidth:106, width:106, items:items});
  Ext.button.Button.prototype.initComponent.apply(this, arguments);
}, onMenuButtonClick:function(btn) {
  this.setLockMode(btn.getItemId());
}, updateLockMode:function(lockMode) {
  if (!lockMode || this.isConfiguring) {
    return;
  }
  var button = this.getMenu().down('#' + lockMode);
  this.setText(button.config.text);
  var menuItems = this.getMenu().items.items;
  for (var i = 0; i < menuItems.length; i++) {
    if (menuItems[i].getItemId() == lockMode) {
      menuItems[i].addCls('selected');
    } else {
      menuItems[i].removeCls('selected');
    }
  }
}}, 0, ['shootlocktoggle'], ['component', 'box', 'button', 'shootlocktoggle'], {'component':true, 'box':true, 'button':true, 'shootlocktoggle':true}, ['widget.shootlocktoggle'], 0, [mdsWidget.view, 'ShootLockToggle'], 0);
Ext.cmd.derive('comments.model.CommentEntry', Ext.data.Model, {entityName:'CommentEntry', fields:[{name:'CommentDateTime', type:'date', persist:false}, {name:'MemberUID', persist:false}, {name:'Text'}, {name:'ShareTypeID'}, {name:'ShareMembers'}, {name:'IsMine', type:'boolean', persist:false}, {name:'CommentEntryID'}, {calculate:function(data) {
  return data.IsMine ? true : false;
}, name:'IsEditable', persist:false}, {name:'MemberFirstName', persist:false}, {name:'MemberLastName', persist:false}, {calculate:function(data) {
  return data.IsMine ? 'my-comment' : 'not-my-comment';
}, name:'OwnershipCls', persist:false}, {name:'referenceTime', convert:function(v) {
  if (v) {
    return v;
  }
  return new Date;
}, persist:false}, {calculate:function(data) {
  return customData.Util.getTimeDescription(data.referenceTime, data.CommentDateTime);
}, name:'TimeDescription', type:'string', persist:false}, {name:'MemberName', calculate:function(data) {
  return Ext.String.trim(data.MemberFirstName + ' ' + data.MemberLastName);
}, persist:false}, {name:'ShareCls', calculate:function(data) {
  return data.ShareTypeID == 1 ? 'team' : data.ShareTypeID == 2 ? 'me' : data.ShareTypeID == 3 ? 'custom' : '';
}, persist:false}, {name:'id'}, {name:'ParentID', mapping:function(data) {
  if (data.PunchItemID) {
    return data.PunchItemID;
  }
  return null;
}}, {name:'mentions'}, {name:'CommentStyled', calculate:function(data) {
  var text = data.Text;
  text = text.replace(/</g, '\x26lt;');
  text = text.replace(/>/g, '\x26gt;');
  if (data.mentions && data.mentions.length) {
    data.mentions.sort(function(item1, item2) {
      if (item1.Position == item2.Position) {
        return 0;
      }
      return item1.Position > item2.Position ? -1 : 1;
    });
    Ext.each(data.mentions, function(mention) {
      var end = mention.Position + mention.Length + 1, start = mention.Position;
      text = [text.slice(0, end), '\x3c/span\x3e', text.slice(end)].join('');
      text = [text.slice(0, start), '\x3cspan class\x3d"mention"\x3e', text.slice(start)].join('');
    });
  }
  return text;
}}], idProperty:'CommentEntryID', clientIdProperty:'id', proxy:{type:'ajax', reader:{type:'json', rootProperty:'data'}, writer:{writeAllFields:true}}}, 0, 0, 0, 0, 0, 0, [comments.model, 'CommentEntry'], 0);
Ext.cmd.derive('comments.view.batchaddcomment.AddCommentModel', Ext.app.ViewModel, {data:{saving:false, saveDone:false}, formulas:{saveEnabled:function(get) {
  return !!get('comment.value');
}}}, 0, 0, 0, 0, ['viewmodel.batchaddcomment'], 0, [comments.view.batchaddcomment, 'AddCommentModel'], 0);
Ext.cmd.derive('comments.view.batchaddcomment.AddCommentController', Ext.app.ViewController, {statics:{MAX_PHOTOS:100}, init:function() {
  analytics.Ctrl.setOptionalDefaultEventProperties({'Object Type':'Photo Comment', 'Context':'Batch-Add Comment Dialog'});
}, save:function() {
  var vm = this.getViewModel(), shareButton = this.lookupReference('shareWithButton'), shareMemberUIDs = shareButton.getSelectedMemberArray(), jsonData = {Text:this.lookupReference('comment').getValue(), CommentType:'photo', mentions:[]};
  jsonData.ShareTypeID = shareButton.getSelectedShareType();
  if (jsonData.ShareTypeID == 3) {
    jsonData.ShareMembers = shareMemberUIDs;
  }
  jsonData.PhotoIdentifiers = [];
  vm.get('selectedPhotos').each(function(rec) {
    jsonData.PhotoIdentifiers.push(rec.get('id'));
  });
  vm.set('saving', true);
  analytics.Ctrl.log('Commented on Photo', {}, ['Photo List', 'Photo Action Element']);
  Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daComments.batchSaveComments', jsonData:jsonData, params:{ProjectUID:vm.get('ProjectUID'), nComments:1}, successCallback:function() {
    vm.set('saveDone', true);
    this.getView().fireEvent('changedphotos', jsonData);
    Ext.defer(function() {
      this.getView().destroy();
    }, 1000, this);
  }, afterFailMessageCallback:function(data, message) {
    vm.set('saving', false);
    vm.set('errorMessage', message ? message : mvstr.G_UnexpectedError);
  }, scope:this});
}}, 0, 0, 0, 0, ['controller.batchaddcomment'], 0, [comments.view.batchaddcomment, 'AddCommentController'], 0);
Ext.cmd.derive('comments.view.batchaddcomment.AddComment', Ext.window.Window, {viewModel:{type:'batchaddcomment'}, controller:'batchaddcomment', ui:'orange', cls:'photo-actions-window', localized:{title:'PUL_Add a Comment'}, modal:true, padding:'28 20 24 20', width:426, height:415, layout:{type:'vbox'}, constructor:function() {
  var me = this;
  me.items = [{xtype:'container', width:'100%', flex:1, layout:{type:'hbox'}, items:[{xtype:'component', cls:'instructions', html:'\x3cb\x3e' + mvstr['PUL_Add a Comment to Phot'] + '\x3c/b\x3e\x3cdiv\x3e' + mvstr['PUL_This will add your co'] + '\x3c/div\x3e', width:216}, {xtype:'photoselectionthumb'}]}, {xtype:'container', layout:{type:'hbox', align:'top'}, items:[{xtype:'component', html:'\x3cb\x3e' + mvstr['PUL_Add your comment'] + '\x3c/b\x3e', padding:'3 0 0 0'}, {xtype:'shareWithButton', reference:'shareWithButton', 
  menuUi:'white', ui:'plain'}]}, {xtype:'detailformtextarea', reference:'comment', publishes:'value', maxLength:255, enforceMaxLength:true, width:'100%', height:107}];
  Ext.window.Window.prototype.constructor.apply(this, arguments);
}, dockedItems:[{xtype:'container', dock:'bottom', layout:{type:'hbox', pack:'center'}, padding:'12 0 0 0', items:[{xtype:'button', scale:'medium', ui:'grey', localized:{text:'G_Cancel'}, margin:'0 12 0 12', listeners:{click:function() {
  this.up('window').destroy();
}}}, {xtype:'savebutton', reference:'saveButton', bind:{processing:'{saving}', done:'{saveDone}', disabled:'{!saveEnabled}'}, margin:'0 12 0 12', listeners:{click:'save'}}]}]}, 1, ['batchaddcomment'], ['component', 'box', 'container', 'panel', 'window', 'batchaddcomment'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true, 'batchaddcomment':true}, ['widget.batchaddcomment'], 0, [comments.view.batchaddcomment, 'AddComment'], 0);
Ext.cmd.derive('comments.view.comments.Comment', Ext.container.Container, {cls:'comment-component', comment:null, readOnlyTpl:new Ext.XTemplate('\x3ctpl for\x3d"."\x3e\x3cdiv class\x3d"comment-container"\x3e\x3cdiv class\x3d"comment-text"\x3e\x3ctpl if\x3d"IsEditable"\x3e\x3cdiv class\x3d"comment-menu-button"\x3e\x3c/div\x3e\x3c/tpl\x3e\x3cspan class\x3d"comment-member-name"\x3e{MemberName}:\x3c/span\x3e\x26nbsp;{CommentStyled}\x3c/div\x3e\x3cdiv class\x3d"comment-footer"\x3e\x3cspan class\x3d"comment-date"\x3e{TimeDescription}\x3c/span\x3e\x3cdiv class\x3d"comment-permissions {ShareCls}"\x3e\x3c/div\x3e\x3c/div\x3e\x3c/div\x3e\x3c/tpl\x3e'), 
initComponent:function() {
  Ext.container.Container.prototype.initComponent.apply(this, arguments);
  this.startReadOnly();
}, listeners:{click:{element:'el', fn:'onCommentEntryClick'}}, startReadOnly:function() {
  var html = this.readOnlyTpl.apply(this.comment.getData());
  this.removeAll(true);
  this.add({xtype:'component', html:html});
}, startEdit:function() {
  var width = this.getEl().getWidth();
  this.removeAll(true);
  this.add([{xtype:'textarea', cls:'existing-comment', minLength:1, maxLength:255, allowOnlyWhitespace:false, value:this.comment.get('Text'), height:46, grow:true, enableKeyEvents:true, listeners:{keydown:this.onEntryKeyPress, scope:this, blur:{fn:this.onEntryBlur, delay:1}}, margin:0, width:width}, {xtype:'component', cls:'directions', localized:{html:'GC_Press escape to exit'}, margin:'2 2 3 2'}]);
  var textArea = this.down('textarea');
  textArea.focus();
  var tmp = textArea.getValue();
  textArea.setValue('');
  textArea.setValue(tmp);
}, onEntryKeyPress:function(textArea, e) {
  var charChode = e.getCharCode();
  if (charChode == e.ENTER && !e.shiftKey) {
    if (!textArea.isValid()) {
      e.preventDefault();
      return false;
    }
    this.lookupController().updateComment(this);
    return false;
  } else {
    if (charChode == e.ESC) {
      this.onEntryBlur();
      return false;
    }
  }
  return true;
}, onEntryBlur:function() {
  this.comment.reject();
  this.startReadOnly();
}}, 0, ['commentcomponent'], ['component', 'box', 'container', 'commentcomponent'], {'component':true, 'box':true, 'container':true, 'commentcomponent':true}, ['widget.commentcomponent'], 0, [comments.view.comments, 'Comment'], 0);
Ext.cmd.derive('comments.view.comments.CommentMenu', Ext.menu.Menu, {showSeparator:false, ui:'comment', defaultAlign:'tr-bl?', items:[{localized:{text:'GC_Edit'}, icon:'mds/image/icon/details_edit.png', listeners:{click:function(menuItem) {
  menuItem.up('menu').commentCmp.startEdit();
}}}, {localized:{text:'GC_Delete'}, icon:'mds/image/icon/x.png', listeners:{click:function(menuItem) {
  var menu = menuItem.up('menu');
  menu.hide();
  Ext.defer(function() {
    this.lookupController().deleteComment(menu.commentCmp);
  }, 1, this);
}}}]}, 0, ['commentmenu'], ['component', 'box', 'container', 'panel', 'menu', 'commentmenu'], {'component':true, 'box':true, 'container':true, 'panel':true, 'menu':true, 'commentmenu':true}, ['widget.commentmenu'], 0, [comments.view.comments, 'CommentMenu'], 0);
Ext.cmd.derive('comments.view.comments.CommentsController', Ext.app.ViewController, {config:{isWaiting:false}, newCommentMentions:[], currentMention:null, init:function() {
  this.control({'#listWrapper shareWithButton':{selectionChange:function(settings) {
    var record = settings.button.comment, viewModel = this.getViewModel(), commentParams = viewModel.get('commentParams'), comments = this.getStore('comments');
    record.set('ShareTypeID', settings.selectedShareType);
    record.set('ShareMembers', settings.selectedMemberList ? settings.selectedMemberList.split(',') : []);
    if (commentParams) {
      comments.getProxy().setExtraParams(commentParams);
      comments.sync({silentSuccess:true, callback:this.loadComments, scope:this});
    }
  }}});
  this.addListener('triggerbufferload', this.doCommentsLoad, this, {buffer:1000});
}, beforeCommentsLoaded:function(count) {
  var view = this.getView();
  if (count) {
    view.setLoading(true);
  } else {
    view.setLoading(false);
  }
  view.down('#listWrapper').removeAll();
}, doCommentsLoad:function() {
  var bufferLoad = !!this.getViewModel().get('commentViewData.BufferLoad'), count = this.getViewModel().get('commentViewData.CommentCount');
  if (!bufferLoad || bufferLoad && count) {
    this.getStore('comments').load({callback:this.onCommentsLoaded, scope:this});
  }
}, loadComments:function() {
  var count = this.getViewModel().get('commentViewData.CommentCount'), comments = this.getStore('comments'), bufferLoad = !!this.getViewModel().get('commentViewData.BufferLoad');
  if (comments.isLoading()) {
    comments.mvAbort();
  }
  this.beforeCommentsLoaded(count);
  if (count) {
    if (bufferLoad) {
      this.fireEvent('triggerbufferload');
    } else {
      this.doCommentsLoad();
    }
  } else {
    comments.loadData([], false);
    this.getView().onCommentsRefresh(comments);
  }
}, onCommentsLoaded:function(data, operation, success) {
  if (success) {
    this.getView().setLoading(false);
  }
}, saveNewComment:function() {
  var shareButton = this.lookupReference('newCommentShareMemberButton'), view = this.getView(), viewModel = this.getViewModel(), mentionsEnabled = !view.down('commententryfield_old').isVisible(), textFieldRef = mentionsEnabled ? 'newCommentEntry' : 'newCommentText', textField = this.lookupReference(textFieldRef), commentList = view.down('#listWrapper'), comments = this.getStore('comments'), textValue = textField.getValue(), mentions = this.newCommentMentions, commentParams = viewModel.get('commentParams');
  viewModel.set('commentViewData.CommentCount', viewModel.get('commentViewData.CommentCount') + 1);
  var record = Ext.create('comments.model.CommentEntry', {ShareTypeID:shareButton.getSelectedShareType(), ShareMembers:shareButton.getSelectedMemberArray(), Text:textValue, MemberFirstName:viewModel.get('account.MemberUsername'), MemberLastName:'', referenceTime:new Date, CommentDateTime:new Date, mentions:mentions, IsMine:true});
  textField.setValue('');
  comments.add(record);
  record.newCmp = view.onCommentsRefresh(comments);
  commentList.scrollBy(0, Infinity);
  if (commentParams) {
    record.newCmp.mask('Saving ...');
  }
  var sync = Ext.bind(function() {
    if (commentParams) {
      comments.getProxy().setExtraParams(commentParams);
      comments.sync({success:function(batch) {
        var records = batch.getOperations()[0].getRecords();
        view.onCommentsRefresh(comments);
        commentList.scrollBy(0, Infinity);
        for (var i = 0; i < records.length; i++) {
          records[i].newCmp.unmask();
        }
        this.newCommentMentions = [];
        comments.fireEvent('aftersync');
      }, afterFailMessageCallback:function(batch) {
        var records = batch.getOperations()[0].getRecords();
        for (var i = 0; i < records.length; i++) {
          comments.remove(records[i]);
        }
        textField.setValue(textValue);
        this.newCommentMentions = mentions;
        view.onCommentsRefresh(comments);
        comments.fireEvent('aftersync');
      }});
    }
  }, this);
  if (!comments.isSyncing) {
    sync();
  } else {
    if (!this.getIsWaiting()) {
      this.setIsWaiting(true);
      comments.addListener('aftersync', function() {
        sync();
        this.setIsWaiting(false);
      }, this, {single:true});
    }
  }
  if (commentParams && commentParams.Identifier) {
    var shareProps = permissions.Values.getPermissionEventProperties(shareButton.getSelectedShareType());
    if (commentParams.CommentType == 'photo') {
      analytics.Ctrl.log('Commented on Photo', Ext.apply({'Photo List':commentParams.Identifier, 'Photo Action Element':'Photo Viewer Comment Entry'}, shareProps));
    } else {
      if (commentParams.CommentType == 'punchitem') {
        analytics.Ctrl.log('Commented on Photo', shareProps, ['Task List Item ID']);
      }
    }
  }
}, deleteComment:function(commentCmp) {
  var comments = this.getStore('comments'), record = commentCmp.comment, view = this.getView(), commentParams = this.getViewModel().get('commentParams');
  comments.remove(record);
  view.onCommentsRefresh(comments);
  if (commentParams) {
    Ext.defer(function() {
      comments.getProxy().setExtraParams(commentParams);
      comments.sync({scope:this, useDefaults:true, afterFailMessageCallback:this.loadComments, silentSuccess:true});
    }, 1, this);
    if (commentParams.Identifier) {
      analytics.Ctrl.log('Deleted Comment on Photo', {'Photo List':commentParams.Identifier, 'Photo Action Element':'Photo Viewer Comment Entry'});
    }
  }
}, onCommentEntryClick:function(e, target) {
  var targetEl = Ext.fly(target), commentCmp = Ext.getCmp(targetEl.up('.comment-component').id);
  if (targetEl.hasCls('comment-menu-button')) {
    if (this.commentMenu) {
      this.commentMenu.destroy();
    }
    this.commentMenu = this.getView().add({commentCmp:commentCmp, xtype:'commentmenu'});
    this.commentMenu.showBy(targetEl);
  }
}, initView:function() {
  this.lookupReference('newCommentShareMemberButton').setParentView(this.getViewModel().getParent().getView());
}, updateComment:function(commentCmp) {
  var newValue = commentCmp.down('textarea').getValue(), comment = commentCmp.comment, commentParams = this.getViewModel().get('commentParams'), comments = this.getStore('comments');
  comment.set('Text', newValue);
  commentCmp.startReadOnly();
  if (commentParams) {
    commentCmp.mask('Saving ...');
    comments.getProxy().setExtraParams(commentParams);
    comments.sync({success:function() {
      commentCmp.unmask();
    }, afterFailMessageCallback:function() {
      comment.reject();
      commentCmp.startReadOnly();
      commentCmp.unmask();
    }});
  }
}, newCommentKeyDown:function(textField, e) {
  var charCode = e.getCharCode(), mentionActive = this.activeMentionKeydown(e) || this.checkMentionSelectionOnKeydown(e);
  if (mentionActive) {
    e.preventDefault();
    return false;
  }
  this.newCommentTextChange();
  if (charCode == e.ENTER && !e.shiftKey) {
    if (!textField.isValid()) {
      e.preventDefault();
      return false;
    }
    this.saveNewComment();
    e.preventDefault();
    return false;
  } else {
    if (e.event.key == '@') {
      this.currentMention = {Position:e.getTarget().selectionStart};
      this.lookupReference('userMentionSelection').show();
    } else {
      if (charCode == e.ESC) {
        textField.blur();
        return false;
      }
    }
  }
  return true;
}, activeMentionKeydown:function(e) {
  if (!this.currentMention) {
    return;
  }
  var charCode = e.getCharCode(), text = this.lookupReference('newCommentEntry').getValue(), start = this.currentMention.Position;
  end = text.slice(start).search(/\s/);
  if (e.getTarget().selectionStart <= start || end > -1 && e.getTarget().selectionStart > end + start) {
    this.breakMention();
    return;
  }
  if (charCode == e.ENTER && !e.shiftKey) {
    this.addMentionToComment();
    return true;
  } else {
    if (charCode == e.DOWN) {
      this.navigateBoundlist(1);
      return true;
    } else {
      if (charCode == e.UP) {
        this.navigateBoundlist(-1);
        return true;
      } else {
        if (charCode == e.SPACE) {
          this.breakMention();
        }
      }
    }
  }
}, breakMention:function() {
  this.currentMention = null;
  this.lookupReference('userMentionSelection').hide();
}, navigateBoundlist:function(direction) {
  var boundlist = this.lookupReference('userMentionSelection'), store = boundlist.getStore(), selection = boundlist.selection, position = store.findExact('MemberUID', selection.get('MemberUID')), scroller = boundlist.getScrollable();
  position = Math.min(store.getCount() - 1, position + direction);
  boundlist.select(store.getAt(position));
  var node = boundlist.getNode(boundlist.selection);
  scroller.scrollIntoView(node);
}, filterBoundlist:function(commentText) {
  var store = this.lookupReference('userMentionSelection').getStore(), start = this.currentMention.Position, mentions = this.newCommentMentions, text = commentText || this.lookupReference('newCommentEntry').getValue(), end = text.slice(start).search(/\s/), endPos = end > -1 ? end + start : text.length, searchText = text.slice(start + 1, endPos).toLowerCase() || '', memberUIDs = [];
  store.clearFilter();
  Ext.each(mentions, function(mention) {
    memberUIDs.push(mention.MemberUID);
  });
  store.filterBy(function(record) {
    var name = record.get('MemberDisplayName').toLowerCase(), id = record.get('MemberUID');
    return name.indexOf(searchText) > -1 && memberUIDs.indexOf(id) == -1;
  });
}, addMentionToComment:function(list, item) {
  var boundlist = list || this.lookupReference('userMentionSelection'), record = item || boundlist.selection, textfield = this.lookupReference('newCommentEntry'), commentText = textfield.getValue(), start = this.currentMention.Position, end = commentText.slice(start).search(/\s/), name = record.get('MemberDisplayName').trim();
  this.currentMention.MemberUID = record.get('MemberUID');
  this.currentMention.MemberDisplayName = name;
  this.currentMention.Length = name.length;
  end = end > -1 ? end + start : commentText.length;
  commentText = commentText.slice(0, start + 1) + name + commentText.slice(end);
  this.newCommentMentions.push(this.currentMention);
  this.currentMention = null;
  this.newCommentMentions = this.newCommentMentions.sort(function(item1, item2) {
    if (item1.Position == item2.Position) {
      return 0;
    }
    return item1.Position > item2.Position ? -1 : 1;
  });
  textfield.setValue(commentText);
  boundlist.hide();
}, commentTextAreaScroll:function(e) {
  var commentOverlay = this.lookupReference('commentOverlay'), commentTextArea = this.lookupReference('newCommentEntry'), scrollTop = 0;
  commentOverlay.removeCls('scrollable');
  if (commentTextArea.inputEl.isScrollable()) {
    commentOverlay.addCls('scrollable');
  }
  if (e && commentOverlay) {
    scrollTop += e.target.scrollTop;
    commentOverlay.setStyle({'top':-1 * scrollTop + 'px'});
  }
}, newCommentTextChange:function() {
  var commentOverlay = this.lookupReference('commentOverlay'), text = this.lookupReference('newCommentEntry').getValue();
  this.checkMentionPositions(text);
  if (this.currentMention) {
    this.filterBoundlist(text);
  }
  text = text.replace(/</g, '\x26lt;');
  text = text.replace(/>/g, '\x26gt;');
  var mentions = this.newCommentMentions;
  if (mentions && mentions.length) {
    Ext.each(mentions, function(mention) {
      var end = mention.Position + mention.Length + 1, start = mention.Position, cls = 'mention' + (mention.Selected ? ' highlight' : '');
      text = [text.slice(0, end), '\x3c/span\x3e', text.slice(end)].join('');
      text = [text.slice(0, start), '\x3cspan class\x3d"' + cls + '"\x3e', text.slice(start)].join('');
    });
  }
  commentOverlay.setHtml(text);
  this.commentTextAreaScroll();
}, checkMentionPositions:function(newValue) {
  var mentions = this.newCommentMentions, survivingMentions = [];
  Ext.each(mentions, function(mention) {
    var mentionString = '@' + mention.MemberDisplayName, mentionIndex = newValue.indexOf(mentionString);
    if (mentionIndex > -1) {
      mention.Position = mentionIndex;
      survivingMentions.push(mention);
    }
  });
  this.newCommentMentions = null;
  this.newCommentMentions = survivingMentions;
}, hideUserMentionSelection:function() {
  this.lookupReference('userMentionSelection').hide();
}, checkMentionSelectionOnKeydown:function(e) {
  var charCode = e.getCharCode(), mentions = this.newCommentMentions, cursorPos = e.target.selectionStart, textarea = this.lookupReference('newCommentEntry'), returnVal = false;
  if (charCode != e.LEFT && charCode != e.RIGHT && charCode != e.BACKSPACE) {
    return;
  }
  Ext.each(mentions, function(mention) {
    var start = mention.Position;
    var end = mention.Position + mention.Length + 1;
    if (charCode == e.LEFT) {
      if (cursorPos == end) {
        if (!mention.Selected) {
          mention.Selected = returnVal = true;
        } else {
          textarea.selectText(start + 1, start + 1);
        }
      }
    } else {
      if (charCode == e.RIGHT) {
        if (cursorPos == start) {
          if (mention.Selected) {
            textarea.selectText(end, end);
          } else {
            mention.Selected = returnVal = true;
          }
        }
      } else {
        if (charCode == e.BACKSPACE) {
          if (mention.Selected) {
            var text = textarea.getValue();
            text = text.slice(0, start) + text.slice(end);
            textarea.setValue(text);
            textarea.selectText(start, start);
            returnVal = true;
            return;
          }
          if (cursorPos == end) {
            mention.Selected = returnVal = true;
          }
        }
      }
    }
  });
  this.newCommentTextChange();
  return returnVal;
}, checkMentionCaretPosition:function(textarea, e) {
  var cursorPos = e.target.selectionEnd, mentions = this.newCommentMentions, controller = this;
  textarea = textarea || this.lookupReference('newCommentEntry');
  Ext.each(mentions, function(mention) {
    var start = mention.Position;
    var end = mention.Position + mention.Length + 1;
    if (start != cursorPos && end != cursorPos && mention.Selected) {
      mention.Selected = false;
      controller.newCommentTextChange();
    }
    if (start < cursorPos && end > cursorPos && !mention.Selected) {
      textarea.selectText(end, end);
    }
  });
}}, 0, 0, 0, 0, ['controller.comments'], 0, [comments.view.comments, 'CommentsController'], 0);
Ext.cmd.derive('comments.view.comments.CommentEntryField', Ext.container.Container, {items:[{xtype:'container', items:[{xtype:'container', cls:'new-comment-form', margin:'2 0 0 0', width:'100%', layout:{type:'hbox'}, bind:{hidden:'{!canWriteComments}'}, items:[{xtype:'container', flex:1, items:[{xtype:'component', reference:'commentOverlay', cls:'new-comment-overlay', width:'100%'}, {xtype:'textareafield', cls:'new-comment', reference:'newCommentEntry', allowBlank:false, grow:true, localized:{emptyText:'GC_Write a comment…'}, 
minLength:1, maxLength:255, growMax:125, growMin:40, enforceMaxLength:true, invalidCls:'', triggerWrapInvalidCls:'', inputWrapInvalidCls:'', width:'100%', preventMark:true, enableKeyEvents:true, listeners:{keydown:'newCommentKeyDown', change:'newCommentTextChange', focusleave:'hideUserMentionSelection', render:function(textarea) {
  var controller = this.lookupController();
  textarea.inputEl.on('scroll', controller.commentTextAreaScroll, controller);
  textarea.inputEl.on('click', function(e) {
    controller.checkMentionCaretPosition(null, e);
  });
}, keyup:'checkMentionCaretPosition'}}]}, {xtype:'shareWithButton', reference:'newCommentShareMemberButton', width:38, height:42, arrowAlign:'left', iconSize:'medium', bind:{selectedShareType:'{defaultShareTypeID}'}}]}]}, {xtype:'boundlist', reference:'userMentionSelection', bind:'{people}', maxHeight:150, floating:true, hidden:true, defaultAlign:'bl', alignOnScroll:true, cls:'userMentionSelection', itemTpl:'{MemberDisplayName}\x3cbr\x3e\x3cspan class\x3d"email"\x3e{MemberEmail}\x3c/span\x3e', listeners:{itemclick:'addMentionToComment', 
beforeshow:function(picker) {
  var commentForm = this.up('comments');
  picker.lookupController().filterBoundlist();
  picker.setWidth(commentForm.getWidth());
}, show:function(picker) {
  var area = picker.lookupController().lookupReference('newCommentEntry');
  picker.anchorTo(area, 'tl-bl', [-1, 6]);
  picker.setMaxHeight(150);
}, refresh:function(boundlist) {
  var store = boundlist.getStore();
  if (store.getAt(0)) {
    boundlist.select(store.getAt(0));
  }
}, hide:function(picker) {
  picker.getStore().clearFilter();
}}}]}, 0, ['commententryfield'], ['component', 'box', 'container', 'commententryfield'], {'component':true, 'box':true, 'container':true, 'commententryfield':true}, ['widget.commententryfield'], 0, [comments.view.comments, 'CommentEntryField'], 0);
Ext.cmd.derive('comments.view.comments.CommentEntryField_old', Ext.container.Container, {items:[{xtype:'container', cls:'new-comment-form', margin:'2 0 0 0', width:'100%', layout:{type:'hbox'}, bind:{hidden:'{!canWriteComments}'}, items:[{xtype:'textfield', cls:'new-comment', reference:'newCommentText', allowBlank:false, localized:{emptyText:'GC_Write a comment…'}, minLength:1, maxLength:255, enforceMaxLength:true, invalidCls:'', triggerWrapInvalidCls:'', inputWrapInvalidCls:'', flex:1, height:40, 
preventMark:true, enableKeyEvents:true, listeners:{keydown:function(textField, e) {
  var charChode = e.getCharCode();
  if (charChode == e.ENTER && !e.shiftKey) {
    if (!textField.isValid()) {
      e.preventDefault();
      return false;
    }
    this.lookupController().saveNewComment();
    return false;
  } else {
    if (charChode == e.ESC) {
      textField.blur();
      return false;
    }
  }
  return true;
}}}, {xtype:'shareWithButton', reference:'newCommentShareMemberButton', width:38, height:42, arrowAlign:'left', iconSize:'medium', bind:{selectedShareType:'{defaultShareTypeID}'}}]}]}, 0, ['commententryfield_old'], ['component', 'box', 'container', 'commententryfield_old'], {'component':true, 'box':true, 'container':true, 'commententryfield_old':true}, ['widget.commententryfield_old'], 0, [comments.view.comments, 'CommentEntryField_old'], 0);
Ext.cmd.derive('comments.view.comments.Comments', Ext.container.Container, {cls:'comments-view', controller:'comments', viewModel:{type:'comments'}, layout:{type:'vbox', align:'start'}, bind:{comments:'{comments}', userCls:'{commentsCls}'}, config:{loadMaskCls:'light-load-indicator'}, items:[{xtype:'container', itemId:'listWrapper', reserveScrollbar:true, width:'100%', flex:1, scrollable:{x:false, y:true}, items:[]}, {xtype:'component', itemId:'emptyText', cls:'empty-text', localized:{html:'GC_There are currently n'}, 
flex:2, width:'100%', margin:'0 25 0 5'}, {xtype:'commententryfield', width:'100%', hidden:true, bind:{hidden:'{!mentionsEnabled}'}}, {xtype:'commententryfield_old', width:'100%', hidden:true, bind:{hidden:'{mentionsEnabled}'}}], listeners:{afterrender:{fn:'initView'}}, setComments:function(comments) {
  comments.addListener('refresh', function() {
    this.onCommentsRefresh(comments);
    this.down('#listWrapper').scrollBy(0, Infinity);
  }, this);
}, onCommentsRefresh:function(comments) {
  var count = comments.getCount(), list = this.down('#listWrapper'), commentCmps = [], removeCmps = [], ids = [], commentCountChange = this.items.length != count, i;
  this.suspendLayouts();
  for (i = 0; i < count; i++) {
    comments.getAt(i).set('referenceTime', new Date);
  }
  for (i = 0; i < list.items.length; i++) {
    var cmp = list.items.items[i], id = cmp.comment.getId();
    if (comments.getById(id)) {
      ids.push(id);
      cmp.startReadOnly();
    } else {
      removeCmps.push(cmp);
    }
  }
  for (i = 0; i < count; i++) {
    if (!Ext.Array.contains(ids, comments.getAt(i).getId())) {
      commentCmps.push({xtype:'commentcomponent', comment:comments.getAt(i)});
    }
  }
  list.add(commentCmps);
  for (i = 0; i < removeCmps.length; i++) {
    list.remove(removeCmps[i], true);
  }
  if (commentCountChange) {
    this.fireEvent('commentcountchange', Ext.Object.merge(this.getViewModel().get('commentParams') || {}, {nComments:count}));
  }
  if (count) {
    this.down('#emptyText').hide();
  } else {
    this.down('#emptyText').show();
  }
  this.resumeLayouts(true);
  return list.items.length ? list.items.items[list.items.length - 1] : null;
}}, 0, ['comments'], ['component', 'box', 'container', 'comments'], {'component':true, 'box':true, 'container':true, 'comments':true}, ['widget.comments'], 0, [comments.view.comments, 'Comments'], 0);
Ext.cmd.derive('comments.view.comments.CommentsModel', Ext.app.ViewModel, {data:{project_CommentMentionsEnabled:false, newCommentTextValue:''}, formulas:{commentParams:function(get) {
  var type = get('commentViewData.CommentType'), ProjectUID = get('ProjectUID'), id = get('commentViewData.Identifier'), comments = get('comments');
  if (!get('account.canRead') || !ProjectUID) {
    return null;
  }
  var params = id ? {Identifier:id} : null;
  if (params) {
    if (isNaN(ProjectUID)) {
      params.ProjectUID = ProjectUID;
    } else {
      params.ProjectID = ProjectUID;
    }
  }
  if (params && comments) {
    comments.getProxy().setExtraParams(params);
  }
  return params;
}, triggerLoadComments:function(get) {
  var commentParams = get('commentParams'), comments = get('comments');
  if (commentParams && comments && !comments.getModifiedRecords().length) {
    this.getView().lookupController().loadComments();
  }
}, canWriteComments:function(get) {
  return !!(get('account.canWrite') && get('commentParams'));
}, mentionsEnabled:function(get) {
  return !!(get('project_CommentMentionsEnabled') || get('project.commentMentionsEnabled'));
}, commentsCls:function(get) {
  return get('mentionsEnabled') ? 'with-mentions' : 'no-mentions';
}}, stores:{comments:{model:'comments.model.CommentEntry', autoLoad:false, sortOnLoad:true, proxy:{type:'jsonp', api:{create:'/index.cfm?fuseaction\x3daComments.saveComments', read:'/index.cfm?fuseaction\x3daComments.getComments', update:'/index.cfm?fuseaction\x3daComments.saveComments', destroy:'/index.cfm?fuseaction\x3daComments.removeComments'}, reader:{type:'json', rootProperty:'data'}}, data:[]}}}, 0, 0, 0, 0, ['viewmodel.comments'], 0, [comments.view.comments, 'CommentsModel'], 0);
Ext.cmd.derive('viewerPhoto.model.Photo', Ext.data.Model, {fields:[{name:'storePosition', type:'int'}, {name:'photoIndex', type:'int', convert:function(value, record) {
  return value === undefined ? record.get('storePosition') : value;
}}, {name:'photoID', type:'int', defaultValue:0, mapping:'PhotoID'}, {name:'hotspotID', type:'int', defaultValue:0}, {name:'shootUID', type:'string', defaultValue:'00000000-0000-0000-0000-000000000000'}, {name:'albumUID', type:'string', defaultValue:'00000000-0000-0000-0000-000000000000'}, {name:'UDEFPhotoUID', type:'string', defaultValue:''}, {name:'WebcamPhotoUID', type:'string', defaultValue:''}, {name:'commentThreadID', type:'int', defaultValue:0}, {name:'SphereImageID', type:'int', defaultValue:0}, 
{name:'id', type:'string', calculate:function(data) {
  if (data.UDEFPhotoUID.length !== 0) {
    return 'U' + data.UDEFPhotoUID;
  } else {
    if (data.WebcamPhotoUID.length !== 0) {
      return 'W' + data.WebcamPhotoUID;
    } else {
      if (data.Type == 'B') {
        return 'B' + data.SphereImageID;
      } else {
        return 'P' + data.photoID;
      }
    }
  }
}}, {name:'isUDEF', type:'boolean', calculate:function(data) {
  if (data.UDEFPhotoUID.length === 0) {
    return false;
  } else {
    return true;
  }
}}, {name:'isWebcam', type:'boolean', calculate:function(data) {
  if (data.WebcamPhotoUID.length === 0) {
    return false;
  } else {
    return true;
  }
}}, {name:'name', type:'string', defaultValue:'', mapping:'Description'}, {name:'floorplanDesc', type:'string', defaultValue:'', mapping:'Location'}, {name:'dateTaken', mapping:'PhotoDate', type:'tzadate'}, {name:'src', type:'string', mapping:'ImageURL'}, {name:'med', type:'string', mapping:'ImageURLMedium'}, {name:'tmb', type:'string', mapping:'ImageURLThumb'}, {name:'floorplanUID', type:'string', defaultValue:'0'}, {name:'floorplanImage', type:'string', defaultValue:''}, {name:'floorplanImageW', 
type:'int', defaultValue:null}, {name:'floorplanImageH', type:'int', defaultValue:null}, {name:'floorplanOffsetLeft', type:'int', defaultValue:null}, {name:'floorplanOffsetTop', type:'int', defaultValue:null}, {name:'floorplanLabel', type:'string', defaultValue:null}, {name:'commentCount', type:'int', defaultValue:'0', mapping:'CommentCount'}, {name:'hasAnnotations', type:'int', defaultValue:'0', mapping:'HasAnnotations'}, {name:'isFavorite', type:'boolean', convert:function(value) {
  if (value > 0) {
    return true;
  }
  return false;
}}, {name:'WebcamUID', type:'string', defaultValue:''}, {name:'Weather', type:'string', defaultValue:''}, {name:'TemperatureF', type:'auto'}, {name:'WindDirection', type:'string'}, {name:'WindMPH', type:'auto'}, {name:'altitude', type:'string'}, {name:'latitude', type:'string'}, {name:'longitude', type:'string'}, {name:'IconName', type:'string', calculate:function(data) {
  if (data.id.charAt(0) != 'W') {
    return '';
  }
  var weather = data.Weather, icon;
  if (weather.indexOf('Thunderstorm') != -1) {
    icon = 'storm';
  } else {
    if (weather.indexOf('Ice') != -1 || weather.indexOf('Hail') != -1) {
      if (weather.indexOf('Rain') != -1 || weather.indexOf('Drizzle') != -1) {
        icon = 'rainsnow';
      } else {
        icon = 'hail';
      }
    } else {
      if (weather.indexOf('Snow') != -1) {
        if (weather.indexOf('Freezing') != -1 || weather.indexOf('Rain') != -1 || weather.indexOf('Drizzle') != -1) {
          icon = 'rainsnow.png';
        } else {
          icon = 'snow';
        }
      } else {
        if (weather.indexOf('Dust') != -1 || weather.indexOf('Sand') != -1) {
          icon = 'dust';
        } else {
          if (weather.indexOf('Windy') != -1 && weather.indexOf('Rain') == -1 && weather.indexOf('Fog') == -1) {
            icon = 'clear_sunny';
          } else {
            if (weather.indexOf('Cloudy') != -1) {
              icon = 'part_cloud';
            } else {
              if (weather.indexOf('Fair') != -1 || weather.indexOf('Clear') != -1 || weather.indexOf('Sunny') != -1) {
                icon = 'clear_sunny';
              } else {
                if (weather.indexOf('A Few Clouds') != -1) {
                  icon = 'part_cloud';
                } else {
                  if (weather.indexOf('Overcast') != -1) {
                    icon = 'overcast';
                  } else {
                    if (weather.indexOf('Freezing') != -1) {
                      if (weather.indexOf('Fog') != -1) {
                        icon = 'fog';
                      }
                      var nRain = weather.match(/Rain/g);
                      nRain = nRain ? nRain.length : 0;
                      var nDrizzle = weather.match(/Drizzle/g);
                      nDrizzle = nDrizzle ? nDrizzle.length : 0;
                      if (nRain + nDrizzle > 1) {
                        icon = 'rainsnow';
                      } else {
                        icon = 'hail';
                      }
                    } else {
                      if (weather.indexOf('Showers') != -1 || weather.indexOf('Light Rain') != -1 || weather.indexOf('Drizzle') != -1 || weather.indexOf('Rain') != -1) {
                        icon = 'rain';
                      } else {
                        if (weather.indexOf('Fog') != -1 || weather.indexOf('Haze') != -1) {
                          icon = 'fog';
                        } else {
                          icon = 'overcast';
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  var hour = data.dateTaken.getHours();
  if ((hour < 6 || hour > 19) && (icon == 'clear_sunny' || icon == 'part_cloud')) {
    if (icon == 'clear_sunny') {
      icon = 'clear_night';
    } else {
      if (icon == 'part_cloud') {
        icon = 'part_cloud_night';
      }
    }
  }
  return icon + '.png';
}}, {name:'isSelected', type:'boolean', defaultValue:false}, {name:'tmbSelected', type:'boolean', defaultValue:false}, {name:'mdslink_clientFloorplanViewer'}, {name:'DescLine1', type:'string', defaultValue:'', mapping:'name'}, {name:'DescLine2', type:'string', defaultValue:'', mapping:'floorplanDesc'}, {name:'DescLine3', convert:function(v, rec) {
  var photoNumber = rec.get('photoIndex'), date = rec.get('dateTaken'), desc = Ext.Date.format(date, 'M d Y');
  return photoNumber ? desc += ' - Photo ' + photoNumber : desc;
}}, {name:'FileSize', type:'int', defaultValue:0}, {name:'Type', defaultValue:'P'}, {name:'ImageURLMedium', type:'string', mapping:'med'}, {name:'Identifier', type:'int', mapping:'photoID'}, {name:'PhotoDate', type:'tzadate', mapping:'dateTaken'}, {name:'ImageURLThumb', type:'string', mapping:'med'}, {name:'is360Pano', type:'boolean', defaultValue:false}, {name:'isInteriorPano', type:'boolean', defaultValue:false}, {name:'CanSnapshot', type:'boolean', calculate:function(data) {
  return data.is360Pano || data.isInteriorPano;
}}]}, 0, 0, 0, 0, 0, 0, [viewerPhoto.model, 'Photo'], 0);
Ext.cmd.derive('floorplanList.PlanUtil', Ext.Base, {singleton:true, pinPointToLayer:function(feature, latlng) {
  var pushpinType = feature.properties.PushpinType, iconSize = mdsData.FloorplanValues.DEFAULT_ICON_SIZE, iconAnchor = feature.properties.PunchItemID ? mdsData.FloorplanValues.PUNCHPIN_ICON_ANCHOR : mdsData.FloorplanValues.DEFAULT_ICON_ANCHOR;
  if (mdsData.FloorplanValues.ICON_ANCHORS[pushpinType]) {
    iconAnchor = mdsData.FloorplanValues.ICON_ANCHORS[pushpinType];
  }
  var markerIcon = MVLeaflet.divIcon({html:mdsData.FloorplanValues.iconTemplate.apply(floorplanList.PlanUtil.getPinValuesFromFeature(feature)), iconSize:iconSize, iconAnchor:iconAnchor});
  return MVLeaflet.marker(latlng, {icon:markerIcon});
}, getPinValuesFromFeature:function(feature) {
  var iconSize = mdsData.FloorplanValues.DEFAULT_ICON_SIZE;
  return {PushpinSymbol:feature.properties.PushpinSymbol, TextOverlay:feature.properties.TextOverlay ? feature.properties.TextOverlay : '', width:iconSize[0], height:iconSize[1], cls:feature.properties.PunchItemID ? 'punchpin' : 'pushpin'};
}, filterPushpinData:function(data, isList) {
  var itemsToRemove = [];
  for (var i = 0; i < data.features.length; i++) {
    if (!!data.features[i].properties.PunchItemID != isList) {
      itemsToRemove.push(data.features[i]);
    }
  }
  for (var i = 0; i < itemsToRemove.length; i++) {
    Ext.Array.remove(data.features, itemsToRemove[i]);
  }
}, pinToFeature:function(pin) {
  return {properties:pin.getData(), id:pin.getId(), type:'Feature', geometry:{coordinates:[pin.get('PushpinXCoordinate'), pin.get('PushpinYCoordinate')], type:'Point'}};
}, pinsToFeatures:function(pinStore) {
  var count = pinStore.getCount(), data = [];
  for (var i = 0; i < count; i++) {
    data.push(floorplanList.PlanUtil.pinToFeature(pinStore.getAt(i)));
  }
  return {type:'FeatureCollection', features:data};
}}, 0, 0, 0, 0, 0, 0, [floorplanList, 'PlanUtil'], 0);
Ext.cmd.derive('floorplanList.store.Floorplans', Ext.data.Store, {model:'mdsData.model.Floorplan', proxy:{type:'jsonp', reader:{type:'json', root:'data'}, url:'index.cfm?fuseaction\x3daClientFloorplanOverview.getFloorplans'}}, 0, 0, 0, 0, ['store.floorplans'], 0, [floorplanList.store, 'Floorplans'], 0);
Ext.cmd.derive('floorplanList.view.FloorplanList', Ext.view.View, {cls:'floorplan-list'}, 0, ['floorplanlist'], ['component', 'box', 'dataview', 'floorplanlist'], {'component':true, 'box':true, 'dataview':true, 'floorplanlist':true}, ['widget.floorplanlist'], 0, [floorplanList.view, 'FloorplanList'], 0);
Ext.cmd.derive('floorplanList.view.FloorplanOverview', floorplanList.view.FloorplanList, {bind:{store:'{floorplans}', emptyText:'{listEmptyText}'}, itemSelector:'.floorplanCover', groupTpl:'\x3cdiv class\x3d"title mds-light-bg-list-header"\x3e{ProjectShootTypeLabel}\x3c/div\x3e', groupField:'ProjectShootTypeLabel', noLink:false, initComponent:function() {
  this.tpl = ['\x3ctpl for\x3d"."\x3e', '\x3cdiv class\x3d"floorplanCover"\x3e', this.noLink ? '' : '\x3ca href\x3d"{BaseURL}ProjectUID\x3d{ProjectUID}\x26FloorplanUID\x3d{FloorplanUID}\x26ListTypeID\x3d{ListTypeID}"\x3e', '\x3cimg id\x3d"F-{FloorplanUID}" class\x3d"floorplanCoverImage" src\x3d"{ImageURL}"\x3e', '\x3cdiv class\x3d"floorplanCoverLabel"\x3e\x3cspan\x3e{FloorplanDescription}\x3c/span\x3e\x3c/div\x3e', '\x3cdiv class\x3d"floorplan-badges"\x3e', '\x3ctpl if\x3d"CommentCount \x26gt; 0"\x3e', 
  "\x3cspan class\x3d\"badge-icon comment\" onclick\x3d\"function isCommentIconClicked() { analytics.Ctrl.log('Clicked Activity Callout', { 'Floorplan Name': '{FloorplanDescription}', 'Callout Type': 'Comment'  }); }; isCommentIconClicked();\"\x3e", '\x3cimg src\x3d"mds/image/icon/comment.png"\x3e\x3c/span\x3e', '\x3cspan class\x3d"badge-label"\x3e{CommentCount}\x3c/span\x3e', '\x3c/tpl\x3e', '\x3ctpl if\x3d"PushpinCount \x26gt; 0"\x3e', "\x3cdiv class\x3d\"badge-icon pushpin\" onclick\x3d\"function isPushpinIconClicked() { analytics.Ctrl.log('Clicked Activity Callout', { 'Floorplan Name': '{FloorplanDescription}', 'Callout Type': 'Pushpin'  }); }; isPushpinIconClicked();\"\x3e", 
  '\x3cimg src\x3d"mds/module/clientFileManager/image/pin_green.png"\x3e\x3c/div\x3e', '\x3cspan class\x3d"badge-label"\x3e{PushpinCount}\x3c/span\x3e', '\x3c/tpl\x3e', '\x3c/div\x3e', this.noLink ? '' : '\x3c/a\x3e', '\x3ctpl if\x3d"PunchlistPlanUID"\x3e', '\x3ctpl if\x3d"Pins.length"\x3e', '\x3cdiv class\x3d"floorplanCoverLabel punch-item"\x3e', '\x3ctpl for\x3d"Pins"\x3e', '\x3cdiv class\x3d"punchpin {Cls}"\x3e\x3cimg src\x3d"{PushpinSymbol}"\x3e\x3cspan\x3e{Count}\x3c/span\x3e\x3c/div\x3e', '\x3c/tpl\x3e', 
  '\x3c/div\x3e', '\x3c/tpl\x3e', '\x3c/tpl\x3e', '\x3cscript\x3efunction isCommentIconClicked() { console.log("inside isCommentIconClicked"); }\x3c/script\x3e', '\x3c/div\x3e', '\x3c/tpl\x3e'];
  floorplanList.view.FloorplanList.prototype.initComponent.apply(this, arguments);
}, listeners:{itemclick:function(view, record, item, index, event, eOpts) {
  analytics.Ctrl.log('Clicked Floorplan', {'Floorplan Name':record.data.FloorplanDescription, 'Floorplan UID':record.data.FloorplanUID});
}}}, 0, ['floorplanoverview'], ['component', 'box', 'dataview', 'floorplanlist', 'floorplanoverview'], {'component':true, 'box':true, 'dataview':true, 'floorplanlist':true, 'floorplanoverview':true}, ['widget.floorplanoverview'], 0, [floorplanList.view, 'FloorplanOverview'], 0);
Ext.cmd.derive('multiupload.UploadManager', Ext.util.MixedCollection, {singleton:true, register:function(item) {
  this.add(item);
}, unregister:function(item) {
  this.remove(item);
}, getKey:function(o) {
  return o.instanceId;
}, uploadCallback:function(id, data) {
  var item = this.get(id);
  if (item) {
    switch(data.event) {
      case 'fileAdded':
        item.fireEvent('fileadded', item, data);
        break;
      case 'fileOpen':
        item.fireEvent('uploadstart', item, data);
        break;
      case 'uploadProgress':
        item.fireEvent('uploadprogress', item, data);
        break;
      case 'uploadComplete':
        item.fireEvent('uploadcomplete', item, data);
        break;
      case 'uploadCompleteData':
        item.fireEvent('uploaddatacomplete', item, data);
        break;
      case 'queueUploadComplete':
        item.fireEvent('queuecomplete', item, data);
        break;
      case 'queueUploadDataComplete':
        item.fireEvent('queuedatacomplete', item, data);
        break;
      case 'uploadError':
        item.fireEvent('uploaderror', item, data);
        break;
    }
  }
}}, 0, 0, 0, 0, 0, 0, [multiupload, 'UploadManager'], 0);
Ext.cmd.derive('multiupload.Upload', Ext.flash.Component, {width:101, height:22, wmode:'transparent', url:'/mds/sencha/ux/multiupload/Upload.swf', statics:{instanceId:0}, constructor:function(config) {
  config = config || {};
  config.instanceId = Ext.String.format('upload-{0}', ++multiupload.Upload.instanceId);
  config.flashVars = config.flashVars || {};
  config.flashVars = Ext.apply({instanceId:config.instanceId, buttonImagePath:'/mds/image/multiupload/button.png', buttonImageHoverPath:'/mds/image/multiupload/button.png', fileFilters:'Images (*.jpg)|*.jpg', uploadUrl:'/upload/url', maxFileSize:0, maxQueueLength:0, maxQueueSize:0, callback:'multiupload.UploadManager.uploadCallback'}, config.uploadConfig);
  Ext.flash.Component.prototype.constructor.call(this, config);
}, initComponent:function() {
  multiupload.UploadManager.register(this);
  Ext.flash.Component.prototype.initComponent.apply(this, arguments);
}, onDestroy:function() {
  multiupload.UploadManager.unregister(this);
  Ext.flash.Component.prototype.onDestroy.apply(this, arguments);
}}, 1, ['uploader'], ['component', 'box', 'flash', 'uploader'], {'component':true, 'box':true, 'flash':true, 'uploader':true}, ['widget.uploader'], 0, [multiupload, 'Upload'], 0);
Ext.cmd.derive('multiupload.Panel', Ext.panel.Panel, {statics:{doUploaderCheck:function(callback, callbackScope) {
  if (Dropzone.isBrowserSupported()) {
    callback.call(callbackScope);
  } else {
    Ext.Loader.loadScript({url:'mds/lib/swfobject.js', onLoad:callback, scope:callbackScope});
  }
}}, layout:'fit', initComponent:function() {
  var me = this;
  if (Dropzone.isBrowserSupported()) {
    var uploadMessage = mvstr['FVCFD_Drop files here'];
    if (this.uploadConfig.hasOwnProperty('uploadMessage')) {
      uploadMessage = this.uploadConfig.uploadMessage;
    }
    var shareBtnHidden = false;
    if (this.uploadConfig.hasOwnProperty('hideShareButton') && this.uploadConfig.hideShareButton) {
      shareBtnHidden = this.uploadConfig.hideShareButton;
    }
    var addFilesLabel = mvstr['FVCFD_Add files'];
    if (this.uploadConfig.hasOwnProperty('addFilesLabel')) {
      addFilesLabel = this.uploadConfig.addFilesLabel;
    }
    var clearFilesLabel = mvstr['FVCFD_Clear files'];
    if (this.uploadConfig.hasOwnProperty('clearFilesLabel')) {
      clearFilesLabel = this.uploadConfig.clearFilesLabel;
    }
    me.tbar = [{xtype:'button', text:addFilesLabel, itemId:'dropzoneAddFilesBtn', icon:'mds/module/clientFileManager/image/icons/folder_new.png', cls:'dz-clickable'}, {xtype:'button', text:clearFilesLabel, itemId:'dropzoneClearFilesBtn', icon:'mds/module/clientFileManager/image/icons/delete.png', hidden:true}, '-\x3e', {xtype:'shareWithButton', reference:'uploadShareButton', itemId:'fileUploadShareWithButton', ownerUID:'multiupload', hidden:shareBtnHidden}];
    me.items = [{xtype:'component', itemId:'dropzoneUploadComponent', bodyPadding:20, cls:'dropzone dz-clickable dropzone-previews', autoScroll:true, html:'\x3cdiv class\x3d"dz-message"\x3e\x3cspan\x3e' + uploadMessage + '\x3c/span\x3e\x3c/div\x3e'}];
  } else {
    me.tbar = [{xtype:'uploader', uploadConfig:this.uploadConfig, listeners:{'fileadded':function(source, file) {
      me.child('#flashUploadPanel').store.add({id:file.fileIndex, name:file.fileName, size:file.fileSize, status:'waiting...', progress:0});
    }, 'uploadstart':function(source, file) {
      var grid = me.child('#flashUploadPanel');
      var record = grid.store.getById(file.fileIndex);
      if (record) {
        record.set('status', 'uploading...');
      }
    }, 'uploadprogress':function(source, file) {
      var grid = me.child('#flashUploadPanel');
      var record = grid.store.getById(file.fileIndex);
      if (record) {
        var p = Math.min(Math.round(file.fileProgress / file.fileSize * 100), 100);
        record.set('progress', p);
      }
    }, 'uploaddatacomplete':function(source, file) {
      var grid = me.child('#flashUploadPanel');
      var record = grid.store.getById(file.fileIndex);
      if (record) {
        record.set('status', 'completed');
      }
      me.fireEvent('fileuploadcomplete', file.data);
      me.fireEvent('fileUploadedAndAccepted', file.data);
    }, 'queuedatacomplete':function(source, data) {
      Ext.Msg.show({title:'Complete', msg:'Upload queue complete. ' + data.files + ' file(s) uploaded.', buttons:Ext.Msg.OK, icon:Ext.Msg.INFO});
    }, 'uploaderror':function(src, data) {
      var msg = 'ErrorType: ' + data.errorType;
      switch(data.errorType) {
        case 'FileSize':
          msg = 'This file is too big: ' + Ext.util.Format.fileSize(data.fileSize) + '. The maximum upload size is ' + Ext.util.Format.fileSize(data.maxFileSize) + '.';
          break;
        case 'QueueLength':
          msg = 'The maximum number of photos which can be uploaded in a single batch is ' + data.maxQueueLength + '. Please select fewer photos and try again.';
          break;
      }
      Ext.Msg.show({title:'Upload Error', msg:msg, buttons:Ext.Msg.OK, icon:Ext.Msg.ERROR});
    }}}, '-\x3e', {xtype:'shareWithButton', itemId:'fileUploadShareWithButton', ownerUID:'multiupload', hidden:shareBtnHidden}];
    me.items = [{xtype:'grid', itemId:'flashUploadPanel', viewConfig:{markDirty:false, selectedItemCls:''}, store:{fields:['id', 'name', 'size', 'status', 'progress']}, columns:[{header:'Name', dataIndex:'name', width:200}, {header:'Size', dataIndex:'size', renderer:Ext.util.Format.fileSize, flex:2}, {header:'Status', dataIndex:'status', flex:2}, {header:'Progress', dataIndex:'progress', renderer:function(v) {
      return v + '%';
    }, flex:2}]}];
  }
  Ext.panel.Panel.prototype.initComponent.apply(this, arguments);
}, listeners:{render:function() {
  var me = this;
  if (!Dropzone.isBrowserSupported()) {
    return;
  }
  var uploadUrl = this.uploadConfig.dropzoneUploadUrl;
  var acceptedFiles = this.uploadConfig.acceptedFiles;
  var maxFileSize = Math.round(this.uploadConfig.maxFileSize / 1048576);
  var maxFiles = this.uploadConfig.maxQueueLength;
  var uploadParams = {};
  if (this.uploadConfig.hasOwnProperty('uploadParams')) {
    uploadParams = this.uploadConfig.uploadParams;
  }
  var element = this.child('#dropzoneUploadComponent');
  var fileTypesMap = {doc:'doc', docx:'doc', xls:'xls', xlsx:'xls', ppt:'ppt', pptx:'ppt', mp4:'mp4', avi:'avi', mpg:'mpg', pdf:'pdf', zip:'zip', tar:'zip', gz:'zip', gif:'gif', png:'png', jpg:'jpg', jpeg:'jpg', tif:'tiff', tiff:'tiff', dwg:'dwg', dwf:'dwf', dxf:'dxf', rvt:'rvt', ifc:'ifc'};
  var dropzoneComponent = new Dropzone('#' + element.id, {url:uploadUrl, maxFilesize:maxFileSize, maxFiles:maxFiles, paramName:'Filedata', thumbnailHeight:128, thumbnailWidth:128, parallelUploads:10, timeout:this.uploadConfig.timeout || 600000, clickable:'.dz-clickable', acceptedFiles:acceptedFiles, uploadMultiple:false, createImageThumbnails:true, autoProcessQueue:true, dictFileTooBig:'This file is too big ({{filesize}}MB). The max filesize is {{maxFilesize}}MB.', dictResponseError:'There was an error uploading the file (status code {{statusCode}})', 
  previewTemplate:'\x3cdiv class\x3d"dz-preview dz-file-preview"\x3e\x3cdiv class\x3d"dz-image"\x3e\x3cimg data-dz-thumbnail /\x3e\x3c/div\x3e\x3cdiv class\x3d"dz-filetype none"\x3e\x3c/div\x3e\x3cdiv class\x3d"dz-details"\x3e\x3cdiv class\x3d"dz-size"\x3e\x3cspan data-dz-size\x3e\x3c/span\x3e\x3c/div\x3e\x3cdiv class\x3d"dz-filename"\x3e\x3cspan data-dz-name\x3e\x3c/span\x3e\x3c/div\x3e\x3c/div\x3e\x3cdiv class\x3d"dz-progress"\x3e\x3cspan class\x3d"dz-upload" data-dz-uploadprogress\x3e\x3c/span\x3e\x3c/div\x3e\x3cdiv class\x3d"dz-error-message"\x3e\x3cspan data-dz-errormessage\x3e\x3c/span\x3e\x3c/div\x3e\x3cdiv class\x3d"dz-success-mark"\x3e\x3csvg width\x3d"54px" height\x3d"54px" viewBox\x3d"0 0 54 54" version\x3d"1.1" xmlns\x3d"http://www.w3.org/2000/svg"\x3e\x3ctitle\x3eCheck\x3c/title\x3e\x3cg stroke\x3d"none" stroke-width\x3d"1" fill\x3d"none" fill-rule\x3d"evenodd"\x3e\x3cpath d\x3d"M23.5,31.8431458 L17.5852419,25.9283877 C16.0248253,24.3679711 13.4910294,24.366835 11.9289322,25.9289322 C10.3700136,27.4878508 10.3665912,30.0234455 11.9283877,31.5852419 L20.4147581,40.0716123 C20.5133999,40.1702541 20.6159315,40.2626649 20.7218615,40.3488435 C22.2835669,41.8725651 24.794234,41.8626202 26.3461564,40.3106978 L43.3106978,23.3461564 C44.8771021,21.7797521 44.8758057,19.2483887 43.3137085,17.6862915 C41.7547899,16.1273729 39.2176035,16.1255422 37.6538436,17.6893022 L23.5,31.8431458 Z M27,53 C41.3594035,53 53,41.3594035 53,27 C53,12.6405965 41.3594035,1 27,1 C12.6405965,1 1,12.6405965 1,27 C1,41.3594035 12.6405965,53 27,53 Z" stroke-opacity\x3d"0.2" stroke\x3d"#747474" fill-opacity\x3d"0.7" fill\x3d"#26BE26"\x3e\x3c/path\x3e\x3c/g\x3e\x3c/svg\x3e\x3c/div\x3e\x3cdiv class\x3d"dz-error-mark"\x3e\x3csvg width\x3d"54px" height\x3d"54px" viewBox\x3d"0 0 54 54" version\x3d"1.1" xmlns\x3d"http://www.w3.org/2000/svg"\x3e\x3ctitle\x3eError\x3c/title\x3e\x3cg stroke\x3d"none" stroke-width\x3d"1" fill\x3d"none" fill-rule\x3d"evenodd"\x3e\x3cg stroke\x3d"#747474" stroke-opacity\x3d"0.2" fill\x3d"#BE2626" fill-opacity\x3d"0.7"\x3e\x3cpath d\x3d"M32.6568542,29 L38.3106978,23.3461564 C39.8771021,21.7797521 39.8758057,19.2483887 38.3137085,17.6862915 C36.7547899,16.1273729 34.2176035,16.1255422 32.6538436,17.6893022 L27,23.3431458 L21.3461564,17.6893022 C19.7823965,16.1255422 17.2452101,16.1273729 15.6862915,17.6862915 C14.1241943,19.2483887 14.1228979,21.7797521 15.6893022,23.3461564 L21.3431458,29 L15.6893022,34.6538436 C14.1228979,36.2202479 14.1241943,38.7516113 15.6862915,40.3137085 C17.2452101,41.8726271 19.7823965,41.8744578 21.3461564,40.3106978 L27,34.6568542 L32.6538436,40.3106978 C34.2176035,41.8744578 36.7547899,41.8726271 38.3137085,40.3137085 C39.8758057,38.7516113 39.8771021,36.2202479 38.3106978,34.6538436 L32.6568542,29 Z M27,53 C41.3594035,53 53,41.3594035 53,27 C53,12.6405965 41.3594035,1 27,1 C12.6405965,1 1,12.6405965 1,27 C1,41.3594035 12.6405965,53 27,53 Z"\x3e\x3c/path\x3e\x3c/g\x3e\x3c/g\x3e\x3c/svg\x3e\x3c/div\x3e\x3c/div\x3e', 
  storageUsed:this.uploadConfig.storageUsed, storageQuota:this.uploadConfig.storageQuota});
  var clearBtn = this.down('#dropzoneClearFilesBtn');
  clearBtn.on('click', function() {
    dropzoneComponent.removeAllFiles();
    clearBtn.setHidden(true);
    me.fireEvent('clearfiles');
  });
  dropzoneComponent.on('addedfile', function(file) {
    clearBtn.setHidden(false);
    if (this.options.storageQuota !== undefined && this.options.storageUsed + file.size > this.options.storageQuota) {
      this.emit('error', file, 'Insufficient storage space');
      this.options.autoQueue = false;
      return;
    }
    this.options.autoQueue = true;
    var dot = file.name.lastIndexOf('.');
    if (dot != -1) {
      var fileExt = file.name.substr(dot + 1).toLowerCase();
      console.log('File ext: ' + fileExt + ', ' + fileTypesMap.hasOwnProperty(fileExt));
      if (fileTypesMap.hasOwnProperty(fileExt)) {
        var fileTypes = file.previewElement.querySelectorAll('.dz-filetype');
        if (fileTypes.length == 1) {
          fileTypes[0].classList.remove('none');
          fileTypes[0].classList.add(fileTypesMap[fileExt]);
        } else {
          console.log('File types: ' + fileTypes.length);
        }
      }
    }
  });
  dropzoneComponent.on('uploadprogress', function(o, progress, bytesSent) {
  });
  dropzoneComponent.on('sending', function(file, xhr, formData) {
    var data = Ext.apply({}, uploadParams);
    me.fireEvent('addUploadFormData', data, file);
    for (var key in data) {
      formData.append(key, data[key]);
    }
  });
  dropzoneComponent.on('success', function(file, response) {
    var success = true;
    if (response) {
      success = response.success;
    }
    if (success) {
      me.fireEvent('fileUploadedAndAccepted', response.data);
      this.options.storageUsed += file.size;
    } else {
      console.log('Upload failed: ' + response.message);
      file.status = Dropzone.ERROR;
      file.previewElement.classList.remove('dz-success');
      dropzoneComponent.emit('error', file, response.message, {});
    }
  });
  dropzoneComponent.on('error', function(file, msg, xhr) {
    console.log('Error uploading file ' + file.name + ': ' + msg);
    if (msg.length > 100) {
      msg = 'There was an error uploading the file.';
    }
    if (file.previewElement) {
      file.previewElement.classList.remove('dz-success');
      file.previewElement.classList.add('dz-error');
      var errorElements = file.previewElement.querySelectorAll('[data-dz-errormessage]');
      for (var i = 0; i < errorElements.length; i++) {
        errorElements[i].textContent = msg;
      }
    }
  });
  dropzoneComponent.handleFiles = function(files) {
    if (files.length > maxFiles) {
      Ext.Msg.show({title:'Upload Error', icon:Ext.Msg.ERROR, buttons:Ext.Msg.OK, message:'The maximum number of files which can be uploaded in a single batch is ' + maxFiles + '.\x3cbr\x3ePlease select fewer files and try again.'});
    } else {
      Dropzone.prototype.handleFiles.call(this, files);
    }
  };
  dropzoneComponent.addFile = function(file) {
    if (file.size == 0) {
      var msg = 'Uploading folders is not supported.';
      if (file.type) {
        msg = 'The file "' + file.name + '" is empty.';
      }
      Ext.Msg.show({title:'Upload Error', icon:Ext.Msg.ERROR, buttons:Ext.Msg.OK, message:msg});
    } else {
      Dropzone.prototype.addFile.call(this, file);
    }
  };
}, 'fileUploadedAndAccepted':function(fileData) {
  this.fireEvent('fileUploadCompleted', fileData);
}}}, 0, ['uploadPanel'], ['component', 'box', 'container', 'panel', 'uploadPanel'], {'component':true, 'box':true, 'container':true, 'panel':true, 'uploadPanel':true}, ['widget.uploadPanel'], 0, [multiupload, 'Panel'], 0);
Ext.cmd.derive('filters.view.Filters', Ext.view.View, {itemSelector:'div.filter', margin:'0 1 0 1', padding:'0 0 15 0', cls:'filters', config:{filterValueName:'FilterValue', filterLabelName:'FilterValue'}, initComponent:function() {
  this.tpl = new Ext.XTemplate('\x3ctpl for\x3d"."\x3e', '\x3cdiv class\x3d"filter"\x3e\x3cinput type\x3d"checkbox" \x3ctpl if\x3d"isSelected"\x3echecked\x3c/tpl\x3e onclick\x3d"return false;"\x3e\x3cdiv class\x3d"filter-name"\x3e{' + this.filterLabelName + '}\x3c/div\x3e\x3c/div\x3e', '\x3c/tpl\x3e');
  Ext.view.View.prototype.initComponent.apply(this, arguments);
}, clearSelected:function() {
  this.getStore().each(function(rec) {
    rec.set('isSelected', false);
  });
}, listeners:{itemclick:function(view, record, item) {
  record.set('isSelected', !record.get('isSelected'));
  if (record.get('isSelected')) {
    Ext.fly(item).addCls('selected');
  } else {
    Ext.fly(item).removeCls('selected');
  }
}}}, 0, ['filter'], ['component', 'box', 'dataview', 'filter'], {'component':true, 'box':true, 'dataview':true, 'filter':true}, ['widget.filter'], 0, [filters.view, 'Filters'], 0);
Ext.cmd.derive('filters.view.FiltersPane', Ext.Container, {cls:'filters-pane', padding:'40 10 0 10', width:224}, 0, 0, ['component', 'box', 'container'], {'component':true, 'box':true, 'container':true}, 0, 0, [filters.view, 'FiltersPane'], 0);
Ext.cmd.derive('clientPunchlist.model.Assignee', Ext.data.Model, {fields:[{name:'PunchlistCustomAssigneeID', type:'int'}, {name:'AssigneeFirstName', type:'string'}, {name:'AssigneeLastName', type:'string'}, {name:'AssigneeEmail', type:'string'}, {name:'MemberUID', type:'string'}, {name:'IsDefault', type:'int'}, {name:'IsOwner', type:'int', defaultValue:0}, {name:'NoAccess', type:'boolean'}, {name:'FilterValue', mapping:function(data) {
  return Ext.String.trim(data.AssigneeFirstName + ' ' + data.AssigneeLastName);
}}, {name:'AssigneeID', type:'string'}, {name:'Assignee', type:'string', calculate:function(data) {
  return Ext.String.trim(data.AssigneeFirstName + ' ' + data.AssigneeLastName);
}}, {name:'IsAssignee', type:'boolean', defaultValue:'false'}, {name:'InUse', type:'boolean', defaultValue:false}, {name:'CanDelete', type:'boolean', calculate:function(data) {
  return data.IsOwner && !data.InUse;
}}], idProperty:'AssigneeID', clientIdProperty:'AssigneeID'}, 0, 0, 0, 0, 0, 0, [clientPunchlist.model, 'Assignee'], 0);
Ext.cmd.derive('clientPunchlist.values.FixMemberAccess', Ext.Base, {singleton:true, activeUserNoAccessTitle:"You don't have permissions to access this {ListTypeName}", activeUserNoAccessExplanation1:'You do not currently have permission to access this task list. You are still assigned the task but unable to access it.', activeUserNoAccessExplanation2:'Contact your Multivista Project Implementation Specialist or send a request to Multivista support to change these permissions.', activeUserNoAccessPostTitle:'Your request has been sent!', 
activeUserNoAccessPostExplanation:'Your permissions request has been sent and you should be able to access your {listTypeDesc} shortly. You will be notified when your permissions have been changed.', otherUserNoAccessTitleLong:'Request Permissions Change for {MemberName}', otherUserNoAccessTitleShort:'Request Permissions Change', otherUserNoAccessExplanation1:'This user does not currently have permission to access this task list. You can assign the task to them and they will be notified of the assignment but unable to access it.', 
otherUserNoAccessExplanation2:'You can click here to send a request to Multivista support to change these permissions', otherUserNoAccessPostTitle:'Your Request has been Sent', otherUserNoAccessPostExplanation:'A request has been sent to Multivista Support to change the permissions for this user. Return to the list item by clicking the done button below.'}, 0, 0, 0, 0, 0, 0, [clientPunchlist.values, 'FixMemberAccess'], 0);
Ext.cmd.derive('clientPunchlist.view.fixMemberAccess.WindowController', Ext.app.ViewController, {closeWindow:function() {
  this.getView().destroy();
}, sendRequest:function() {
  this.getViewModel().set('maskMessage', mvstr['TLNA_Sending Request...']);
  Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daClientPunchlist.requestPermissions', params:{ProjectUID:this.getViewModel().get('ProjectUID'), MemberUID:this.getViewModel().get('MemberUID')}, successCallback:function() {
    this.getViewModel().set('step', 1);
    this.getViewModel().set('maskMessage', '');
  }, failure:function() {
    this.getViewModel().set('maskMessage', '');
  }, scope:this});
}}, 0, 0, 0, 0, ['controller.fixmemberaccesswindow'], 0, [clientPunchlist.view.fixMemberAccess, 'WindowController'], 0);
Ext.cmd.derive('clientPunchlist.view.fixMemberAccess.WindowModel', Ext.app.ViewModel, {data:{step:0, maskMessage:''}}, 0, 0, 0, 0, ['viewmodel.fixmemberaccesswindow'], 0, [clientPunchlist.view.fixMemberAccess, 'WindowModel'], 0);
Ext.cmd.derive('clientPunchlist.model.Base', Ext.data.Model, {schema:{id:'clientPunchlist', namespace:'clientPunchlist.model'}}, 0, 0, 0, 0, 0, 0, [clientPunchlist.model, 'Base'], 0);
Ext.cmd.derive('clientPunchlist.model.Follower', Ext.data.Model, {idProperty:'MemberUID', fields:[{name:'MemberUID', type:'string'}, {name:'IsCreator', type:'boolean', persist:false}, {name:'IsSubscriber', type:'boolean', persist:true}, {name:'IsAssignee', type:'boolean', persist:false}, {name:'IsFollower', type:'boolean', calculate:function(data) {
  return !!(data.IsCreator || data.IsSubscriber || data.IsAssignee);
}}, {name:'NoAccess', type:'boolean'}, {name:'MemberFirstName', type:'string', persist:false}, {name:'MemberLastName', type:'string', persist:false}, {name:'MemberName', type:'string', persist:false, calculate:function(data) {
  return Ext.String.trim((data.MemberFirstName ? data.MemberFirstName : '') + ' ' + (data.MemberLastName ? data.MemberLastName : ''));
}}]}, 0, 0, 0, 0, 0, 0, [clientPunchlist.model, 'Follower'], 0);
Ext.cmd.derive('clientPunchlist.model.PunchItem', clientPunchlist.model.Base, {fields:[{name:'ProjectUID', type:'string'}, {name:'PunchStatusID', type:'int', defaultValue:mdsData.PunchlistValues.PUNCH_STATUS.OPEN}, {name:'PunchStatusLabel', persist:false, calculate:function(data) {
  return mvstr['TLIS_' + data.PunchStatusID];
}}, {name:'WorkStatusID', type:'int', persist:true, defaultValue:mdsData.PunchlistValues.WORK_STATUS.NOT_STARTED}, {name:'WorkStatusLabel', persist:false, calculate:function(data) {
  return mvstr['TLWS_' + data.WorkStatusID];
}}, {name:'PunchlistCategoryID', type:'int'}, {name:'CategoryLabel', type:'string', persist:false, depends:'PunchlistCategoryID', convert:function(value, record) {
  var translationID = 'TLC_' + record.get('PunchlistCategoryID');
  return mvstr[translationID] || value;
}}, {name:'Description', type:'string'}, {name:'LocationDetail', type:'string'}, {name:'DueDate', type:'date', dateFormat:'Y-m-d'}, {name:'ExternalIDString', type:'string'}, {name:'ShareTypeID', type:'int'}, {name:'PunchPinCount', type:'int'}, {name:'PunchPins'}, {name:'PunchlistPlans', persist:false}, {name:'CreatorName', type:'string', persist:false, mapping:function(data) {
  return Ext.String.trim(data.CreatorFirstName + ' ' + data.CreatorLastName);
}}, {name:'CompletionDate', type:'date', persist:false}, {name:'DocumentCount'}, {name:'PhotoCount'}, {name:'CreationDate', type:'date', persist:false}, {name:'LastEditorFirstName'}, {name:'LastEditorLastName'}, {name:'LastEditorName', persist:false, mapping:function(data) {
  return Ext.String.trim(data.LastEditorFirstName + ' ' + data.LastEditorLastName);
}}, {name:'LastEditedDate', type:'date', persist:false}, {name:'ListTypeID'}, {name:'CategoryAbbreviation', type:'string'}, {name:'CategoryAbbreviationOrCategory', type:'string', calculate:function(data) {
  return data.CategoryAbbreviation ? data.CategoryAbbreviation : data.CategoryLabel;
}}, {name:'IsOwner', type:'boolean'}, {name:'IsAssignee', type:'boolean'}, {name:'IsSubscriber', type:'boolean'}, {name:'IsFollower', calculate:function(data) {
  return data.IsOwner || data.IsAssignee || data.IsSubscriber;
}}, {name:'DueDateDescription', calculate:function(data) {
  var today = new Date, dueDate = data.DueDate, punchStatusID = data.PunchStatusID;
  if (!mdsData.PunchlistValues.isOverdue({DueDate:dueDate, PunchStatusID:punchStatusID})) {
    return Ext.Date.format(data.DueDate, 'M j, Y');
  }
  var nDays = Ext.Date.diff(data.DueDate, today, Ext.Date.DAY);
  return nDays + ' Day' + (nDays == 1 ? '' : 's') + ' OVERDUE';
}}, {name:'PlanList', calculate:function(data) {
  var plans = data.PunchlistPlans, labels = [];
  if (!plans) {
    return '';
  }
  for (var i = 0; i < plans.length; i++) {
    var desc = plans[i].PunchlistPlanDescription;
    if (desc) {
      labels.push(desc);
    }
  }
  return labels.join(', ');
}}, {name:'PunchlistPlanUIDs', persist:true, calculate:function(data) {
  var uids = [];
  if (!data.PunchlistPlans) {
    return uids;
  }
  for (var i = 0; i < data.PunchlistPlans.length; i++) {
    uids.push(data.PunchlistPlans[i].PunchlistPlanUID);
  }
  return uids;
}}, {name:'PushpinSymbol', persist:false, calculate:function(data) {
  var PunchStatusID = data.PunchStatusID, WorkStatusID = data.WorkStatusID;
  if (PunchStatusID == mdsData.PunchlistValues.PUNCH_STATUS.CLOSED) {
    return 'mds/image/clientFloorplanViewer/punchpin-5.png';
  } else {
    if (mdsData.PunchlistValues.isOverdue({DueDate:data.DueDate, PunchStatusID:data.PunchStatusID})) {
      return 'mds/image/clientFloorplanViewer/punchpin-6.png';
    }
    if (WorkStatusID == mdsData.PunchlistValues.WORK_STATUS.NOT_STARTED) {
      return 'mds/image/clientFloorplanViewer/punchpin-1.png';
    } else {
      if (WorkStatusID == mdsData.PunchlistValues.WORK_STATUS.IN_PROGRESS) {
        return 'mds/image/clientFloorplanViewer/punchpin-2.png';
      } else {
        if (WorkStatusID == mdsData.PunchlistValues.WORK_STATUS.COMPLETE) {
          return 'mds/image/clientFloorplanViewer/punchpin-3.png';
        } else {
          return 'mds/image/clientFloorplanViewer/punchpin-4.png';
        }
      }
    }
  }
}}, {name:'Assignees', persist:true, defaultValue:[]}, {name:'AssigneeList', type:'string', persist:false, calculate:function(data) {
  var assignees = data.Assignees, names = [];
  for (var i = 0; i < assignees.length; i++) {
    names.push(Ext.String.trim(assignees[i].AssigneeFirstName + ' ' + assignees[i].AssigneeLastName));
  }
  return names.join(', ');
}}, {name:'PrevPunchItemID', type:'int'}, {name:'NextPunchItemID', type:'int'}, {name:'CommentCount', persist:false}], idProperty:'PunchItemID', clientIdProperty:'id', proxy:{type:'ajax', writer:{type:'json', writeAllFields:false}, reader:{type:'json', rootProperty:'data'}, api:{read:'/index.cfm?fuseaction\x3daClientPunchlist.getProjectPunchItems', create:'/index.cfm?fuseaction\x3daClientPunchlist.createPunchItem', update:'/index.cfm?fuseaction\x3daClientPunchlist.updatePunchItem'}}, validators:{PunchlistCategoryID:{type:'range', 
min:1}, Description:{type:'presence'}}}, 0, 0, 0, 0, 0, 0, [clientPunchlist.model, 'PunchItem'], 0);
Ext.cmd.derive('clientPunchlist.model.PunchStatus', Ext.data.Model, {fields:['PunchStatusID', 'Label', {name:'FilterValue', calculate:function(data) {
  return data.Label;
}}]}, 0, 0, 0, 0, 0, 0, [clientPunchlist.model, 'PunchStatus'], 0);
Ext.cmd.derive('clientPunchlist.model.PunchlistCategory', Ext.data.Model, {fields:[{name:'PunchlistCategoryID', type:'int'}, {name:'CategoryLabel', type:'string', convert:function(value, record) {
  var translationID = 'TLC_' + record.get('PunchlistCategoryID');
  return mvstr[translationID] || value;
}}, {name:'CategoryAbbreviation', type:'string'}, {name:'InUse', type:'boolean'}], idProperty:'PunchlistCategoryID', clientIdProperty:'id'}, 0, 0, 0, 0, 0, 0, [clientPunchlist.model, 'PunchlistCategory'], 0);
Ext.cmd.derive('clientPunchlist.model.WorkStatus', Ext.data.Model, {fields:['WorkStatusID', 'Label', {name:'FilterValue', calculate:function(data) {
  return data.Label;
}}]}, 0, 0, 0, 0, 0, 0, [clientPunchlist.model, 'WorkStatus'], 0);
Ext.cmd.derive('clientPunchlist.store.PunchItems', Ext.data.Store, {model:'clientPunchlist.model.PunchItem', proxy:{url:'/index.cfm?fuseaction\x3daClientPunchlist.getProjectPunchItems'}}, 0, 0, 0, 0, ['store.punchitems'], 0, [clientPunchlist.store, 'PunchItems'], 0);
Ext.cmd.derive('clientPunchlist.store.PunchStatus', Ext.data.Store, {proxy:{type:'memory'}, constructor:function() {
  this.config.data = [{PunchStatusID:mdsData.PunchlistValues.PUNCH_STATUS.OPEN, Label:mvstr['TLIS_' + mdsData.PunchlistValues.PUNCH_STATUS.OPEN]}, {PunchStatusID:mdsData.PunchlistValues.PUNCH_STATUS.CLOSED, Label:mvstr['TLIS_' + mdsData.PunchlistValues.PUNCH_STATUS.CLOSED]}, {PunchStatusID:mdsData.PunchlistValues.PUNCH_STATUS.ON_HOLD, Label:mvstr['TLIS_' + mdsData.PunchlistValues.PUNCH_STATUS.ON_HOLD]}];
  Ext.data.Store.prototype.constructor.apply(this, arguments);
}}, 1, 0, 0, 0, ['store.punchstatus'], 0, [clientPunchlist.store, 'PunchStatus'], 0);
Ext.cmd.derive('clientPunchlist.store.WorkStatus', Ext.data.Store, {proxy:{type:'memory'}, constructor:function() {
  this.config.data = [{WorkStatusID:mdsData.PunchlistValues.WORK_STATUS.ON_HOLD, Label:mvstr['TLWS_' + mdsData.PunchlistValues.WORK_STATUS.ON_HOLD]}, {WorkStatusID:mdsData.PunchlistValues.WORK_STATUS.NOT_STARTED, Label:mvstr['TLWS_' + mdsData.PunchlistValues.WORK_STATUS.NOT_STARTED]}, {WorkStatusID:mdsData.PunchlistValues.WORK_STATUS.IN_PROGRESS, Label:mvstr['TLWS_' + mdsData.PunchlistValues.WORK_STATUS.IN_PROGRESS]}, {WorkStatusID:mdsData.PunchlistValues.WORK_STATUS.COMPLETE, Label:mvstr['TLWS_' + 
  mdsData.PunchlistValues.WORK_STATUS.COMPLETE]}];
  Ext.data.Store.prototype.constructor.apply(this, arguments);
}}, 1, 0, 0, 0, ['store.workstatus'], 0, [clientPunchlist.store, 'WorkStatus'], 0);
Ext.cmd.derive('clientPunchlist.view.CloneConfirmationWindow', Ext.window.Window, {height:300, width:390, title:'Duplicate Confirmation', modal:true, resizable:false, layout:{type:'vbox', align:'center'}, defaults:{width:'100%'}, config:{saveArgs:[]}, items:[{xtype:'label', flex:2, padding:20, text:'Would you like to include the photos, pins, and files in the duplicated item about to be created?'}, {xtype:'fieldcontainer', labelAlign:'top', flex:3, margin:'20 60 0 60', fieldLabel:'Include', layout:{type:'hbox', 
pack:'center'}, defaults:{xtype:'checkbox', ui:'plain-21', flex:1}, items:[{boxLabel:'Photos', itemId:'includePhotos', bind:{value:{bindTo:'{tasklistSetting_includePhotos}', single:true}}}, {boxLabel:'Pins', itemId:'includePins', bind:{value:{bindTo:'{tasklistSetting_includePins}', single:true}}}, {boxLabel:'Files', itemId:'includeFiles', bind:{value:{bindTo:'{tasklistSetting_includeFiles}', single:true}}}]}], fbar:['-\x3e', {xtype:'button', scale:'medium', ui:'grey', text:'Cancel', margin:'0 20 0 0', 
handler:function(button) {
  button.up('cloneConfirmationWindow').close();
}}, {xtype:'button', scale:'medium', ui:'green', text:'Duplicate', listeners:{click:'onCloneConfirm'}}, '-\x3e']}, 0, ['cloneConfirmationWindow'], ['component', 'box', 'container', 'panel', 'window', 'cloneConfirmationWindow'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true, 'cloneConfirmationWindow':true}, ['widget.cloneConfirmationWindow'], 0, [clientPunchlist.view, 'CloneConfirmationWindow'], 0);
Ext.cmd.derive('clientPunchlist.view.ItemActionMenu', Ext.menu.Menu, {plain:true, items:[{text:'Print', hidden:true, bind:{hidden:'{unsaved}'}, handler:'printPunchItem'}, {text:'Delete', hidden:true, bind:{hidden:'{!editingOwnExisting}'}, handler:'deletePunchItem'}, {localized:{text:'TL_Follow list'}, hidden:true, bind:{hidden:'{!followControlsVisible}'}, handler:'showFollowers'}]}, 0, ['itemActionMenu'], ['component', 'box', 'container', 'panel', 'menu', 'itemActionMenu'], {'component':true, 'box':true, 
'container':true, 'panel':true, 'menu':true, 'itemActionMenu':true}, ['widget.itemActionMenu'], 0, [clientPunchlist.view, 'ItemActionMenu'], 0);
Ext.cmd.derive('clientPunchlist.view.PunchItemFilters', filters.view.FiltersPane, {reference:'punchItemFilters', layout:{type:'vbox', align:'stretch'}, width:203, items:[{xtype:'container', layout:{type:'hbox'}, items:[{xtype:'component', localized:{html:'TLLFP_Filters'}, cls:'title'}, {xtype:'component', flex:1}, {xtype:'component', reference:'clearFilters', cls:'clear', localized:{html:'TLLFP_Clear All'}, listeners:{click:'onClearFiltersClick', element:'el'}}]}, {xtype:'container', cls:'filters-pane-inner', 
layout:{type:'vbox', align:'stretch'}, scrollable:{x:false, y:'auto'}, items:[{xtype:'component', cls:'title', localized:{html:'TLLFP_Category'}}, {xtype:'filter', bind:{store:'{categories}'}, listeners:{'itemclick':'updateFilter'}, reference:'categoryFilters', localized:{title:'TLLFP_Category'}, filterValueName:'PunchlistCategoryID', filterLabelName:'CategoryLabel'}, {xtype:'component', cls:'title', localized:{html:'TLLFP_Work Status'}}, {xtype:'filter', listeners:{'itemclick':'updateFilter'}, reference:'workStatusFilters', 
localized:{title:'TLLFP_Work Status'}, bind:{store:'{workstatus}'}, filterValueName:'WorkStatusID', filterLabelName:'Label'}, {xtype:'component', cls:'title', localized:{html:'TLLFP_Item Status'}, bind:{hidden:'{ClosedView}'}}, {xtype:'filter', listeners:{'itemclick':'updateFilter'}, reference:'statusFilters', localized:{title:'TLLFP_Item Status'}, bind:{store:'{punchstatus}', hidden:'{ClosedView}'}, filterValueName:'PunchStatusID', filterLabelName:'Label'}, {xtype:'component', cls:'title', localized:{html:'TLLFP_Assignee'}}, 
{xtype:'filter', bind:{store:'{assignees}'}, listeners:{'itemclick':'updateFilter'}, reference:'assigneeFilters', localized:{title:'TLLFP_Assignee'}, filterValueName:'AssigneeID'}]}]}, 0, ['punchitemfilters'], ['component', 'box', 'container', 'punchitemfilters'], {'component':true, 'box':true, 'container':true, 'punchitemfilters':true}, ['widget.punchitemfilters'], 0, [clientPunchlist.view, 'PunchItemFilters'], 0);
Ext.cmd.derive('clientPunchlist.view.fixMemberAccess.InfoColumn', Ext.grid.column.Action, {cls:'no-access-info-col', tdCls:'no-access-info', icon:'/mds/image/icon/info.png', localized:{tooltip:'TLNA_otherUserNoAccessExplanation'}, width:18}, 0, ['fixmemberaccessinfocolumn'], ['component', 'box', 'container', 'headercontainer', 'gridcolumn', 'actioncolumn', 'fixmemberaccessinfocolumn'], {'component':true, 'box':true, 'container':true, 'headercontainer':true, 'gridcolumn':true, 'actioncolumn':true, 
'fixmemberaccessinfocolumn':true}, ['widget.fixmemberaccessinfocolumn'], 0, [clientPunchlist.view.fixMemberAccess, 'InfoColumn'], 0);
Ext.cmd.derive('clientPunchlist.view.fixMemberAccess.Window', Ext.Window, {cls:'fix-member-access-prompt', width:700, minHeight:300, modal:true, closable:true, localized:{title:'TL_Send Permission Chang'}, layout:{type:'card'}, controller:'fixmemberaccesswindow', viewModel:{type:'fixmemberaccesswindow'}, bind:{activeItem:'{step}'}, constructor:function() {
  var me = this;
  me.items = [{xtype:'container', cls:'inner-container', padding:50, layout:{type:'vbox', align:'center'}, setMaskMessage:function(msg) {
    msg ? this.mask(msg) : this.unmask();
  }, bind:{maskMessage:'{maskMessage}'}, items:[{xtype:'label', bind:mvstr['TLNA_otherUserNoAccessTitleLong'], cls:'title', width:'100%'}, {xtype:'label', width:565, margin:'25 0 25 0', cls:'explanation', html:mvstr['TLNA_otherUserNoAccessExplanation']}, {xtype:'container', layout:{type:'hbox', align:'center'}, margin:'10 0 0 0', items:[{xtype:'button', text:'Cancel', ui:'grey', scale:'large', width:130, height:36, margin:'0 12 0 12', listeners:{click:'closeWindow'}}, {xtype:'button', text:mvstr['TLNA_Send Request'], 
  ui:'orange', scale:'large', width:130, height:36, margin:'0 12 0 12', listeners:{click:'sendRequest'}}]}]}, {xtype:'container', cls:'inner-container', padding:50, layout:{type:'vbox', align:'center'}, items:[{xtype:'label', text:mvstr['TLNA_noAccessPostTitle'], cls:'title', width:'100%'}, {xtype:'label', width:565, cls:'explanation', margin:'25 0 25 0', text:mvstr['TLNA_otherUserNoAccessPostExplanation']}, {xtype:'container', margin:'10 0 0 0', layout:{type:'hbox', align:'center'}, items:[{xtype:'button', 
  text:mvstr['G_Done'], ui:'orange', scale:'large', width:130, height:36, listeners:{click:'closeWindow'}}]}]}];
  Ext.window.Window.prototype.constructor.apply(this, arguments);
}}, 1, ['fixmemberaccessbuttonwindow'], ['component', 'box', 'container', 'panel', 'window', 'fixmemberaccessbuttonwindow'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true, 'fixmemberaccessbuttonwindow':true}, ['widget.fixmemberaccessbuttonwindow'], 0, [clientPunchlist.view.fixMemberAccess, 'Window'], 0);
Ext.cmd.derive('clientPunchlist.view.fixMemberAccess.Button', Ext.Button, {config:{MemberUID:null}, defaultBindProperty:'MemberUID', localized:{text:'TL_Fix'}, width:25, height:18, margin:'1 0 0 0', listeners:{click:function() {
  var record = this.up('grid').getStore().findRecord('MemberUID', this.getMemberUID());
  this.lookupController().getView().add({xtype:'fixmemberaccessbuttonwindow', viewModel:{data:{MemberName:record.get('Assignee') || Ext.String.trim(record.get('MemberFirstName') + ' ' + record.get('MemberLastName')), MemberUID:record.get('MemberUID')}}}).show();
}}}, 0, ['fixmemberaccessbutton'], ['component', 'box', 'button', 'fixmemberaccessbutton'], {'component':true, 'box':true, 'button':true, 'fixmemberaccessbutton':true}, ['widget.fixmemberaccessbutton'], 0, [clientPunchlist.view.fixMemberAccess, 'Button'], 0);
Ext.cmd.derive('clientPunchlist.view.fixMemberAccess.ButtonColumn', Ext.grid.column.Widget, {tdCls:'no-access-fix', width:40, dataIndex:'MemberUID', menuDisabled:true, focusCls:'', hoverCls:'', widget:{xtype:'fixmemberaccessbutton', ui:'orange', scale:'small'}}, 0, ['fixmemberaccessbuttoncolumn'], ['component', 'box', 'container', 'headercontainer', 'gridcolumn', 'widgetcolumn', 'fixmemberaccessbuttoncolumn'], {'component':true, 'box':true, 'container':true, 'headercontainer':true, 'gridcolumn':true, 
'widgetcolumn':true, 'fixmemberaccessbuttoncolumn':true}, ['widget.fixmemberaccessbuttoncolumn'], 0, [clientPunchlist.view.fixMemberAccess, 'ButtonColumn'], 0);
Ext.cmd.derive('clientPunchlist.view.PunchItemFollowers', Ext.menu.Menu, {cls:'follower-list', items:[{maxHeight:300, width:400, localized:{title:'TL_Follow list'}, xtype:'gridpanel', ui:'detail-popup', cls:'tasklist-member-grid', disableSelection:true, bind:{store:'{followers}'}, hideHeaders:true, columns:[{xtype:'checkcolumn', dataIndex:'IsFollower', width:50, listeners:{checkchange:function(checkcolumn, i, value, record) {
  record.set('IsSubscriber', value);
}}}, {dataIndex:'MemberName', flex:1}, {xtype:'fixmemberaccessinfocolumn'}, {xtype:'fixmemberaccessbuttoncolumn'}], tbar:[{xtype:'component', localized:{html:"TL_Select users you'd li"}}], viewConfig:{getRowClass:function(record) {
  var classes = [];
  if (record.get('IsAssignee')) {
    classes.push('disabled-row assignee');
  } else {
    if (record.get('IsCreator')) {
      classes.push('disabled-row creator');
    }
  }
  if (record.get('NoAccess')) {
    classes.push('no-access');
  }
  return classes.join(' ');
}}}], listeners:{show:function(menu) {
  menu.showBy(menu.up('button'), 'bl', [-320, 5]);
}}}, 0, ['punchItemFollowers'], ['component', 'box', 'container', 'panel', 'menu', 'punchItemFollowers'], {'component':true, 'box':true, 'container':true, 'panel':true, 'menu':true, 'punchItemFollowers':true}, ['widget.punchItemFollowers'], 0, [clientPunchlist.view, 'PunchItemFollowers'], 0);
Ext.cmd.derive('clientPunchlist.view.assignee.ChooseAssigneeWindow', Ext.window.Window, {modal:true, resizable:true, layout:'fit', height:300, width:700, searchField:null, initComponent:function() {
  var me = this, assignees = this.lookupViewModel().get('assignees');
  me.setBind({'title':mvstr['TL_Assign {ListItemDesc}']});
  Ext.applyIf(me, {items:[{xtype:'gridpanel', ui:'detail-popup', cls:'tasklist-member-grid', reference:'chooseAssigneeGrid', store:me.store, alias:'assignee', sortOnLoad:true, rowLines:true, plugins:{ptype:'manualediting', pluginId:'manualEditing'}, bind:{selection:'{assigneeSelection}'}, selModel:{selType:'rowmodel', mode:'SIMPLE', allowDeselect:true, onNavigate:Ext.emptyFn}, viewConfig:{selectedCls:'', markDirty:false, getRowClass:function(record) {
    return record.get('IsDefault') && record.get('NoAccess') ? 'no-access' : '';
  }}, columns:{defaults:{menuDisabled:true}, items:[{xtype:'checkcolumn', localized:{text:'TL_Assign'}, dataIndex:'IsAssignee', width:50}, {localized:{text:'TL_First Name'}, dataIndex:'AssigneeFirstName', flex:2, editor:{xtype:'textfield', allowBlank:false}, renderer:function(value, cell, data) {
    value = Ext.String.htmlEncode(value);
    return data.get('IsDefault') ? data.get('NoAccess') ? value + ' (lacks permissions)' : value : value + "\x3cspan class\x3d'custom-assignee'\x3e(" + mvstr['TL_Custom'] + ')\x3c/span\x3e';
  }}, {localized:{text:'TL_Last Name'}, editor:{xtype:'textfield', allowBlank:true}, formatter:'htmlEncode', dataIndex:'AssigneeLastName', flex:2}, {localized:{text:'TL_Email'}, editor:{xtype:'textfield', allowBlank:true, inputType:'email'}, formatter:'htmlEncode', dataIndex:'AssigneeEmail', flex:3}, {text:'', tdCls:'x-action-col-cell edit-cell', cls:'edit-col', dataIndex:'IsOwner', align:'center', renderer:function(value) {
    return value ? 'g' : '';
  }, width:22}, {text:'', tdCls:'x-action-col-cell delete-cell', cls:'delete-col', dataIndex:'CanDelete', align:'center', renderer:function(value) {
    return value ? 'X' : '';
  }, width:22}, {xtype:'fixmemberaccessinfocolumn'}, {xtype:'fixmemberaccessbuttoncolumn'}]}, listeners:{cellclick:'cellClick', selectionchange:function(grid, selection) {
    var store = grid.getStore();
    store.each(function(assignee) {
      for (var i = 0; i < selection.length; i++) {
        if (selection[i].getId() == assignee.getId()) {
          assignee.set('IsAssignee', true);
          return;
        }
      }
      assignee.set('IsAssignee', false);
    });
  }, render:{fn:function(grid) {
    grid.searchField = Ext.create('formShared.view.components.SearchField', {ui:'searchfield2', renderTo:grid.el.select('.x-grid-header-ct').elements[0], localized:{emptyText:'TL_Find an Assignee...'}, style:{position:'absolute', top:'3px', right:'3px'}, listeners:{search:function(value) {
      var store = grid.getStore(), matcher = Ext.String.createRegex(value, false, false, true);
      store.clearFilter();
      store.setFilters([{filterFn:function(rec) {
        return matcher.test(rec.get('AssigneeFirstName')) || matcher.test(rec.get('AssigneeLastName')) || matcher.test(rec.get('AssigneeEmail'));
      }}]);
    }, clearsearch:function() {
      var searchField = grid.searchField;
      if (searchField.getValue()) {
        searchField.setValue('');
        return;
      }
      var store = grid.getStore();
      store.clearFilter();
    }}});
  }, single:true}, destroy:function(grid) {
    grid.searchField.destroy();
  }}}]});
  Ext.window.Window.prototype.initComponent.apply(this, arguments);
}, bbar:{padding:'5 5 8 5', items:[{xtype:'button', localized:{text:'TL_Create Custom'}, ui:'orange', height:31, scale:'medium', listeners:{click:'customAssignee'}}, '-\x3e', {xtype:'button', ui:'green', localized:{text:'G_Done'}, height:31, scale:'medium', listeners:{click:'onChooseAssigneesDone'}}]}}, 0, ['chooseAssigneeWindow'], ['component', 'box', 'container', 'panel', 'window', 'chooseAssigneeWindow'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true, 'chooseAssigneeWindow':true}, 
['widget.chooseAssigneeWindow'], 0, [clientPunchlist.view.assignee, 'ChooseAssigneeWindow'], 0);
Ext.cmd.derive('clientPunchlist.view.assignee.CustomAssigneeWindow', Ext.window.Window, {localized:{title:'TL_Create Custom Assigne'}, modal:true, resizable:true, layout:'fit', height:200, width:300, initComponent:function() {
  var me = this;
  Ext.applyIf(me, {items:[{xtype:'container', style:'background-color: white', layout:{type:'vbox', pack:'center', align:'middle'}, defaults:{labelWidth:70, width:250}, items:[{xtype:'textfield', localized:{fieldLabel:'TL_First Name'}, alias:'customFirst', margin:'10 0 5 0'}, {xtype:'textfield', localized:{fieldLabel:'TL_Last Name'}, alias:'customLast', emptyText:'(optional)'}, {xtype:'textfield', localized:{fieldLabel:'TL_Email'}, alias:'customEmail', emptyText:'(optional)'}, {xtype:'container', 
  flex:1}]}]});
  Ext.window.Window.prototype.initComponent.apply(this, arguments);
}, bbar:{padding:'5 5 8 5', items:[{xtype:'button', localized:{text:'TL_Cancel'}, scale:'medium', ui:'grey', height:31, listeners:{click:function() {
  Ext.ComponentQuery.query('customAssigneeWindow')[0].destroy();
}}}, '-\x3e', {xtype:'button', scale:'medium', localized:{text:'TL_Done'}, ui:'green', height:31, listeners:{click:'saveCustomAssignee'}}]}}, 0, ['customAssigneeWindow'], ['component', 'box', 'container', 'panel', 'window', 'customAssigneeWindow'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true, 'customAssigneeWindow':true}, ['widget.customAssigneeWindow'], 0, [clientPunchlist.view.assignee, 'CustomAssigneeWindow'], 0);
Ext.cmd.derive('clientPunchlist.view.assignee.assigneefield.AssigneeFieldController', Ext.app.ViewController, {}, 0, 0, 0, 0, ['controller.assigneefield'], 0, [clientPunchlist.view.assignee.assigneefield, 'AssigneeFieldController'], 0);
Ext.cmd.derive('clientPunchlist.view.assignee.assigneefield.AssigneeFieldModel', Ext.app.ViewModel, {}, 0, 0, 0, 0, ['viewmodel.assigneefield'], 0, [clientPunchlist.view.assignee.assigneefield, 'AssigneeFieldModel'], 0);
Ext.cmd.derive('clientPunchlist.view.assignee.assigneefield.AssigneeField', formShared.view.components.MultiSelect, {localized:{title:'TL_Assignees'}, displayField:'Assignee', valueField:'AssigneeID', bind:{readOnly:'{!canEdit}'}, viewConfig:{bind:{store:'{assigneeCollection}'}}, listeners:{onaddclick:'selectAssignee', removerecord:'deselectAssignee'}}, 0, ['assigneefield'], ['component', 'box', 'container', 'multiselect', 'assigneefield'], {'component':true, 'box':true, 'container':true, 'multiselect':true, 
'assigneefield':true}, ['widget.assigneefield'], 0, [clientPunchlist.view.assignee.assigneefield, 'AssigneeField'], 0);
Ext.cmd.derive('clientPunchlist.view.category.ChooseCategoryAbbrevField', Ext.form.field.Text, {width:33, maxLength:2, enforceMaxLength:true, hidden:true, ui:'category-select', bind:{hidden:'{!editing}', value:'{record.CategoryAbbreviation}'}}, 0, ['choosecategoryabbrevfield'], ['component', 'box', 'field', 'textfield', 'choosecategoryabbrevfield'], {'component':true, 'box':true, 'field':true, 'textfield':true, 'choosecategoryabbrevfield':true}, ['widget.choosecategoryabbrevfield'], 0, [clientPunchlist.view.category, 
'ChooseCategoryAbbrevField'], 0);
Ext.cmd.derive('clientPunchlist.view.category.ChooseCategoryDeleteBtn', Ext.button.Button, {text:'X', ui:'plain', width:9, bind:{hidden:'{editing}'}, listeners:{click:function(button) {
  button.up('choosecategoryoption').deleteCategory();
}}}, 0, ['choosecategorydeletebtn'], ['component', 'box', 'button', 'choosecategorydeletebtn'], {'component':true, 'box':true, 'button':true, 'choosecategorydeletebtn':true}, ['widget.choosecategorydeletebtn'], 0, [clientPunchlist.view.category, 'ChooseCategoryDeleteBtn'], 0);
Ext.cmd.derive('clientPunchlist.view.category.ChooseCategoryDoneBtn', Ext.button.Button, {ui:'grey2', scale:'small', text:'Done', hidden:true, width:32, height:18, bind:{hidden:'{!editing}'}, listeners:{click:function() {
  this.up('choosecategoryoption').onDoneEdit();
}}}, 0, ['choosecategorydonebtn'], ['component', 'box', 'button', 'choosecategorydonebtn'], {'component':true, 'box':true, 'button':true, 'choosecategorydonebtn':true}, ['widget.choosecategorydonebtn'], 0, [clientPunchlist.view.category, 'ChooseCategoryDoneBtn'], 0);
Ext.cmd.derive('clientPunchlist.view.category.ChooseCategoryEditBtn', Ext.button.Button, {ui:'plain', width:18, height:18, bind:{hidden:'{editing}'}, listeners:{click:function(button) {
  button.up('choosecategoryoption').editCategory();
}}}, 0, ['choosecategoryeditbtn'], ['component', 'box', 'button', 'choosecategoryeditbtn'], {'component':true, 'box':true, 'button':true, 'choosecategoryeditbtn':true}, ['widget.choosecategoryeditbtn'], 0, [clientPunchlist.view.category, 'ChooseCategoryEditBtn'], 0);
Ext.cmd.derive('clientPunchlist.view.category.ChooseCategoryNameField', Ext.form.field.Text, {width:80, hidden:true, ui:'category-select', bind:{hidden:'{!editing}', value:'{record.CategoryLabel}'}}, 0, ['choosecategorynamefield'], ['component', 'box', 'field', 'textfield', 'choosecategorynamefield'], {'component':true, 'box':true, 'field':true, 'textfield':true, 'choosecategorynamefield':true}, ['widget.choosecategorynamefield'], 0, [clientPunchlist.view.category, 'ChooseCategoryNameField'], 0);
Ext.cmd.derive('clientPunchlist.view.category.ChooseCategoryRadio', Ext.form.field.Radio, {ui:'plain-radio-16', name:'CategoryLabel', focus:Ext.emptyFn}, 0, ['choosecategoryradio'], ['component', 'box', 'field', 'checkboxfield', 'checkbox', 'radiofield', 'radio', 'choosecategoryradio'], {'component':true, 'box':true, 'field':true, 'checkboxfield':true, 'checkbox':true, 'radiofield':true, 'radio':true, 'choosecategoryradio':true}, ['widget.choosecategoryradio'], 0, [clientPunchlist.view.category, 
'ChooseCategoryRadio'], 0);
Ext.cmd.derive('clientPunchlist.view.category.ChooseCategoryOption', Ext.Container, {viewModel:{data:{editing:false, record:null}, formulas:{categoryAbbrevLabel:function(get) {
  var categoryAbbreviation = get('record.CategoryAbbreviation');
  return categoryAbbreviation ? '(' + categoryAbbreviation + ')' : '';
}}}, config:{record:null, focusable:false}, layout:{type:'hbox'}, width:185, height:22, listeners:{'deletecategory':'deleteCategory', 'editcategory':'editCategory', 'click':{fn:function(e, target) {
  var cmp = Ext.getCmp(this.id);
  if (!cmp.lookupViewModel().get('editing')) {
    cmp.down('choosecategoryradio').setValue(true);
  }
}, element:'el', scope:'this'}}, initComponent:function() {
  var record = this.getRecord(), categoryID = record.get('PunchlistCategoryID'), catItems = [{xtype:'choosecategoryradio', inputValue:categoryID, value:this.config.initialValue}, {xtype:'label', cls:'category-label', margin:'0 1 0 0', maxWidth:100, bind:{html:'{record.CategoryLabel:htmlEncode}', hidden:'{editing}'}}, {xtype:'label', cls:'category-abbrev', bind:{html:'{categoryAbbrevLabel}', hidden:'{editing}'}, margin:'0 1 0 0'}, {xtype:'choosecategorynamefield'}, {xtype:'choosecategoryabbrevfield'}, 
  {xtype:'choosecategorydonebtn'}], isOwner = record.get('IsOwner'), inUse = record.get('InUse');
  if (isOwner) {
    catItems.push({xtype:'choosecategoryeditbtn'});
    if (!inUse) {
      catItems.push({xtype:'choosecategorydeletebtn'});
    }
  }
  this.items = catItems;
  this.getViewModel().set('record', record);
  Ext.container.Container.prototype.initComponent.apply(this, arguments);
}, getLabel:function() {
  var record = this.getRecord();
  return record.get('CategoryLabel') + (record.get('CategoryAbbreviation') ? ' (' + record.get('CategoryAbbreviation') + ')' : '');
}, deleteCategory:function() {
  Ext.Msg.confirm('Confirm', 'Are you sure you\'d like to delete the category "' + this.getLabel() + '"?', function(btn) {
    if (btn == 'yes') {
      this.fireEvent('deletecategory', this.getRecord());
    }
  }, this);
}, editCategory:function() {
  var options = this.up('chooseCategoryWindow').getOptions();
  for (var i = 0; i < options.length; i++) {
    options[i].getViewModel().set('editing', options[i] == this);
  }
}, onDoneEdit:function() {
  var record = this.getRecord();
  this.getViewModel().set('editing', false);
  if (record.dirty) {
    this.fireEvent('editcategory', record);
  }
}}, 0, ['choosecategoryoption'], ['component', 'box', 'container', 'choosecategoryoption'], {'component':true, 'box':true, 'container':true, 'choosecategoryoption':true}, ['widget.choosecategoryoption'], 0, [clientPunchlist.view.category, 'ChooseCategoryOption'], 0);
Ext.cmd.derive('clientPunchlist.view.category.ChooseCategoryWindow', Ext.window.Window, {viewModel:{data:{newRecord:null}}, config:{store:null}, localized:{title:'TL_Choose Category'}, modal:true, resizable:false, layout:'fit', height:400, width:400, scrollable:{x:false, y:'auto'}, reference:'chooseCategoryWindow', closeAction:'hide', dockedItems:[{xtype:'container', cls:'top-container', padding:'0 10 0 10', height:34, width:'100%', layout:{type:'hbox', align:'middle'}, items:[{xtype:'label', cls:'create-label', 
localized:{html:'TL_Create Category'}, flex:1}, {xtype:'textfield', localized:{emptyText:'TL_Type Name'}, width:128, height:22, margin:'0 5 0 0', bind:{value:'{newRecord.CategoryLabel}'}}, {xtype:'textfield', localized:{emptyText:'TL_Abbrev.'}, width:50, height:22, margin:'0 5 0 0', bind:{value:'{newRecord.CategoryAbbreviation}'}, maxLength:2, enforceMaxLength:true}, {xtype:'button', ui:'orange', scale:'small', localized:{text:'TL_Add'}, height:22, disabled:true, bind:{disabled:'{!newRecord.CategoryLabel}'}, 
listeners:{click:function() {
  this.lookupController().createCategory(this.lookupViewModel().get('newRecord'));
}}}]}], initComponent:function() {
  var me = this, categories = [], store = this.getStore(), count = store.getCount();
  for (var i = 0; i < count; i++) {
    var record = store.getAt(i);
    categories.push({xtype:'choosecategoryoption', record:record, initialValue:this.config.PunchlistCategoryID == record.getId()});
  }
  Ext.applyIf(me, {items:[{margin:0, xtype:'radiogroup', alias:'categoryRadios', itemId:'categoryRadios', focusable:false, width:400, columns:2, vertical:false, defaults:{margin:'5 0 0 5'}, reference:'categoryContainer', items:categories, validate:function() {
    return true;
  }, onFocusableContainerMousedown:Ext.emptyFn}]});
  this.getViewModel().set('newRecord', this.getNewRecord());
  store.addListener('remove', this.onRecordRemove, this);
  store.addListener('add', this.onRecordsAdd, this);
  store.addListener('createsuccess', this.onCreateSuccess, this);
  Ext.window.Window.prototype.initComponent.apply(this, arguments);
}, bbar:{padding:'5 5 8 5', items:['-\x3e', {xtype:'button', localized:{text:'TL_Done'}, ui:'green', height:31, scale:'medium', listeners:{click:function() {
  this.up('chooseCategoryWindow').onDone();
}}}]}, getOptions:function() {
  return this.query('choosecategoryoption');
}, getOptionById:function(id) {
  var options = this.getOptions();
  for (var i = 0; i < options.length; i++) {
    if (options[i].getRecord().getId() == id) {
      return options[i];
    }
  }
  return null;
}, onRecordRemove:function(store, records) {
  for (var i = 0; i < records.length; i++) {
    var option = this.getOptionById(records[i].getId());
    if (option) {
      option.hide();
    }
  }
}, onRecordsAdd:function(store, records) {
  for (var i = 0; i < records.length; i++) {
    var option = this.getOptionById(records[i].getId());
    if (option) {
      option.show();
    } else {
      var index = store.indexOf(records[i]);
      this.down('#categoryRadios').insert(index, {xtype:'choosecategoryoption', record:records[i]});
    }
  }
}, onCreateSuccess:function(record) {
  this.getViewModel().set('newRecord', this.getNewRecord());
  var option = this.getOptionById(record.getId());
  option.down('radio').setValue(true);
}, onDone:function() {
  var options = this.getOptions(), record = null;
  for (var i = 0; i < options.length; i++) {
    if (options[i].down('radio').getValue()) {
      record = options[i].getRecord();
      break;
    }
  }
  if (record) {
    this.lookupController().changeCategory(record);
  }
  this.hide();
}, getNewRecord:function() {
  return Ext.create('clientPunchlist.model.PunchlistCategory', {InUse:0, IsDefault:0, IsOwner:1});
}, confirmDelete:function(record) {
  var option = this.getOptionById(record.getId());
  if (option) {
    option.destroy();
  }
}, listeners:{hide:function() {
  Ext.defer(function() {
    Ext.suspendLayouts();
    this.destroy();
    Ext.resumeLayouts();
  }, 1, this);
}, destroy:function() {
  var store = this.getStore();
  store.removeListener('remove', this.onRecordRemove, this);
  store.removeListener('add', this.onRecordsAdd, this);
  store.removeListener('createsuccess', this.onCreateSuccess, this);
}}}, 0, ['chooseCategoryWindow'], ['component', 'box', 'container', 'panel', 'window', 'chooseCategoryWindow'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true, 'chooseCategoryWindow':true}, ['widget.chooseCategoryWindow'], 0, [clientPunchlist.view.category, 'ChooseCategoryWindow'], 0);
Ext.cmd.derive('clientPunchlist.view.components.WorkStatusCombo', formShared.view.components.Combo, {constructor:function() {
  formShared.view.components.Combo.prototype.constructor.apply(this, arguments);
  this.addListener('change', this.updateStyle, this);
}, updateStyle:function(combo, newValue, oldValue) {
  if (newValue) {
    if (this.myCls) {
      this.removeCls(this.myCls);
    }
    this.myCls = 'work-status-' + newValue;
    this.addCls(this.myCls);
  }
}}, 1, ['workstatuscombo'], ['component', 'box', 'field', 'textfield', 'pickerfield', 'combobox', 'combo', 'detailformcombo', 'workstatuscombo'], {'component':true, 'box':true, 'field':true, 'textfield':true, 'pickerfield':true, 'combobox':true, 'combo':true, 'detailformcombo':true, 'workstatuscombo':true}, ['widget.workstatuscombo'], 0, [clientPunchlist.view.components, 'WorkStatusCombo'], 0);
Ext.cmd.derive('clientPunchlist.view.detailForm.PunchItemCategoryField', formShared.view.components.TextField, {flex:1, margin:'0 5 0 0', localized:{fieldLabel:'TL_Category'}, reference:'category', allowBlank:false, readOnly:true, cls:'combo-empty-dark'}, 0, ['punchitemcategoryfield'], ['component', 'box', 'field', 'textfield', 'detailformtextfield', 'punchitemcategoryfield'], {'component':true, 'box':true, 'field':true, 'textfield':true, 'detailformtextfield':true, 'punchitemcategoryfield':true}, 
['widget.punchitemcategoryfield'], 0, [clientPunchlist.view.detailForm, 'PunchItemCategoryField'], 0);
Ext.cmd.derive('clientPunchlist.view.detailForm.DetailFormPanel1', Ext.form.Panel, {ui:'detail-form', padding:'10 20 15 15', layout:{type:'vbox', align:'stretch'}, viewModel:{formulas:{detailsTitle:function(get) {
  if (get('unsaved')) {
    return mvstr['TL_Details'];
  } else {
    var id = get('PunchItem.ProjectPunchItemID');
    return id ? mvstr['TL_Item #{x}'].replace('{x}', id) : '';
  }
}}}, constructor:function() {
  this.items = [{xtype:'title', cls:'x-panel-header-title-detail-form', bind:{text:'{detailsTitle}'}}, {xtype:'container', layout:{type:'hbox'}, margin:'15 0 0 0', items:[{xtype:'detailformtextfield', margin:'0 35 0 0 ', localized:{fieldLabel:'TL_Description'}, allowBlank:false, afterLabelTextTpl:new Ext.XTemplate('\x3cspan class\x3d"mvRequired"\x3e(mvstr[TL_Required])\x3c/span\x3e'), flex:1, bind:{readOnly:'{!canEdit}', value:'{PunchItem.Description}'}, listeners:{change:'onDescriptionChange'}}, 
  {xtype:'detailformcombo', width:100, localized:{fieldLabel:'TL_Item Status'}, valueField:'PunchStatusID', displayField:'Label', readOnly:true, bind:{store:'{punchstatus}', value:'{PunchItem.PunchStatusID}', readOnly:'{!canEditPunchStatus}'}, listeners:{change:'onItemStatusComboChange'}}]}, {xtype:'container', layout:{type:'hbox', align:'stretchmax'}, margin:'35 0 0 0', items:[{xtype:'assigneefield', required:true}, {xtype:'container', margin:'0 0 0 35', layout:{type:'vbox', align:'stretch'}, flex:1, 
  items:[{xtype:'container', layout:{type:'hbox', align:'bottom'}, items:[{xtype:'punchitemcategoryfield', afterLabelTextTpl:new Ext.XTemplate('\x3cspan class\x3d"mvRequired"\x3e(mvstr[TL_Required])\x3c/span\x3e'), bind:{value:'{PunchItem.CategoryLabel}'}}, {xtype:'button', ui:'orange', height:30, listeners:{click:'selectCategory'}, hidden:true, bind:{hidden:'{!canEdit}', text:'{categoryButtonText}', loading:'{!_categoriesLoaded}', disabled:'{!_categoriesLoaded}'}}]}, {xtype:'detailformtextfield', 
  margin:'25 0 0 0', localized:{fieldLabel:'TL_Alternate ID'}, maxLength:255, bind:{readOnly:'{!canEdit}', value:'{PunchItem.ExternalIDString}'}}]}]}, {xtype:'detailformtextfield', reference:'locationField', localized:{fieldLabel:'TL_Location'}, margin:'25 0 0 0', maxLength:255, bind:{readOnly:'{!canEdit}', value:'{PunchItem.LocationDetail}'}}, {xtype:'container', margin:'25 0 0 0', layout:{type:'hbox'}, items:[{xtype:'workstatuscombo', localized:{fieldLabel:'TL_Work Status'}, valueField:'WorkStatusID', 
  displayField:'Label', readOnly:true, bind:{store:'{workstatus}', value:'{PunchItem.WorkStatusID}', readOnly:'{!canEdit}'}, listeners:{change:'onWorkStatusComboChange'}}, {xtype:'datefield', margin:'0 0 0 175', ui:'detail-form', width:160, localized:{fieldLabel:'TL_Due Date'}, reference:'dueDateField', name:'DueDate', allowBlank:false, editable:false, labelAlign:'top', labelSeparator:'', readOnly:true, cls:'with-icon', format:'M j, Y', bind:{value:'{PunchItem.DueDate}', readOnly:'{!canEdit}'}}]}];
  Ext.form.Panel.prototype.constructor.apply(this, arguments);
}}, 1, ['detailformpanel1'], ['component', 'box', 'container', 'panel', 'form', 'detailformpanel1'], {'component':true, 'box':true, 'container':true, 'panel':true, 'form':true, 'detailformpanel1':true}, ['widget.detailformpanel1'], 0, [clientPunchlist.view.detailForm, 'DetailFormPanel1'], 0);
Ext.cmd.derive('clientPunchlist.view.detailForm.PhotoFileList', Ext.view.View, {cls:'documentList', border:true, padding:0, itemSelector:'.photo', margin:'10 15 0 15', bind:{store:'{photos}'}, scrollable:{x:'auto', y:false}, focusable:false, tpl:['\x3ctpl for\x3d"."\x3e', '\x3cdiv class\x3d"photo fileviewer-item type-cls-{Type}"\x3e', '\x3cdiv class\x3d"img-wrap"\x3e', '\x3cdiv class\x3d"remove-button"\x3e\x3c/div\x3e', '\x3cimg src\x3d"{ImageURLMedium}" alt\x3d"Open in Photo Viewer"\x3e', '\x3c/div\x3e', 
'\x3cdiv class\x3d"details"\x3e', '\x3ctpl if\x3d"CreatorName"\x3e\x3cdiv class\x3d"uploader"\x3eUploaded by: {CreatorName}\x3c/div\x3e\x3cbr\x3e\x3c/tpl\x3e', '\x3cdiv class\x3d"date"\x3e{PhotoDate:date("M j, Y")}\x3c/div\x3e', '\x3c/div\x3e', '\x3c/div\x3e', '\x3c/tpl\x3e'], listeners:{beforerefresh:function(view) {
  if (!this.hasCls('print')) {
    view.up('photofileviewer').setHeight(view.getStore().getCount() ? 370 : 90);
  }
}}}, 0, ['detailformphotofilelist'], ['component', 'box', 'dataview', 'detailformphotofilelist'], {'component':true, 'box':true, 'dataview':true, 'detailformphotofilelist':true}, ['widget.detailformphotofilelist'], 0, [clientPunchlist.view.detailForm, 'PhotoFileList'], 0);
Ext.cmd.derive('clientPunchlist.view.detailForm.DetailForm', Ext.panel.Panel, {layout:{type:'fit'}, itemId:'activePage', width:'100%', flex:1, viewModel:{formulas:{showComments:function(get) {
  return get('onEntryPage');
}, addPhotoButtonHidden:function(get) {
  return !!(!get('canEdit') || get('onPhotoPage'));
}, addPhotoButtonDisabled:function(get) {
  return !get('unsaved') && !get('_photosLoaded');
}, pinsHidden:function(get) {
  return !get('onEntryPage') && !get('onPhotoPage');
}, filesHidden:function(get) {
  return !get('onEntryPage');
}, backToListText:function(get) {
  var ListTypeID = get('ListTypeID');
  return ListTypeID ? '\x26lt; ' + mvstr['TL_Back_to_' + ListTypeID] : '';
}}}, bind:{savedCls:'{unsaved}', editCls:'{canEdit}'}, setSavedCls:function(unsaved) {
  if (unsaved) {
    this.removeCls('saved');
    this.addCls('unsaved');
  } else {
    this.removeCls('unsaved');
    this.addCls('saved');
  }
}, setEditCls:function(canEdit) {
  if (canEdit) {
    this.addCls('can-edit-item');
  } else {
    this.removeCls('can-edit-item');
  }
}, initComponent:function() {
  if (this.printMode) {
    return Ext.panel.Panel.prototype.initComponent.apply(this, arguments);
  }
  if (app.getName() != 'clientPunchlistOverview') {
    this.lookupViewModel().notify();
  }
  var onPhotoPage = this.lookupViewModel().get('onPhotoPage'), onEntryPage = !!(this.up('clientPunchlistEntry') || this.up('entryPage')), panels = [{xtype:'container', layout:'hbox', items:[{xtype:'container', layout:{type:'vbox'}, flex:1, items:[{xtype:'detailformpanel1', height:445, margin:'0 0 20 0', width:'100%'}]}, {xtype:'container', width:400, height:445, layout:{type:'hbox', align:'stretch'}, items:[{xtype:'panel', localized:{title:'GC_Comments'}, margin:'0 0 0 20', padding:'15 15 18 15', 
  bodyPadding:'5 0 0 5', ui:'detail-form', cls:'comments', width:380, layout:{type:'fit'}, items:[{xtype:'comments', reference:'comments', flex:1}]}], hidden:true, bind:{hidden:'{!showComments}'}}]}, {xtype:'punchItemLocations', margin:'20 0 20 0', padding:'20 0 20 0', hidden:true, bind:{hidden:'{pinsHidden}'}}, {xtype:'fileviewer', reference:'fileViewer', ui:'detail-form', showDownloadButton:false, showTbarTitle:true, scrollable:null, margin:'20 0 0 0', padding:'20 0 20 0', title:null, fileList:{xtype:'detailformfilelist', 
  initRefresh:true}, folderFileList:{xtype:'detailformfilelist', bind:{store:'{folderFiles}'}}, addButton:{xtype:'button', ui:'orange', scale:'large', localized:{text:'TL_Add File'}, minWidth:104, margin:'0 15 0 0', bind:{hidden:'{!canEdit}'}}, hidden:true, bind:{hidden:'{filesHidden}'}}];
  if (onEntryPage || onPhotoPage) {
    Ext.Array.insert(panels, onPhotoPage ? 0 : 1, [{xtype:'photofileviewer', reference:'photoList', ui:'detail-form', title:null, tbarTitle:onPhotoPage ? mvstr['TL_Selected Photos'] : mvstr['TL_Photos'], listView:{xtype:'detailformphotofilelist'}, addButton:{xtype:'button', ui:'orange', scale:'large', minWidth:104, localized:{text:'TL_Add Photo'}, margin:'0 15 0 0', hidden:true, disabled:true, bind:{hidden:'{addPhotoButtonHidden}', disabled:'{addPhotoButtonDisabled}'}}, showDownloadButton:false, 
    showTbarTitle:true, scrollable:null, margin:'0 0 12 0', padding:'20 0 0 0', width:onEntryPage ? 1150 : '100%', height:90}]);
  }
  this.tbar = {xtype:'container', margin:'10 0 4 0', width:'100%', layout:{type:'hbox', align:'center'}, items:[{xtype:'component', flex:1}, {xtype:'container', layout:{type:'hbox', align:'middle'}, width:onEntryPage ? 1150 : 959, height:30, items:[{xtype:'container', layout:{type:'hbox', align:'middle'}, width:750, height:'100%', items:[{xtype:'button', ui:'plain', cls:'content-link', hrefTarget:'', hidden:true, bind:{html:'{backToListText}', href:'{backLink}', hidden:'{!onEntryPage}'}, listeners:{click:'onBackLinkClick'}}, 
  {xtype:'component', flex:1}, {xtype:'container', layout:{type:'vbox', align:'end', pack:'end'}, height:'100%', items:[{xtype:'component', hideMode:'visibility', cls:'editor-label', bind:{html:"\x3cspan class\x3d'label'\x3emvstr[TL_Created By]:\x3c/span\x3e {PunchItem.CreatorName} on {PunchItem.CreationDate:date('M j, Y')}", hidden:'{unsaved}'}}, {xtype:'component', hideMode:'visibility', cls:'editor-label', margin:'2 0 0 0', bind:{html:"\x3cspan class\x3d'label'\x3emvstr[TL_Last Edited By]:\x3c/span\x3e {PunchItem.LastEditorName} on {PunchItem.LastEditedDate:date('M j, Y')}", 
  hidden:'{!PunchItem.LastEditedDate}'}}]}]}, {xtype:'component', flex:1}, {xtype:'container', layout:{type:'hbox'}, hidden:true, bind:{hidden:'{!followControlsVisible}'}, items:[{xtype:'button', height:25, minWidth:70, cls:'edit-followers-btn', _disabledCls:'', ui:'orange', scale:'small', textAlign:'left', bind:{isFollower:'{isFollower}', disabled:'{followDisabled}'}, setIsFollower:function(isFollower) {
    this.setText(isFollower ? mvstr['TL_Following'] : mvstr['TL_Follow']);
    this.setIcon(isFollower ? 'mds/image/icon/btn-following-check-icon.png' : 'mds/image/icon/btn_follow-star-icon.png');
  }, listeners:{click:'toggleFollow'}}]}, {xtype:'button', ui:'more-options', reference:'menuButton', scale:'medium', margin:'0 0 0 15', menu:{xtype:'itemActionMenu'}, hidden:true, bind:{hidden:'{!onEntryPage}'}}]}, {xtype:'component', flex:1}, {xtype:'component', width:Ext.getScrollbarSize().width}]};
  var panelContainer = {xtype:'container', width:'100%', items:panels};
  if (onEntryPage) {
    panelContainer.minHeight = Ext.getBody().getViewSize().height;
  }
  this.items = [{xtype:'panel', reference:'punchItemDetails', layout:{type:'fit'}, items:{xtype:'panel', reference:'scrollableContainer', layout:{type:'hbox', pack:'middle'}, flex:1, width:'100%', scrollable:{x:false, y:'scroll'}, items:[{xtype:'button', ui:'plain', reference:'prevPunchItem', cls:'taskitem-nav-btn previous', text:'\x3c', margin:'0 10 0 0', hidden:true, bind:{hidden:'{!onTaskList}'}, listeners:{click:'prev'}}, {xtype:'container', layout:{type:'vbox'}, width:onEntryPage ? 1150 : '100%', 
  padding:!onEntryPage ? 5 : 0, items:[panelContainer]}, {xtype:'button', ui:'plain', reference:'nextPunchItem', cls:'taskitem-nav-btn next', text:'\x3e', margin:'0 0 0 10', hrefTarget:'', hidden:true, bind:{hidden:'{!onTaskList}'}, listeners:{click:'next'}}]}, fbar:{xtype:'container', layout:{type:'hbox', pack:'middle'}, defaults:{height:31, xtype:'button', scale:'medium', padding:'0 15 0 15', margin:15}, items:[{xtype:'button', ui:'grey', localized:{text:'TL_Cancel'}, bind:{href:'{backLink}'}, 
  hrefTarget:'', listeners:{click:'onCancelClick'}}, {xtype:'button', ui:'orange', localized:{text:'TL_Done'}, listeners:{click:'saveAndBack'}, disabled:true, bind:{disabled:'{saveDisabled}'}}, {xtype:'button', ui:'orange', localized:{text:'TL_Done \x26 New'}, listeners:{click:'saveAndNew'}, disabled:true, hidden:true, bind:{disabled:'{saveDisabled}', hidden:{bindTo:'{doneAndNewHidden}', single:true}}}], hidden:true, bind:{hidden:'{!canEdit}'}}}];
  Ext.panel.Panel.prototype.initComponent.apply(this, arguments);
}}, 0, ['punchitemdetails'], ['component', 'box', 'container', 'panel', 'punchitemdetails'], {'component':true, 'box':true, 'container':true, 'panel':true, 'punchitemdetails':true}, ['widget.punchitemdetails'], 0, [clientPunchlist.view.detailForm, 'DetailForm'], 0);
Ext.cmd.derive('clientPunchlist.view.location.SelectPunchPlanWindow', Ext.window.Window, {title:'Select Location(s)', modal:true, resizable:true, layout:'fit', height:300, width:500, initComponent:function() {
  var me = this;
  Ext.applyIf(me, {items:[{xtype:'gridpanel', reference:'planGrid', store:this.store, alias:'punchplan', sortOnLoad:true, rowLines:true, selModel:{selType:'checkboxmodel', mode:'SIMPLE', injectCheckbox:'last', allowDeselect:true}, columns:[{text:'Category', dataIndex:'ProjectShootTypeLabel', flex:1}, {text:'Location', dataIndex:'PunchlistPlanDescription', flex:1}], bbar:['-\x3e', {xtype:'button', text:'Done', listeners:{click:'saveSelectedPlans'}}], listeners:{beforedeselect:function(grid, record) {
    if (Ext.Array.contains(me.store.PinnedLocations, record.get('PunchlistPlanUID'))) {
      Ext.Msg.alert('Error', 'Cannot deselect a location that the item is pinned to.');
      return false;
    }
  }}}]});
  Ext.window.Window.prototype.initComponent.apply(this, arguments);
}}, 0, ['selectPunchPlanWindow'], ['component', 'box', 'container', 'panel', 'window', 'selectPunchPlanWindow'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true, 'selectPunchPlanWindow':true}, ['widget.selectPunchPlanWindow'], 0, [clientPunchlist.view.location, 'SelectPunchPlanWindow'], 0);
Ext.cmd.derive('clientPunchlist.view.detailForm.DetailFormController', Ext.app.ViewController, {init:function() {
  analytics.Ctrl.setOptionalDefaultEventProperties({'Task List UI':'Task List Item Details - New Item', 'Object Type':'Task List Item', 'Context':'Task List Item - New Item'});
  var viewModel = this.getViewModel();
  viewModel.bind('{assigneeSelection}', this.onAssigneeSelectionChange, this);
  this.initPunchItem();
  var b2 = viewModel.bind({_commentsLoaded:'{_commentsLoaded}', PunchItem:'{PunchItem}'}, function(data) {
    if (!data._commentsLoaded || !data.PunchItem) {
      return;
    }
    var commentStore = this.lookupReference('comments').lookupViewModel().get('comments');
    commentStore.addListener('datachanged', function() {
      data.PunchItem.set('CommentCount', commentStore.getCount());
    }, this);
    b2.destroy();
  }, this);
  viewModel.bind('{PunchItem}', function(punchItem) {
    if (punchItem && !isNaN(punchItem.getId())) {
      analytics.Ctrl.setOptionalDefaultEventProperties({'Task List Item ID':punchItem.getId(), 'Task List Item List':punchItem.getId(), 'Task List UI':'Task List Item Details - Existing Item', 'Context':'Task List Item Details - Existing Item'});
    }
  });
}, initPunchItem:function() {
  this.loadPunchItem(this.getViewModel().get('ProjectUID'));
}, loadPunchItem:function(ProjectUID, punchItemID, record) {
  var loaded = !!record;
  record = record || Ext.create('clientPunchlist.model.PunchItem');
  var view = this.getView(), viewModel = this.getViewModel(), dirtyCheck = function() {
    if (viewModel.getView()) {
      viewModel.set('dirty', record.dirty);
      viewModel.set('recordValid', record.isValid());
    }
  }, locationField = this.lookupReference('locationField'), dueDateField = this.lookupReference('dueDateField'), commentStore = this.lookupReference('comments').lookupViewModel().get('comments');
  viewModel.set('PunchItem', record);
  commentStore.addListener('load', function() {
    viewModel.set('_commentsLoaded', true);
  }, this, {single:true});
  if (record) {
    dirtyCheck();
  }
  record.session = {afterLoad:dirtyCheck, afterEdit:dirtyCheck, afterReject:dirtyCheck, afterCommit:dirtyCheck};
  if (punchItemID) {
    var loadMask = function() {
      if (record.isLoading()) {
        view.mask();
      }
    }, params = {ProjectUID:ProjectUID, PunchItemID:punchItemID};
    var ListTypeID = viewModel.get('ListTypeID');
    if (ListTypeID) {
      params.ListTypeID = ListTypeID;
    }
    if (!loaded) {
      record.getProxy().setExtraParams(params);
      record.load({callback:Ext.bind(view.unmask, view)});
    }
    if (view.getEl()) {
      loadMask();
    } else {
      view.addListener('afterrender', loadMask, undefined, {single:true});
    }
    Ext.defer(function() {
      this.getStore('files').load(function() {
        viewModel.bind('{_filesDataChanged}', function() {
          record.set('DocumentCount', viewModel.get('files').getCount());
        }, this);
      });
      this.getStore('photos').load(function() {
        viewModel.bind('{_photosDataChanged}', function() {
          record.set('PhotoCount', viewModel.get('photos').getCount());
        }, this);
      });
      this.getStore('pins').load(function() {
        viewModel.bind('{_pinsDataChanged}', function() {
          record.set('PunchPinCount', viewModel.get('pins').getCount());
        }, this);
      });
    }, 10, this);
    locationField.addListener('change', function() {
      locationField.addListener('change', this.onLocationChange, this);
    }, this, {single:true});
    dueDateField.addListener('change', function() {
      dueDateField.addListener('change', this.onDueDateChange, this);
    }, this, {single:true});
  } else {
    locationField.addListener('change', this.onLocationChange, this);
    dueDateField.addListener('change', function() {
      dueDateField.addListener('change', function() {
        dueDateField.addListener('change', this.onDueDateChange, this);
      }, this, {single:true});
    }, this, {single:true});
    record.getProxy().setExtraParams({ProjectUID:ProjectUID});
    viewModel.bind('{initialPunchlistCategoryID}', this.initializePunchlistCategory, this);
    viewModel.bind('{initialPunchlistLocation}', this.initializePunchlistLocation, this);
    viewModel.bind('{initialPunchlistDueDate}', this.initializePunchlistDueDate, this);
  }
}, getAssigneeChanges:function() {
  var modifiedRecords = this.getStore('assignees').getModifiedRecords(), changedAssignees = [];
  for (var i = 0; i < modifiedRecords.length; i++) {
    if (modifiedRecords[i].getData({changes:true}).IsAssignee !== undefined) {
      changedAssignees.push(modifiedRecords[i]);
    }
  }
  return changedAssignees;
}, savePunchItem:function(success, scope, forceNoPrompt, cloneSettings) {
  var viewModel = this.getViewModel(), punchItem = viewModel.get('PunchItem'), assignees = [], modifiedRecords = this.getAssigneeChanges(), doClone = viewModel.get('alwaysCloneWhenDone_readOnly'), showClonePrompt = doClone && viewModel.get('showConfirmationPrompt_readOnly'), includePhotos = cloneSettings ? cloneSettings.includePhotos : viewModel.get('tasklistSetting_includePhotos'), includePins = cloneSettings ? cloneSettings.includePins : viewModel.get('tasklistSetting_includePins'), includeFiles = 
  cloneSettings ? cloneSettings.includeFiles : viewModel.get('tasklistSetting_includeFiles');
  if (showClonePrompt && !forceNoPrompt) {
    this.getView().add({xtype:'cloneConfirmationWindow', reference:'cloneConfirmationWindow', saveArgs:[success, scope, true]}).showBy(Ext.getBody(), 'c-c?');
    return;
  }
  if (modifiedRecords.length) {
    for (var i = 0; i < modifiedRecords.length; i++) {
      assignees.push(modifiedRecords[i].getData({changes:true, critical:true}));
    }
    punchItem.set('Assignees', assignees);
  }
  punchItem.set('ListTypeID', viewModel.get('ListTypeID'));
  var view = this.getView().up(), unsaved = viewModel.get('unsaved'), fileStore = this.getStore('files'), followerStore = this.getStore('followers'), stores = [this.getStore('photos'), this.getStore('pins'), fileStore, this.lookupReference('comments').lookupViewModel().get('comments')], topView = this.getView().up('punchlistwindow') || this.getView().up('clientviewport'), nStoresToSync = 0, storeSyncsOK = true, data = {}, needPunchItemSave = !!(punchItem.dirty || punchItem.phantom), doneFn = function() {
    var punchWindow = view.up('punchlistwindow');
    topView.setLoading(false);
    if (punchWindow) {
      Ext.defer(punchWindow.destroy, 1, punchWindow);
      data[0].IsNewItem = unsaved ? 1 : 0;
      app.fireEvent('startaddpunchpin', data[0]);
    }
    delete punchItem.session;
    if (storeSyncsOK && success) {
      success.call(scope);
    }
  }, afterSyncFn = function() {
    if (this.name) {
      viewModel.set('_' + this.name + 'Loaded', true);
      viewModel.set('save_' + this.name + 'Done', true);
    }
  }, cloneFn = function() {
    Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daClientPunchlist.clonePunchItem', params:{ProjectUID:viewModel.get('ProjectUID'), PunchItemID:viewModel.get('PunchItem.PunchItemID'), includePhotos:includePhotos, includePins:includePins, includeFiles:includeFiles}, scope:this, successCallback:function() {
      viewModel.set('save_cloneDone', true);
    }, afterFailMessageCallback:function() {
      topView.unmask();
      console.log("didn't clone :(");
    }});
  };
  for (var i = 0; i < stores.length; i++) {
    if (!stores[i]) {
      continue;
    }
    if (stores[i].getModifiedRecords().length || stores[i].getRemovedRecords().length) {
      nStoresToSync++;
    }
  }
  var needStoreSave = !!nStoresToSync, needFollowersSave = !!followerStore.getModifiedRecords().length, savePunchItemFn = Ext.bind(function() {
    if (needPunchItemSave) {
      punchItem.save({success:function(record, operation, inData) {
        data = inData;
        if (unsaved) {
          viewModel.set('PunchItemID', data[0].PunchItemID);
          viewModel.notify();
          app.fireEvent('savednewpunchitem', viewModel.get('PunchItemID'));
        }
        viewModel.set('save_itemDone', true);
      }, afterFailMessageCallback:function() {
        if (!unsaved) {
          punchItem.reject();
        }
        topView.unmask();
      }, scope:this});
    }
  }, this), syncFn = function() {
    if (needStoreSave) {
      for (var i = 0; i < stores.length; i++) {
        var store = stores[i], params = store.getProxy().getExtraParams();
        params.IsNewItem = unsaved ? 1 : 0;
        store.sync({silentSuccess:true, callback:afterSyncFn, failure:function() {
          storeSyncsOK = false;
        }, scope:store});
      }
    }
    if (!unsaved && needFollowersSave) {
      followerStore.sync({silentSuccess:true, success:function() {
        viewModel.set('save_FollowersDone', true);
      }});
    }
  };
  topView.setLoading(true);
  punchItem.set('ShareTypeID', this.getViewModel().get('account.canShare') ? 1 : 2);
  if (needFollowersSave && unsaved) {
    var followers = [], records = followerStore.getModifiedRecords();
    for (i = 0; i < records.length; i++) {
      var memberUID = records[i].get('MemberUID');
      if (customData.Util.isUUID(memberUID)) {
        followers.push({MemberUID:memberUID, IsSubscriber:records[i].get('IsSubscriber')});
      }
    }
    if (followers.length) {
      punchItem.set('Followers', followers);
    }
    viewModel.set('save_FollowersDone', true);
  } else {
    viewModel.set('save_FollowersDone', !needFollowersSave);
  }
  viewModel.bind({save_pinsDone:'{save_pinsDone}', save_photosDone:'{save_photosDone}', save_filesDone:'{save_filesDone}', save_itemDone:'{save_itemDone}', save_cloneDone:'{save_cloneDone}', save_FollowersDone:'{save_FollowersDone}'}, function(data) {
    if (data.save_pinsDone && data.save_photosDone && data.save_filesDone && data.save_itemDone && data.save_cloneDone && data.save_FollowersDone) {
      doneFn();
    }
  }, this);
  if (unsaved) {
    viewModel.bind({save_itemDone:'{save_itemDone}'}, function(data) {
      if (data.save_itemDone) {
        syncFn();
      }
    }, this);
  } else {
    viewModel.bind({save_pinsDone:'{save_pinsDone}', save_filesDone:'{save_filesDone}', save_photosDone:'{save_photosDone}', save_FollowersDone:'{save_FollowersDone}'}, function(data) {
      if (data.save_pinsDone && data.save_filesDone && data.save_photosDone && data.save_FollowersDone) {
        savePunchItemFn();
      }
    }, this);
  }
  if (doClone) {
    viewModel.bind({save_pinsDone:'{save_pinsDone}', save_photosDone:'{save_photosDone}', save_filesDone:'{save_filesDone}', save_itemDone:'{save_itemDone}', save_FollowersDone:'{save_FollowersDone}'}, function(data) {
      if (data.save_pinsDone && data.save_photosDone && data.save_filesDone && data.save_itemDone && data.save_FollowersDone) {
        cloneFn();
      }
    }, this);
  } else {
    viewModel.set('save_cloneDone', true);
  }
  viewModel.set('save_itemDone', !needPunchItemSave);
  for (var i = 0; i < stores.length; i++) {
    if (!stores[i]) {
      continue;
    }
    if (!stores[i].getModifiedRecords().length && !stores[i].getRemovedRecords().length) {
      viewModel.set('save_' + stores[i].name + 'Done', true);
    }
  }
  if (unsaved) {
    savePunchItemFn();
  } else {
    syncFn();
  }
}, selectCategory:function() {
  var store = this.getStore('categories'), view = this.getView();
  view.add({xtype:'chooseCategoryWindow', store:store, reference:'chooseCategoryWindow', PunchlistCategoryID:this.getViewModel().get('PunchItem.PunchlistCategoryID')}).showBy(Ext.getBody(), 'c-c?');
}, changeCategory:function(record) {
  this.getViewModel().set('PunchItem.PunchlistCategoryID', record.getId());
  this.getViewModel().set('PunchItem.CategoryLabel', record.get('CategoryLabel'));
  this.getViewModel().set('PunchItem.CategoryAbbreviation', record.get('CategoryAbbreviation'));
  this.getViewModel().set('punchlistCategoryChanged', true);
}, createCategory:function(record) {
  var categoryWindow = this.lookupReference('chooseCategoryWindow');
  categoryWindow.mask('Saving ...');
  var store = this.getStore('categories');
  store.add(record);
  store.sync({success:function() {
    categoryWindow.unmask();
    store.fireEvent('createsuccess', record);
  }, afterFailMessageCallback:function() {
    store.rejectChanges();
    categoryWindow.unmask();
  }});
}, deleteCategory:function(record) {
  var categoryWindow = this.lookupReference('chooseCategoryWindow');
  categoryWindow.mask('Saving ...');
  var store = this.getStore('categories');
  store.remove(record);
  store.sync({success:function() {
    categoryWindow.unmask();
    categoryWindow.confirmDelete(record);
  }, afterFailMessageCallback:function() {
    store.rejectChanges();
    categoryWindow.unmask();
  }});
}, editCategory:function(record) {
  var categoryWindow = this.lookupReference('chooseCategoryWindow');
  categoryWindow.mask('Saving ...');
  var store = this.getStore('categories');
  store.sync({success:function() {
    categoryWindow.unmask();
  }, afterFailMessageCallback:function() {
    store.rejectChanges();
    categoryWindow.unmask();
  }});
}, selectPlans:function() {
  var store = this.getStore('punchplans'), punchplans = this.getViewModel().get('PunchItem.PunchlistPlanUIDs'), view = this.getView(), selectPunchPlanWindow = view.add({xtype:'selectPunchPlanWindow', store:store, reference:'selectPunchPlanWindow'}).showBy(Ext.getBody(), 'c-c?'), grid = selectPunchPlanWindow.down('grid');
  for (var i = 0; i < punchplans.length; i++) {
    var index = grid.store.find('PunchlistPlanUID', punchplans[i]);
    grid.getSelectionModel().select(index, true);
  }
}, saveSelectedPlans:function(button) {
  var selectedPlans = this.lookupReference('planGrid').getSelectionModel().getSelection(), planData = [];
  for (var i = 0; i < selectedPlans.length; i++) {
    planData.push(selectedPlans[i].getData());
  }
  this.getViewModel().set('PunchItem.PunchlistPlans', planData);
  button.up('window').destroy();
}, initializePunchlistCategory:function(PunchlistCategoryID) {
  var record = this.getViewModel().getStore('categories').getById(PunchlistCategoryID);
  if (record) {
    this.changeCategory(record);
  }
}, initializePunchlistLocation:function(punchlistLocation) {
  if (punchlistLocation !== null) {
    this.getViewModel().set('PunchItem.LocationDetail', punchlistLocation);
  }
}, initializePunchlistDueDate:function(punchlistDueDate) {
  if (punchlistDueDate !== null) {
    this.getViewModel().set('PunchItem.DueDate', punchlistDueDate);
  }
}, selectAssignee:function() {
  this.getView().add({xtype:'chooseAssigneeWindow', store:this.getStore('assignees'), reference:'chooseAssigneeWindow', AssigneeID:this.getViewModel().get('PunchItem.AssigneeID')}).showBy(Ext.getBody(), 'c-c?');
}, deselectAssignee:function(record) {
  var assignees = this.getViewModel().get('assignees'), record = assignees.getById(record.getId());
  record.set('IsAssignee', false);
}, onAssigneesUpdate:function(store) {
  this.getViewModel().set('assigneesChanged', (new Date).getTime());
  this.getViewModel().set('assigneesDirty', !!this.getAssigneeChanges().length);
  var modifiedRecords = store.getModifiedRecords(), modifiedRecord = null, updatedData = null, assigneeIDs = [];
  store.each(function(item) {
    if (item.get('IsAssignee')) {
      assigneeIDs.push(item.getId());
    }
  });
  for (var i = 0; i < modifiedRecords.length; i++) {
    modifiedRecord = modifiedRecords[i];
    var modifiedData = modifiedRecord.getData({changes:true, critical:true});
    if (modifiedData.AssigneeFirstName !== undefined || modifiedData.AssigneeLastName !== undefined || modifiedData.AssigneeEmail !== undefined) {
      updatedData = Ext.clone(modifiedData);
      delete updatedData.IsAssignee;
    }
  }
  if (updatedData) {
    Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daClientPunchlist.updatePunchlistCustomAssignee', params:{ProjectUID:this.getViewModel().get('ProjectUID')}, jsonData:updatedData, scope:this, successCallback:function() {
      if (modifiedData.IsAssignee !== undefined) {
        modifiedRecord.set('IsAssignee', !modifiedData.IsAssignee, {silent:true});
      }
      modifiedRecord.commit(true);
      if (modifiedData.IsAssignee !== undefined) {
        modifiedRecord.set('IsAssignee', modifiedData.IsAssignee, {silent:true});
      }
    }, afterFailMessageCallback:function() {
      modifiedRecord.reject();
      if (modifiedData.IsAssignee !== undefined) {
        modifiedRecord.set('IsAssignee', modifiedData.IsAssignee);
      }
    }});
  }
}, onAssigneesLoad:function() {
  this.getViewModel().set('assigneesLoaded', true);
}, onAssigneeSelectionChange:function(assignees) {
  var followers = this.getStore('followers');
  if (followers) {
    followers.each(function(follower) {
      for (var i = 0; i < assignees.length; i++) {
        var MemberUID = assignees[i].get('MemberUID');
        if (follower.get('MemberUID') == MemberUID) {
          follower.set('IsAssignee', true);
          return;
        }
      }
      follower.set('IsAssignee', false);
    });
  }
}, customAssignee:function() {
  this.getView().add({xtype:'customAssigneeWindow', reference:'customAssigneeWindow'}).showBy(Ext.getBody(), 'c-c?');
}, onChooseAssigneesDone:function() {
  this.lookupReference('chooseAssigneeWindow').destroy();
}, onFollowersLoad:function(store) {
  var viewModel = this.getViewModel(), MemberUID = viewModel.get('account.MemberUID'), userFollowerModel = store.getById(MemberUID);
  if (!userFollowerModel) {
    userFollowerModel = Ext.create('clientPunchlist.model.Follower', {MemberUID:MemberUID, IsCreator:viewModel.get('isOwner'), IsSubscriber:viewModel.get('PunchItem.IsSubscriber'), IsAssignee:viewModel.get('IsAssignee'), NoAccess:false, MemberFirstName:viewModel.get('account.MemberUsername')});
    store.add(userFollowerModel);
  }
  if (!viewModel.get('PunchItemID')) {
    userFollowerModel.set('IsCreator', true);
  }
  viewModel.set('isFollower', userFollowerModel.get('IsFollower'));
  viewModel.set('userFollowerModel', userFollowerModel);
  viewModel.set('followersLoaded', true);
}, onFollowersUpdate:function(store) {
  var viewModel = this.getViewModel();
  viewModel.set('followersChanged', !!store.getModifiedRecords().length);
  viewModel.set('isFollower', store.getById(viewModel.get('account.MemberUID')).get('IsFollower'));
}, toggleFollow:function() {
  var userFollowerModel = this.getViewModel().get('userFollowerModel'), newSetting = !userFollowerModel.get('IsSubscriber');
  userFollowerModel.set('IsSubscriber', newSetting);
  analytics.Ctrl.log('Toggled Following Task List Item', {'Action':newSetting ? 'Followed' : 'Unfollowed'}, ['Task List Item ID', 'Task List UI']);
}, saveCustomAssignee:function() {
  var fn = Ext.ComponentQuery.query("textfield[alias\x3d'customFirst']")[0].value, ln = Ext.ComponentQuery.query("textfield[alias\x3d'customLast']")[0].value, em = Ext.ComponentQuery.query("textfield[alias\x3d'customEmail']")[0].value;
  if (!fn.length) {
    Ext.Msg.alert('Error', 'Custom assignees must be given a First Name value.');
  } else {
    Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daClientPunchlist.createPunchlistCustomAssignee', params:{ProjectUID:this.getViewModel().get('ProjectUID'), CustomAssigneeFirstName:fn, CustomAssigneeLastName:ln.length ? ln : null, CustomAssigneeEmail:em.length ? em : null}, scope:this, successCallback:function(data) {
      var grid = Ext.ComponentQuery.query("grid[alias\x3d'assignee']")[0];
      var newEntry = grid.store.add({PunchlistCustomAssigneeID:data, AssigneeFirstName:fn, AssigneeLastName:ln, AssigneeEmail:em, IsDefault:0, IsOwner:1, AssigneeID:'C' + data, IsAssignee:true})[0];
      var row = grid.store.indexOf(newEntry);
      grid.getSelectionModel().select(newEntry, true, true);
      grid.getView().scrollRowIntoView(row, true);
      grid.store.Assignee = newEntry;
      Ext.ComponentQuery.query('customAssigneeWindow')[0].destroy();
    }, failure:function() {
      Ext.Msg.alert('Error', 'An error occurred. Assignee could not be saved.');
    }});
  }
}, cellClick:function(view, td, cellIndex, record, tr, rowIndex, e, eOpts) {
  if (record.get('CanDelete') && e.position.column.cls === 'delete-col') {
    this.deleteAssignee(record, rowIndex);
  }
  if (record.get('IsOwner') && e.position.column.cls === 'edit-col') {
    view.grid.getPlugin('manualEditing').startEdit(record);
  }
  if (e.position.column.xtype === 'gridcolumn' && !e.position.column.cls) {
    if (view.getSelectionModel().getSelection().indexOf(record) > -1) {
      view.getSelectionModel().deselect(record);
    } else {
      view.getSelectionModel().select(record, true);
    }
  }
}, deleteAssignee:function(record, rowIndex) {
  Ext.Msg.confirm('Confirm', "Are you sure you'd like to delete this custom assignee?", function(btn, text) {
    if (btn == 'yes') {
      Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daClientPunchlist.deletePunchlistCustomAssignee', params:{ProjectUID:this.getViewModel().get('ProjectUID'), PunchlistCustomAssigneeID:record.get('PunchlistCustomAssigneeID')}, scope:this, successCallback:function() {
        var store = Ext.ComponentQuery.query('chooseAssigneeWindow')[0].store;
        store.removeAt(rowIndex);
      }, failure:function() {
        Ext.Msg.alert('Error', 'An error occurred. Assignee could not be deleted.');
      }});
    }
  }, this);
}, updatePins:function(data) {
  var store = this.getStore('pins');
  if (!store) {
    return;
  }
  store.suspendEvents(false);
  var count = store.getCount();
  for (var i = 0; i < count; i++) {
    var item = store.getAt(i);
    item.set('PushpinSymbol', data.PushpinSymbol);
    item.set('TextOverlay', data.CategoryAbbreviation);
    item.set('ListTypeID', data.ListTypeID);
  }
  Ext.defer(function() {
    store.resumeEvents();
    var pinnedLocations = this.lookupReference('pinnedLocationsDataview');
    if (pinnedLocations) {
      pinnedLocations.refresh();
    }
  }, 50, this);
}, saveAndBack:function() {
  analytics.Ctrl.log('Clicked Task List Item Done Button', {}, ['Task List UI']);
  app.fireEvent('savingnewpunchitem', this.getStore('photos'));
  this.savePunchItem();
}, addPunchPinToPlan:function() {
  this.getView().setActiveItem(this.lookupReference('pinWizard'));
}, closePinWizard:function() {
  this.getView().setActiveItem(this.lookupReference('punchItemDetails'));
}, deletePunchPin:function(view, record, item, index, e) {
  if (Ext.fly(e.target).hasCls('remove-button')) {
    var viewModel = this.getViewModel();
    var pins = viewModel.get('pins');
    pins.remove(record);
    e.preventDefault();
    return false;
  }
}, onDescriptionChange:function(descriptionField) {
  this.getViewModel().set('punchItemDescriptionValid', descriptionField.isValid());
}, onLocationChange:function(field, value) {
  this.getViewModel().set('punchlistLocationChanged', true);
}, onDueDateChange:function(field, value) {
  if (value) {
    this.getViewModel().set('punchlistDueDateChanged', true);
  }
}, printPunchItem:function() {
  var viewModel = this.getViewModel();
  var params = {ProjectUID:viewModel.get('ProjectUID'), ListTypeID:viewModel.get('ListTypeID'), PunchItemID:viewModel.get('PunchItem.PunchItemID'), PunchStatusID:viewModel.get('PunchItem.PunchStatusID')};
  var printUrl = mdslink.server + '/index.cfm?fuseaction\x3daClientPunchlist.detailsPDF\x26' + Ext.Object.toQueryString(params);
  window.open(printUrl, '_blank');
}, deletePunchItem:function() {
  Ext.Msg.confirm('Confirm', 'Delete selected item?', function(btn, text) {
    if (btn == 'yes') {
      Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daClientPunchlist.deletePunchItem', params:{ProjectUID:this.getViewModel().get('ProjectUID'), PunchItemID:this.getViewModel().get('PunchItem.PunchItemID')}, scope:this, successCallback:function(data) {
        if (this.backToList) {
          var punchItem = this.getViewModel().get('PunchItem');
          punchItem.store.remove(punchItem);
          this.backToList();
        } else {
          document.location.href = this.getViewModel().get('backLink');
        }
      }}, this);
    }
  }, this);
}, onCloneConfirm:function() {
  var settingsWindow = this.lookupReference('cloneConfirmationWindow'), args = settingsWindow.getSaveArgs();
  args.push({includePhotos:settingsWindow.down('#includePhotos').getValue(), includePins:settingsWindow.down('#includePins').getValue(), includeFiles:settingsWindow.down('#includeFiles').getValue()});
  this.savePunchItem.apply(this, args);
  settingsWindow.destroy();
}, deleteButtonClicked:function() {
  Ext.Msg.confirm('Confirm', "Are you sure you'd like to delete this item?", function(btn, text) {
    if (btn == 'yes') {
      Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daClientPunchlist.deletePunchItem', params:{ProjectUID:this.getViewModel().get('ProjectUID'), PunchItemID:this.PunchItem.get('PunchItemID')}, scope:this, successCallback:function(data) {
        Ext.Msg.alert('Success', 'Item deleted successfully', function(btn, text) {
          if (btn == 'ok') {
            window.location = mdslink.clientPunchlistOverview + 'ProjectUID\x3d' + this.getViewModel().get('ProjectUID');
          }
        }, this);
      }}, this);
    }
  }, this);
}, cancelButtonClicked:function() {
  this.setFormValues(this.PunchItem);
}, setFormValues:function(record) {
  Ext.ComponentQuery.query('shareWithButton')[0].initialize(record.get('ShareTypeID'), record.get('ShareMembers'));
  var form = Ext.ComponentQuery.query('punchitemdetails')[0];
  form.loadRecord(record);
}, saveAndNew:function() {
  analytics.Ctrl.log('Clicked Task List Item Done and New Button');
  this.savePunchItem(function() {
    document.location.href = document.location.href;
  }, this);
}, onBackLinkClick:function() {
  analytics.Ctrl.log('Clicked Back To Task List Link', {}, ['Task List UI']);
}, next:Ext.emptyFn, prev:Ext.emptyFn, nextPrev:Ext.emptyFn, onCancelClick:function(button) {
  var buttonWindow = button.up('window');
  if (buttonWindow) {
    buttonWindow.destroy();
  }
}, showFollowers:function() {
  this.getView().add({xtype:'punchItemFollowers', reference:'punchItemFollowers'}).showBy(this.lookupReference('menuButton'), 'c-c?');
}, onWorkStatusComboChange:function(combo, newValue, oldValue) {
  var id = this.getViewModel().get('PunchItem.PunchItemID');
  if (id && !oldValue) {
    return;
  }
  var optionalProperties = ['Task List UI'];
  if (!id || !isNaN(id)) {
    optionalProperties.push('Task List Item List');
  }
  analytics.Ctrl.log('Changed Task List Item Work Status', {'Work Status':combo.getDisplayValue(), 'Work Status ID':newValue}, optionalProperties);
}, onItemStatusComboChange:function(combo, newValue, oldValue) {
  var id = this.getViewModel().get('PunchItem.PunchItemID');
  if (id && !oldValue) {
    return;
  }
  var optionalProperties = ['Task List UI'];
  if (!id || !isNaN(id)) {
    optionalProperties.push('Task List Item List');
  }
  analytics.Ctrl.log('Changed Task List Item Status', {'Item Status':combo.getDisplayValue(), 'Item Status ID':newValue}, optionalProperties);
}}, 0, 0, 0, 0, ['controller.detailform'], 0, [clientPunchlist.view.detailForm, 'DetailFormController'], 0);
Ext.cmd.derive('clientPunchlist.view.detailForm.DetailFormModel', Ext.app.ViewModel, {data:{dirty:false, recordValid:false, _forceUpdatePins:0, followersChanged:false, isFollower:false, userFollowerModel:null, followersLoaded:false, assigneesLoaded:false, assigneesChanged:0, assigneesDirty:false, punchItemDescriptionValid:true, private_PunchlistCategoryID:null, private_AssigneeList:null, private_punchlistLocation:null, private_punchlistDueDate:null, punchlistCategoryChanged:false, punchlistLocationChanged:false, 
punchlistDueDateChanged:false, save_itemDone:false, save_pinsDone:false, save_photosDone:false, save_filesDone:false, save_cloneDone:false, save_FollowersDone:false, _commentsLoaded:false}, formulas:{onEntryPage:function() {
  return !!(this.getView().xtype == 'clientPunchlistEntry' || this.getView().xtype == 'entryPage');
}, canEdit:function(get) {
  return !!(get('account.canWrite') && (get('isOwner') || get('account.canShare')));
}, showEditButton:function(get) {
  return !!(get('canEdit') && !get('unsaved'));
}, isOwner:function(get) {
  return !!(get('unsaved') || get('PunchItem.IsOwner'));
}, canEditPunchStatus:function(get) {
  return !!(get('isOwner') || get('account.TaskListItemStatusPermission'));
}, editingOwn:function(get) {
  return !!(get('canEdit') && get('isOwner'));
}, editingExisting:function(get) {
  return !!(get('canEdit') && !get('unsaved'));
}, editingOwnExisting:function(get) {
  return !!(get('canEdit') && get('PunchItem.IsOwner'));
}, unsaved:function(get) {
  if (!get('onEntryPage')) {
    return true;
  }
  var PunchItem = get('PunchItem');
  return PunchItem ? isNaN(PunchItem.getId()) : !get('PunchItemID');
}, commentViewData:function(get) {
  var PunchItem = get('PunchItem');
  if (!PunchItem || isNaN(PunchItem.getId())) {
    return null;
  }
  return {CommentType:'punchitem', CommentCount:get('PunchItem.CommentCount'), Identifier:get('PunchItem.PunchItemID')};
}, _triggerUpdatePins:{bind:{PinsLoaded:'{_pinsLoaded}', PushpinSymbol:'{PunchItem.PushpinSymbol}', CategoryAbbreviation:'{PunchItem.CategoryAbbreviation}', ListTypeID:'{PunchItem.ListTypeID}', _forceUpdatePins:'{_forceUpdatePins}'}, get:function(data) {
  this.getView().lookupController().updatePins(data);
}}, saveDisabled:function(get) {
  var PunchItem = get('PunchItem'), valid = get('valid'), unsaved = get('unsaved'), saveDisabled = PunchItem ? unsaved ? !valid : !get('hasChanges') || !valid : true;
  return saveDisabled;
}, hasChanges:function(get) {
  var PunchItem = get('PunchItem'), dirty = get('dirty'), storeChanged = !!(get('_photosDataChanged') > 0 || get('_filesDataChanged') > 0 || get('_pinsDataChanged') > 0 || get('followersChanged') || get('assigneesDirty')), hasChanges = PunchItem ? dirty || storeChanged : false;
  return hasChanges;
}, valid:function(get) {
  return get('recordValid') && get('assigneeSelection').length && get('punchItemDescriptionValid');
}, _triggerPhotoSet:function(get) {
  var view = this.getView(), photos = get('photos');
  if (photos && view.photos) {
    var convertedPhotos = [];
    for (var i = 0; i < view.photos.length; i++) {
      var data = Ext.clone(view.photos[i].getData());
      if (view.photos[i].$className != 'mdsData.model.Photo') {
        data.Type = data.UDEFPhotoUID ? 'U' : data.WebcamPhotoUID ? 'W' : 'P';
        data.Identifier = data.id.substr(1, data.id.length - 1);
        data.ImageURLMedium = data.med || data.ImageURL;
        data.PhotoDate = data.PhotoDate || data.dateTaken;
      }
      var convertedRecord = Ext.create('mdsData.model.Photo', data);
      convertedRecord.phantom = true;
      convertedPhotos.push(convertedRecord);
    }
    photos.add(convertedPhotos);
  }
}, followDisabled:function(get) {
  return !!(get('isOwner') || get('userFollowerModel.IsAssignee'));
}, followControlsVisible:function(get) {
  return get('followersLoaded') && get('canEdit');
}, assigneeSelection:function(get) {
  if (!get('assigneesLoaded') && !get('assigneesChanged')) {
    return [];
  }
  return get('assignees').query('IsAssignee', true).items;
}, assigneeCollection:function(get) {
  return Ext.create('Ext.data.Store', {data:get('assigneeSelection')});
}, categoryButtonText:function(get) {
  return get('PunchItem.PunchlistCategoryID') ? mvstr['TL_Change'] : mvstr['TL_Add'];
}, locationButtonText:function(get) {
  return get('PunchItem.PlanList') ? mvstr['TL_Change'] : mvstr['TL_Add'];
}, initialPunchlistCategoryID:function(get) {
  return null;
}, initialPunchlistLocation:function(get) {
  return null;
}, initialPunchlistDueDate:function(get) {
  var dueDate = new Date, workDaysAdded = 0, weekendDays = Ext.Date.weekendDays;
  while (workDaysAdded < 5) {
    dueDate = Ext.Date.add(dueDate, Ext.Date.DAY, 1);
    if (Ext.Array.indexOf(weekendDays, dueDate.getDay()) == -1) {
      workDaysAdded++;
    }
  }
  return get('punchlistDueDateChanged') || !get('unsaved') ? null : dueDate;
}, ListItemDesc:function(get) {
  var ListTypeID = get('ListTypeID');
  return ListTypeID ? mvstr['TL_ListItemDesc_' + ListTypeID] : mvstr['TL_ListItemDesc'];
}, doneAndNewHidden:function(get) {
  return !(app.getName() == 'clientPunchlistEntry' && !Ext.Object.fromQueryString(document.location.search).PunchItemID);
}, cloneOptionAvailable:function(get) {
  return !get('doneAndNewHidden');
}}, stores:{punchstatus:{type:'punchstatus'}, workstatus:{type:'workstatus'}, categories:{autoLoad:true, model:'clientPunchlist.model.PunchlistCategory', proxy:{type:'ajax', reader:{type:'json'}, writer:{writeAllFields:false, allowSingle:false}, api:{create:'/index.cfm?fuseaction\x3daClientPunchlist.createProjectPunchlistCategories', read:'/index.cfm?fuseaction\x3daClientPunchlist.getProjectPunchlistCategories', update:'/index.cfm?fuseaction\x3daClientPunchlist.updateProjectPunchlistCategories', 
destroy:'/index.cfm?fuseaction\x3daClientPunchlist.deleteProjectPunchlistCategories'}, extraParams:{ProjectUID:'{ProjectUID}'}}, sorters:[{property:'CategoryLabel', direction:'ASC'}], mvAutoLoadVars:true}, assignees:{model:'clientPunchlist.model.Assignee', autoLoad:true, sorters:[{property:'AssigneeLastName', direction:'ASC'}, {property:'AssigneeFirstName', direction:'ASC'}], proxy:{api:{read:'/index.cfm?fuseaction\x3daClientPunchlist.getProjectPunchlistAssignees', update:'/index.cfm?fuseaction\x3daClientPunchlist.updatePunchItemAssignees'}, 
extraParams:{ProjectUID:'{ProjectUID}', PunchItemID:'{PunchItemID}'}, writer:{writeAllFields:false}}, listeners:{update:'onAssigneesUpdate', add:'onAssigneesUpdate', remove:'onAssigneesUpdate', load:'onAssigneesLoad'}}, assigneeSelectionStore:{model:'clientPunchlist.model.Assignee', proxy:{type:'memory'}}, punchplans:{autoLoad:true, model:'mdsData.model.Floorplan', PinnedLocations:[], proxy:{api:{read:'/index.cfm?fuseaction\x3daClientPunchlist.getProjectPunchlistPlans'}, extraParams:{ProjectUID:'{ProjectUID}', 
ListTypeID:'{ListTypeID}'}}}, files:{type:'files', proxy:{api:{create:'/index.cfm?fuseaction\x3daClientPunchlist.addDocumentsToPunchItem', read:'/index.cfm?fuseaction\x3daClientPunchlist.getPunchItemDocuments', update:'/index.cfm?fuseaction\x3daClientPunchlist.addDocumentsToPunchItem', destroy:'/index.cfm?fuseaction\x3daClientPunchlist.removeDocumentsFromPunchItem'}, extraParams:{PunchItemID:'{PunchItemID}', ProjectUID:'{ProjectUID}'}}, autoLoad:false, allowAutoSave:false, mvAutoDataChangedVar:true}, 
photos:{model:'mdsData.model.Photo', proxy:{api:{create:'/index.cfm?fuseaction\x3daClientPunchlist.addPhotosToPunchItem', read:'/index.cfm?fuseaction\x3daClientPunchlist.getPunchItemPhotos', destroy:'/index.cfm?fuseaction\x3daClientPunchlist.removePhotosFromPunchItem'}, extraParams:{PunchItemID:'{PunchItemID}', ProjectUID:'{ProjectUID}'}}, autoLoad:false, allowAutoSave:false, mvAutoDataChangedVar:true, mvAutoLoadVars:true}, pins:{model:'mdsData.model.Pushpin', proxy:{api:{read:'/index.cfm?fuseaction\x3daClientPunchlist.getPunchItemPins', 
create:'/index.cfm?fuseaction\x3daClientPunchlist.addPunchPinsToPunchItem', destroy:'/index.cfm?fuseaction\x3daClientPunchlist.deletePunchPins'}, extraParams:{ProjectUID:'{ProjectUID}', PunchItemID:'{PunchItemID}'}}, listeners:{add:{fn:function(store) {
  this.getViewModel().set('_forceUpdatePins', (new Date).getTime());
}, scope:'controller'}, scope:'controller'}, mvAutoLoadVars:true, mvAutoDataChangedVar:true}, followers:{model:'clientPunchlist.model.Follower', autoLoad:true, proxy:{api:{read:'/index.cfm?fuseaction\x3daClientPunchlist.getPunchItemFollowers', update:'/index.cfm?fuseaction\x3daClientPunchlist.updatePunchItemFollowers'}, writer:{allowSingle:false}, extraParams:{ProjectUID:'{ProjectUID}', PunchItemID:'{PunchItemID}'}}, listeners:{update:'onFollowersUpdate', load:'onFollowersLoad'}}}}, 0, 0, 0, 0, ['viewmodel.punchitemdetail'], 
0, [clientPunchlist.view.detailForm, 'DetailFormModel'], 0);
Ext.cmd.derive('clientPunchlist.view.detailForm.FileList', Ext.view.View, {cls:'documentList', border:true, padding:0, itemSelector:'.document', bind:{store:'{files}'}, scrollable:{x:'auto', y:false}, initRefresh:false, focusable:false, style:'white-space: nowrap;', tpl:['\x3ctpl for\x3d"."\x3e', '\x3cdiv class\x3d"document fileviewer-item"\x3e', '\x3cdiv class\x3d"remove-button"\x3e\x3c/div\x3e', '\x3cimg src\x3d"{DocumentSymbolLarge}"\x3e', '\x3cdiv class\x3d"details"\x3e', '{DocumentFilename}', 
'\x3c/div\x3e', '\x3c/div\x3e', '\x3c/tpl\x3e'], getMaskTarget:function() {
  return this.up().el;
}}, 0, ['detailformfilelist'], ['component', 'box', 'dataview', 'detailformfilelist'], {'component':true, 'box':true, 'dataview':true, 'detailformfilelist':true}, ['widget.detailformfilelist'], 0, [clientPunchlist.view.detailForm, 'FileList'], 0);
Ext.cmd.derive('clientPunchlist.view.template.PinnedLocation', Ext.Base, {singleton:true, constructor:function() {
  this.interactive = Ext.create('Ext.XTemplate', '\x3ctpl for\x3d"."\x3e', '\x3cdiv class\x3d"punchPinCover"\x3e', '\x3ctpl if\x3d"this.isSaved(values)"\x3e', '\x3ca href\x3d"{mdslink_clientFloorplanViewer_punchlistPlan}ProjectUID\x3d{ProjectUID}', '\x26FloorplanUID\x3d{FloorplanUID}\x26pushpinUID\x3d{PushpinUID}\x26ListTypeID\x3d{ListTypeID}"\x3e', '\x3c/tpl\x3e', '\x3cdiv class\x3d"punchPinCoverImage"', ' style\x3d"background-image: url({floorplanImage}); background-position: {[this.getOffset(values)]}; background-repeat: no-repeat"\x3e', 
  '{[this.getPin(values)]}\x3cdiv class\x3d"remove-button"\x3e\x3c/div\x3e\x3c/div\x3e', '\x3cdiv class\x3d"floorplanCoverLabel"\x3e\x3cspan\x3e{LocationName}\x3c/span\x3e\x3c/div\x3e', '\x3ctpl if\x3d"this.isSaved(values)"\x3e', '\x3c/a\x3e', '\x3c/tpl\x3e', '\x3c/div\x3e', '\x3c/tpl\x3e', {getOffset:this.getOffset, getPin:this.getPin, isSaved:this.isSaved});
  this.readOnly = Ext.create('Ext.XTemplate', '\x3ctpl for\x3d"."\x3e', '\x3cdiv class\x3d"punchPinCover"\x3e', '\x3cimg src\x3d"{PunchPinOverviewURL}"\x3e', '\x3cimg src\x3d"{PunchPinZoomURL}"\x3e', '\x3cdiv class\x3d"floorplanCoverLabel"\x3e\x3cspan\x3e{LocationName}\x3c/span\x3e\x3c/div\x3e', '\x3c/div\x3e', '\x3c/tpl\x3e', {getOffset:this.getOffset, getPin:this.getPin, isSaved:this.isSaved});
  this.callParent(arguments);
}, getOffset:function(values) {
  var x = -1 * values.PushpinXCoordinate + 133;
  var y = -1 * values.PushpinYCoordinate + 133;
  return x + 'px ' + y + 'px';
}, getPin:function(values) {
  return mdsData.FloorplanValues.iconTemplate.apply(floorplanList.PlanUtil.getPinValuesFromFeature({properties:{PunchItemID:values.PunchItemID, PushpinSymbol:values.PushpinSymbol, TextOverlay:values.TextOverlay}}));
}, isSaved:function(values) {
  return customData.Util.isUUID(values.PushpinUID);
}}, 1, 0, 0, 0, 0, 0, [clientPunchlist.view.template, 'PinnedLocation'], 0);
Ext.cmd.derive('clientPunchlist.view.location.PinnedLocationsDataView', Ext.view.View, {cls:'pinned-locations-view', itemSelector:'.punchPinCover', tpl:clientPunchlist.view.template.PinnedLocation.interactive}, 0, ['pinnedlocationsdata'], ['component', 'box', 'dataview', 'pinnedlocationsdata'], {'component':true, 'box':true, 'dataview':true, 'pinnedlocationsdata':true}, ['widget.pinnedlocationsdata'], 0, [clientPunchlist.view.location, 'PinnedLocationsDataView'], 0);
Ext.cmd.derive('clientPunchlist.view.location.PinnedLocations', Ext.form.Panel, {fieldDefaults:{labelWidth:100}, ui:'detail-form', layout:{type:'vbox'}, viewModel:{formulas:{loading:function(get) {
  return !get('unsaved') ? !get('_pinsLoaded') : false;
}}}, bodyPadding:5, border:true, tbar:{ui:'detail-form', items:[{xtype:'component', cls:'x-panel-header-title-detail-form', localized:{html:'TL_Pinned Locations'}, margin:'0 0 0 15'}, '-\x3e', {xtype:'button', ui:'orange', scale:'large', localized:{text:'TL_Add Pin'}, minWidth:104, margin:'0 15 0 0', bind:{hidden:'{!canEdit}'}, listeners:{click:'addPunchPinToPlan'}}]}, items:[{xtype:'container', width:'100%', layout:{type:'auto'}, items:{xtype:'pinnedlocationsdata', reference:'pinnedLocationsDataview', 
listeners:{itemclick:'deletePunchPin'}, bind:{store:'{pins}'}}}], bind:{loading:'{loading}'}}, 0, ['punchItemLocations'], ['component', 'box', 'container', 'panel', 'form', 'punchItemLocations'], {'component':true, 'box':true, 'container':true, 'panel':true, 'form':true, 'punchItemLocations':true}, ['widget.punchItemLocations'], 0, [clientPunchlist.view.location, 'PinnedLocations'], 0);
Ext.cmd.derive('clientPunchlist.view.punchlist.PunchlistController', Ext.app.ViewController, {filters:{statusFilters:{arr:[], fieldName:'PunchStatusID', filterFieldName:'PunchStatusID', fn:function(record) {
  var includeClosed = this.getViewModel().get('ClosedItemsVisible');
  if ((!this.filters.statusFilters.arr.length || Ext.Array.contains(this.filters.statusFilters.arr, record.get('PunchStatusID'))) && (includeClosed || record.get('PunchStatusID') != mdsData.PunchlistValues.PUNCH_STATUS.CLOSED)) {
    return true;
  }
  return false;
}}, categoryFilters:{arr:[], fieldName:'PunchlistCategoryID', filterFieldName:'PunchlistCategoryID'}, locationFilters:{arr:[], filterFieldName:'FilterValue', fn:function(record) {
  var plans = record.get('PunchlistPlans');
  for (var i = 0; i < plans.length; i++) {
    if (Ext.Array.contains(this.filters.locationFilters.arr, plans[i].PunchlistPlanDescription)) {
      return true;
    }
  }
  return false;
}}, assigneeFilters:{arr:[], filterFieldName:'AssigneeID', fn:function(record) {
  var assignees = record.get('Assignees'), arr = this.filters.assigneeFilters.arr;
  for (var i = 0; i < assignees.length; i++) {
    if (Ext.Array.contains(arr, assignees[i].AssigneeID)) {
      return true;
    }
  }
  return false;
}}, workStatusFilters:{arr:[], filterFieldName:'WorkStatusID', fieldName:'WorkStatusID'}}, imgArray:[], loadedImgCount:0, punchitemsLoaded:function(punchitems) {
  var categoryList = [], locationList = [], found = false;
  for (var i = 0; i < punchitems.count(); i++) {
    found = false;
    var punchItem = punchitems.getAt(i), categoryId = punchItem.get('PunchlistCategoryID'), category = mvstr['TLC_' + categoryId] || punchItem.get('CategoryLabel');
    for (var j = 0; j < categoryList.length; j++) {
      if (categoryList[j].CategoryLabel == category) {
        found = true;
        break;
      }
    }
    if (!found) {
      categoryList.push({CategoryLabel:category, PunchlistCategoryID:categoryId});
    }
    found = false;
    var plans = punchitems.getAt(i).get('PunchlistPlans');
    if (plans.length) {
      for (var j = 0; j < plans.length; j++) {
        if (!Ext.Array.contains(locationList, plans[j].PunchlistPlanDescription)) {
          locationList.push(plans[j].PunchlistPlanDescription);
        }
      }
    }
  }
  var locationFilters = [];
  for (var x in locationList) {
    locationFilters.push({FilterValue:locationList[x]});
  }
  this.getStore('categories').setData(categoryList);
  this.getStore('locations').setData(locationFilters);
  var viewModel = this.getViewModel(), punchItems = viewModel.get('punchitems'), count = punchItems.getCount(), names = [], data = [];
  for (var i = 0; i < count; i++) {
    var punchItem = punchItems.getAt(i), assignees = punchItem.get('Assignees');
    for (var j = 0; j < assignees.length; j++) {
      var assignee = clientPunchlist.model.Assignee.fieldsMap.Assignee.calculate(assignees[j]);
      if (!Ext.Array.contains(names, assignee)) {
        names.push(assignee);
        data.push(assignees[j]);
      }
    }
  }
  viewModel.get('assignees').loadRawData(data);
  viewModel.set('punchitemsStoreLoaded', true);
}, updateFilter:function(view, record, item) {
  var filterName = view.reference;
  if (record.get('isSelected')) {
    this.filters[filterName].arr.push(record.get(this.filters[filterName].filterFieldName));
  } else {
    var index = this.filters[filterName].arr.indexOf(record.get(this.filters[filterName].filterFieldName));
    if (index > -1) {
      this.filters[filterName].arr.splice(index, 1);
    }
  }
  this.filterGrid();
}, onClearFiltersClick:function() {
  analytics.Ctrl.log('Cleared All Filters');
  for (var key in this.filters) {
    this.filters[key].arr = [];
  }
  var filters = Ext.ComponentQuery.query('filter');
  for (var i = 0; i < filters.length; i++) {
    filters[i].clearSelected();
  }
  this.filterGrid();
}, nonEmptyFilterExists:function() {
  for (var key in this.filters) {
    if (this.filters[key].arr.length) {
      return true;
    }
  }
  return !!this.searchValue;
}, filterGrid:function(status) {
  var punchitemsStore = this.getViewModel().getStore('punchitems');
  punchitemsStore.clearFilter();
  if (this.nonEmptyFilterExists() || this.getViewModel().get('ClosedItemsLoaded') && !this.getViewModel().get('ClosedItemsVisible')) {
    punchitemsStore.filter({filterFn:Ext.bind(function(record) {
      for (var key in this.filters) {
        if (key == 'statusFilters') {
          if (!this.filters[key].fn.call(this, record)) {
            return false;
          }
        } else {
          if (this.filters[key].arr.length) {
            if (this.filters[key].fn) {
              if (!this.filters[key].fn.call(this, record)) {
                return false;
              }
            } else {
              if (!Ext.Array.contains(this.filters[key].arr, record.get(this.filters[key].fieldName))) {
                return false;
              }
            }
          }
        }
      }
      if (!this.searchValue) {
        return true;
      }
      var description = record.get('Description').toLowerCase(), location = record.get('PlanList').toLowerCase(), details = record.get('LocationDetail').toLowerCase(), assignee = record.get('AssigneeList').toLowerCase(), creator = record.get('CreatorName').toLowerCase(), searchDate = new Date(this.searchValue);
      return !!(mdsData.PunchlistValues.WORK_STATUS_LABELS[record.get('WorkStatusID')].toLowerCase() == this.searchValue || mdsData.PunchlistValues.PUNCH_STATUS_LABELS[record.get('PunchStatusID')].toLowerCase() == this.searchValue || record.get('ProjectPunchItemID') == this.searchValue || record.get('CategoryLabel').toLowerCase() == this.searchValue || record.get('CategoryAbbreviation').toLowerCase() == this.searchValue || description && description.indexOf(this.searchValue) != -1 || location && 
      location.indexOf(this.searchValue) != -1 || details && details.indexOf(this.searchValue) != -1 || assignee && assignee.indexOf(this.searchValue) != -1 || creator && creator.indexOf(this.searchValue) != -1 || Ext.Date.diff(searchDate, record.get('DueDate'), Ext.Date.DAY) == 0 || Ext.Date.diff(searchDate, record.get('CompletionDate'), Ext.Date.DAY) == 0);
    }, this)});
  }
}, onAddPinToExistingClick:function(button) {
  var data = this.lookupReference('punchItemGrid').getSelection()[0].getData(), pinDescription = this.getViewModel().get('pinDescription');
  data.IsNewItem = 0;
  if (pinDescription == 'Pin') {
    app.fireEvent('startaddpunchpin', data);
  } else {
    if (pinDescription == 'Photo') {
      app.fireEvent('startaddphototopunchitem', data);
    }
  }
  button.up('punchlistwindow').destroy();
}, loadImage:function(url) {
  var img = new Image;
  img.onload = Ext.bind(this.imgOnLoad, this);
  img.onerror = Ext.bind(this.imgOnLoad, this);
  img.src = url;
}, imgOnLoad:function() {
  this.loadedImgCount++;
  if (this.loadedImgCount == this.imgArray.length) {
    this.onImagesReady();
  }
}, onImagesReady:Ext.emptyFn}, 0, 0, 0, 0, ['controller.punchlist'], 0, [clientPunchlist.view.punchlist, 'PunchlistController'], 0);
Ext.cmd.derive('clientPunchlist.view.punchlist.PunchlistModel', Ext.app.ViewModel, {data:{SNID1:'', SNID2:'', SAID1:'', SAID2:'', onTaskList:false}, stores:{punchstatus:{type:'punchstatus'}, workstatus:{type:'workstatus'}, punchitems:{type:'punchitems', autoLoad:true, listeners:{load:'punchitemsLoaded'}, proxy:{extraParams:{ProjectUID:'{ProjectUID}', ListTypeID:'{ListTypeID}', PunchStatusID:'{PunchStatusID}', SNID1:'{SNID1}', SNID2:'{SNID2}', SAID1:'{SAID1}', SAID2:'{SAID2}', onTaskList:'{onTaskList}'}}}, 
locations:{fields:['FilterValue'], proxy:{type:'memory'}, sorters:[{sorterFn:function(a, b) {
  if (a.get('FilterValue') < b.get('FilterValue')) {
    return -1;
  }
  if (a.get('FilterValue') > b.get('FilterValue')) {
    return 1;
  }
  return 0;
}}]}, categories:{fields:['FilterValue'], proxy:{type:'memory'}, sorters:[{sorterFn:function(a, b) {
  if (a.get('FilterValue') < b.get('FilterValue')) {
    return -1;
  }
  if (a.get('FilterValue') > b.get('FilterValue')) {
    return 1;
  }
  return 0;
}}]}, assignees:{model:'clientPunchlist.model.Assignee', proxy:{type:'memory'}}}, formulas:{ListTypeName:function(get) {
  return get('ListTypeNameLong');
}, ListTypeNameLong:function(get) {
  var ListTypeID = get('ListTypeID');
  return ListTypeID ? mvstr['TL_Name_' + ListTypeID] : '';
}}}, 0, 0, 0, 0, ['viewmodel.punchlist'], 0, [clientPunchlist.view.punchlist, 'PunchlistModel'], 0);
Ext.cmd.derive('planGrid.model.Project', Ext.data.Model, {fields:[{name:'uid', type:'string'}, {name:'name', type:'string'}], idProperty:'uid'}, 0, 0, 0, 0, 0, 0, [planGrid.model, 'Project'], 0);
Ext.cmd.derive('planGrid.model.RFI', Ext.data.Model, {fields:[{name:'uid', type:'string'}, {name:'number', type:'int'}, {name:'title', type:'string'}, {name:'displayField', type:'string', calculate:function(data) {
  return '#' + data.number + ' - ' + data.title;
}}, {name:'status'}, {name:'statusLabel', convert:function(v, rec) {
  return rec.get('status').label;
}}], idProperty:'uid'}, 0, 0, 0, 0, 0, 0, [planGrid.model, 'RFI'], 0);
Ext.cmd.derive('planGrid.model.RFIStatus', Ext.data.Model, {fields:[{name:'uid', type:'string'}, {name:'color', type:'string'}, {name:'label', type:'string'}, {name:'name', type:'string', calculate:function(value) {
  var name = value.label || 'unnamed';
  return name.charAt(0).toUpperCase() + name.slice(1);
}}], idProperty:'uid'}, 0, 0, 0, 0, 0, 0, [planGrid.model, 'RFIStatus'], 0);
Ext.cmd.derive('planGrid.model.User', Ext.data.Model, {fields:[{name:'uid', type:'string'}, {name:'first_name', type:'string'}, {name:'last_name', type:'string'}, {name:'displayField', type:'string', calculate:function(data) {
  var names = [];
  if (data.first_name) {
    names.push(data.first_name);
  }
  if (data.last_name) {
    names.push(data.last_name);
  }
  return names.join(' ');
}}], idProperty:'uid'}, 0, 0, 0, 0, 0, 0, [planGrid.model, 'User'], 0);
Ext.cmd.derive('planGrid.store.RFIs', Ext.data.Store, {model:'planGrid.model.RFI', proxy:{url:'/index.cfm?fuseaction\x3daPlanGrid.getRFIs'}, changeFilterValue:function(filterValue) {
  this.clearFilter();
  this.filter({filterFn:function(item) {
    return item.get('status') == filterValue;
  }});
}}, 0, 0, 0, 0, 0, 0, [planGrid.store, 'RFIs'], 0);
Ext.cmd.derive('planGrid.view.plangridwindow.PlanGridWindowModel', Ext.app.ViewModel, {stores:{planGridProjects:{model:'planGrid.model.Project', proxy:{url:'/index.cfm?fuseaction\x3daPlanGrid.getProjects'}, autoLoad:true, listeners:{load:'onProjectsLoad'}}, integrationEntityTypes:{proxy:{type:'memory'}, model:'formShared.model.IntegrationEntityType', data:[{id:'Document', name:'Document', createAction:'uploadDocuments'}]}, planGridProjectUsers:{model:'planGrid.model.User', proxy:{url:'/index.cfm?fuseaction\x3daPlanGrid.getProjectUsers'}}}, 
data:{private_planGridSetting_projectID:null, private_planGridSetting_entityType:null, private_planGridSetting_attachAsPhoto:null, private_planGridSetting_attachAs4View:null, private_planGridSetting_rfiAssignee:null, planGridSetting_rfiStatus:null, singlePhotoTitle:'', entityID:'', planGridUserID:0, entityStoreLoaded:false, cardHeight:312, warningHeight:0, saving:false, saveDone:false, errorMessage:'', showAlertMessage:false, rfiSentDate:null, rfiDueDate:null, projectsLoaded:false, attachFloorplanOnly:false}, 
formulas:{planGridSetting_projectID:{get:function(get) {
  var planGridSetting_projectID = get('private_planGridSetting_projectID');
  if (planGridSetting_projectID !== null) {
    return planGridSetting_projectID;
  }
  if (!get('globalPreferencesReady')) {
    return null;
  }
  return mdsPreferences.ProjectPreferences.getPlanGridSetting_projectID();
}, set:function(value) {
  this.set('private_planGridSetting_projectID', value);
  mdsPreferences.ProjectPreferences.setPlanGridSetting_projectID(value);
}}, planGridSetting_entityType:{get:function(get) {
  var planGridSetting_entityType = get('private_planGridSetting_entityType'), entityTypes = get('integrationEntityTypes');
  if (planGridSetting_entityType !== null) {
    return planGridSetting_entityType;
  }
  if (!get('globalPreferencesReady')) {
    return null;
  }
  planGridSetting_entityType = mdsPreferences.ProjectPreferences.getPlanGridSetting_entityType();
  if (!entityTypes || entityTypes.find('id', planGridSetting_entityType) == -1) {
    return null;
  }
  return planGridSetting_entityType;
}, set:function(value) {
  this.set('private_planGridSetting_entityType', value);
  mdsPreferences.ProjectPreferences.setPlanGridSetting_entityType(value);
}}, planGridSetting_attachAsPhoto:{get:function(get) {
  var planGridSetting_attachAsPhoto = get('private_planGridSetting_attachAsPhoto');
  if (planGridSetting_attachAsPhoto !== null) {
    return planGridSetting_attachAsPhoto;
  }
  if (!get('globalPreferencesReady')) {
    return null;
  }
  var pref = mdsPreferences.ProjectPreferences.getPlanGridSetting_attachAsPhoto();
  return pref === undefined ? false : pref;
}, set:function(value) {
  this.set('private_planGridSetting_attachAsPhoto', value);
  mdsPreferences.ProjectPreferences.setPlanGridSetting_attachAsPhoto(value);
}}, planGridSetting_attachAs4View:{get:function(get) {
  var planGridSetting_attachAs4View = get('private_planGridSetting_attachAs4View');
  if (planGridSetting_attachAs4View !== null) {
    return planGridSetting_attachAs4View;
  }
  if (!get('globalPreferencesReady')) {
    return null;
  }
  var pref = mdsPreferences.ProjectPreferences.getPlanGridSetting_attachAs4View();
  return pref === undefined ? true : pref;
}, set:function(value) {
  this.set('private_planGridSetting_attachAs4View', value);
  mdsPreferences.ProjectPreferences.setPlanGridSetting_attachAs4View(value);
}}, planGridSetting_rfiAssignee:{get:function(get) {
  var planGridSetting_rfiAssignee = get('private_planGridSetting_rfiAssignee');
  if (planGridSetting_rfiAssignee !== null) {
    return planGridSetting_rfiAssignee;
  }
  if (!get('globalPreferencesReady')) {
    return null;
  }
  return mdsPreferences.ProjectPreferences.getPlanGridSetting_rfiAssignee();
}, set:function(value) {
  this.set('private_planGridSetting_rfiAssignee', value);
  mdsPreferences.ProjectPreferences.setPlanGridSetting_rfiAssignee(value);
}}, entityType:function(get) {
  return get('integrationEntityTypes').getById(get('planGridSetting_entityType'));
}, entity:function(get) {
  var entityTypeID = get('private_planGridSetting_entityType'), planGridUserID = get('planGridUserID');
  if (!entityTypeID || !planGridUserID) {
    return null;
  }
  var store = get('entityStore');
  if (!store) {
    return null;
  }
  return store.getById(get('entityID'));
}, projectSelected:function(get) {
  return get('projectsLoaded') && get('planGridSetting_projectID');
}, multiplePhotosSelected:function(get) {
  return this.getView().getPhotos().length > 1;
}, calculatedEntityID:function(get) {
  return get('entityID');
}, submitReady:function(get) {
  var entityType = get('entityType');
  if (!entityType) {
    return false;
  }
  return true;
}, entityStoreID:function(get) {
  var entityType = get('entityType'), project_id = get('planGridSetting_projectID');
  if (!entityType) {
    return null;
  }
  var storeId = 'planGrid_' + entityType.get('name').replace(' ', '') + '_' + project_id;
  return storeId;
}, entityStore:function(get) {
  var entityType = get('entityType'), planGridUserID = get('planGridUserID'), storeType = get('entityStoreType');
  if (!entityType || !planGridUserID || !storeType) {
    return Ext.create('Ext.data.Store', {proxy:'memory'});
  }
  var entityTypeID = get('entityType').getId(), storeId = get('entityStoreID'), store = Ext.getStore(storeId), controller = this.getView().lookupController();
  if (!store && get('planGridSetting_projectID')) {
    store = Ext.create(storeType, {storeId:storeId, autoLoad:true, proxy:{extraParams:controller.getEntityStoreParams(entityTypeID)}, listeners:{load:controller.onEntityStoreLoad, scope:controller}});
  }
  if (store) {
    this.set('entityStoreLoaded', store.isLoaded());
  }
  return store;
}, entityStoreType:function(get) {
  var entityType = get('entityType');
  if (!entityType) {
    return null;
  }
  var storeType = entityType.get('storeType');
  if (!storeType) {
    return null;
  }
  return storeType;
}, card:function(get) {
  var controller = this.getView().lookupController(), entityTypeID = get('private_planGridSetting_entityType'), projectID = get('planGridSetting_projectID'), defaultCard = controller.lookupReference('card_default');
  return projectID ? controller.lookupReference('card_' + entityTypeID) || controller.lookupReference('card_' + entityTypeID) || defaultCard : defaultCard;
}, itemDescription:function(get) {
  return 'item';
}, lowercaseEntityName:function(get) {
  var entityType = get('entityType');
  if (!entityType) {
    return '';
  }
  var name = entityType.get('name');
  return name.toLowerCase();
}, emptyText:function(get) {
  var entityStore = get('entityStore'), entityStoreLoaded = get('entityStoreLoaded');
  if (get('submitReady') || !entityStore || !entityStoreLoaded || entityStore.getCount()) {
    return '- Select -';
  }
  return 'No ' + get('itemDescription') + 's available.';
}, noItemsAvailable:function(get) {
  var entityStore = get('entityStore'), entityStoreLoaded = get('entityStoreLoaded');
  return !(get('submitReady') || !entityStore || !entityStoreLoaded || entityStore.getCount());
}, warningMessage:function(get) {
  var entityStore = get('entityStore'), entityStoreLoaded = get('entityStoreLoaded'), entityType = get('entityType'), errorMessage = get('errorMessage'), message = '', storeType = get('entityStoreType'), showAlertMessage = !!(get('showAlertMessage') || errorMessage);
  if (!showAlertMessage || get('submitReady') || storeType && !entityStore || storeType && !entityStoreLoaded) {
    message = '';
  } else {
    if (storeType && !entityStore.getCount()) {
      message = 'You cannot complete the ' + get('lowercaseEntityName') + ' submission because there are no ' + get('itemDescription') + 's to select.';
    } else {
      if (storeType && !get('calculatedEntityID')) {
        message = 'You cannot complete the export process until you have selected a' + (get('itemDescription') == 'item' ? 'n' : '') + ' ' + get('itemDescription') + '.';
      } else {
        if (entityType.getId() == 'Photo' && !get('multiplePhotosSelected') && !get('planGridPhotoPhotoTitle.value')) {
          message = 'You cannot complete the export process until you have chosen a title';
        } else {
          if (!get('planGridSetting_attachAsPhoto') && !get('planGridSetting_attachAs4View')) {
            message = 'You cannot complete the export process until you have chosen what files to attach.';
          }
        }
      }
    }
  }
  if (message) {
    this.set('errorMessage', '');
  } else {
    this.set('warningHeight', 0);
    if (errorMessage) {
      message = errorMessage;
    }
  }
  if (!message) {
    this.set('showAlertMessage', false);
  }
  return message;
}, windowHeight:function(get) {
  return get('cardHeight') + get('warningHeight');
}, planGridUsers:function(get) {
  var projectID = get('planGridSetting_projectID');
  if (!projectID) {
    return Ext.create('Ext.data.Store', {proxy:{type:'memory'}});
  }
  var storeID = 'planGridUsers-' + projectID, store = Ext.getStore(storeID);
  return store || Ext.create('Ext.data.Store', {model:'planGrid.model.User', proxy:{url:'/index.cfm?fuseaction\x3daPlanGrid.getProjectUsers', extraParams:{project_id:projectID}}, mvAutoLoadVars:true, autoLoad:true, storeId:storeID});
}, planGridRFIStatuses:function(get) {
  var projectID = get('planGridSetting_projectID');
  if (!projectID) {
    return Ext.create('Ext.data.Store', {proxy:{type:'memory'}});
  }
  var storeID = 'planGridRFIStatuses-' + projectID, store = Ext.getStore(storeID);
  return store || Ext.create('Ext.data.Store', {model:'planGrid.model.RFIStatus', proxy:{url:'/index.cfm?fuseaction\x3daPlanGrid.getProjectRFIStatuses', extraParams:{project_id:projectID}}, mvAutoLoadVars:true, autoLoad:true, storeId:storeID});
}}}, 0, 0, 0, 0, ['viewmodel.planGridwindow'], 0, [planGrid.view.plangridwindow, 'PlanGridWindowModel'], 0);
Ext.cmd.derive('planGrid.view.plangridwindow.PlanGridWindowController', Ext.app.ViewController, {init:function() {
  var vm = this.getViewModel();
  var b1 = vm.bind({planGridUserID:'{planGridUserID}', projectsLoaded:'{projectsLoaded}'}, function(data) {
    if (data.projectsLoaded && data.planGridUserID) {
      this.onReady();
      b1.destroy();
    }
  }, this);
  vm.bind('{card}', this.onCardChange, this);
  vm.bind('{windowHeight}', this.onWindowHeightChange, this);
  vm.bind({multiplePhotosSelected:'{multiplePhotosSelected}', ProjectUID:'{ProjectUID}'}, function(data) {
    var photos = this.getView().getPhotos(), fileTitle = this.getView().getFileTitle();
    vm.set('singlePhotoTitle', fileTitle);
    if (!data.multiplePhotosSelected && !fileTitle) {
      Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daPlanGrid.getPhotoTitle', params:{ProjectUID:data.ProjectUID, photos:photos[0]}, successCallback:function(data) {
        vm.set('singlePhotoTitle', data);
      }});
    }
  }, this);
  Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daPlanGrid.getUser', successCallback:function(data) {
    this.getViewModel().set('planGridUserID', data.uid);
  }, afterFailMessageCallback:function() {
    this.getView().destroy();
  }, scope:this});
  Ext.defer(function() {
    this.getView().showBy(Ext.getBody(), 't-t?', [0, this.getWindowY(Ext.getBody().getHeight())], false);
  }, 1, this);
  Ext.getBody().addListener('resize', function(component, dimensions) {
    this.getView().setPosition(this.getWindowX(dimensions.width), this.getWindowY(dimensions.height), false, true);
  }, this, {buffer:200});
}, onBoxReady:function() {
  this.lookupReference('cards').setLoading(true);
}, getWindowX:function(bodyWidth) {
  return Math.max(0, (bodyWidth - this.getView().el.getWidth()) / 2);
}, getWindowY:function(bodyHeight) {
  var topOffset = (bodyHeight - 699) / 2, currentHeight = this.getView().el.getHeight();
  if (topOffset + currentHeight > bodyHeight) {
    topOffset = (bodyHeight - currentHeight) / 2;
  }
  return Math.max(0, topOffset);
}, onReady:function() {
  var projectID = this.getViewModel().get('planGridSetting_projectID');
  if (projectID) {
    this.lookupReference('projects').setValue(projectID);
  }
  this.lookupReference('cards').setLoading(false);
}, onProjectChange:function(combo, projectID) {
  if (projectID) {
    this.getViewModel().set('planGridSetting_projectID', projectID);
  } else {
    this.getViewModel().set('entityID', '');
  }
  this.getViewModel().set('showAlertMessage', false);
}, getEntityStoreId:function(entityTypeID) {
  var entityType = this.getStore('integrationEntityTypes').getById(entityTypeID), project_id = this.getViewModel().get('planGridSetting_projectID');
  var storeId = 'planGrid_' + entityType.get('name').replace(' ', '') + '_' + project_id;
  if (entityType.get('subCreateActions')) {
    storeId += '_' + this.getViewModel().get('subType');
  }
  return storeId;
}, getEntityStoreParams:function(entityTypeID) {
  var viewModel = this.getViewModel(), extraParams = {project_id:viewModel.get('planGridSetting_projectID')};
  if (viewModel.get('planGridSetting_entityType') == 'DailyLog') {
    extraParams.log_date = Ext.Date.format(viewModel.get('dailyLogDate'), 'Y-m-d');
  }
  return extraParams;
}, getCreateAction:function() {
  var entityType = this.getStore('integrationEntityTypes').getById(this.getViewModel().get('planGridSetting_entityType')), subType = this.getViewModel().get('subType'), subCreateActions = entityType.get('subCreateActions');
  return subCreateActions ? entityType.get('subCreateActions')[subType] : entityType.get('createAction');
}, getSubmitParams:function() {
  var viewModel = this.getViewModel(), photos = this.getView().getPhotos(), entityID = viewModel.get('calculatedEntityID'), entityTypeID = viewModel.get('planGridSetting_entityType'), card = viewModel.get('card'), entity = viewModel.get('entity'), displayField = entity ? entity.get('displayField') : '', params = {ProjectUID:viewModel.get('ProjectUID'), photos:photos.join(','), project_id:viewModel.get('private_planGridSetting_projectID'), uid:entityID, dateString:Ext.Date.format(new Date, 'ymd'), 
  includeAnnotations:this.getView().getIncludeAnnotations(), displayName:displayField, projectName:viewModel.get('planGridProjects').getById(viewModel.get('planGridSetting_projectID')).get('name')};
  if (entityTypeID == 'Photo' && photos.length == 1) {
    params.title = this.lookupReference('planGridPhotoPhotoTitle').getValue();
  } else {
    if (entityTypeID == 'Document' && photos.length == 1) {
      params.title = this.lookupReference('planGridDocumentPhotoTitle').getValue();
    } else {
      if (entityTypeID == 'CreateRFI') {
        params.question = card.down('#comments').getValue();
        params.title = this.lookupReference('planGridNewRFITitle').getValue();
        if (viewModel.get('rfiDueDate')) {
          params.dueDate = Ext.Date.dateFormat(viewModel.get('rfiDueDate'), 'C');
        }
        if (viewModel.get('rfiSentDate')) {
          params.sentDate = Ext.Date.dateFormat(viewModel.get('rfiSentDate'), 'C');
        }
        if (viewModel.get('planGridSetting_rfiStatus')) {
          params.status = viewModel.get('planGridSetting_rfiStatus');
        }
        if (viewModel.get('planGridSetting_rfiAssignee')) {
          params.assignees = viewModel.get('planGridSetting_rfiAssignee').join();
        }
      }
    }
  }
  if (entityTypeID != 'Photo') {
    params.attachAsPhoto = card.down('#attachPhoto').getValue();
    params.attachAs4View = card.down('#attachDetails').getValue();
  }
  params.attachAsFloorplan = this.getViewModel().get('attachFloorplanOnly');
  if (params.attachAsFloorplan) {
    params.attachAsPhoto = params.attachAs4View = false;
    params.FloorplanUID = viewModel.get('FloorplanUID');
    params.displayHeader = card.down('#headerCheckbox').getValue();
    params.displayHotspots = card.down('#hotspotsCheckbox').getValue();
    params.displayPushpins = card.down('#pushpinsCheckbox').getValue();
    params.title = this.lookupReference('planGridDocumentPhotoTitle').getValue();
  }
  return params;
}, submitPhotos:function() {
  var viewModel = this.getViewModel();
  if (!viewModel.get('submitReady')) {
    viewModel.set('showAlertMessage', true);
    return;
  }
  viewModel.set('showAlertMessage', false);
  viewModel.set('saving', true);
  if (viewModel.get('subType') == 'CreateNewAlbum') {
    this.createNewAlbum();
    return;
  }
  var params = this.getSubmitParams();
  var asyncUploads = viewModel.get('account.features.uploadscenterVisible');
  params.asynchronous = asyncUploads;
  Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daPlanGrid.' + this.getCreateAction(), params:params, successCallback:function(data) {
    if (asyncUploads) {
      window.app.fireEvent('reloadfileuploads', {sourceType:'integration', responseData:data, photos:params.photos.split(',')});
    } else {
      viewModel.set('saveDone', true);
    }
    if (data && data.callback) {
      data.callback();
    }
    Ext.defer(function() {
      this.getView().destroy();
    }, 1000, this);
  }, afterFailMessageCallback:function(data, message) {
    viewModel.set('saving', false);
    viewModel.set('errorMessage', message ? message : mvstr.G_UnexpectedError);
  }, noAlert:true, scope:this});
  this.logExportAnalyticsEvent(params);
}, logExportAnalyticsEvent:function(params) {
  if (params.attachAsFloorplan) {
    analytics.Ctrl.log('Exported Floorplan', {'Floorplan UID':params.FloorplanUID, 'Integration':'Procore'});
  } else {
    var action = 'Photo Viewer Menu';
    if (location.href.toLowerCase().indexOf('clientphotolist') !== -1) {
      action = 'Photo List Menu';
    }
    analytics.Ctrl.log('Exported Photo', {'Photo List':params.photos, 'Photo Action Element':action, 'Integration':'Procore'});
  }
}, onCardChange:function(card) {
  if (card) {
    this.lookupReference('cards').setActiveItem(card);
    this.getViewModel().set('cardHeight', card.getWindowHeight());
  }
  this.getViewModel().set('showAlertMessage', false);
}, onWarningResize:function(component) {
  this.getViewModel().set('warningHeight', component.el.getHeight());
}, onEntityStoreLoad:function(store) {
  if (store == this.getViewModel().get('entityStore')) {
    this.getViewModel().set('entityStoreLoaded', true);
  }
}, onWindowHeightChange:function(windowHeight) {
  this.getView().setHeight(windowHeight);
}, onProjectsLoad:function() {
  this.getViewModel().set('projectsLoaded', true);
}}, 0, 0, 0, 0, ['controller.planGridwindow'], 0, [planGrid.view.plangridwindow, 'PlanGridWindowController'], 0);
Ext.cmd.derive('planGrid.view.cards.Default', Ext.Container, {config:{windowHeight:312}, reference:'card_default'}, 0, ['plangriddefault'], ['component', 'box', 'container', 'plangriddefault'], {'component':true, 'box':true, 'container':true, 'plangriddefault':true}, ['widget.plangriddefault'], 0, [planGrid.view.cards, 'Default'], 0);
Ext.cmd.derive('planGrid.view.form.User', formShared.view.components.ComboMultiselect, {width:'100%', fieldLabel:'Assignee', queryMode:'local', displayField:'displayField', emptyText:'- Select -', valueField:'uid', editable:false, bind:{store:'{planGridUsers}'}}, 0, ['plangriduser'], ['component', 'box', 'field', 'textfield', 'pickerfield', 'combobox', 'combo', 'tagfield', 'detailformmulticombo', 'plangriduser'], {'component':true, 'box':true, 'field':true, 'textfield':true, 'pickerfield':true, 'combobox':true, 
'combo':true, 'tagfield':true, 'detailformmulticombo':true, 'plangriduser':true}, ['widget.plangriduser'], 0, [planGrid.view.form, 'User'], 0);
Ext.cmd.derive('planGrid.view.cards.Document', Ext.Container, {reference:'card_Document', layout:'vbox', config:{windowHeight:390}, items:[{xtype:'detailformtextfield', reference:'planGridDocumentPhotoTitle', fieldLabel:'Title', emptyText:'Enter title', margin:'0 0 28 0', width:'100%', publishes:'value', hidden:true, bind:{hidden:'{multiplePhotosSelected}', value:'{singlePhotoTitle}'}}, {xtype:'integrationattachment', photoBinding:'{planGridSetting_attachAsPhoto}', pdfBinding:'{planGridSetting_attachAs4View}'}]}, 
0, ['plangriddocument'], ['component', 'box', 'container', 'plangriddocument'], {'component':true, 'box':true, 'container':true, 'plangriddocument':true}, ['widget.plangriddocument'], 0, [planGrid.view.cards, 'Document'], 0);
Ext.cmd.derive('planGrid.view.cards.CreateRFI', Ext.Container, {reference:'card_CreateRFI', layout:'vbox', config:{windowHeight:662}, items:[{xtype:'container', layout:'hbox', width:'100%', margin:'0 0 18 0', items:[{xtype:'detailformtextfield', width:202, reference:'planGridNewRFITitle', fieldLabel:'Title', emptyText:'Enter title', publishes:'value'}, {xtype:'component', flex:1}, {xtype:'detailformcombo', width:202, fieldLabel:'Status', emptyText:'- Select -', valueField:'uid', displayField:'name', 
bind:{store:'{planGridRFIStatuses}', value:'{planGridSetting_rfiStatus}'}}]}, {xtype:'plangriduser', margin:'0 0 18 0', bind:{value:'{planGridSetting_rfiAssignee}'}}, {xtype:'container', layout:'hbox', width:'100%', margin:'0 0 18 0', items:[{xtype:'datefield', mvPickerUI:'mds-light', cls:'with-icon', labelAlign:'top', width:202, ui:'detail-form', fieldLabel:'Sent Date', labelSeparator:'', bind:{value:'{rfiSentDate}'}}, {xtype:'component', flex:1}, {xtype:'datefield', mvPickerUI:'mds-light', cls:'with-icon', 
labelAlign:'top', width:202, ui:'detail-form', fieldLabel:'Due Date', labelSeparator:'', bind:{value:'{rfiDueDate}'}}]}, {xtype:'integrationcomments', fieldLabel:'Question'}, {xtype:'integrationattachment', photoBinding:'{planGridSetting_attachAsPhoto}', pdfBinding:'{planGridSetting_attachAs4View}'}]}, 0, ['plangridcreaterfi'], ['component', 'box', 'container', 'plangridcreaterfi'], {'component':true, 'box':true, 'container':true, 'plangridcreaterfi':true}, ['widget.plangridcreaterfi'], 0, [planGrid.view.cards, 
'CreateRFI'], 0);
Ext.cmd.derive('planGrid.view.cards.ExistingRFI', Ext.Container, {reference:'card_ExistingRFI', layout:'vbox', config:{windowHeight:768}, items:[{xtype:'container', layout:'hbox', width:'100%', margin:'0 0 18 0', items:[{xtype:'detailformtextfield', width:202, fieldLabel:'Title', emptyText:'Enter title', publishes:'value'}, {xtype:'component', flex:1}, {xtype:'detailformcombo', width:202, fieldLabel:'Status', emptyText:'- Select -', valueField:'uid', displayField:'name', bind:{store:'{planGridRFIStatuses}', 
value:'{planGridSetting_rfiStatus}'}}]}, {xtype:'plangriduser', margin:'0 0 18 0', bind:{value:'{planGridSetting_rfiAssignee}'}}, {xtype:'container', layout:'hbox', width:'100%', margin:'0 0 18 0', items:[{xtype:'datefield', mvPickerUI:'mds-light', cls:'with-icon', labelAlign:'top', width:202, ui:'detail-form', fieldLabel:'Sent Date', labelSeparator:'', bind:{value:'{rfiSentDate}'}}, {xtype:'component', flex:1}, {xtype:'datefield', mvPickerUI:'mds-light', cls:'with-icon', labelAlign:'top', width:202, 
ui:'detail-form', fieldLabel:'Due Date', labelSeparator:'', bind:{value:'{rfiDueDate}'}}]}, {xtype:'integrationcomments', margin:'0 0 18 0', fieldLabel:'Question'}, {xtype:'integrationcomments', margin:'0 0 18 0', itemId:'answer', fieldLabel:'Answer'}, {xtype:'integrationattachment', photoBinding:'{planGridSetting_attachAsPhoto}', pdfBinding:'{planGridSetting_attachAs4View}'}]}, 0, ['plangridexistingrfi'], ['component', 'box', 'container', 'plangridexistingrfi'], {'component':true, 'box':true, 'container':true, 
'plangridexistingrfi':true}, ['widget.plangridexistingrfi'], 0, [planGrid.view.cards, 'ExistingRFI'], 0);
Ext.cmd.derive('planGrid.view.plangridwindow.PlanGridWindow', Ext.window.Window, {ui:'orange', cls:'integration-window', modalMaskCls:'dark-mask', viewModel:{type:'planGridwindow'}, controller:'planGridwindow', config:{photos:null, includeAnnotations:true, attachFloorplanOnly:false, fileTitle:''}, updateAttachFloorplanOnly:function(floorplanOnly) {
  this.getViewModel().set('attachFloorplanOnly', floorplanOnly);
}, width:488, modal:true, title:'Add to PlanGrid', layout:{type:'fit'}, bind:{height:'{windowHeight}', disabled:'{saving}'}, dockedItems:[{xtype:'container', reference:'warning', dock:'top', cls:'warning', layout:{type:'hbox', align:'center'}, minHeight:41, padding:10, hidden:true, bind:{hidden:'{!warningMessage}'}, listeners:{'resize':'onWarningResize', 'show':'onWarningResize'}, items:[{xtype:'component', flex:1, bind:{html:'\x3cspan\x3e{warningMessage}\x3c/span\x3e'}}]}], items:[{xtype:'panel', 
padding:25, layout:'card', reference:'cards', loadMaskCls:'light-load-indicator', dockedItems:[{xtype:'container', dock:'top', layout:'hbox', margin:'0 0 18 0', items:[{xtype:'detailformcombo', width:202, reference:'projects', fieldLabel:'Project', emptyText:'- Select -', queryMode:'local', displayField:'name', valueField:'uid', bind:{store:'{planGridProjects}', value:'{procoreSetting_projectID}'}, listeners:{change:'onProjectChange'}}, {xtype:'component', flex:1}, {xtype:'integrationtype', bind:{value:'{planGridSetting_entityType}', 
store:'{integrationEntityTypes}', disabled:'{!projectSelected}'}}]}, {xtype:'container', dock:'bottom', layout:{type:'hbox', pack:'center'}, padding:'25 0 0 0', items:[{xtype:'button', scale:'medium', ui:'grey', text:'Cancel', margin:'0 12 0 12', listeners:{click:function() {
  this.up('window').destroy();
}}}, {xtype:'savebutton', reference:'saveButton', bind:{processing:'{saving}', done:'{saveDone}'}, margin:'0 12 0 12', listeners:{click:function() {
  this.lookupController().submitPhotos();
}}}]}], items:[{xtype:'plangriddefault'}, {xtype:'plangriddocument'}, {xtype:'plangridcreaterfi'}, {xtype:'plangridexistingrfi'}]}], doRealign:Ext.emptyFn, setPosition:function(x, y, animate, force) {
  if (force) {
    return Ext.window.Window.prototype.setPosition.apply(this, arguments);
  }
}, listeners:{boxready:'onBoxReady'}}, 0, ['plangridwindow'], ['component', 'box', 'container', 'panel', 'window', 'plangridwindow'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true, 'plangridwindow':true}, ['widget.plangridwindow'], 0, [planGrid.view.plangridwindow, 'PlanGridWindow'], 0);
Ext.cmd.derive('procore.model.AssigneeResponse', Ext.data.Model, {fields:[{name:'id', type:'int'}, {name:'position', type:'int'}, {name:'name', type:'string'}, {name:'approved', type:'boolean'}, {name:'displayField', type:'int', calculate:function(data) {
  return '#' + data.position + ' - ' + data.name;
}}]}, 0, 0, 0, 0, 0, 0, [procore.model, 'AssigneeResponse'], 0);
Ext.cmd.derive('procore.model.ChangeEvent', Ext.data.Model, {fields:[{name:'id', type:'int'}, {name:'number', type:'int'}, {name:'title', type:'string'}, {name:'displayField', type:'string', calculate:function(data) {
  return '#' + data.number + ' - ' + data.title;
}}]}, 0, 0, 0, 0, 0, 0, [procore.model, 'ChangeEvent'], 0);
Ext.cmd.derive('procore.model.Company', Ext.data.Model, {fields:[{name:'id', type:'int'}, {name:'name', type:'string'}, {name:'is_active', type:'boolean'}]}, 0, 0, 0, 0, 0, 0, [procore.model, 'Company'], 0);
Ext.cmd.derive('procore.model.CostCode', Ext.data.Model, {fields:[{name:'id', type:'int'}, {name:'name', type:'string'}]}, 0, 0, 0, 0, 0, 0, [procore.model, 'CostCode'], 0);
Ext.cmd.derive('procore.model.DeliveryLog', Ext.data.Model, {fields:[{name:'id', type:'int'}, {name:'position', type:'int'}, {name:'time_hour', type:'int'}, {name:'time_minute', type:'int'}, {name:'delivery_from', type:'string'}, {name:'dateString', type:'string', calculate:function(data) {
  return formShared.IntegrationsUtil.getDisplayDateString(data);
}}, {name:'displayField', calculate:function(data) {
  var str = '#' + data.position + ' - ' + data.dateString;
  if (data.delivery_from) {
    str += ' - ' + data.delivery_from;
  }
  return str;
}}]}, 0, 0, 0, 0, 0, 0, [procore.model, 'DeliveryLog'], 0);
Ext.cmd.derive('procore.model.Location', Ext.data.Model, {fields:[{name:'id', type:'int'}, {name:'name', type:'string'}]}, 0, 0, 0, 0, 0, 0, [procore.model, 'Location'], 0);
Ext.cmd.derive('procore.model.ManpowerLog', Ext.data.Model, {fields:[{name:'id', type:'int'}, {name:'contact'}, {name:'cost_code'}, {name:'location'}, {name:'num_hours', type:'number'}, {name:'num_workers', type:'number'}, {name:'position', type:'int'}, {name:'contactName', calculate:function(data) {
  return data.contact && data.contact.name ? data.contact.name : '';
}}, {name:'locationName', calculate:function(data) {
  return data.location && data.location.name ? data.location.name : '';
}}, {name:'costCodeName', calculate:function(data) {
  return data.cost_code && data.cost_code.name ? data.cost_code.name : '';
}}, {name:'displayField', calculate:function(data) {
  var str = '#' + data.position;
  if (data.contactName) {
    str += ' - ' + data.contactName;
  }
  if (data.locationName) {
    str += ' - ' + data.locationName;
  }
  if (data.costCodeName) {
    str += ' - ' + data.costCodeName;
  }
  return str;
}}]}, 0, 0, 0, 0, 0, 0, [procore.model, 'ManpowerLog'], 0);
Ext.cmd.derive('procore.model.ManpowerLogsVendorOption', Ext.data.Model, {fields:[{name:'id', type:'int'}, {name:'name', type:'string'}]}, 0, 0, 0, 0, 0, 0, [procore.model, 'ManpowerLogsVendorOption'], 0);
Ext.cmd.derive('procore.model.Meeting', Ext.data.Model, {fields:[{name:'id', type:'int'}, {name:'position', type:'int'}, {name:'title', type:'string'}, {name:'meeting_date', type:'string'}, {name:'meeting_date_formatted', type:'string', calculate:function(data) {
  return !data.meeting_date ? '' : Ext.Date.format(Ext.Date.parse(data.meeting_date, 'Y-m-d'), 'd/m/Y');
}}, {name:'displayField', type:'string', calculate:function(data) {
  var descs = ['#' + data.position];
  if (data.title) {
    descs.push(data.title);
  }
  if (data.meeting_date_formatted) {
    descs.push(data.meeting_date_formatted);
  }
  return descs.join(' - ');
}}]}, 0, 0, 0, 0, 0, 0, [procore.model, 'Meeting'], 0);
Ext.cmd.derive('procore.model.NotesLog', Ext.data.Model, {fields:[{name:'id', type:'int'}, {name:'position', type:'int'}, {name:'location'}, {name:'locationName', calculate:function(data) {
  return data.location && data.location.name ? data.location.name : '';
}}, {name:'displayField', mapping:'id'}, {name:'dateString', type:'string', calculate:function(data) {
  return formShared.IntegrationsUtil.getDisplayDateString(data);
}}, {name:'displayField', calculate:function(data) {
  var str = '#' + data.position;
  if (data.locationName) {
    str += ' - ' + data.locationName;
  }
  return str;
}}]}, 0, 0, 0, 0, 0, 0, [procore.model, 'NotesLog'], 0);
Ext.cmd.derive('procore.model.Observation', Ext.data.Model, {fields:[{name:'id', type:'int'}, {name:'number', type:'int'}, {name:'name', type:'string'}, {name:'type', type:'auto'}, {name:'displayField', type:'string', calculate:function(data) {
  return '#' + data.number + ' - ' + data.type.name + ' - ' + data.name;
}}]}, 0, 0, 0, 0, 0, 0, [procore.model, 'Observation'], 0);
Ext.cmd.derive('procore.model.ObservationType', Ext.data.Model, {fields:[{name:'id', type:'int'}, {name:'name', type:'string'}, {name:'category', type:'string'}]}, 0, 0, 0, 0, 0, 0, [procore.model, 'ObservationType'], 0);
Ext.cmd.derive('procore.model.PhotoCategory', Ext.data.Model, {fields:[{name:'id', type:'int'}, {name:'name', type:'string'}, {name:'displayField', type:'string', mapping:'name', persist:false}]}, 0, 0, 0, 0, 0, 0, [procore.model, 'PhotoCategory'], 0);
Ext.cmd.derive('procore.model.Project', Ext.data.Model, {fields:[{name:'id', type:'int'}, {name:'name', type:'string'}, {name:'display_name', type:'string'}, {name:'company', type:'auto'}]}, 0, 0, 0, 0, 0, 0, [procore.model, 'Project'], 0);
Ext.cmd.derive('procore.model.PunchItem', Ext.data.Model, {fields:[{name:'id', type:'int'}, {name:'position', type:'int'}, {name:'name', type:'string'}, {name:'assignments', type:'auto'}, {name:'due_date'}, {name:'status'}, {name:'assigneeNamesArray', calculate:function(data) {
  var assignments = data.assignments, assigneeNamesArray = [];
  if (!assignments) {
    return [];
  }
  for (var i = 0; i < assignments.length; i++) {
    assigneeNamesArray.push(assignments[i].name);
  }
  return assigneeNamesArray;
}}, {name:'vendorNamesArray', calculate:function(data) {
  var assignments = data.assignments, vendorNamesArray = [];
  if (!assignments) {
    return [];
  }
  for (var i = 0; i < assignments.length; i++) {
    var vendor = assignments[i].vendor;
    if (vendor) {
      vendorNamesArray.push(vendor.name);
    }
  }
  return vendorNamesArray;
}}, {name:'displayField', type:'int', calculate:function(data) {
  return '#' + data.position + ' - ' + data.name;
}}]}, 0, 0, 0, 0, 0, 0, [procore.model, 'PunchItem'], 0);
Ext.cmd.derive('procore.model.RFI', Ext.data.Model, {fields:[{name:'id', type:'int'}, {name:'number', type:'int'}, {name:'subject', type:'string'}, {name:'displayField', type:'string', calculate:function(data) {
  return '#' + data.number + ' - ' + data.subject;
}}, {name:'status', type:'string'}]}, 0, 0, 0, 0, 0, 0, [procore.model, 'RFI'], 0);
Ext.cmd.derive('procore.model.SafetyViolationLog', Ext.data.Model, {fields:[{name:'id', type:'int'}, {name:'position', type:'int'}, {name:'time_hour', type:'int'}, {name:'time_minute', type:'int'}, {name:'subject', type:'string'}, {name:'dateString', type:'string', calculate:function(data) {
  return formShared.IntegrationsUtil.getDisplayDateString(data);
}}, {name:'displayField', calculate:function(data) {
  var str = '#' + data.position + ' - ' + data.dateString;
  if (data.subject) {
    str += ' - ' + data.subject;
  }
  return str;
}}]}, 0, 0, 0, 0, 0, 0, [procore.model, 'SafetyViolationLog'], 0);
Ext.cmd.derive('procore.model.User', Ext.data.Model, {fields:[{name:'id', type:'int'}, {name:'number', type:'int'}, {name:'subject', type:'string'}]}, 0, 0, 0, 0, 0, 0, [procore.model, 'User'], 0);
Ext.cmd.derive('procore.model.WeatherLog', Ext.data.Model, {fields:[{name:'id', type:'int'}, {name:'displayField', mapping:'id'}, {name:'position', type:'int'}, {name:'time_hour', type:'int'}, {name:'time_minute', type:'int'}, {name:'temperature'}, {name:'wind'}, {name:'precipitation'}, {name:'dateString', type:'string', calculate:function(data) {
  return formShared.IntegrationsUtil.getDisplayDateString(data);
}}, {name:'displayField', calculate:function(data) {
  return '#' + data.position + ' - ' + data.dateString;
}}]}, 0, 0, 0, 0, 0, 0, [procore.model, 'WeatherLog'], 0);
Ext.cmd.derive('procore.store.AssigneeResponses', Ext.data.Store, {model:'procore.model.AssigneeResponse', proxy:{url:'/index.cfm?fuseaction\x3daProcore.getPunchAssignments'}}, 0, 0, 0, 0, 0, 0, [procore.store, 'AssigneeResponses'], 0);
Ext.cmd.derive('procore.store.ChangeEvents', Ext.data.Store, {model:'procore.model.ChangeEvent', proxy:{url:'/index.cfm?fuseaction\x3daProcore.getChangeEvents'}}, 0, 0, 0, 0, 0, 0, [procore.store, 'ChangeEvents'], 0);
Ext.cmd.derive('procore.store.Companies', Ext.data.Store, {model:'procore.model.Company', proxy:{url:'/index.cfm?fuseaction\x3daProcore.getCompanies'}}, 0, 0, 0, 0, ['store.procorecompanies'], 0, [procore.store, 'Companies'], 0);
Ext.cmd.derive('procore.store.CostCodes', Ext.data.Store, {model:'procore.model.CostCode', pageSize:1000, proxy:{url:'/index.cfm?fuseaction\x3daProcore.getCostCodes'}}, 0, 0, 0, 0, ['store.procorecostcodes'], 0, [procore.store, 'CostCodes'], 0);
Ext.cmd.derive('procore.store.DeliveryLogs', Ext.data.Store, {model:'procore.model.DeliveryLog', proxy:{url:'/index.cfm?fuseaction\x3daProcore.getDeliveryLogs'}}, 0, 0, 0, 0, 0, 0, [procore.store, 'DeliveryLogs'], 0);
Ext.cmd.derive('procore.store.Locations', Ext.data.Store, {model:'procore.model.Location', pageSize:1000, proxy:{url:'/index.cfm?fuseaction\x3daProcore.getLocations'}}, 0, 0, 0, 0, ['store.procorelocations'], 0, [procore.store, 'Locations'], 0);
Ext.cmd.derive('procore.store.ManpowerLogs', Ext.data.Store, {model:'procore.model.ManpowerLog', proxy:{url:'/index.cfm?fuseaction\x3daProcore.getManpowerLogs'}}, 0, 0, 0, 0, 0, 0, [procore.store, 'ManpowerLogs'], 0);
Ext.cmd.derive('procore.store.ManpowerLogsVendorOptions', Ext.data.Store, {model:'procore.model.ManpowerLogsVendorOption', proxy:{url:'/index.cfm?fuseaction\x3daProcore.getManpowerLogsVendorOptions'}}, 0, 0, 0, 0, ['store.manpowerlogsvendoroptions'], 0, [procore.store, 'ManpowerLogsVendorOptions'], 0);
Ext.cmd.derive('procore.store.Meetings', Ext.data.Store, {model:'procore.model.Meeting', proxy:{url:'/index.cfm?fuseaction\x3daProcore.getMeetings'}}, 0, 0, 0, 0, 0, 0, [procore.store, 'Meetings'], 0);
Ext.cmd.derive('procore.store.NotesLogs', Ext.data.Store, {model:'procore.model.NotesLog', proxy:{url:'/index.cfm?fuseaction\x3daProcore.getNotesLogs'}}, 0, 0, 0, 0, 0, 0, [procore.store, 'NotesLogs'], 0);
Ext.cmd.derive('procore.store.ObservationTypes', Ext.data.Store, {model:'procore.model.ObservationType', proxy:{url:'/index.cfm?fuseaction\x3daProcore.getObservationTypes'}}, 0, 0, 0, 0, ['store.procoreobservationtypes'], 0, [procore.store, 'ObservationTypes'], 0);
Ext.cmd.derive('procore.store.Observations', Ext.data.Store, {model:'procore.model.Observation', proxy:{url:'/index.cfm?fuseaction\x3daProcore.getObservationItems'}}, 0, 0, 0, 0, 0, 0, [procore.store, 'Observations'], 0);
Ext.cmd.derive('procore.store.PhotoCategories', Ext.data.Store, {model:'procore.model.PhotoCategory', proxy:{api:{create:'/index.cfm?fuseaction\x3daProcore.createImageCategory', read:'/index.cfm?fuseaction\x3daProcore.getPhotoCategories'}, writer:{writeAllFields:false}}}, 0, 0, 0, 0, 0, 0, [procore.store, 'PhotoCategories'], 0);
Ext.cmd.derive('procore.store.Projects', Ext.data.Store, {model:'procore.model.Project', proxy:{url:'/index.cfm?fuseaction\x3daProcore.getProjects'}}, 0, 0, 0, 0, ['store.procoreprojects'], 0, [procore.store, 'Projects'], 0);
Ext.cmd.derive('procore.store.PunchItems', Ext.data.Store, {model:'procore.model.PunchItem', pageSize:25, proxy:{url:'/index.cfm?fuseaction\x3daProcore.getPunchListItems'}}, 0, 0, 0, 0, 0, 0, [procore.store, 'PunchItems'], 0);
Ext.cmd.derive('procore.store.RFIs', Ext.data.Store, {model:'procore.model.RFI', remoteFilter:true, pageSize:25, proxy:{url:'/index.cfm?fuseaction\x3daProcore.getRFIs'}}, 0, 0, 0, 0, 0, 0, [procore.store, 'RFIs'], 0);
Ext.cmd.derive('procore.store.SafetyViolationLogs', Ext.data.Store, {model:'procore.model.SafetyViolationLog', proxy:{url:'/index.cfm?fuseaction\x3daProcore.getSafetyViolationLogs'}}, 0, 0, 0, 0, 0, 0, [procore.store, 'SafetyViolationLogs'], 0);
Ext.cmd.derive('procore.store.WeatherLogs', Ext.data.Store, {model:'procore.model.WeatherLog', proxy:{url:'/index.cfm?fuseaction\x3daProcore.getWeatherLogs'}}, 0, 0, 0, 0, 0, 0, [procore.store, 'WeatherLogs'], 0);
Ext.cmd.derive('procore.view.procorewindow.ProcoreWindowModel', Ext.app.ViewModel, {stores:{procoreCompanies:{type:'procorecompanies', autoLoad:true, mvAutoLoadVars:true}, procoreProjects:{proxy:{type:'memory'}}, manpowerLogsVendorOptions:{type:'manpowerlogsvendoroptions', mvAutoLoadVars:true}, locations:{type:'procorelocations', mvAutoLoadVars:true}, costCodes:{type:'procorecostcodes', mvAutoLoadVars:true}, observationTypes:{type:'procoreobservationtypes', mvAutoLoadVars:true}}, data:{private_procoreSetting_companyID:null, 
private_procoreSetting_projectID:null, private_procoreSetting_entityType:null, private_procoreSetting_attachAsPhoto:null, private_procoreSetting_attachAs4View:null, private_procoreSetting_dailyLogSubType:null, private_procoreSetting_punchlistAction:null, private_procoreSetting_observationAction:null, private_procoreSetting_photoAction:null, private_procoreSetting_photoCategoryID:null, private_procoreSetting_rfiFilterValue:null, entityID:'', projectsLoaded:false, dailyLogDate:new Date, procoreUserID:0, 
entityStoreLoaded:false, cardHeight:312, saving:false, saveDone:false, warningMessage:'', attachFloorplanOnly:false, _weatherLogConditions:'', _photoExifData:''}, formulas:{procoreSetting_companyID:{get:function(get) {
  var procoreSetting_companyID = get('private_procoreSetting_companyID');
  if (procoreSetting_companyID !== null) {
    return procoreSetting_companyID;
  }
  if (!get('globalPreferencesReady')) {
    return null;
  }
  return mdsPreferences.ProjectPreferences.getProcoreSetting_companyID();
}, set:function(value) {
  this.set('private_procoreSetting_companyID', value);
  mdsPreferences.ProjectPreferences.setProcoreSetting_companyID(value);
}}, procoreSetting_projectID:{get:function(get) {
  var procoreSetting_projectID = get('private_procoreSetting_projectID');
  if (procoreSetting_projectID !== null) {
    return procoreSetting_projectID;
  }
  if (!get('globalPreferencesReady')) {
    return null;
  }
  return mdsPreferences.ProjectPreferences.getProcoreSetting_projectID();
}, set:function(value) {
  this.set('private_procoreSetting_projectID', value);
  mdsPreferences.ProjectPreferences.setProcoreSetting_projectID(value);
}}, integrationEntityType:{get:function(get) {
  var integrationEntityType = get('private_procoreSetting_entityType');
  if (integrationEntityType !== null) {
    return integrationEntityType;
  }
  if (!get('globalPreferencesReady')) {
    return null;
  }
  integrationEntityType = mdsPreferences.ProjectPreferences.getProcoreSetting_entityType();
  return get('integrationEntityTypes').getById(integrationEntityType) ? integrationEntityType : '';
}, set:function(value) {
  this.set('private_procoreSetting_entityType', value);
  mdsPreferences.ProjectPreferences.setProcoreSetting_entityType(value);
}}, integrationAttachAsPhoto:{get:function(get) {
  var integrationAttachAsPhoto = get('private_procoreSetting_attachAsPhoto');
  if (integrationAttachAsPhoto !== null) {
    return integrationAttachAsPhoto;
  }
  if (!get('globalPreferencesReady')) {
    return null;
  }
  var pref = mdsPreferences.ProjectPreferences.getProcoreSetting_attachAsPhoto();
  return pref === undefined ? false : pref;
}, set:function(value) {
  this.set('private_procoreSetting_attachAsPhoto', value);
  mdsPreferences.ProjectPreferences.setProcoreSetting_attachAsPhoto(value);
}}, integrationAttachAs4View:{get:function(get) {
  var integrationAttachAs4View = get('private_procoreSetting_attachAs4View');
  if (integrationAttachAs4View !== null) {
    return integrationAttachAs4View;
  }
  if (!get('globalPreferencesReady')) {
    return null;
  }
  var pref = mdsPreferences.ProjectPreferences.getProcoreSetting_attachAs4View();
  return pref === undefined ? true : pref;
}, set:function(value) {
  this.set('private_procoreSetting_attachAs4View', value);
  mdsPreferences.ProjectPreferences.setProcoreSetting_attachAs4View(value);
}}, procoreSetting_dailyLogSubType:{get:function(get) {
  var procoreSetting_dailyLogSubType = get('private_procoreSetting_dailyLogSubType');
  if (procoreSetting_dailyLogSubType !== null) {
    return procoreSetting_dailyLogSubType;
  }
  if (!get('globalPreferencesReady')) {
    return null;
  }
  var value = mdsPreferences.ProjectPreferences.getProcoreSetting_dailyLogSubType();
  return value || 'WeatherLog';
}, set:function(value) {
  this.set('private_procoreSetting_dailyLogSubType', value);
  mdsPreferences.ProjectPreferences.setProcoreSetting_dailyLogSubType(value);
}}, procoreSetting_punchlistAction:{get:function(get) {
  var procoreSetting_punchlistAction = get('private_procoreSetting_punchlistAction');
  if (procoreSetting_punchlistAction !== null) {
    return procoreSetting_punchlistAction;
  }
  if (!get('globalPreferencesReady')) {
    return null;
  }
  var value = mdsPreferences.ProjectPreferences.getProcoreSetting_punchlistAction();
  return value || 'AssigneeResponse';
}, set:function(value) {
  this.set('private_procoreSetting_punchlistAction', value);
  mdsPreferences.ProjectPreferences.setProcoreSetting_punchlistAction(value);
}}, procoreSetting_observationAction:{get:function(get) {
  var procoreSetting_observationAction = get('private_procoreSetting_observationAction');
  if (procoreSetting_observationAction !== null) {
    return procoreSetting_observationAction;
  }
  if (!get('globalPreferencesReady')) {
    return null;
  }
  var value = mdsPreferences.ProjectPreferences.getProcoreSetting_observationAction();
  return value || 'ObservationCreate';
}, set:function(value) {
  this.set('private_procoreSetting_observationAction', value);
  mdsPreferences.ProjectPreferences.setProcoreSetting_observationAction(value);
}}, procoreSetting_photoAction:{get:function(get) {
  var procoreSetting_photoAction = get('private_procoreSetting_photoAction');
  if (procoreSetting_photoAction !== null) {
    return procoreSetting_photoAction;
  }
  if (!get('globalPreferencesReady')) {
    return null;
  }
  var value = mdsPreferences.ProjectPreferences.getProcoreSetting_photoAction();
  return value || 'AddToExistingAlbum';
}, set:function(value) {
  this.set('private_procoreSetting_photoAction', value);
  mdsPreferences.ProjectPreferences.setProcoreSetting_photoAction(value);
}}, procoreSetting_photoCategoryID:{get:function(get) {
  var procoreSetting_photoCategoryID = get('private_procoreSetting_photoCategoryID');
  if (procoreSetting_photoCategoryID !== null) {
    return procoreSetting_photoCategoryID;
  }
  if (!get('globalPreferencesReady')) {
    return null;
  }
  return mdsPreferences.ProjectPreferences.getProcoreSetting_photoCategoryID();
}, set:function(value) {
  this.set('private_procoreSetting_photoCategoryID', value);
  mdsPreferences.ProjectPreferences.setProcoreSetting_photoCategoryID(value);
}}, procoreSetting_rfiFilterValue:{get:function(get) {
  var procoreSetting_rfiFilterValue = get('private_procoreSetting_rfiFilterValue');
  if (procoreSetting_rfiFilterValue !== null) {
    return procoreSetting_rfiFilterValue;
  }
  if (!get('globalPreferencesReady')) {
    return null;
  }
  var value = mdsPreferences.ProjectPreferences.getProcoreSetting_rfiFilterValue();
  return value || 'open';
}, set:function(value) {
  this.set('private_procoreSetting_rfiFilterValue', value);
  mdsPreferences.ProjectPreferences.setProcoreSetting_rfiFilterValue(value);
}}, entityType:function(get) {
  return get('integrationEntityTypes').getById(get('integrationEntityType'));
}, entity:function(get) {
  var entityTypeID = get('integrationEntityType'), procoreUserID = get('procoreUserID');
  if (!entityTypeID || !procoreUserID) {
    return null;
  }
  var store = get('entityStore');
  if (!store || !get('entityStoreLoaded')) {
    return null;
  }
  return store.getById(get('calculatedEntityID'));
}, projectSelected:function(get) {
  return get('projectsLoaded') && get('procoreSetting_projectID');
}, subType:function(get) {
  var entityType = get('entityType');
  if (entityType) {
    var id = entityType.getId();
    if (id == 'DailyLog') {
      return get('procoreSetting_dailyLogSubType');
    }
    if (id == 'PunchList') {
      return get('procoreSetting_punchlistAction');
    }
    if (id == 'Observation') {
      return get('procoreSetting_observationAction');
    }
    if (id == 'Photos') {
      return get('procoreSetting_photoAction');
    }
  }
  return null;
}, calculatedEntityID:function(get) {
  if (get('subType') == 'AddToExistingAlbum') {
    return get('procoreSetting_photoCategoryID');
  }
  return get('entityID');
}, entityStoreID:function(get) {
  var entityType = get('entityType'), project_id = get('procoreSetting_projectID');
  if (!entityType) {
    return null;
  }
  var storeId = 'procore_' + entityType.get('name').replace(' ', '') + '_' + project_id;
  if (entityType.get('hasSubStores')) {
    storeId += '_' + get('subType');
  }
  if (entityType.getId() == 'DailyLog') {
    storeId += '_' + get('dailyLogDate');
  }
  return storeId;
}, entityStore:function(get) {
  var entityType = get('entityType'), procoreUserID = get('procoreUserID'), storeType = get('entityStoreType');
  if (!entityType || !procoreUserID || !storeType) {
    return Ext.create('Ext.data.Store', {proxy:'memory'});
  }
  var entityTypeID = get('entityType').getId(), storeId = get('entityStoreID'), store = Ext.getStore(storeId), controller = this.getView().lookupController();
  if (!store && get('procoreSetting_companyID') && get('procoreSetting_projectID')) {
    store = Ext.create(storeType, {storeId:storeId, autoLoad:true, proxy:{extraParams:controller.getEntityStoreParams(entityTypeID)}, listeners:{load:controller.onEntityStoreLoad, scope:controller}});
    controller.entityStores.push(store);
  }
  if (store) {
    this.set('entityStoreLoaded', store.isLoaded());
  }
  return store;
}, procorePunchListAssignees:function(get) {
  var projectID = get('procoreSetting_projectID');
  if (!projectID) {
    return Ext.create('Ext.data.Store', {proxy:{type:'memory'}});
  }
  var storeID = 'procorePunchlistAssignees-' + projectID, store = Ext.getStore(storeID);
  return store || Ext.create('Ext.data.Store', {model:'procore.model.User', proxy:{url:'/index.cfm?fuseaction\x3daProcore.getPunchListAssignees', extraParams:{project_id:projectID}}, mvAutoLoadVars:true, autoLoad:true, storeId:storeID});
}, procoreRFIAssignees:function(get) {
  var projectID = get('procoreSetting_projectID');
  if (!projectID) {
    return Ext.create('Ext.data.Store', {proxy:{type:'memory'}});
  }
  var storeID = 'procoreRFIAssignees-' + projectID, store = Ext.getStore(storeID);
  return store || Ext.create('Ext.data.Store', {model:'procore.model.User', proxy:{url:'/index.cfm?fuseaction\x3daProcore.getRFIAssignees', extraParams:{project_id:projectID}}, mvAutoLoadVars:true, autoLoad:true, storeId:storeID});
}, entityStoreType:function(get) {
  var entityType = get('entityType'), subType = get('subType');
  if (!entityType) {
    return null;
  }
  var storeType = entityType.get('storeType');
  if (!storeType) {
    if (!subType || subType.match('Create')) {
      return null;
    }
    return 'procore.store.' + subType + 's';
  }
  return storeType;
}, card:function(get) {
  var controller = this.getView().lookupController(), entityTypeID = get('integrationEntityType'), subType = get('subType'), project = get('procoreProject'), defaultCard = controller.lookupReference('card_default');
  return project ? controller.lookupReference('card_' + entityTypeID + '_' + subType) || controller.lookupReference('card_' + entityTypeID) || defaultCard : defaultCard;
}, subCard:function(get) {
  var card = get('card');
  if (card.xtype == 'procoredailylog') {
    return this.getView().lookupController().lookupReference('card_' + get('subType'));
  }
  return null;
}, itemDescription:function(get) {
  return get('integrationEntityType') == 'DailyLog' ? 'sub log item' : 'item';
}, lowercaseEntityName:function(get) {
  var entityType = get('entityType');
  if (!entityType) {
    return '';
  }
  var name = entityType.get('name');
  return name === 'RFI' ? name : name.toLowerCase();
}, emptyText:function(get) {
  var entityStore = get('entityStore'), entityStoreLoaded = get('entityStoreLoaded');
  if (!entityStore || !entityStoreLoaded || entityStore.getCount()) {
    return mvstr['G_Select'];
  }
  return mvstr['INT_No items available.'];
}, noItemsAvailable:function(get) {
  var entityStore = get('entityStore'), entityStoreLoaded = get('entityStoreLoaded');
  return !(!entityStore || !entityStoreLoaded || entityStore.getCount());
}, viewingManpowerLog:function(get) {
  return !!get('procoreSetting_dailyLogSubType').match('ManpowerLog');
}, viewingNotesLog:function(get) {
  return !!get('procoreSetting_dailyLogSubType').match('NotesLog');
}, entityClone:function(get) {
  var entity = get('entity');
  return entity ? entity.clone() : null;
}, weatherLogConditions:function(get) {
  if (!get('procoreSetting_projectID') || !get('procoreSetting_dailyLogSubType').match('WeatherLog')) {
    return null;
  }
  var conditions = get('_weatherLogConditions'), project_id = get('procoreSetting_projectID');
  if (conditions && conditions.project_id == project_id) {
    return conditions;
  }
  Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daProcore.getWeatherConditions', params:{project_id:project_id}, successCallback:function(data) {
    data.project_id = project_id;
    this.set('_weatherLogConditions', data);
  }, afterFailMessageCallback:function() {
    this.set('warningMessage', mvstr['PRO_Could not load weathe']);
  }, scope:this, noAlert:true});
  return null;
}, weatherTemperatures:function(get) {
  var conditions = get('weatherLogConditions');
  if (!conditions) {
    return null;
  }
  return Ext.create('Ext.data.Store', {proxy:'memory', fields:['key', 'value'], data:conditions.temperature});
}, weatherWinds:function(get) {
  var conditions = get('weatherLogConditions');
  if (!conditions) {
    return null;
  }
  return Ext.create('Ext.data.Store', {proxy:'memory', fields:['key', 'value'], data:conditions.wind});
}, noManpowerLogsVendorOptionsAvailable:function(get) {
  var store = get('manpowerLogsVendorOptions'), storeLoaded = get('_manpowerLogsVendorOptionsLoaded');
  return !(!store || !storeLoaded || store.getCount());
}, manpowerLogsVendorOptionsEmptyText:function(get) {
  return get('noManpowerLogsVendorOptionsAvailable') ? mvstr['PRO_No companies availabl'] : mvstr['G_Select'];
}, noLocationsAvailable:function(get) {
  var store = get('locations'), storeLoaded = get('_locationsLoaded');
  return !(!store || !storeLoaded || store.getCount());
}, locationsEmptyText:function(get) {
  return get('noLocationsAvailable') ? mvstr['PRO_No locations availabl'] : mvstr['G_Select'];
}, noCostCodesAvailable:function(get) {
  var store = get('costCodes'), storeLoaded = get('_costCodesLoaded');
  return !(!store || !storeLoaded || store.getCount());
}, costCodesEmptyText:function(get) {
  return get('noCostCodesAvailable') ? mvstr['PRO_No cost codes availab'] : mvstr['G_Select'];
}, photoExifData:function(get) {
  var photos = this.getView().getPhotos(), datePhoto = this.getView().getDatePhoto();
  if (photos.length != 1 || this.getView().getPhotoDate()) {
    return [];
  }
  var photoExifData = get('_photoExifData');
  if (photoExifData) {
    return photoExifData;
  }
  Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daClientPhotoViewer.getExifData', params:{id:datePhoto ? datePhoto.get('id') : photos[0], projectUID:get('ProjectUID'), webcamUID:''}, successCallback:function(data) {
    this.set('_photoExifData', data);
  }, afterFailMessageCallback:function() {
    return [];
  }, scope:this, noAlert:true});
  return null;
}, photoExifDateTime:function(get) {
  var photoDate = this.getView().getPhotoDate();
  if (!photoDate) {
    var photoExifData = get('photoExifData'), dateTimeStr = Ext.Date.format(new Date, 'Y-m-d H:i:s');
    if (!photoExifData) {
      return null;
    }
    for (var i = 0; i < photoExifData.length; i++) {
      if (Ext.Array.contains(['PhotoOriginalDate', 'Date/Time'], photoExifData[i].name)) {
        dateTimeStr = photoExifData[i].description;
        break;
      }
    }
    photoDate = Ext.Date.parse(dateTimeStr, 'Y-m-d H:i:s') || Ext.Date.parse(dateTimeStr, 'Y:m:d H:i:s');
  }
  return photoDate;
}, photoExifDateTimeStr:function(get) {
  return Ext.Date.format(get('photoExifDateTime'), 'Y-m-d H:i:s');
}, procoreProject:function(get) {
  var companyID = get('procoreSetting_companyID'), projectID = get('procoreSetting_projectID');
  if (!get('projectsLoaded') || !companyID || !projectID) {
    return null;
  }
  var store = get('procoreProjects');
  return store ? store.getById(projectID) : null;
}, dailyLogLabel:function(get) {
  var dailyLogDate = get('dailyLogDate');
  return mvstr['PRO_Logs for {x}'].replace('{x}', Ext.Date.format(dailyLogDate, mvstr['DATE_Short']));
}, integrationEntityTypes:function() {
  return Ext.create('Ext.data.Store', {proxy:{type:'memory'}, model:'formShared.model.IntegrationEntityType', data:[{id:'ChangeEvent', name:mvstr['PRO_Change Event'], storeType:'procore.store.ChangeEvents', createAction:'submitToChangeEvent', searchFields:['number', 'title']}, {id:'DailyLog', name:mvstr['PRO_Daily Log'], subCreateActions:{DeliveryLog:'submitToDeliveryLog', SafetyViolationLog:'submitToSafetyViolationLog', WeatherLog:'submitToWeatherLog', WeatherLogCreate:'createWeatherLog', ManpowerLog:'submitToManpowerLog', 
  ManpowerLogCreate:'createManpowerLog', NotesLog:'submitToNotesLog', NotesLogCreate:'createNotesLog'}, subSearchFields:{DeliveryLog:['position', 'dateString', 'delivery_from'], SafetyViolationLog:['position', 'dateString', 'subject'], WeatherLog:[], ManpowerLog:['position', 'contactName', 'locationName', 'costCodeName'], NotesLog:[]}, hasSubStores:true}, {id:'Observation', name:mvstr['PRO_Observation'], storeType:'procore.store.Observations', subCreateActions:{ObservationCreate:'createObservation', 
  ObservationItem:'submitToObservationItem', ObservationResponse:'submitToObservationResponse'}, searchFields:['number', 'name', 'type']}, {id:'Meeting', name:mvstr['PRO_Meeting'], storeType:'procore.store.Meetings', createAction:'submitToMeeting', searchFields:['position', 'title', 'meeting_date_formatted']}, {id:'Photos', name:mvstr['PRO_Photos'], storeType:'procore.store.PhotoCategories', createAction:'submitToPhotoCategory', searchFields:['name']}, {id:'PunchList', name:mvstr['PRO_Punch List - Update'], 
  subCreateActions:{AssigneeResponse:'submitToPunchAssignment', PunchItem:'submitToPunchListItem'}, subSearchFields:{AssigneeResponse:['position', 'name'], PunchItem:['position', 'name', 'assigneeNamesArray', 'vendorNamesArray']}, hasSubStores:true}, {id:'PunchListCreateItem', name:mvstr['PRO_Punch List - Create'], createAction:'createPunchlistItem'}, {id:'RFI', name:mvstr['PRO_RFI - Update'], storeType:'procore.store.RFIs', createAction:'submitToRFI', searchFields:['number', 'subject']}, {id:'RFICreate', 
  name:mvstr['PRO_RFI - Create'], createAction:'createRFI'}]});
}, procorePunchlistActions:function() {
  return Ext.create('Ext.data.Store', {proxy:{type:'memory'}, data:[{id:'PunchItem', name:mvstr['PRO_Update Status']}, {id:'AssigneeResponse', name:mvstr['PRO_Update Response']}]});
}, procoreAssigneeResponseStatuses:function() {
  return Ext.create('Ext.data.Store', {proxy:{type:'memory'}, data:[{name:mvstr['PRO_Unresolved'], value:false}, {name:mvstr['PRO_Resolved'], value:true}]});
}, procorePunchItemStatuses:function() {
  return Ext.create('Ext.data.Store', {proxy:{type:'memory'}, data:[{id:'Open', name:mvstr['PRO_Open']}, {id:'Closed', name:mvstr['PRO_Closed']}]});
}, procoreDailyLogTypes:function() {
  return Ext.create('Ext.data.Store', {proxy:{type:'memory'}, data:[{id:'DeliveryLog', name:mvstr['PRO_Delivery Log']}, {id:'SafetyViolationLog', name:mvstr['PRO_Safety Violation Log']}, {id:'WeatherLog', name:mvstr['PRO_Weather Log - Update']}, {id:'WeatherLogCreate', name:mvstr['PRO_Weather Log - Create']}, {id:'ManpowerLog', name:mvstr['PRO_Manpower Log - Update']}, {id:'ManpowerLogCreate', name:mvstr['PRO_Manpower Log - Create']}, {id:'NotesLog', name:mvstr['PRO_Notes Log - Update']}, {id:'NotesLogCreate', 
  name:mvstr['PRO_Notes Log - Create']}]});
}, procorePhotoActions:function() {
  return Ext.create('Ext.data.Store', {proxy:{type:'memory'}, data:[{id:'CreateNewAlbum', name:mvstr['PRO_Create New Album']}, {id:'AddToExistingAlbum', name:mvstr['PRO_Add to Existing Album']}]});
}, procoreRFIFilters:function() {
  return Ext.create('Ext.data.Store', {proxy:{type:'memory'}, data:[{value:mvstr['PRO_Open'], id:'open'}, {value:mvstr['PRO_Closed'], id:'closed'}, {value:mvstr['PRO_Draft'], id:'draft'}]});
}, procoreObservationActions:function() {
  return Ext.create('Ext.data.Store', {proxy:{type:'memory'}, data:[{id:'ObservationCreate', name:mvstr['PRO_Create']}, {id:'ObservationResponse', name:mvstr['PRO_Add Comment']}, {id:'ObservationItem', name:mvstr['PRO_Update Observation']}]});
}, procoreObservationStatuses:function() {
  return Ext.create('Ext.data.Store', {proxy:{type:'memory'}, data:[{id:'initiated', name:mvstr['PRO_Initiated']}, {id:'ready_for_review', name:mvstr['PRO_Ready For Review']}, {id:'not_accepted', name:mvstr['PRO_Not Accepted']}, {id:'closed', name:mvstr['PRO_Closed']}]});
}, punchlistPriorities:function() {
  return Ext.create('Ext.data.Store', {proxy:{type:'memory'}, data:[{id:'low', name:mvstr['PRO_Low']}, {id:'medium', name:mvstr['PRO_Medium']}, {id:'high', name:mvstr['PRO_High']}]});
}, observationPriorities:function() {
  return Ext.create('Ext.data.Store', {proxy:{type:'memory'}, data:[{id:'Low', name:mvstr['PRO_Low']}, {id:'Medium', name:mvstr['PRO_Medium']}, {id:'High', name:mvstr['PRO_High']}, {id:'Urgent', name:mvstr['PRO_Urgent']}]});
}}}, 0, 0, 0, 0, ['viewmodel.procorewindow'], 0, [procore.view.procorewindow, 'ProcoreWindowModel'], 0);
Ext.cmd.derive('procore.view.procorewindow.ProcoreWindowController', Ext.app.ViewController, {entityStores:[], init:function() {
  var vm = this.getViewModel();
  vm.bind('{procoreSetting_companyID}', this.onCompanyChange, this);
  vm.bind({_procoreCompaniesLoaded:'{_procoreCompaniesLoaded}', procoreSetting_companyID:'{procoreSetting_companyID}', procoreUserID:'{procoreUserID}', photoExifData:'{photoExifData}'}, function(data) {
    if (data._procoreCompaniesLoaded && data.procoreSetting_companyID !== null && data.procoreUserID && data.photoExifData) {
      this.onWindowReady();
    }
  }, this);
  vm.bind({card:'{card}', subCard:'{subCard}'}, this.onCardChange, this);
  vm.bind({procoreSetting_rfiFilterValue:'{procoreSetting_rfiFilterValue}', entityStore:'{entityStore}'}, function(data) {
    var rfi = vm.get('integrationEntityTypes').getById('RFI');
    if (data.entityStore && data.entityStore.$className == rfi.get('storeType')) {
      var filters = data.procoreSetting_rfiFilterValue.rfiFilter;
      var proxy = data.entityStore.getProxy(), params = proxy.getExtraParams();
      if (filters) {
        params.status = typeof filters == 'object' ? filters.join(',') : filters;
        proxy.setExtraParams(params);
        this.lookupReference('procoreRFILookup').loadPage(1);
      } else {
        if (params.status) {
          delete params.status;
          proxy.setExtraParams(params);
          this.lookupReference('procoreRFILookup').loadPage(1);
        }
      }
    }
  }, this);
  vm.bind({entityType:'{entityType}', entity:'{entity}'}, function(data) {
    if (data.entity && data.entity.get('status') && data.entityType.getId() === 'RFI') {
      var entityStatus = data.entity.get('status');
      if (entityStatus != 'draft') {
        this.getViewModel().get('procoreRFIFilters').filter({filterFn:function(item) {
          return item.getId() != 'draft';
        }});
      } else {
        this.getViewModel().get('procoreRFIFilters').clearFilter();
      }
      this.lookupReference('procoreRFIStatus').setValue(entityStatus);
    }
  }, this);
  vm.bind({viewingManpowerLog:'{viewingManpowerLog}', project_id:'{procoreSetting_projectID}', manpowerLogsVendorOptions:'{manpowerLogsVendorOptions}', costCodes:'{costCodes}'}, function(data) {
    if (data.viewingManpowerLog && data.project_id) {
      var stores = [data.manpowerLogsVendorOptions, data.costCodes];
      for (var i = 0; i < stores.length; i++) {
        if (stores[i]) {
          stores[i].getProxy().setExtraParams({project_id:data.project_id});
          stores[i].load();
        }
      }
    }
  }, this);
  vm.bind({viewingManpowerLog:'{viewingManpowerLog}', viewingNotesLog:'{viewingNotesLog}', project_id:'{procoreSetting_projectID}', locations:'{locations}'}, function(data) {
    if ((data.viewingManpowerLog || data.viewingNotesLog) && data.project_id && data.locations && data.locations.getProxy().getExtraParams().project_id != data.project_id) {
      data.locations.getProxy().setExtraParams({project_id:data.project_id});
      data.locations.load();
    }
  }, this);
  vm.bind({integrationEntityType:'{integrationEntityType}', project_id:'{procoreSetting_projectID}', observationTypes:'{observationTypes}'}, function(data) {
    if (data.integrationEntityType == 'Observation' && data.project_id) {
      var stores = [data.observationTypes];
      for (var i = 0; i < stores.length; i++) {
        if (stores[i]) {
          stores[i].getProxy().setExtraParams({project_id:data.project_id});
          stores[i].load();
        }
      }
    }
  }, this);
  Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daProcore.getUser', successCallback:function(data) {
    if (this.getViewModel()) {
      this.getViewModel().set('procoreUserID', data.id);
    }
  }, afterFailMessageCallback:function() {
    this.getView().destroy();
  }, scope:this});
  Ext.getBody().addListener('resize', this.onBrowserResize, this);
  Ext.defer(function() {
    this.getView().showBy(Ext.getBody(), 't-t', [0, this.getWindowOffset()]);
  }, 1, this);
}, onBoxReady:function() {
  this.getView().setLoading(true);
}, onWindowReady:function() {
  this.getView().setLoading(false);
}, onProjectsLoaded:function(projects) {
  var viewModel = this.getViewModel(), savedProjectID = viewModel.get('procoreSetting_projectID');
  viewModel.set('projectsLoaded', true);
  if (savedProjectID && projects.getById(savedProjectID)) {
    this.lookupReference('projects').setValue(savedProjectID);
  } else {
    this.lookupReference('projects').setValue('');
  }
}, onCompanyChange:function(companyID) {
  if (companyID) {
    this.getViewModel().set('procoreProjects', this.getProjectStore(companyID));
  }
  this.getViewModel().set('warningMessage', '');
}, onProjectChange:function(combo, projectID) {
  if (projectID) {
    this.getViewModel().set('procoreSetting_projectID', projectID);
  } else {
    this.getViewModel().set('entityID', '');
  }
  this.getViewModel().set('warningMessage', '');
}, getProjectStoreID:function(companyID) {
  return 'procoreProjectStore-' + companyID;
}, getProjectStore:function(companyID) {
  if (!companyID) {
    return Ext.create('Ext.data.Store', {proxy:{type:'memory'}});
  }
  var storeID = this.getProjectStoreID(companyID), store = Ext.getStore(storeID);
  this.getViewModel().set('projectsLoaded', store && store.isLoaded());
  return store || Ext.create('procore.store.Projects', {autoLoad:true, proxy:{extraParams:{company_id:companyID}}, listeners:{load:{fn:this.onProjectsLoaded, scope:this}}});
}, getEntityStoreId:function(entityTypeID) {
  var entityType = this.getViewModel().get('integrationEntityTypes').getById(entityTypeID), project_id = this.getViewModel().get('procoreSetting_projectID');
  var storeId = 'procore_' + entityType.get('name').replace(' ', '') + '_' + project_id;
  if (entityType.get('subCreateActions')) {
    storeId += '_' + this.getViewModel().get('subType');
  }
  return storeId;
}, getEntityStoreParams:function(entityTypeID) {
  var viewModel = this.getViewModel(), extraParams = {project_id:viewModel.get('procoreSetting_projectID')};
  if (viewModel.get('integrationEntityType') == 'DailyLog') {
    extraParams.log_date = Ext.Date.format(viewModel.get('dailyLogDate'), 'Y-m-d');
  }
  return extraParams;
}, getCreateAction:function() {
  var entityType = this.getViewModel().get('integrationEntityTypes').getById(this.getViewModel().get('integrationEntityType')), subType = this.getViewModel().get('subType'), subCreateActions = entityType.get('subCreateActions');
  return subCreateActions ? entityType.get('subCreateActions')[subType] : entityType.get('createAction');
}, getSubmitParams:function(data) {
  var viewModel = this.getViewModel(), photos = this.getView().getPhotos(), entityID = data && data.id ? data.id : viewModel.get('calculatedEntityID'), card = viewModel.get('subCard') || viewModel.get('card'), form = card, pushpinUID = this.getView().getPushpinUID(), entity = viewModel.get('entity'), displayField = data && data.displayField ? data.displayField : entity ? entity.get('displayField') : '', Photo360ID = this.getView().getPhoto360ID(), params = {ProjectUID:viewModel.get('ProjectUID'), 
  photos:photos.join(','), project_id:viewModel.get('private_procoreSetting_projectID'), dateString:Ext.Date.format(new Date, 'ymd'), includeAnnotations:this.getView().getIncludeAnnotations(), displayName:displayField, projectName:viewModel.get('procoreProjects').getById(viewModel.get('procoreSetting_projectID')).get('name'), asynchronous:this.isAsyncUpload(), time_zone:viewModel.get('procoreProject.time_zone')};
  if (entityID) {
    params.id = entityID;
  }
  if (pushpinUID) {
    params.PushpinUID = pushpinUID;
  }
  if (Photo360ID) {
    params.Photo360ID = Photo360ID;
  }
  if (form.getValues) {
    Ext.mergeIf(params, form.getValues());
  }
  params.attachAsFloorplan = this.getViewModel().get('attachFloorplanOnly');
  if (params.attachAsFloorplan) {
    params.attachAsPhoto = params.attachAs4View = false;
    params.FloorplanUID = viewModel.get('FloorplanUID');
  }
  return params;
}, isAsyncUpload:function() {
  var viewModel = this.getViewModel(), entityTypeObj = viewModel.get('entityType');
  if (!entityTypeObj) {
    return false;
  }
  var entityType = entityTypeObj.getId(), asyncUpload = viewModel.get('account.features.uploadscenterVisible');
  if (Ext.Array.contains(['RFICreate', 'RFI'], entityType) && (this.getView().getPhotos().length > 1 || viewModel.get('integrationAttachAsPhoto') && viewModel.get('integrationAttachAs4View'))) {
    asyncUpload = false;
  }
  return asyncUpload;
}, submitPhotos:function(data) {
  var viewModel = this.getViewModel(), asyncUpload = this.isAsyncUpload(), card = viewModel.get('subCard') || viewModel.get('card'), warning = '';
  if (!viewModel.get('procoreProject')) {
    warning = mvstr['PROMSG_NoProject'];
  } else {
    if (!viewModel.get('integrationEntityType')) {
      warning = mvstr['INTMSG_NoType'];
    }
  }
  var errors = card.getErrors();
  if (errors.length) {
    warning = errors[0];
  }
  viewModel.set('warningMessage', warning);
  if (warning) {
    return;
  }
  viewModel.set('saving', true);
  if (viewModel.get('subType') == 'CreateNewAlbum' && !data) {
    this.createNewAlbum();
    return;
  }
  var params = this.getSubmitParams(data);
  Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daProcore.' + this.getCreateAction(), params:params, successCallback:function(data) {
    if (asyncUpload) {
      window.app.fireEvent('reloadfileuploads', {sourceType:'integration', responseData:data, photos:params.photos.split(',')});
    } else {
      viewModel.set('saveDone', true);
    }
    if (data && data.callback) {
      data.callback();
    }
    Ext.defer(function() {
      this.getView().destroy();
    }, 1000, this);
  }, afterFailMessageCallback:function(data, message) {
    viewModel.set('saving', false);
    viewModel.set('warningMessage', message ? message : mvstr.G_UnexpectedError);
  }, noAlert:true, scope:this});
  this.logExportAnalyticsEvent(params);
}, logExportAnalyticsEvent:function(params) {
  if (params.attachAsFloorplan) {
    analytics.Ctrl.log('Exported Floorplan', {'Floorplan UID':params.FloorplanUID, 'Integration':'Procore'});
  } else {
    var action = 'Photo Viewer Menu';
    if (location.href.toLowerCase().indexOf('clientphotolist') !== -1) {
      action = 'Photo List Menu';
    }
    analytics.Ctrl.log('Exported Photo', {'Photo List':params.photos, 'Photo Action Element':action, 'Integration':'Procore'});
  }
}, createNewAlbum:function() {
  var viewModel = this.getViewModel(), store = viewModel.get('entityStore'), record = Ext.create('procore.model.PhotoCategory', {name:this.lookupReference('procoreNewAlbumName').getValue()});
  store.add(record);
  store.sync({success:function() {
    var id = record.getId();
    this.submitPhotos({id:id, displayField:record.get('displayField'), callback:function() {
      viewModel.set('procoreSetting_photoAction', 'AddToExistingAlbum');
      viewModel.set('procoreSetting_photoCategoryID', id);
    }});
  }, afterFailMessageCallback:function(batch, message) {
    store.rejectChanges();
    viewModel.set('saving', false);
    viewModel.set('warningMessage', message ? message : mvstr.G_UnexpectedError);
  }, scope:this, noAlert:true});
}, onCardChange:function(data) {
  if (data.card) {
    this.lookupReference('cards').setActiveItem(data.card);
    if (data.subCard) {
      data.card.down('#subCards').setActiveItem(data.subCard);
    }
  }
  this.getViewModel().set('warningMessage', '');
}, onEntityStoreLoad:function(store) {
  if (store == this.getViewModel().get('entityStore')) {
    this.getViewModel().set('entityStoreLoaded', true);
  }
}, getWindowOffset:function() {
  return Math.min(102, Math.max(0, Ext.getBody().getHeight() - this.getView().el.getHeight()));
}, onBrowserResize:function() {
  var bodyHeight = Ext.getBody().getHeight(), windowHeight = Math.min(this.getView().getDefaultHeight(), bodyHeight);
  this.getView().setHeight(windowHeight);
  this.getView().alignTo(Ext.getBody(), 't-t', [0, this.getWindowOffset()]);
}}, 0, 0, 0, 0, ['controller.procorewindow'], 0, [procore.view.procorewindow, 'ProcoreWindowController'], 0);
Ext.cmd.derive('procore.view.cards.Default', Ext.form.Panel, {reference:'card_default', items:[{xtype:'integrationtype', hidden:true, bind:{hidden:'{!procoreProject}'}}]}, 0, ['procoredefault'], ['component', 'box', 'container', 'panel', 'form', 'procoredefault'], {'component':true, 'box':true, 'container':true, 'panel':true, 'form':true, 'procoredefault':true}, ['widget.procoredefault'], 0, [procore.view.cards, 'Default'], 0);
Ext.cmd.derive('procore.view.cards.ChangeEvent', Ext.form.Panel, {reference:'card_ChangeEvent', layout:'vbox', items:[{xtype:'container', layout:'hbox', width:'100%', margin:'0 0 28 0', items:[{xtype:'integrationtype'}, {xtype:'component', flex:1}, {xtype:'integrationlookup'}]}, {xtype:'integrationcomments'}, {xtype:'integrationattachment'}]}, 0, ['procorechangeevent'], ['component', 'box', 'container', 'panel', 'form', 'procorechangeevent'], {'component':true, 'box':true, 'container':true, 'panel':true, 
'form':true, 'procorechangeevent':true}, ['widget.procorechangeevent'], 0, [procore.view.cards, 'ChangeEvent'], 0);
Ext.cmd.derive('procore.view.cards.DailyLog', Ext.form.Panel, {reference:'card_DailyLog', layout:'fit', dockedItems:[{xtype:'container', layout:'hbox', width:'100%', margin:'0 0 28 0', dock:'top', items:[{xtype:'integrationtype'}, {xtype:'component', flex:1}, {xtype:'integrationssubtype', bind:{store:'{procoreDailyLogTypes}', value:'{procoreSetting_dailyLogSubType}'}}]}], items:[{xtype:'panel', itemId:'subCards', layout:'card', items:[{xtype:'procoredeliverylog'}, {xtype:'procoresafetyviolationlog'}, 
{xtype:'procoreweatherlog'}, {xtype:'procoreweatherlogcreate'}, {xtype:'procoremanpowerlog'}, {xtype:'procoremanpowerlogcreate'}, {xtype:'procorenoteslog'}, {xtype:'procorenoteslogcreate'}]}]}, 0, ['procoredailylog'], ['component', 'box', 'container', 'panel', 'form', 'procoredailylog'], {'component':true, 'box':true, 'container':true, 'panel':true, 'form':true, 'procoredailylog':true}, ['widget.procoredailylog'], 0, [procore.view.cards, 'DailyLog'], 0);
Ext.cmd.derive('procore.view.cards.Documents', Ext.form.Panel, {reference:'card_Documents', layout:'vbox', items:[{xtype:'integrationtype', margin:'0 0 28 0'}, {xtype:'detailformtextfield', reference:'procoreDocumentTitle', localized:{fieldLabel:'PRO_Title', emptyText:'PRO_Enter title'}, margin:'0 0 28 0', width:'100%', name:'title', allowBlank:false}, {xtype:'integrationattachment'}]}, 0, ['procoredocuments'], ['component', 'box', 'container', 'panel', 'form', 'procoredocuments'], {'component':true, 
'box':true, 'container':true, 'panel':true, 'form':true, 'procoredocuments':true}, ['widget.procoredocuments'], 0, [procore.view.cards, 'Documents'], 0);
Ext.cmd.derive('procore.view.cards.Meeting', Ext.form.Panel, {reference:'card_Meeting', layout:'vbox', items:[{xtype:'container', layout:'hbox', width:'100%', margin:'0 0 28 0', items:[{xtype:'integrationtype'}, {xtype:'component', flex:1}, {xtype:'integrationlookup'}]}, {xtype:'integrationattachment'}]}, 0, ['procoremeeting'], ['component', 'box', 'container', 'panel', 'form', 'procoremeeting'], {'component':true, 'box':true, 'container':true, 'panel':true, 'form':true, 'procoremeeting':true}, ['widget.procoremeeting'], 
0, [procore.view.cards, 'Meeting'], 0);
Ext.cmd.derive('procore.view.form.ObservationStatus', formShared.view.components.Combo, {width:202, localized:{fieldLabel:'PRO_Response Status', emptyText:'G_Select'}, displayField:'name', valueField:'id', allowBlank:true, name:'status', bind:{store:'{procoreObservationStatuses}'}}, 0, ['procoreobservationstatus'], ['component', 'box', 'field', 'textfield', 'pickerfield', 'combobox', 'combo', 'detailformcombo', 'procoreobservationstatus'], {'component':true, 'box':true, 'field':true, 'textfield':true, 
'pickerfield':true, 'combobox':true, 'combo':true, 'detailformcombo':true, 'procoreobservationstatus':true}, ['widget.procoreobservationstatus'], 0, [procore.view.form, 'ObservationStatus'], 0);
Ext.cmd.derive('procore.view.cards.Observation', Ext.form.Panel, {layout:'vbox', items:[{xtype:'container', layout:'hbox', width:'100%', margin:'0 0 28 0', items:[{xtype:'integrationtype'}, {xtype:'component', flex:1}, {xtype:'integrationssubtype', bind:{store:'{procoreObservationActions}', value:'{procoreSetting_observationAction}'}}]}, {xtype:'integrationlookup', width:'100%', margin:'0 0 28 0'}, {xtype:'procoreobservationstatus', margin:'0 0 28 0', bind:{value:'{entityClone.status}'}, name:'status'}, 
{xtype:'integrationcomments'}, {xtype:'integrationattachment'}]}, 0, ['procoreobservation'], ['component', 'box', 'container', 'panel', 'form', 'procoreobservation'], {'component':true, 'box':true, 'container':true, 'panel':true, 'form':true, 'procoreobservation':true}, ['widget.procoreobservation'], 0, [procore.view.cards, 'Observation'], 0);
Ext.cmd.derive('procore.view.cards.ObservationCreate', Ext.form.Panel, {reference:'card_Observation_ObservationCreate', layout:'vbox', items:[{xtype:'container', layout:'hbox', width:'100%', margin:'0 0 28 0', items:[{xtype:'integrationtype'}, {xtype:'component', flex:1}, {xtype:'integrationssubtype', bind:{store:'{procoreObservationActions}', value:'{procoreSetting_observationAction}'}}]}, {layout:'hbox', width:'100%', margin:'0 0 28 0', items:[{xtype:'detailformgroupedcombo', localized:{fieldLabel:'PRO_Type'}, 
width:202, bind:{store:'{observationTypes}'}, name:'type_id', allowBlank:false}, {xtype:'component', flex:1}, {xtype:'procoreobservationstatus', localized:{fieldLabel:'PRO_Status'}, value:'initiated', name:'status'}]}, {layout:'hbox', width:'100%', margin:'0 0 28 0', items:[{xtype:'detailformtextfield', localized:{fieldLabel:'PRO_Title'}, width:202, name:'name', allowBlank:false}, {xtype:'component', flex:1}, {xtype:'detailformcombo', width:202, localized:{fieldLabel:'PRO_Priority', emptyText:'G_Select'}, 
displayField:'name', valueField:'id', allowBlank:true, bind:{store:'{observationPriorities}'}, name:'priority'}]}, {layout:{type:'hbox', align:'bottom'}, width:'100%', margin:'0 0 28 0', items:[{xtype:'datefield', mvPickerUI:'mds-light', cls:'with-icon', labelAlign:'top', width:202, ui:'detail-form', localized:{fieldLabel:'PRO_Due Date'}, labelSeparator:'', value:new Date, name:'due_date', submitFormat:'Y-m-d'}, {xtype:'component', flex:1}, {xtype:'checkboxfield', ui:'plain-16', localized:{boxLabel:'PRO_Private'}, 
name:'personal', value:true, inputValue:true, uncheckedValue:false}]}, {xtype:'integrationcomments', localized:{fieldLabel:'PRO_Description'}, name:'description', allowBlank:false}, {xtype:'integrationattachment'}]}, 0, ['procoreobservationcreate'], ['component', 'box', 'container', 'panel', 'form', 'procoreobservationcreate'], {'component':true, 'box':true, 'container':true, 'panel':true, 'form':true, 'procoreobservationcreate':true}, ['widget.procoreobservationcreate'], 0, [procore.view.cards, 
'ObservationCreate'], 0);
Ext.cmd.derive('procore.view.cards.PhotosExistingAlbum', Ext.form.Panel, {reference:'card_Photos_AddToExistingAlbum', layout:'vbox', items:[{xtype:'container', layout:'hbox', width:'100%', margin:'0 0 28 0', items:[{xtype:'integrationtype'}, {xtype:'component', flex:1}, {xtype:'integrationssubtype', bind:{store:'{procorePhotoActions}', value:'{procoreSetting_photoAction}'}}]}, {xtype:'integrationlookup', width:'100%', localized:{fieldLabel:'PRO_Album', emptyText:'G_Select'}, bind:{value:'{procoreSetting_photoCategoryID}'}}]}, 
0, ['procorephotosexistingalbum'], ['component', 'box', 'container', 'panel', 'form', 'procorephotosexistingalbum'], {'component':true, 'box':true, 'container':true, 'panel':true, 'form':true, 'procorephotosexistingalbum':true}, ['widget.procorephotosexistingalbum'], 0, [procore.view.cards, 'PhotosExistingAlbum'], 0);
Ext.cmd.derive('procore.view.cards.PhotosNewAlbum', Ext.form.Panel, {reference:'card_Photos_CreateNewAlbum', layout:'vbox', items:[{xtype:'container', layout:'hbox', width:'100%', margin:'0 0 28 0', items:[{xtype:'integrationtype'}, {xtype:'component', flex:1}, {xtype:'integrationssubtype', bind:{store:'{procorePhotoActions}', value:'{procoreSetting_photoAction}'}}]}, {xtype:'detailformtextfield', reference:'procoreNewAlbumName', localized:{fieldLabel:'PRO_Name New Album', emptyText:'PRO_Enter new album name'}, 
width:'100%', publishes:'value', allowBlank:false}]}, 0, ['procorephotosnewalbum'], ['component', 'box', 'container', 'panel', 'form', 'procorephotosnewalbum'], {'component':true, 'box':true, 'container':true, 'panel':true, 'form':true, 'procorephotosnewalbum':true}, ['widget.procorephotosnewalbum'], 0, [procore.view.cards, 'PhotosNewAlbum'], 0);
Ext.cmd.derive('procore.view.cards.PunchListAssignment', Ext.form.Panel, {reference:'card_PunchList_AssigneeResponse', layout:'vbox', items:[{xtype:'container', layout:'hbox', width:'100%', margin:'0 0 28 0', items:[{xtype:'integrationtype'}, {xtype:'component', flex:1}, {xtype:'integrationssubtype', bind:{store:'{procorePunchlistActions}', value:'{procoreSetting_punchlistAction}'}}]}, {xtype:'container', layout:'hbox', width:'100%', margin:'0 0 28 0', items:[{xtype:'integrationlookup'}, {xtype:'component', 
flex:1}, {xtype:'detailformcombo', reference:'procorePunchAssignmentStatus', width:202, localized:{fieldLabel:'PRO_Response Status'}, displayField:'name', valueField:'value', bind:{store:'{procoreAssigneeResponseStatuses}', value:'{entityClone.approved}'}, name:'approved'}]}, {xtype:'integrationcomments'}, {xtype:'integrationattachment'}]}, 0, ['procorepunchlistassignment'], ['component', 'box', 'container', 'panel', 'form', 'procorepunchlistassignment'], {'component':true, 'box':true, 'container':true, 
'panel':true, 'form':true, 'procorepunchlistassignment':true}, ['widget.procorepunchlistassignment'], 0, [procore.view.cards, 'PunchListAssignment'], 0);
Ext.cmd.derive('procore.view.cards.PunchListCreateItem', Ext.form.Panel, {reference:'card_PunchListCreateItem', layout:'vbox', items:[{xtype:'integrationtype', margin:'0 0 28 0'}, {xtype:'container', layout:{type:'hbox', align:'bottom'}, width:'100%', margin:'0 0 28 0', items:[{xtype:'detailformtextfield', localized:{fieldLabel:'PRO_Title'}, width:202, allowBlank:false, name:'title'}, {xtype:'component', flex:1}, {xtype:'procoreuser', width:202, bind:{store:'{procorePunchListAssignees}'}, name:'assignees'}]}, 
{xtype:'container', layout:'hbox', width:'100%', margin:'0 0 28 0', items:[{xtype:'detailformcombo', width:202, localized:{fieldLabel:'PRO_Priority', emptyText:'G_Select'}, displayField:'name', valueField:'id', bind:{store:'{punchlistPriorities}'}, allowBlank:false, name:'priority'}, {xtype:'component', flex:1}, {xtype:'datefield', mvPickerUI:'mds-light', cls:'with-icon', labelAlign:'top', width:202, ui:'detail-form', localized:{fieldLabel:'PRO_Due Date'}, labelSeparator:'', value:new Date, name:'dueDate', 
submitFormat:'Y-m-d'}]}, {xtype:'integrationcomments'}, {xtype:'integrationattachment'}]}, 0, ['procorepunchlistcreateitem'], ['component', 'box', 'container', 'panel', 'form', 'procorepunchlistcreateitem'], {'component':true, 'box':true, 'container':true, 'panel':true, 'form':true, 'procorepunchlistcreateitem':true}, ['widget.procorepunchlistcreateitem'], 0, [procore.view.cards, 'PunchListCreateItem'], 0);
Ext.cmd.derive('procore.view.cards.PunchListUpdateItem', Ext.form.Panel, {reference:'card_PunchList_PunchItem', layout:'vbox', items:[{xtype:'container', layout:'hbox', width:'100%', margin:'0 0 28 0', items:[{xtype:'integrationtype'}, {xtype:'component', flex:1}, {xtype:'integrationssubtype', bind:{store:'{procorePunchlistActions}', value:'{procoreSetting_punchlistAction}'}}]}, {xtype:'integrationremotelookup', localized:{fieldLabel:'PRO_Punch List Item'}, width:'100%', margin:'0 0 28 0'}, {xtype:'container', 
layout:'hbox', width:'100%', margin:'0 0 28 0', items:[{xtype:'detailformcombo', reference:'procorePunchItemStatus', width:202, localized:{fieldLabel:'PRO_Update Status'}, displayField:'name', valueField:'id', bind:{store:'{procorePunchItemStatuses}', value:'{entityClone.status}'}, name:'status'}, {xtype:'component', flex:1}, {xtype:'datefield', mvPickerUI:'mds-light', cls:'with-icon', labelAlign:'top', width:202, ui:'detail-form', localized:{fieldLabel:'PRO_Due Date'}, labelSeparator:'', bind:{value:'{entityClone.due_date}'}, 
name:'dueDate', submitFormat:'Y-m-d'}]}, {xtype:'integrationcomments'}, {xtype:'integrationattachment'}]}, 0, ['procorepunchlistupdateitem'], ['component', 'box', 'container', 'panel', 'form', 'procorepunchlistupdateitem'], {'component':true, 'box':true, 'container':true, 'panel':true, 'form':true, 'procorepunchlistupdateitem':true}, ['widget.procorepunchlistupdateitem'], 0, [procore.view.cards, 'PunchListUpdateItem'], 0);
Ext.cmd.derive('procore.view.form.User', formShared.view.components.ComboMultiselect, {width:'100%', localized:{fieldLabel:'PRO_Assignee', emptyText:'G_Select'}, queryMode:'local', displayField:'name', valueField:'id', editable:true, typeAhead:true, bind:{value:{bindTo:'{procoreUserID}', single:true}}, getSubmitData:function() {
  return {assignees:this.getValue().join()};
}}, 0, ['procoreuser'], ['component', 'box', 'field', 'textfield', 'pickerfield', 'combobox', 'combo', 'tagfield', 'detailformmulticombo', 'procoreuser'], {'component':true, 'box':true, 'field':true, 'textfield':true, 'pickerfield':true, 'combobox':true, 'combo':true, 'tagfield':true, 'detailformmulticombo':true, 'procoreuser':true}, ['widget.procoreuser'], 0, [procore.view.form, 'User'], 0);
Ext.cmd.derive('procore.view.cards.RFICreate', Ext.form.Panel, {reference:'card_RFICreate', layout:'vbox', items:[{xtype:'integrationtype', margin:'0 0 28 0'}, {xtype:'container', layout:{type:'hbox', align:'bottom'}, width:'100%', margin:'0 0 28 0', items:[{xtype:'detailformtextfield', localized:{fieldLabel:'PRO_Subject'}, width:202, allowBlank:false, name:'title'}, {xtype:'component', flex:1}, {xtype:'procoreuser', width:202, bind:{store:'{procoreRFIAssignees}'}, allowBlank:false, name:'assignees'}]}, 
{xtype:'container', layout:{type:'hbox', align:'bottom'}, width:'100%', margin:'0 0 28 0', items:[{xtype:'datefield', mvPickerUI:'mds-light', cls:'with-icon', labelAlign:'top', width:202, ui:'detail-form', localized:{fieldLabel:'PRO_Due Date'}, labelSeparator:'', name:'dueDate', submitFormat:'Y-m-d'}, {xtype:'component', flex:1}, {xtype:'checkboxfield', ui:'plain-16', localized:{boxLabel:'PRO_Draft'}, checked:true, margin:'0 28 0 0', inputValue:true, uncheckedValue:false, name:'draft'}, {xtype:'checkboxfield', 
reference:'procoreRFIPrivate', ui:'plain-16', localized:{boxLabel:'PRO_Private'}, inputValue:true, uncheckedValue:false, name:'private'}]}, {xtype:'integrationcomments', localized:{fieldLabel:'PRO_Question'}, reference:'procoreRFIQuestion', allowBlank:false}, {xtype:'integrationattachment'}]}, 0, ['procorerficreate'], ['component', 'box', 'container', 'panel', 'form', 'procorerficreate'], {'component':true, 'box':true, 'container':true, 'panel':true, 'form':true, 'procorerficreate':true}, ['widget.procorerficreate'], 
0, [procore.view.cards, 'RFICreate'], 0);
Ext.cmd.derive('procore.view.cards.RFIUpdate', Ext.form.Panel, {reference:'card_RFI', layout:'vbox', items:[{xtype:'integrationtype', margin:'0 0 28 0', width:202}, {xtype:'container', layout:{type:'hbox', align:'bottom'}, width:'100%', items:[{xtype:'label', text:'RFI', uiCls:'form-item-label-detail-form'}, {xtype:'component', flex:1}, {xtype:'checkboxgroup', localized:{fieldLabel:'PRO_Filter'}, labelStyle:'font-family: Arial, sans-serif; padding-top: 2px;', labelWidth:40, padding:0, publishes:'rfiFilter.value', 
defaults:{name:'rfiFilter', ui:'plain-16', margin:'0 0 0 8'}, items:[{localized:{boxLabel:'PRO_Open'}, inputValue:'open'}, {localized:{boxLabel:'PRO_Closed'}, inputValue:'closed'}, {localized:{boxLabel:'PRO_Draft'}, inputValue:'draft'}], bind:{value:'{procoreSetting_rfiFilterValue}'}}]}, {xtype:'integrationremotelookup', reference:'procoreRFILookup', margin:'0 0 28 0', width:'100%', fieldLabel:''}, {xtype:'container', layout:{type:'hbox', align:'bottom'}, width:'100%', margin:'0 0 28 0', items:[{xtype:'detailformcombo', 
width:202, localized:{fieldLabel:'PRO_Update Status'}, valueField:'id', displayField:'value', reference:'procoreRFIStatus', bind:{store:'{procoreRFIFilters}'}, name:'status'}, {xtype:'component', flex:1}, {xtype:'checkboxfield', ui:'plain-16', localized:{boxLabel:'PRO_Official Response'}, name:'replyOfficial', inputValue:true, uncheckedValue:false}]}, {xtype:'integrationcomments'}, {xtype:'integrationattachment'}]}, 0, ['procorerfiupdate'], ['component', 'box', 'container', 'panel', 'form', 'procorerfiupdate'], 
{'component':true, 'box':true, 'container':true, 'panel':true, 'form':true, 'procorerfiupdate':true}, ['widget.procorerfiupdate'], 0, [procore.view.cards, 'RFIUpdate'], 0);
Ext.cmd.derive('procore.view.cards.dailylogs.DeliveryLog', Ext.form.Panel, {reference:'card_DeliveryLog', layout:'vbox', items:[{xtype:'procoreloglookup', margin:'0 0 11 0'}, {xtype:'integrationcomments'}, {xtype:'integrationattachment'}]}, 0, ['procoredeliverylog'], ['component', 'box', 'container', 'panel', 'form', 'procoredeliverylog'], {'component':true, 'box':true, 'container':true, 'panel':true, 'form':true, 'procoredeliverylog':true}, ['widget.procoredeliverylog'], 0, [procore.view.cards.dailylogs, 
'DeliveryLog'], 0);
Ext.cmd.derive('procore.view.cards.dailylogs.LogLookup', Ext.Container, {layout:'vbox', width:'100%', items:[{xtype:'container', layout:{type:'hbox', align:'bottom'}, width:'100%', items:[{xtype:'integrationlookup', width:408, bind:{fieldLabel:'{dailyLogLabel}'}, getErrors:function() {
  if (!this.getStore() || !this.getStore().getCount()) {
    return [mvstr['INTMSG_NoItems']];
  }
  if (!this.getValue()) {
    return [mvstr['PROMSG_NoSubLogItem']];
  }
  return [];
}}, {xtype:'datefield', mvPickerUI:'mds-light', cls:'with-icon no-date-display', width:30, ui:'detail-form', reference:'dailyLogDate', name:'date', submitFormat:'Y-m-d', maxValue:new Date, bind:{value:'{dailyLogDate}'}}]}, {xtype:'component', cls:'info-text', margin:'3 0 0 0', localized:{html:'PRO_select day to view lo'}}]}, 0, ['procoreloglookup'], ['component', 'box', 'container', 'procoreloglookup'], {'component':true, 'box':true, 'container':true, 'procoreloglookup':true}, ['widget.procoreloglookup'], 
0, [procore.view.cards.dailylogs, 'LogLookup'], 0);
Ext.cmd.derive('procore.view.cards.dailylogs.ManpowerLog', Ext.form.Panel, {reference:'card_ManpowerLog', items:[{xtype:'procoreloglookup', margin:'0 0 11 0'}, {xtype:'container', layout:'hbox', width:'100%', margin:'0 0 28 0', items:[{xtype:'procorelocation', bind:{value:'{entityClone.location.id}'}}, {xtype:'component', flex:1}, {xtype:'detailformcombo', name:'contact_id', editable:true, forceSelection:true, listConfig:{loadMask:false}, width:202, localized:{fieldLabel:'PRO_Company'}, displayField:'name', 
valueField:'id', allowBlank:true, bind:{store:'{manpowerLogsVendorOptions}', emptyText:'{manpowerLogsVendorOptionsEmptyText}', value:'{entityClone.contact.id}'}}]}, {xtype:'container', layout:'hbox', width:'100%', margin:'0 0 28 0', items:[{xtype:'container', layout:'hbox', width:202, defaults:{xtype:'detailformnumberfield', hideTrigger:false, step:1, minValue:0, publishes:'value', flex:1}, items:[{name:'num_workers', value:1, reference:'manpowerLogsWorkers', localized:{fieldLabel:'PRO_Workers'}, 
bind:{value:'{entityClone.num_workers}'}, margin:'0 14 0 0'}, {name:'num_hours', value:8, reference:'manpowerLogsHours', localized:{fieldLabel:'PRO_Hours'}, bind:{value:'{entityClone.num_hours}'}}]}, {xtype:'component', flex:1}, {xtype:'detailformcombo', name:'cost_code_id', editable:true, forceSelection:true, listConfig:{loadMask:false}, width:202, localized:{fieldLabel:'PRO_Cost Code'}, displayField:'name', valueField:'id', allowBlank:true, bind:{store:'{costCodes}', emptyText:'{costCodesEmptyText}', 
value:'{entityClone.cost_code.id}'}}]}, {xtype:'integrationcomments'}, {xtype:'integrationattachment'}]}, 0, ['procoremanpowerlog'], ['component', 'box', 'container', 'panel', 'form', 'procoremanpowerlog'], {'component':true, 'box':true, 'container':true, 'panel':true, 'form':true, 'procoremanpowerlog':true}, ['widget.procoremanpowerlog'], 0, [procore.view.cards.dailylogs, 'ManpowerLog'], 0);
Ext.cmd.derive('procore.view.cards.dailylogs.ManpowerLogCreate', Ext.form.Panel, {reference:'card_ManpowerLogCreate', items:[{xtype:'container', layout:'hbox', width:'100%', margin:'0 0 28 0', items:[{xtype:'datefield', labelSeparator:'', mvPickerUI:'mds-light', cls:'with-icon', labelAlign:'top', width:202, ui:'detail-form', localized:{fieldLabel:'PRO_Date'}, name:'date', submitFormat:'Y-m-d', value:new Date}, {xtype:'component', flex:1}, {xtype:'procorelocation'}]}, {xtype:'container', layout:'hbox', 
width:'100%', margin:'0 0 28 0', items:[{xtype:'detailformcombo', name:'contact_id', editable:true, forceSelection:true, listConfig:{loadMask:false}, width:202, localized:{fieldLabel:'PRO_Company'}, displayField:'name', valueField:'id', allowBlank:true, bind:{store:'{manpowerLogsVendorOptions}', emptyText:'{manpowerLogsVendorOptionsEmptyText}', value:'{entityClone.contact.id}'}}, {xtype:'component', flex:1}, {xtype:'container', layout:'hbox', width:202, defaults:{xtype:'detailformnumberfield', hideTrigger:false, 
step:1, minValue:0, publishes:'value', flex:1}, items:[{name:'num_workers', value:1, reference:'manpowerLogsWorkers', localized:{fieldLabel:'PRO_Workers'}, bind:{value:'{entityClone.num_workers}'}, margin:'0 14 0 0'}, {name:'num_hours', value:8, reference:'manpowerLogsHours', localized:{fieldLabel:'PRO_Hours'}, bind:{value:'{entityClone.num_hours}'}}]}]}, {xtype:'container', layout:'hbox', width:'100%', margin:'0 0 28 0', items:[{xtype:'detailformcombo', name:'cost_code_id', editable:true, forceSelection:true, 
listConfig:{loadMask:false}, width:202, localized:{fieldLabel:'PRO_Cost Code'}, displayField:'name', valueField:'id', allowBlank:true, bind:{store:'{costCodes}', emptyText:'{costCodesEmptyText}', value:'{entityClone.cost_code.id}'}}]}, {xtype:'integrationcomments'}, {xtype:'integrationattachment'}]}, 0, ['procoremanpowerlogcreate'], ['component', 'box', 'container', 'panel', 'form', 'procoremanpowerlogcreate'], {'component':true, 'box':true, 'container':true, 'panel':true, 'form':true, 'procoremanpowerlogcreate':true}, 
['widget.procoremanpowerlogcreate'], 0, [procore.view.cards.dailylogs, 'ManpowerLogCreate'], 0);
Ext.cmd.derive('procore.view.cards.dailylogs.NotesLog', Ext.form.Panel, {reference:'card_NotesLog', items:[{xtype:'procoreloglookup', margin:'0 0 11 0'}, {xtype:'container', layout:'hbox', width:'100%', margin:'0 0 28 0', items:[{xtype:'procorelocation', bind:{value:'{entityClone.location.id}'}}]}, {xtype:'integrationcomments'}, {xtype:'integrationattachment'}]}, 0, ['procorenoteslog'], ['component', 'box', 'container', 'panel', 'form', 'procorenoteslog'], {'component':true, 'box':true, 'container':true, 
'panel':true, 'form':true, 'procorenoteslog':true}, ['widget.procorenoteslog'], 0, [procore.view.cards.dailylogs, 'NotesLog'], 0);
Ext.cmd.derive('procore.view.cards.dailylogs.NotesLogCreate', Ext.form.Panel, {reference:'card_NotesLogCreate', items:[{xtype:'container', layout:'hbox', width:'100%', margin:'0 0 28 0', items:[{xtype:'datefield', labelSeparator:'', mvPickerUI:'mds-light', cls:'with-icon', labelAlign:'top', width:202, ui:'detail-form', localized:{fieldLabel:'PRO_Date'}, name:'date', submitFormat:'Y-m-d', value:new Date}, {xtype:'component', flex:1}, {xtype:'procorelocation'}]}, {xtype:'integrationcomments'}, {xtype:'integrationattachment'}]}, 
0, ['procorenoteslogcreate'], ['component', 'box', 'container', 'panel', 'form', 'procorenoteslogcreate'], {'component':true, 'box':true, 'container':true, 'panel':true, 'form':true, 'procorenoteslogcreate':true}, ['widget.procorenoteslogcreate'], 0, [procore.view.cards.dailylogs, 'NotesLogCreate'], 0);
Ext.cmd.derive('procore.view.cards.dailylogs.SafetyViolationLog', Ext.form.Panel, {reference:'card_SafetyViolationLog', items:[{xtype:'procoreloglookup', margin:'0 0 11 0'}, {xtype:'integrationcomments'}, {xtype:'integrationattachment'}]}, 0, ['procoresafetyviolationlog'], ['component', 'box', 'container', 'panel', 'form', 'procoresafetyviolationlog'], {'component':true, 'box':true, 'container':true, 'panel':true, 'form':true, 'procoresafetyviolationlog':true}, ['widget.procoresafetyviolationlog'], 
0, [procore.view.cards.dailylogs, 'SafetyViolationLog'], 0);
Ext.cmd.derive('procore.view.cards.dailylogs.WeatherLog', Ext.form.Panel, {reference:'card_WeatherLog', layout:'vbox', items:[{xtype:'procoreloglookup', margin:'0 0 11 0'}, {xtype:'container', layout:'hbox', width:'100%', margin:'0 0 28 0', items:[{xtype:'detailformcombo', flex:1, editable:true, forceSelection:true, listConfig:{loadMask:false}, localized:{fieldLabel:'PRO_Temperature', emptyText:'G_Select'}, name:'temperature', displayField:'value', valueField:'key', allowBlank:true, bind:{store:'{weatherTemperatures}', 
value:'{entityClone.temperature}'}}, {xtype:'detailformcombo', flex:1, margin:'0 0 0 10', editable:true, forceSelection:true, listConfig:{loadMask:false}, localized:{fieldLabel:'PRO_Wind', emptyText:'G_Select'}, name:'wind', displayField:'value', valueField:'key', allowBlank:true, bind:{store:'{weatherWinds}', value:'{entityClone.wind}'}}, {xtype:'detailformtextfield', flex:1, margin:'0 0 0 10', name:'precipitation', localized:{fieldLabel:'PRO_Precipitation'}, bind:{value:'{entityClone.precipitation}'}}]}, 
{xtype:'integrationcomments'}, {xtype:'integrationattachment'}]}, 0, ['procoreweatherlog'], ['component', 'box', 'container', 'panel', 'form', 'procoreweatherlog'], {'component':true, 'box':true, 'container':true, 'panel':true, 'form':true, 'procoreweatherlog':true}, ['widget.procoreweatherlog'], 0, [procore.view.cards.dailylogs, 'WeatherLog'], 0);
Ext.cmd.derive('procore.view.cards.dailylogs.WeatherLogCreate', Ext.form.Panel, {reference:'card_WeatherLogCreate', layout:'vbox', items:[{xtype:'container', layout:'hbox', width:'100%', margin:'0 0 28 0', items:[{xtype:'datefield', mvPickerUI:'mds-light', cls:'with-icon', labelAlign:'top', width:202, ui:'detail-form', localized:{fieldLabel:'PRO_Date'}, labelSeparator:'', name:'date', submitFormat:'Y-m-d', bind:{value:'{photoExifDateTime}'}}, {xtype:'component', flex:1}, {xtype:'container', layout:'hbox', 
width:202, defaults:{xtype:'timefield', ui:'detail-form', minValue:'12:00 AM', width:90, labelAlign:'top', labelSeparator:'', editable:false, isFormField:false, formatText:'', bind:{value:'{photoExifDateTime}'}}, isFormField:true, name:'time', isValid:function() {
  return true;
}, isDirty:function() {
  return true;
}, getSubmitData:function() {
  var hour = Ext.Date.format(this.down('#hour').getValue(), 'H'), minute = Ext.Date.format(this.down('#minute').getValue(), 'i');
  return {time:hour + ':' + minute, timeString:formShared.IntegrationsUtil.getDisplayDateString({time_hour:hour, time_minute:minute})};
}, items:[{maxValue:'11:00 PM', itemId:'hour', increment:60, format:'g A', localized:{fieldLabel:'PRO_Time'}, margin:'0 10 0 0', getErrors:function() {
  return [];
}}, {maxValue:'12:59 AM', itemId:'minute', increment:5, format:'i', fieldLabel:'\x26nbsp;', getErrors:function() {
  return [];
}}]}]}, {xtype:'container', layout:'hbox', width:'100%', margin:'0 0 28 0', items:[{xtype:'detailformcombo', flex:1, editable:true, forceSelection:true, listConfig:{loadMask:false}, localized:{fieldLabel:'PRO_Temperature', emptyText:'G_Select'}, name:'temperature', displayField:'value', valueField:'key', allowBlank:true, bind:{store:'{weatherTemperatures}', value:'{entityClone.temperature}'}}, {xtype:'detailformcombo', flex:1, margin:'0 0 0 10', editable:true, forceSelection:true, listConfig:{loadMask:false}, 
localized:{fieldLabel:'PRO_Wind', emptyText:'G_Select'}, name:'wind', displayField:'value', valueField:'key', allowBlank:true, bind:{store:'{weatherWinds}', value:'{entityClone.wind}'}}, {xtype:'detailformtextfield', flex:1, margin:'0 0 0 10', name:'precipitation', localized:{fieldLabel:'PRO_Precipitation'}, bind:{value:'{entityClone.precipitation}'}}]}, {xtype:'integrationcomments'}, {xtype:'integrationattachment'}]}, 0, ['procoreweatherlogcreate'], ['component', 'box', 'container', 'panel', 'form', 
'procoreweatherlogcreate'], {'component':true, 'box':true, 'container':true, 'panel':true, 'form':true, 'procoreweatherlogcreate':true}, ['widget.procoreweatherlogcreate'], 0, [procore.view.cards.dailylogs, 'WeatherLogCreate'], 0);
Ext.cmd.derive('procore.view.form.Location', formShared.view.components.Combo, {name:'location_id', editable:true, forceSelection:true, listConfig:{loadMask:false}, width:202, localized:{fieldLabel:'PRO_Location'}, displayField:'name', valueField:'id', allowBlank:true, bind:{store:'{locations}', emptyText:'{locationsEmptyText}'}}, 0, ['procorelocation'], ['component', 'box', 'field', 'textfield', 'pickerfield', 'combobox', 'combo', 'detailformcombo', 'procorelocation'], {'component':true, 'box':true, 
'field':true, 'textfield':true, 'pickerfield':true, 'combobox':true, 'combo':true, 'detailformcombo':true, 'procorelocation':true}, ['widget.procorelocation'], 0, [procore.view.form, 'Location'], 0);
Ext.cmd.derive('procore.view.form.ProjectAndCompany', Ext.container.Container, {layout:'hbox', margin:'0 0 28 0', padding:'25 0 0 25', width:463, items:[{xtype:'detailformcombo', width:202, localized:{fieldLabel:'PRO_Company', emptyText:'G_Select'}, queryMode:'local', displayField:'name', valueField:'id', disabled:true, bind:{store:'{procoreCompanies}', value:'{procoreSetting_companyID}', disabled:'{!_procoreCompaniesLoaded}'}}, {xtype:'component', flex:1}, {xtype:'detailformcombo', width:202, reference:'projects', 
localized:{fieldLabel:'PRO_Project', emptyText:'G_Select'}, queryMode:'local', displayField:'name', valueField:'id', disabled:true, bind:{store:'{procoreProjects}', disabled:'{!_procoreCompaniesLoaded}'}, listeners:{change:'onProjectChange'}}]}, 0, ['procoreprojectandcompany'], ['component', 'box', 'container', 'procoreprojectandcompany'], {'component':true, 'box':true, 'container':true, 'procoreprojectandcompany':true}, ['widget.procoreprojectandcompany'], 0, [procore.view.form, 'ProjectAndCompany'], 
0);
Ext.cmd.derive('procore.view.procorewindow.ProcoreWindow', Ext.window.Window, {ui:'orange', cls:'integration-window separate-form-error-message', modalMaskCls:'dark-mask', loadMaskCls:'light-load-indicator', viewModel:{type:'procorewindow'}, controller:'procorewindow', config:{photos:null, includeAnnotations:true, PushpinUID:'', attachFloorplanOnly:false, PhotoDate:null, width:488, defaultHeight:650, datePhoto:null, Photo360ID:null}, updateAttachFloorplanOnly:function(floorplanOnly) {
  this.getViewModel().set('attachFloorplanOnly', floorplanOnly);
}, padding:'0 0 25 0', defaultAlign:'t-t', modal:true, localized:{title:'PRO_Add to Procore'}, noRepositionFloatingItems:true, layout:{type:'vbox'}, scrollable:true, bind:{disabled:'{saving}'}, dockedItems:[{xtype:'container', reference:'warning', dock:'top', cls:'warning', layout:{type:'hbox', align:'center'}, minHeight:41, padding:10, hidden:true, bind:{hidden:'{!warningMessage}'}, items:[{xtype:'component', flex:1, bind:{html:'\x3cspan\x3e{warningMessage}\x3c/span\x3e'}}]}, {xtype:'container', 
dock:'bottom', layout:{type:'hbox', pack:'center'}, padding:'25 0 0 0', items:[{xtype:'button', scale:'medium', ui:'grey', text:'Cancel', margin:'0 12 0 12', listeners:{click:function() {
  this.up('window').destroy();
}}}, {xtype:'savebutton', reference:'saveButton', bind:{processing:'{saving}', done:'{saveDone}'}, margin:'0 12 0 12', listeners:{click:function() {
  this.lookupController().submitPhotos();
}}}]}], items:[{xtype:'procoreprojectandcompany'}, {xtype:'panel', width:463, padding:'0 0 0 25', layout:'card', reference:'cards', items:[{xtype:'procoredefault'}, {xtype:'procorerfiupdate'}, {xtype:'procorerficreate'}, {xtype:'procoredailylog'}, {xtype:'procorepunchlistassignment'}, {xtype:'procorepunchlistupdateitem'}, {xtype:'procorepunchlistcreateitem'}, {xtype:'procorechangeevent'}, {xtype:'procoreobservation', reference:'card_Observation_ObservationResponse'}, {xtype:'procoreobservation', 
reference:'card_Observation_ObservationItem'}, {xtype:'procoreobservationcreate'}, {xtype:'procorephotosnewalbum'}, {xtype:'procorephotosexistingalbum'}, {xtype:'procoremeeting'}]}], listeners:{boxready:'onBoxReady'}, destroy:function() {
  var entityStores = this.lookupController().entityStores;
  for (var i = 0; i < entityStores.length; i++) {
    entityStores[i].destroy();
  }
  return Ext.window.Window.prototype.destroy.apply(this, arguments);
}}, 0, ['procorewindow'], ['component', 'box', 'container', 'panel', 'window', 'procorewindow'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true, 'procorewindow':true}, ['widget.procorewindow'], 0, [procore.view.procorewindow, 'ProcoreWindow'], 0);
Ext.cmd.derive('procore.view.procorefloorplanexport.ProcoreFloorplanExportModel', procore.view.procorewindow.ProcoreWindowModel, {formulas:{submitReady:function(get) {
  return !!get('procoreDocumentTitle.value');
}, warningMessage:function(get) {
  var errorMessage = get('errorMessage'), message = '', showAlertMessage = !!(get('showAlertMessage') || errorMessage);
  if (!showAlertMessage || get('submitReady')) {
    message = '';
  } else {
    if (!get('procoreDocumentTitle.value')) {
      message = 'You cannot export the document because no title was specified.';
    }
  }
  if (message) {
    this.set('errorMessage', '');
  } else {
    if (errorMessage) {
      message = errorMessage;
    }
  }
  this.set('warningHeight', message ? 41 : 0);
  if (!message) {
    this.set('showAlertMessage', false);
  }
  return message;
}, integrationEntityType:function() {
  return 'Documents';
}, entityStore:function() {
  return '';
}, subType:function() {
  return '';
}, integrationEntityTypes:function() {
  return Ext.create('Ext.data.Store', {proxy:{type:'memory'}, model:'formShared.model.IntegrationEntityType', data:[{id:'Documents', name:'Documents', storeType:'procore.store.Documents', createAction:'submitToDocuments'}]});
}}}, 0, 0, 0, 0, ['viewmodel.procorefloorplanexport'], 0, [procore.view.procorefloorplanexport, 'ProcoreFloorplanExportModel'], 0);
Ext.cmd.derive('procore.view.procorefloorplanexport.ProcoreFloorplanExportController', procore.view.procorewindow.ProcoreWindowController, {init:function() {
  procore.view.procorewindow.ProcoreWindowController.prototype.init.apply(this, arguments);
  this.lookupReference('procoreDocumentTitle').setValue(this.getView().getFileTitle());
}}, 0, 0, 0, 0, ['controller.procorefloorplanexport'], 0, [procore.view.procorefloorplanexport, 'ProcoreFloorplanExportController'], 0);
Ext.cmd.derive('procore.view.procorefloorplanexport.ProcoreFloorplanExport', procore.view.procorewindow.ProcoreWindow, {viewModel:{type:'procorefloorplanexport'}, config:{fileTitle:'', defaultHeight:478}, controller:'procorefloorplanexport', items:[{xtype:'procoreprojectandcompany'}, {xtype:'panel', width:463, padding:'0 0 0 25', layout:'card', reference:'cards', items:[{xtype:'procoredefault'}, {xtype:'procoredocuments'}]}]}, 0, ['procorewindow-floorplanexport'], ['component', 'box', 'container', 
'panel', 'window', 'procorewindow', 'procorewindow-floorplanexport'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true, 'procorewindow':true, 'procorewindow-floorplanexport':true}, ['widget.procorewindow-floorplanexport'], 0, [procore.view.procorefloorplanexport, 'ProcoreFloorplanExport'], 0);
Ext.cmd.derive('aconex.model.ListMail', Ext.data.Model, {idProperty:'mailId', fields:[{name:'mailId', type:'string'}, {name:'reasonForIssue', type:'string'}, {name:'subject', type:'string'}, {name:'status', type:'string'}, {name:'correspondenceType', type:'string'}, {name:'fromUserId', type:'string'}, {name:'mailNo', type:'string'}, {name:'displayField', calculate:function(data) {
  var subject = data.subject;
  var regex = /&#(\d+);|([^&])/g;
  var match;
  var charCodes = [];
  while (match = regex.exec(subject)) {
    if (match[1] != null) {
      charCodes.push(match[1]);
    } else {
      charCodes.push(match[2].charCodeAt(0));
    }
  }
  if (charCodes.length < 2) {
    var result = subject.replace(/&/g, '\x26amp;');
    console.log(result);
    return data.mailNo + ' - ' + result;
  }
  var result = String.fromCharCode.apply(null, charCodes);
  subject = result != null ? result : subject;
  return data.mailNo + ' - ' + result;
}}]}, 0, 0, 0, 0, 0, 0, [aconex.model, 'ListMail'], 0);
Ext.cmd.derive('aconex.model.MandatoryFieldModel', Ext.data.Model, {idProperty:'id', fields:[{name:'id', type:'string'}, {name:'name', type:'string'}, {name:'type', type:'string'}, {name:'values'}, {name:'rules'}, {name:'mailFormField', type:'boolean', defaultValue:false}, {name:'restrictedField', type:'boolean', defaultValue:false}]}, 0, 0, 0, 0, 0, 0, [aconex.model, 'MandatoryFieldModel'], 0);
Ext.cmd.derive('aconex.model.MandatoryFieldValue', Ext.data.Model, {idProperty:'id', fields:[{name:'id', type:'string'}, {name:'value', type:'string'}]}, 0, 0, 0, 0, 0, 0, [aconex.model, 'MandatoryFieldValue'], 0);
Ext.cmd.derive('aconex.model.Project', Ext.data.Model, {idProperty:'ProjectId', fields:[{name:'ProjectId', type:'int'}, {name:'ProjectName', type:'string'}, {name:'ExportTypes', type:'string'}, {name:'MailTypes', type:'string'}, {name:'StatusTypes', type:'string'}, {name:'OfficialResponse', type:'boolean'}]}, 0, 0, 0, 0, 0, 0, [aconex.model, 'Project'], 0);
Ext.cmd.derive('aconex.model.User', Ext.data.Model, {idProperty:'UserId', fields:[{name:'UserId', type:'int'}, {name:'UserName', type:'string'}]}, 0, 0, 0, 0, 0, 0, [aconex.model, 'User'], 0);
Ext.cmd.derive('aconex.view.aconexwindow.AconexWindowModel', Ext.app.ViewModel, {stores:{aconexProjects:{storeId:'loadedAconexProjects', model:'aconex.model.Project', proxy:{url:'/index.cfm?fuseaction\x3daAconex.getProjects'}, autoLoad:true, listeners:{load:'onProjectsLoaded'}}, integrationEntityTypes:{proxy:{type:'memory'}, model:'formShared.model.IntegrationEntityType', data:[{id:'Photo', name:'Photo', createAction:'uploadPhotos'}, {id:'Document', name:'Document', createAction:'uploadDocuments'}, 
{id:'RFICreate', name:'Mail - Create', createAction:'createRFI'}, {id:'RFIUpdate', name:'Mail - Update', storeType:'aconex.model.ListMail', createAction:'submitToRFI', searchFields:['mailId', 'reasonForIssue', 'subject', 'status']}]}, aconexUsers:{storeId:'aconexUsers', model:'aconex.model.User', proxy:{url:'/index.cfm?fuseaction\x3daAconex.getAconexUsers', extraParams:{project_id:'{aconexSetting_projectID}'}}, autoLoad:false, listeners:{load:'onUsersLoaded'}}, aconexListMail:{storeId:'aconexListMail', 
model:'aconex.model.ListMail', proxy:{url:'/index.cfm?fuseaction\x3daAconex.listMailInBox', extraParams:{project_id:'{aconexSetting_projectID}'}}, mvAutoLoadVars:true, autoLoad:false}, aconexRFIFilters:{storeId:'aconexRFIFiltersStore', proxy:{type:'memory'}, data:[{value:'N/A', id:'N/A'}, {value:'Closed-Out', id:'Closed-Out'}, {value:'Outstanding', id:'Outstanding'}, {value:'Overdue', id:'Overdue'}, {value:'Responded', id:'Responded'}]}, documentMandatoryFields:{storeId:'documentMandatoryFields', 
model:'aconex.model.MandatoryFieldModel', proxy:{url:'/index.cfm?fuseaction\x3daAconex.getAconexDocumentFields', extraParams:{project_id:'{aconexSetting_projectID}'}}, autoLoad:false}, rfiCreateMandatoryFields:{storeId:'rfiCreateMandatoryFields', model:'aconex.model.MandatoryFieldModel', proxy:{url:'/index.cfm?fuseaction\x3daAconex.getAconexCreateMailFields', timeout:180000}, autoLoad:false}, rfiUpdateMandatoryFields:{storeId:'rfiUpdateMandatoryFields', model:'aconex.model.MandatoryFieldModel', proxy:{url:'/index.cfm?fuseaction\x3daAconex.getAconexReplyMailFields\x26loadMetadata\x3dtrue'}, 
autoLoad:false}}, data:{private_aconexSetting_projectID:null, private_aconexSetting_entityType:null, private_aconexSetting_attachAsPhoto:null, private_aconexSetting_attachAs4View:null, private_aconexSetting_rfiFilterValue:null, singlePhotoTitle:'', projectsLoaded:false, usersLoaded:false, saving:false, saveDone:false, errorMessage:'', recentMail:[], lastRfiQuery:'', lastQueryMail:[], rfiFilters:[], attachFloorplanOnly:false, officialResponseHidden:false, uiCustomizations:null}, formulas:{aconexSetting_projectID:{get:function(get) {
  var aconexSetting_projectID = get('private_aconexSetting_projectID');
  if (aconexSetting_projectID !== null) {
    return aconexSetting_projectID;
  }
  if (!get('globalPreferencesReady')) {
    return null;
  }
  return mdsPreferences.ProjectPreferences.getAconexSetting_projectID();
}, set:function(value) {
  this.set('private_aconexSetting_projectID', value);
  mdsPreferences.ProjectPreferences.setAconexSetting_projectID(value);
}}, integrationEntityType:{get:function(get) {
  var aconexSetting_entityType = get('private_aconexSetting_entityType');
  if (aconexSetting_entityType !== null) {
    return aconexSetting_entityType;
  }
  if (!get('globalPreferencesReady')) {
    return null;
  }
  return mdsPreferences.ProjectPreferences.getAconexSetting_entityType();
}, set:function(value) {
  this.set('private_aconexSetting_entityType', value);
  mdsPreferences.ProjectPreferences.setAconexSetting_entityType(value);
}}, aconexSetting_attachAsPhoto:{get:function(get) {
  var aconexSetting_attachAsPhoto = get('private_aconexSetting_attachAsPhoto');
  if (aconexSetting_attachAsPhoto !== null) {
    return aconexSetting_attachAsPhoto;
  }
  if (!get('globalPreferencesReady')) {
    return null;
  }
  var pref = mdsPreferences.ProjectPreferences.getAconexSetting_attachAsPhoto();
  return pref === undefined ? false : pref;
}, set:function(value) {
  this.set('private_aconexSetting_attachAsPhoto', value);
  mdsPreferences.ProjectPreferences.setAconexSetting_attachAsPhoto(value);
}}, aconexSetting_attachAs4View:{get:function(get) {
  var aconexSetting_attachAs4View = get('private_aconexSetting_attachAs4View');
  if (aconexSetting_attachAs4View !== null) {
    return aconexSetting_attachAs4View;
  }
  if (!get('globalPreferencesReady')) {
    return null;
  }
  var pref = mdsPreferences.ProjectPreferences.getAconexSetting_attachAs4View();
  return pref === undefined ? true : pref;
}, set:function(value) {
  this.set('private_aconexSetting_attachAs4View', value);
  mdsPreferences.ProjectPreferences.setAconexSetting_attachAs4View(value);
}}, aconexSetting_rfiFilterValue:{get:function(get) {
  var aconexSetting_rfiFilterValue = get('private_aconexSetting_rfiFilterValue');
  if (aconexSetting_rfiFilterValue !== null) {
    return aconexSetting_rfiFilterValue;
  }
  if (!get('globalPreferencesReady')) {
    return null;
  }
  var value = mdsPreferences.ProjectPreferences.getAconexSetting_rfiFilterValue();
  return value || 'open';
}, set:function(value) {
  this.set('private_aconexSetting_rfiFilterValue', value);
  mdsPreferences.ProjectPreferences.setAconexSetting_rfiFilterValue(value);
}}, entityType:function(get) {
  return get('integrationEntityTypes').getById(get('integrationEntityType'));
}, activeCardIndex:function(get) {
  var type = get('integrationEntityType');
  if (type == 'Photo' || type == 'Document') {
    return 1;
  } else {
    if (type == 'RFICreate') {
      return 2;
    } else {
      if (type == 'RFIUpdate') {
        return 3;
      }
    }
  }
  return 0;
}, projectSelected:function(get) {
  return get('projectsLoaded') && get('aconexSetting_projectID');
}, singlePhotoSelected:function(get) {
  return this.getView().getPhotos().length === 1;
}, multiplePhotosSelected:function(get) {
  return this.getView().getPhotos().length > 1;
}, isPhotoEntityType:function(get) {
  return get('integrationEntityType') == 'Photo';
}, isDocumentEntityType:function(get) {
  return get('integrationEntityType') == 'Document';
}, commentsFieldLabel:function(get) {
  if (get('integrationEntityType') == 'RFICreate') {
    return 'Question';
  }
  return 'Comments';
}, submitReady:function(get) {
  var projectsLoaded = get('projectsLoaded');
  var project_id = get('aconexSetting_projectID');
  var entityTypeId = get('integrationEntityType');
  return projectsLoaded && project_id > 0 && entityTypeId;
}, saveDisabled:function(get) {
  return !get('submitReady');
}}}, 0, 0, 0, 0, ['viewmodel.aconexwindow'], 0, [aconex.view.aconexwindow, 'AconexWindowModel'], 0);
Ext.cmd.derive('aconex.view.aconexwindow.AconexWindowController', Ext.app.ViewController, {entityStores:[], init:function() {
  var vm = this.getViewModel();
  window.awc = this;
  vm.bind({singlePhotoSelected:'{singlePhotoSelected}', ProjectUID:'{ProjectUID}'}, function(data) {
    var photos = this.getView().getPhotos();
    vm.set('singlePhotoTitle', '');
    if (data.singlePhotoSelected) {
      Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daAconex.getPhotoTitle', params:{ProjectUID:data.ProjectUID, photos:photos[0]}, successCallback:function(data) {
        vm.set('singlePhotoTitle', data);
      }});
    }
  }, this);
  Ext.defer(function() {
    this.getView().showBy(Ext.getBody(), 't-t?', [0, this.getWindowY(Ext.getBody().getHeight())], false);
  }, 1, this);
  Ext.getBody().addListener('resize', function(component, dimensions) {
    this.getView().setPosition(this.getWindowX(dimensions.width), this.getWindowY(dimensions.height), false, true);
  }, this, {buffer:200});
}, aconexUIPreferences:function(aconexProject) {
  var vm = this.getViewModel();
  var exportTypes = aconexProject.get('ExportTypes').split(',');
  var statusTypes = aconexProject.get('StatusTypes').split(',');
  var mailTypes = aconexProject.get('MailTypes').split(',');
  var officialResponse = aconexProject.get('OfficialResponse');
  if (!officialResponse) {
    vm.set('officialResponseHidden', true);
  } else {
    vm.set('officialResponseHidden', false);
  }
  var integrationEntityTypes = vm.getStore('integrationEntityTypes');
  integrationEntityTypes.clearFilter();
  integrationEntityTypes.filterBy(function(record) {
    if (exportTypes[0] === '') {
      return true;
    } else {
      if (exportTypes.length == 1 && exportTypes.includes(record.get('name'))) {
        return true;
      } else {
        if (exportTypes.includes(record.get('name'))) {
          return true;
        }
      }
    }
    return false;
  });
  var rfiStatusTypes = Ext.data.StoreManager.lookup('aconexRFIFiltersStore');
  rfiStatusTypes.clearFilter();
  rfiStatusTypes.filterBy(function(record) {
    if (statusTypes[0] === '') {
      return true;
    } else {
      if (statusTypes.length == 1 && statusTypes.includes(record.get('value'))) {
        return true;
      } else {
        if (statusTypes.includes(record.get('value'))) {
          return true;
        }
      }
    }
    return false;
  });
  var mailTypeArray = [];
  var rfiCreateMailTypes = Ext.data.StoreManager.lookup('rfiCreateMandatoryFields');
  rfiCreateMailTypes.clearFilter();
  rfiCreateMailTypes.filterBy(function(record) {
    if (mailTypes[0] === '') {
      return true;
    } else {
      if (record.data.name === 'Mail Type') {
        for (var i = 0; i < record.data.values.length; i++) {
          if (mailTypes.includes(record.data.values[i].value)) {
            mailTypeArray.push(record.data.values[i]);
          }
        }
        record.data.values = mailTypeArray;
        return true;
      }
    }
  });
}, getWindowX:function(bodyWidth) {
  return Math.max(0, (bodyWidth - this.getView().el.getWidth()) / 2);
}, getWindowY:function(bodyHeight) {
  var topOffset = (bodyHeight - 699) / 2, currentHeight = this.getView().el.getHeight();
  if (topOffset + currentHeight > bodyHeight) {
    topOffset = (bodyHeight - currentHeight) / 2;
  }
  return Math.max(0, topOffset);
}, onBoxReady:function() {
  var store = this.getStore('aconexProjects');
  if (store && store.isLoaded()) {
    return;
  }
  this.lookup('mainContainer').setLoading(true);
}, onProjectsLoaded:function(store, records, successful, operation) {
  this.lookup('mainContainer').setLoading(false);
  if (successful) {
    var viewModel = this.getViewModel();
    var savedProjectID = viewModel.get('aconexSetting_projectID');
    viewModel.set('projectsLoaded', true);
    var projectsCombo = this.lookup('projects');
    if (savedProjectID && store.getById(savedProjectID)) {
      projectsCombo.setValue(savedProjectID);
      this.aconexUIPreferences(store.getById(savedProjectID));
    } else {
      if (store.getCount() == 1) {
        var firstProject = store.getAt(0);
        viewModel.set('aconexSetting_projectID', firstProject.id);
        projectsCombo.setValue(firstProject.id);
        this.aconexUIPreferences(firstProject);
      } else {
        viewModel.set('aconexSetting_projectID', 0);
        projectsCombo.clearValue();
      }
    }
  } else {
    var msg = operation.getError() || 'Failed to load Aconex projects';
    Ext.Msg.alert('Error', msg);
    this.getView().destroy();
  }
}, onUsersLoaded:function(store, records, successful) {
  this.getViewModel().set('usersLoaded', successful);
}, onProjectChange:function(combo, aconexProjectId) {
  var vm = this.getViewModel();
  vm.set({aconexSetting_projectID:aconexProjectId, errorMessage:''});
  vm.notify();
  if (aconexProjectId > 0) {
    this.getAconexUsers(aconexProjectId);
    this.getAconexDocumentFields(aconexProjectId);
    this.getAconexCreateMailFields(aconexProjectId);
    this.getAconexListMail(aconexProjectId);
    this.aconexUIPreferences(vm.getStore('aconexProjects').getById(aconexProjectId));
  }
}, getAconexUsers:function(aconexProjectId) {
  this.getStore('aconexUsers').load({scope:this, callback:function(records, operation, success) {
    if (!success) {
      var vm = this.getViewModel();
      if (vm.get('integrationEntityType') === 'RFICreate') {
        vm.set('errorMessage', 'Failed to load aconex users');
        console.error('Failed to load Aconex users for project ' + aconexProjectId);
      }
    }
  }});
}, getAconexDocumentFields:function(aconexProjectId) {
  var vm = this.getViewModel();
  var store = vm.getStore('documentMandatoryFields');
  store.load({callback:function(records, operation, success) {
    if (!success) {
      if (vm.get('integrationEntityType') === 'Photo' || vm.get('integrationEntityType') === 'Document') {
        vm.set('errorMessage', 'Failed to load required fields');
      }
    }
  }});
}, getAconexListMail:function(aconexProjectId) {
  var store = this.getStore('aconexListMail');
  store.removeAll();
  store.un('load', this.rfiMailLoaded, this);
  store.on('load', this.rfiMailLoaded, this);
  store.load({params:{project_id:aconexProjectId, searchText:''}});
}, mailBeforeQuery:function(queryPlan) {
  var vm = this.getViewModel();
  var lastQuery = vm.get('lastRfiQuery');
  if (!queryPlan.query || lastQuery === queryPlan.query) {
    var combo = this.lookup('aconexListMailCombo');
    var store = this.getStore('aconexListMail');
    var mail = vm.get(queryPlan.query ? 'lastQueryMail' : 'recentMail');
    if (mail && mail.length || store.isLoading()) {
      combo.lastQuery = lastQuery;
      if (mail && mail.length && !store.isLoading()) {
        store.setData(mail);
        store.totalCount = mail.length;
      }
      queryPlan.cancel = true;
      combo.getPicker().refresh();
      combo.expand();
    }
  }
  vm.set('lastRfiQuery', queryPlan.query);
  return queryPlan;
}, rfiMailLoaded:function(store, records, success, op) {
  var vm = this.getViewModel();
  var query = vm.get('lastRfiQuery');
  if (success) {
    var combo = this.lookup('aconexListMailCombo');
    if (combo) {
      combo.lastQuery = query;
      if (records.length === 1) {
        combo.setSelection(records[0]);
      }
    }
    vm.set(query ? 'lastQueryMail' : 'recentMail', records);
  } else {
    if (vm.get('integrationEntityType') === 'RFIUpdate') {
      vm.set('errorMessage', 'Failed to ' + (query ? 'search' : 'load') + ' Aconex Mail');
    }
    console.error('Failed to ' + (query ? 'search' : 'load') + ' Aconex Mail ', op);
    console.log(op.getError().statusText);
  }
}, rfiMailChangeHandler:function(combo, mailId) {
  this.getAconexReplyMailFields(mailId);
}, rfiFilterChangeHandler:function(menuItem, checked) {
  var vm = this.getViewModel();
  var filters = vm.get('rfiFilters');
  var value = menuItem.config.inputValue;
  if (checked) {
    filters.push(value);
  } else {
    filters.splice(filters.indexOf(value), 1);
  }
  var store = vm.get('aconexListMail');
  if (store.isLoaded()) {
    store.clearFilter();
    if (filters.length > 0) {
      store.filter(function(record) {
        return filters.indexOf(record.get('status')) != -1;
      });
    }
  }
}, getAconexCreateMailFields:function(aconexProjectId) {
  var vm = this.getViewModel();
  var store = vm.getStore('rfiCreateMandatoryFields');
  store.load({params:{project_id:aconexProjectId}, scope:this, callback:function(records, op, success) {
    if (success) {
      for (var i = 0; i < records.length; i++) {
        var record = records[i];
        if (record.id === 'MailTypeId') {
          var mailTypes = this.filterMailTypes(record.get('values'));
          record.set('values', mailTypes);
          break;
        }
      }
    } else {
      if (vm.get('integrationEntityType') === 'RFICreate') {
        vm.set('errorMessage', 'Failed to load required fields');
      }
      console.error('Failed to load rfi create required fields', op, aconexProjectId);
      console.log(op.getError().statusText);
      console.log('operation failure debug', op);
    }
  }});
}, getAconexReplyMailFields:function(mailId) {
  var vm = this.getViewModel();
  var store = vm.getStore('rfiUpdateMandatoryFields');
  if (!mailId) {
    store.removeAll();
    return;
  }
  var aconexProjectId = vm.get('aconexSetting_projectID');
  store.load({params:{project_id:aconexProjectId, mailId:mailId}, scope:this, callback:function(records, op, success) {
    if (success) {
      for (var i = 0; i < records.length; i++) {
        var record = records[i];
        if (record.id === 'MailTypeId') {
          var mailTypes = this.filterMailTypes(record.get('values'));
          record.set('values', mailTypes);
          break;
        }
      }
    } else {
      if (vm.get('integrationEntityType') === 'RFIUpdate') {
        vm.set('errorMessage', 'Failed to load required fields');
      }
      console.error('Failed to load RFI update required fields', op, aconexProjectId, mailId);
      console.log(op.getError().statusText);
    }
  }});
}, filterMailTypes:function(mailTypes) {
  var filteredMailTypes = mailTypes;
  if (mailTypes && mailTypes.length) {
    var customizations = this.getViewModel().get('uiCustomizations');
    if (customizations && customizations.rfiMailTypes) {
      var allowedMailTypesMap = customizations.rfiMailTypes;
      filteredMailTypes = [];
      for (var i = 0; i < mailTypes.length; i++) {
        var mailType = mailTypes[i];
        var allowed = false;
        if (mailType.id in allowedMailTypesMap && allowedMailTypesMap[mailType.id] === true) {
          allowed = true;
        } else {
          if (mailType.value in allowedMailTypesMap && allowedMailTypesMap[mailType.value] === true) {
            allowed = true;
          } else {
            console.log('*** Skipping mail type', mailType);
          }
        }
        if (allowed) {
          filteredMailTypes.push(mailType);
        }
      }
    }
  }
  return filteredMailTypes;
}, findMailTypeMandatoryField:function(mandatoryFields) {
  var mailTypeId = 0;
  for (var i = 0; i < mandatoryFields.length; i++) {
    var field = mandatoryFields[i];
    if (field.id === 'MailTypeId') {
      mailTypeId = field.value;
      break;
    }
  }
  return mailTypeId;
}, getCreateAction:function() {
  var entityType = this.getViewModel().get('entityType');
  return entityType.get('createAction');
}, getSubmitParams:function() {
  var viewModel = this.getViewModel(), photos = this.getView().getPhotos(), entityTypeID = viewModel.get('integrationEntityType'), pushpinUID = this.getView().getPushpinUID();
  var isPhoto = entityTypeID == 'Photo';
  var isDocument = entityTypeID == 'Document';
  var isRFICreate = entityTypeID == 'RFICreate';
  var isRFIUpdate = entityTypeID == 'RFIUpdate';
  var projects = viewModel.get('aconexProjects');
  if (!projects.isLoaded() || projects.getCount() == 0) {
    viewModel.set('errorMessage', 'There are no projects available');
    return null;
  }
  var aconexProjectId = viewModel.get('aconexSetting_projectID');
  var project = projects.getById(aconexProjectId);
  if (!project) {
    viewModel.set('errorMessage', 'Please select a Project');
    return null;
  }
  if (!entityTypeID) {
    viewModel.set('errorMessage', 'Please select a Type');
    return null;
  }
  var attachments = this.lookup('aconexAttachment');
  var params = {ProjectUID:viewModel.get('ProjectUID'), photos:photos.join(','), project_id:aconexProjectId, includeAnnotations:this.getView().getIncludeAnnotations(), projectName:project.get('ProjectName'), attachAsPhoto:isPhoto || attachments.down('#attachPhoto').getValue(), attachAs4View:isPhoto ? false : attachments.down('#attachDetails').getValue(), attachAsFloorplan:this.getViewModel().get('attachFloorplanOnly'), comment:this.lookup('aconexComments').getValue()};
  if (params.attachAsFloorplan) {
    params.attachAsPhoto = params.attachAs4View = false;
    params.FloorplanUID = viewModel.get('FloorplanUID');
    params.displayHeader = attachments.down('#headerCheckbox').getValue();
    params.displayHotspots = attachments.down('#hotspotsCheckbox').getValue();
    params.displayPushpins = attachments.down('#pushpinsCheckbox').getValue();
  }
  if (pushpinUID) {
    params.PushpinUID = pushpinUID;
  }
  if (isPhoto || isDocument) {
    params = this.addPhotoDocumentParams(params, photos.length === 1, entityTypeID);
  } else {
    if (isRFICreate) {
      params = this.addRFICreateParams(params);
    } else {
      if (isRFIUpdate) {
        params = this.addRFIUpdateParams(params);
      }
    }
  }
  return params;
}, addPhotoDocumentParams:function(params, isSinglePhoto, entityTypeID) {
  var viewModel = this.getViewModel();
  params.aconexProjectTypeId = 0;
  params.mandatoryFields = this.lookup('documentMandatoryFields').getMandatoryValues();
  for (var i = 0; i < params.mandatoryFields.length; i++) {
    var field = params.mandatoryFields[i];
    if (field.id === 'DocumentTypeId') {
      params.aconexProjectTypeId = field.value;
      params.mandatoryFields.splice(i, 1);
      break;
    }
  }
  if (!params.aconexProjectTypeId) {
    viewModel.set('errorMessage', 'Please select a Project Type');
    return null;
  }
  if (isSinglePhoto) {
    params.title = viewModel.get('singlePhotoTitle');
  }
  return params;
}, addRFICreateParams:function(params) {
  var viewModel = this.getViewModel();
  var card = this.lookup('card_RFICreate');
  var assignee = card.down('#assignee').getValue();
  if (assignee.length === 0) {
    viewModel.set('errorMessage', 'Must select an Assignee');
    return null;
  }
  var mandatoryFieldsComp = this.lookup('rfiCreateMandatoryFields');
  var mandatoryFields = mandatoryFieldsComp.getMandatoryValues();
  var mailTypeId = this.findMailTypeMandatoryField(mandatoryFields);
  if (!mailTypeId) {
    viewModel.set('errorMessage', 'Please select a Mail Type');
    return null;
  }
  var errorField = mandatoryFieldsComp.validateMandatoryFields(mandatoryFields);
  if (errorField) {
    viewModel.set('errorMessage', 'Must set a value for ' + errorField.name);
    return null;
  }
  if (!params.comment) {
    viewModel.set('errorMessage', 'A question must be provided.');
    return null;
  }
  params.title = card.down('#subject').getValue();
  params.mandatoryFields = mandatoryFields;
  params.assignee = assignee;
  params.assigneecc = card.down('#assigneecc').getValue();
  params.assigneebcc = card.down('#assigneebcc').getValue();
  params.isPrivate = card.down('#private').getValue();
  var isDraft = card.down('#draft').getValue();
  params.updateStatus = isDraft ? 'DRAFT' : 'Outstanding';
  return params;
}, addRFIUpdateParams:function(params) {
  var viewModel = this.getViewModel();
  var card = this.lookup('card_RFIUpdate');
  var mailCombo = card.down('#mailCombo');
  var mailRecord = mailCombo.getSelection();
  var mailId = mailCombo.getValue();
  if (!mailRecord || !mailId) {
    viewModel.set('errorMessage', 'Please select an RFI to update');
    return null;
  }
  params.toUserId = mailRecord.get('fromUserId');
  var mandatoryFieldsComp = this.lookup('rfiUpdateMandatoryFields');
  var mandatoryFields = mandatoryFieldsComp.getMandatoryValues();
  var mailTypeId = this.findMailTypeMandatoryField(mandatoryFields);
  if (!mailTypeId) {
    viewModel.set('errorMessage', 'Please select a Mail Type');
    return null;
  }
  var errorField = mandatoryFieldsComp.validateMandatoryFields(mandatoryFields);
  if (errorField) {
    viewModel.set('errorMessage', 'Must set a value for ' + errorField.name);
    return null;
  }
  var updateStatus = card.down('#updateStatus').getValue();
  if (!updateStatus) {
    viewModel.set('errorMessage', 'Please set the Update Status');
    return null;
  }
  if (!params.comment) {
    viewModel.set('errorMessage', 'A comment must be provided.');
    return null;
  }
  var subject = mailRecord.get('subject') || '';
  if (subject && subject.indexOf('Re: ') === -1) {
    subject = 'Re: ' + subject;
  }
  params.title = subject;
  params.mailId = mailId;
  params.updateStatus = updateStatus;
  params.officialResponse = card.down('#officialResponse').getValue();
  params.mandatoryFields = mandatoryFields;
  return params;
}, submitPhotos:function() {
  var viewModel = this.getViewModel();
  var params = this.getSubmitParams();
  if (!params) {
    return;
  }
  if (location.href.indexOf('test\x3dtrue') !== -1) {
    params.test = true;
  }
  var asyncUploads = viewModel.get('account.features.uploadscenterVisible'), createAction = this.getCreateAction();
  params.asynchronous = asyncUploads;
  console.log('Uploading photos/documents', params);
  viewModel.set({saving:true, errorMessage:''});
  Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daAconex.' + createAction, jsonData:params, successCallback:function(data) {
    if (asyncUploads) {
      var photoArray = params.photos.split(',');
      if (data.photoFinalActionProcessIds && data.photoFinalActionProcessIds.length == 1 && (createAction == 'createRFI' || createAction == 'submitToRFI')) {
        var processArray = [];
        for (var i = 0; i < photoArray.length; i++) {
          processArray.push(data.photoFinalActionProcessIds[0]);
        }
        data.photoFinalActionProcessIds = processArray;
      }
      window.app.fireEvent('reloadfileuploads', {sourceType:'integration', responseData:data, photos:photoArray});
    } else {
      viewModel.set('saveDone', true);
    }
    if (data && data.callback) {
      data.callback();
    }
    Ext.defer(function() {
      viewModel.set('saving', false);
      this.getView().destroy();
    }, 1000, this);
  }, afterFailMessageCallback:function(data, message) {
    viewModel.set({saving:false, errorMessage:message || mvstr.G_UnexpectedError});
  }, noAlert:true, scope:this});
  this.logExportAnalyticsEvent(params);
}, logExportAnalyticsEvent:function(params) {
  if (params.attachAsFloorplan) {
    analytics.Ctrl.log('Exported Floorplan', {'Floorplan UID':params.FloorplanUID, 'Integration':'Procore'});
  } else {
    var action = 'Photo Viewer Menu';
    if (location.href.toLowerCase().indexOf('clientphotolist') !== -1) {
      action = 'Photo List Menu';
    }
    analytics.Ctrl.log('Exported Photo', {'Photo List':params.photos, 'Photo Action Element':action, 'Integration':'Aconex'});
  }
}}, 0, 0, 0, 0, ['controller.aconexwindow'], 0, [aconex.view.aconexwindow, 'AconexWindowController'], 0);
Ext.cmd.derive('aconex.view.cards.Default', Ext.Container, {reference:'card_default'}, 0, ['aconexdefault'], ['component', 'box', 'container', 'aconexdefault'], {'component':true, 'box':true, 'container':true, 'aconexdefault':true}, ['widget.aconexdefault'], 0, [aconex.view.cards, 'Default'], 0);
Ext.cmd.derive('aconex.view.form.SingleUser', formShared.view.components.Combo, {width:'100%', emptyText:'- Select -', displayField:'UserName', valueField:'UserId', editable:false, publishes:'value', disabled:true, bind:{disabled:'{!usersLoaded}', store:'{aconexUsers}'}}, 0, ['aconexsingleuser'], ['component', 'box', 'field', 'textfield', 'pickerfield', 'combobox', 'combo', 'detailformcombo', 'aconexsingleuser'], {'component':true, 'box':true, 'field':true, 'textfield':true, 'pickerfield':true, 'combobox':true, 
'combo':true, 'detailformcombo':true, 'aconexsingleuser':true}, ['widget.aconexsingleuser'], 0, [aconex.view.form, 'SingleUser'], 0);
Ext.cmd.derive('aconex.view.cards.MandatoryFields', Ext.Container, {layout:'column', columnWidth:1, margin:0, cls:'mandatory-fields', fieldIdObjectMap:null, fieldIdComponentMap:null, presetFieldValues:null, fieldIdRulesMap:null, store:null, getStore:function() {
  return this.store;
}, setStore:function(store) {
  if (this.store) {
    this.store.off('beforeload', this.storeBeforeLoad, this);
    this.store.off('load', this.storeLoaded, this);
  }
  this.store = store;
  if (this.store) {
    this.store.on('beforeload', this.storeBeforeLoad, this);
    this.store.on('load', this.storeLoaded, this);
    if (this.store.isLoading()) {
      this.setLoading();
    }
  }
}, createLoadingSpinner:function() {
  return {xtype:'component', html:'Loading required fields...', cls:'mandatory-fields-spinner', columnWidth:1};
}, storeBeforeLoad:function() {
  this.setLoading();
}, setLoading:function() {
  this.removeAll(true);
  this.add(this.createLoadingSpinner());
}, storeLoaded:function(store, records, successful) {
  console.log(this.reference + ' mandatory fields loaded', successful, records);
  this.removeAll(true);
  if (successful) {
    Ext.defer(function() {
      this.setMandatoryFields(store.getRange());
    }, 100, this);
  }
}, setMandatoryFields:function(records) {
  this.fieldIdObjectMap = {};
  this.fieldIdComponentMap = {};
  this.presetFieldValues = [];
  this.fieldIdRulesMap = {};
  var columnWidth = 0.5;
  var margin = '0 12 15 12';
  if (records && records.length > 0) {
    var items = [];
    var added = 0;
    var conditionals = 0;
    for (var i = 0; i < records.length; i++) {
      var field = records[i].data || records[i];
      var comp;
      var isMandatory = true;
      if (field.rules && field.rules.length) {
        this.fieldIdRulesMap[field.id] = field.rules;
        conditionals++;
        isMandatory = this.isMandatory(field.rules);
      }
      var values = field.values;
      if (values) {
        if (values.length === 1 && field.id !== 'DocumentTypeId' && field.id !== 'MailTypeId' && !field.rules) {
          this.presetFieldValues.push({id:field.id, value:values[0].id});
          continue;
        }
        comp = this.createMultiValueField(field, isMandatory, columnWidth, margin);
      } else {
        comp = this.createSingleValueField(field, isMandatory, columnWidth, margin);
      }
      this.fieldIdObjectMap[field.id] = field;
      this.fieldIdComponentMap[field.id] = comp;
      if (!isMandatory) {
        continue;
      }
      items.push(comp);
      added++;
    }
    console.log(this.reference + ' adding ' + added + ' mandatory fields, ' + conditionals + ' conditional fields');
    this.add(items);
    this.addConditionalRuleListeners();
  }
}, createMultiValueField:function(field, isMandatory, columnWidth, margin) {
  var xtype = 'detailformcombo';
  if (field.type === 'user') {
    return this.createSingleUserCombo(field, isMandatory, columnWidth, margin);
  }
  var typeAhead = false;
  var grow = false;
  var growMax = false;
  if (field.id === 'Attribute1' || field.id === 'Attribute2' || field.id === 'Attribute3' || field.id === 'Attribute4') {
    xtype = 'detailformmulticombo';
    typeAhead = true;
    grow = true;
    growMax = 46;
  }
  var value = '';
  if (field.values.length > 0) {
    var selectedValues = [];
    for (var i = 0; i < field.values.length; i++) {
      var fieldValue = field.values[i];
      if (fieldValue.selected) {
        selectedValues.push(fieldValue.id);
      }
    }
    if (selectedValues.length === 0) {
      selectedValues.push(field.values[0].id);
    }
    if (selectedValues.length > 1) {
      value = selectedValues;
    } else {
      value = selectedValues[0];
    }
  }
  return Ext.create({xtype:xtype, columnWidth:columnWidth, margin:margin, fieldLabel:field.name, queryMode:'local', displayField:'value', valueField:'id', hidden:!isMandatory, forceSelection:true, typeAhead:typeAhead, grow:grow, growMax:growMax, store:Ext.create('Ext.data.Store', {model:'aconex.model.MandatoryFieldValue', data:field.values}), value:value});
}, createSingleValueField:function(field, isMandatory, columnWidth, margin) {
  var xtype = 'detailformtextfield';
  var dataType = field.type;
  var value = field.value || '';
  var height = NaN;
  var allowDecimals = false;
  if (dataType === 'boolean') {
    return this.createCheckBox(field, isMandatory, columnWidth, margin);
  } else {
    if (dataType === 'user') {
      return this.createSingleUserCombo(field, isMandatory, columnWidth, margin);
    }
  }
  if (dataType === 'int' || dataType === 'integer' || dataType === 'long' || dataType === 'double' || dataType === 'number') {
    xtype = 'detailformnumberfield';
    value = Ext.isNumeric(value) ? value : 0;
    allowDecimals = dataType === 'double' || dataType === 'number';
  } else {
    if (dataType === 'multi_line_text') {
      xtype = 'detailformtextarea';
      height = 100;
      columnWidth = 1;
    } else {
      if (dataType === 'date') {
        xtype = 'detailformdatefield';
        if (value) {
          var match = value.match(/^\d{4}-\d\d-\d\d/);
          if (match) {
            value = Ext.Date.parse(match[0], 'Y-m-d');
          } else {
            value = new Date(value);
          }
          if (isNaN(value.getTime())) {
            value = null;
          }
        }
        if (!value) {
          value = Ext.Date.add(new Date, Ext.Date.DAY, 1);
        }
      }
    }
  }
  var config = {xtype:xtype, fieldLabel:field.name, columnWidth:columnWidth, margin:margin, publishes:'value', allowBlank:false, allowDecimals:allowDecimals, value:value, hidden:!isMandatory};
  if (field.specs) {
    for (var i = 0; i < field.specs.length; i++) {
      var spec = field.specs[i];
      if (spec.id === 'minLength') {
        config.minLength = parseInt(spec.value);
      } else {
        if (spec.id === 'maxLength') {
          config.maxLength = parseInt(spec.value);
          config.enforceMaxLength = true;
        } else {
          if (spec.id === 'allowBlank' && spec.value) {
            config.allowBlank = true;
          }
        }
      }
    }
  }
  if (config.allowBlank) {
    config.labelClsExtra = 'optional-label';
  }
  if (!isNaN(height)) {
    config.height = height;
  }
  return Ext.create(config);
}, createCheckBox:function(field, isMandatory, columnWidth, margin) {
  return Ext.create({xtype:'checkboxfield', ui:'plain-16', boxLabel:field.name, labelSeparator:'', cls:'rfi-field-checkbox', checked:false, columnWidth:columnWidth, margin:margin, hidden:!isMandatory});
}, createSingleUserCombo:function(field, isMandatory, columnWidth, margin) {
  return Ext.create({xtype:'aconexsingleuser', fieldLabel:field.name, columnWidth:columnWidth, margin:margin, hidden:!isMandatory, forceSelection:true});
}, addConditionalRuleListeners:function() {
  var conditionalFieldsMap = {};
  var conditionalCount = 0;
  var fieldsToAdd = [];
  for (var id in this.fieldIdRulesMap) {
    var rules = this.fieldIdRulesMap[id];
    if (id in this.fieldIdComponentMap) {
      for (var i = 0; i < rules.length; i++) {
        var rule = rules[i];
        var targetId = rule.id;
        if (targetId && targetId in this.fieldIdComponentMap) {
          var targetComponent = this.fieldIdComponentMap[targetId];
          var store = targetComponent.getStore ? targetComponent.getStore() : null;
          if (!(targetId in conditionalFieldsMap)) {
            if (targetComponent.getValue() && this.isMandatory(rules)) {
              fieldsToAdd.push(this.fieldIdComponentMap[id]);
            }
            targetComponent.on('change', function(targetId, input, newValue, oldValue) {
              this.checkRulesForTarget(targetId);
            }.bind(this, targetId));
            conditionalFieldsMap[targetId] = [];
          }
          var obj = {};
          var allowedValues = rule.values;
          if (allowedValues && allowedValues.length) {
            obj[id] = allowedValues.map(function(item) {
              var id = item.id || '';
              if (store && store.getById(id)) {
                return id + ' - ' + store.getById(id).get('value');
              }
              return id;
            }).join(', ');
          }
          conditionalFieldsMap[targetId].push(obj);
          conditionalCount++;
        }
      }
    }
  }
  this.addConditionalFields(fieldsToAdd);
}, checkRulesForTarget:function(targetId) {
  var checkCount = 0;
  var fieldsToAdd = [];
  for (var id in this.fieldIdRulesMap) {
    var rules = this.fieldIdRulesMap[id];
    for (var i = 0; i < rules.length; i++) {
      var rule = rules[i];
      if (rule.id === targetId) {
        if (id in this.fieldIdComponentMap) {
          var conditionalComponent = this.fieldIdComponentMap[id];
          if (conditionalComponent) {
            if (this.isMandatory(rules)) {
              fieldsToAdd.push(conditionalComponent);
            } else {
              this.removeConditionalField(conditionalComponent);
            }
          }
        }
        checkCount++;
        break;
      }
    }
  }
  this.addConditionalFields(fieldsToAdd);
}, addConditionalFields:function(fields) {
  if (fields.length > 0) {
    this.add(fields);
    for (var i = 0; i < fields.length; i++) {
      fields[i].show();
    }
  }
}, removeConditionalField:function(field) {
  field.hide();
  if (field.ownerCt) {
    this.remove(field, {destroy:false});
  }
}, isMandatory:function(rules) {
  var isMandatory = false;
  for (var i = 0; i < rules.length; i++) {
    var rule = rules[i];
    var targetId = rule.id;
    if (targetId in this.fieldIdComponentMap) {
      var targetComp = this.fieldIdComponentMap[targetId];
      if (targetComp) {
        var newValue = targetComp.getValue();
        if ('values' in rule) {
          var allowedValues = rule.values;
          for (var j = 0; j < allowedValues.length; j++) {
            var allowedValue = allowedValues[j];
            if ('id' in allowedValue) {
              var value = allowedValue.id;
              if (value == newValue) {
                isMandatory = true;
                break;
              }
            }
          }
        } else {
          if (targetComp.isVisible()) {
            isMandatory = !!newValue;
          }
        }
      } else {
        console.log('** No target comp for ' + targetId);
      }
    }
    if (isMandatory) {
      break;
    }
  }
  return isMandatory;
}, getMandatoryValues:function() {
  if (this.presetFieldValues == null) {
    console.warn('Preset field values never set');
    return [];
  }
  var values = this.presetFieldValues.slice(0);
  for (var id in this.fieldIdComponentMap) {
    var comp = this.fieldIdComponentMap[id];
    if (comp.isVisible()) {
      var value = comp.getValue();
      if (comp.xtype === 'detailformdatefield' && Ext.isDate(value)) {
        value = Ext.Date.format(value, 'Y-m-d');
      }
      var mfv = {id:id, value:value};
      values.push(mfv);
    }
  }
  for (var i = 0; i < values.length; i++) {
    mfv = values[i];
    if (mfv.id in this.fieldIdObjectMap) {
      var field = this.fieldIdObjectMap[mfv.id];
      if (field.mailFormField) {
        mfv.mailFormField = true;
      } else {
        if (field.restrictedField) {
          mfv.restrictedField = true;
        }
      }
    }
  }
  return values;
}, validateMandatoryFields:function(mandatoryFields) {
  for (var i = 0; i < mandatoryFields.length; i++) {
    var field = mandatoryFields[i];
    var value = field.value;
    if (Ext.isEmpty(field.value)) {
      var record = this.getStore().getById(field.id);
      var name = record ? record.get('name') : field.id;
      return {id:field.id, name:name, value:value};
    }
  }
  return null;
}}, 0, ['mandatoryfields'], ['component', 'box', 'container', 'mandatoryfields'], {'component':true, 'box':true, 'container':true, 'mandatoryfields':true}, ['widget.mandatoryfields'], 0, [aconex.view.cards, 'MandatoryFields'], 0);
Ext.cmd.derive('aconex.view.cards.PhotoDocument', Ext.Container, {reference:'card_PhotoDocument', layout:'column', items:[{xtype:'detailformtextfield', reference:'aconexPhotoTitle', fieldLabel:'Title', emptyText:'Enter title', margin:'0 12 15 12', columnWidth:1, publishes:'value', hidden:true, bind:{hidden:'{multiplePhotosSelected}', value:'{singlePhotoTitle}'}}, {xtype:'mandatoryfields', reference:'documentMandatoryFields', bind:{store:'{documentMandatoryFields}'}}]}, 0, ['aconexphotodocument'], 
['component', 'box', 'container', 'aconexphotodocument'], {'component':true, 'box':true, 'container':true, 'aconexphotodocument':true}, ['widget.aconexphotodocument'], 0, [aconex.view.cards, 'PhotoDocument'], 0);
Ext.cmd.derive('aconex.view.form.User', formShared.view.components.ComboMultiselect, {width:'100%', emptyText:'- Select -', displayField:'UserName', valueField:'UserId', editable:true, typeAhead:true, publishes:'value', disabled:true, grow:true, bind:{disabled:'{!usersLoaded}', store:'{aconexUsers}'}}, 0, ['aconexuser'], ['component', 'box', 'field', 'textfield', 'pickerfield', 'combobox', 'combo', 'tagfield', 'detailformmulticombo', 'aconexuser'], {'component':true, 'box':true, 'field':true, 'textfield':true, 
'pickerfield':true, 'combobox':true, 'combo':true, 'tagfield':true, 'detailformmulticombo':true, 'aconexuser':true}, ['widget.aconexuser'], 0, [aconex.view.form, 'User'], 0);
Ext.cmd.derive('aconex.view.form.ExpandUserGroup', Ext.Container, {layout:{type:'vbox', align:'stretch'}, items:[{xtype:'component', cls:'expand-user-group-link', html:'\x3ca href\x3d"javascript:void(0)" class\x3d"cc" title\x3d"Show Cc field"\x3eCc\x3c/a\x3e\x3ca href\x3d"javascript:void(0)" class\x3d"bcc" title\x3d"Show Bcc field"\x3eBcc\x3c/a\x3e', height:0, liquidLayout:true, listeners:{click:{fn:function(ev, el) {
  if (el.getAttribute('class') == 'cc') {
    Ext.getCmp('aconexUserCc').show();
  } else {
    Ext.getCmp('aconexUserBcc').show();
  }
  var parent = el.parentNode;
  el.parentNode.removeChild(el);
  if (parent.children.length === 0) {
    parent.parentNode.removeChild(parent);
  }
}, element:'el', delegate:'a'}}}, {xtype:'aconexuser', itemId:'assignee', fieldLabel:'Assignee', allowBlank:false}, {xtype:'aconexuser', fieldLabel:'Cc', hidden:true, margin:'15 0 0 0', id:'aconexUserCc', itemId:'assigneecc'}, {xtype:'aconexuser', fieldLabel:'Bcc', hidden:true, margin:'15 0 0 0', id:'aconexUserBcc', itemId:'assigneebcc'}]}, 0, ['expandusergroup'], ['component', 'box', 'container', 'expandusergroup'], {'component':true, 'box':true, 'container':true, 'expandusergroup':true}, ['widget.expandusergroup'], 
0, [aconex.view.form, 'ExpandUserGroup'], 0);
Ext.cmd.derive('aconex.view.cards.RFICreate', Ext.Container, {reference:'card_RFICreate', layout:'column', defaults:{margin:'0 12 15 12', columnWidth:0.5}, items:[{xtype:'detailformtextfield', reference:'aconexNewRFISubject', fieldLabel:'Subject', columnWidth:1, itemId:'subject', publishes:'value'}, {xtype:'expandusergroup', columnWidth:1}, {xtype:'mandatoryfields', columnWidth:1, margin:0, reference:'rfiCreateMandatoryFields', bind:{store:'{rfiCreateMandatoryFields}'}}, {xtype:'container', layout:{type:'hbox', 
align:'bottom'}, columnWidth:1, margin:'10 12 10 12', items:[{xtype:'checkboxfield', reference:'aconexRFIDraft', ui:'plain-16', boxLabel:'Draft', itemId:'draft', checked:false, margin:'0 28 0 0'}, {xtype:'checkboxfield', reference:'aconexRFIPrivate', ui:'plain-16', boxLabel:'Private', itemId:'private'}]}]}, 0, ['aconexrficreate'], ['component', 'box', 'container', 'aconexrficreate'], {'component':true, 'box':true, 'container':true, 'aconexrficreate':true}, ['widget.aconexrficreate'], 0, [aconex.view.cards, 
'RFICreate'], 0);
Ext.cmd.derive('aconex.view.cards.RFIUpdate', Ext.Container, {reference:'card_RFIUpdate', layout:'column', defaults:{margin:'0 12 15 12', columnWidth:1}, items:[{xtype:'container', layout:{type:'hbox', align:'bottom'}, margin:'0 12 0 12', items:[{xtype:'label', text:'Inbox', uiCls:'form-item-label-detail-form'}, {xtype:'component', flex:1}, {xtype:'button', text:'Filter', ui:'plain', cls:'rfi-filter-btn', menuAlign:'tr-br', menu:{plain:true, scrollable:false, shadow:true, width:125, cls:'rfi-filter-menu', 
defaults:{xtype:'menucheckitem', checkHandler:'rfiFilterChangeHandler'}, items:[{text:'N/A', inputValue:'N/A'}, {text:'Closed-Out', inputValue:'Closed-Out'}, {text:'Outstanding', inputValue:'Outstanding'}, {text:'Overdue', inputValue:'Overdue'}, {text:'Responded', inputValue:'Responded'}]}}]}, {xtype:'detailformcombo', itemId:'mailCombo', reference:'aconexListMailCombo', emptyText:'- Select -', queryMode:'remote', queryDelay:600, queryCaching:true, queryParam:'searchText', triggerAction:'last', minChars:4, 
displayField:'displayField', valueField:'mailId', editable:true, disabled:true, bind:{store:'{aconexListMail}', disabled:'{!projectsLoaded}'}, listeners:{beforequery:'mailBeforeQuery', change:'rfiMailChangeHandler'}}, {xtype:'mandatoryfields', columnWidth:1, margin:0, reference:'rfiUpdateMandatoryFields', bind:{store:'{rfiUpdateMandatoryFields}'}}, {xtype:'detailformcombo', columnWidth:0.5, itemId:'updateStatus', fieldLabel:'Update Status', valueField:'id', displayField:'value', reference:'aconexRFIStatus', 
publishes:'value', bind:{store:'{aconexRFIFilters}'}}, {xtype:'checkboxfield', itemId:'officialResponse', reference:'rfiOfficialResponse', ui:'plain-16', boxLabel:'Official Response', columnWidth:0.5, labelSeparator:'', cls:'rfi-field-checkbox', checked:false, hidden:true, bind:{hidden:'{officialResponseHidden}'}}]}, 0, ['aconexrfiupdate'], ['component', 'box', 'container', 'aconexrfiupdate'], {'component':true, 'box':true, 'container':true, 'aconexrfiupdate':true}, ['widget.aconexrfiupdate'], 0, 
[aconex.view.cards, 'RFIUpdate'], 0);
Ext.cmd.derive('aconex.view.aconexwindow.AconexWindow', Ext.window.Window, {ui:'orange', cls:'integration-window', modalMaskCls:'dark-mask', viewModel:{type:'aconexwindow'}, controller:'aconexwindow', config:{photos:null, includeAnnotations:true, PushpinUID:'', attachFloorplanOnly:false}, updateAttachFloorplanOnly:function(floorplanOnly) {
  this.getViewModel().set('attachFloorplanOnly', floorplanOnly);
}, width:532, maxHeight:710, modal:true, title:'Add to Aconex', layout:{type:'vbox', align:'stretch'}, bind:{disabled:'{saving}'}, dockedItems:[{xtype:'container', reference:'warning', dock:'top', cls:'warning', layout:{type:'hbox', align:'center'}, minHeight:41, padding:10, hidden:true, bind:{hidden:'{!errorMessage}'}, items:[{xtype:'component', flex:1, bind:{html:'\x3cspan\x3e{errorMessage}\x3c/span\x3e'}}]}, {xtype:'container', dock:'bottom', layout:{type:'hbox', pack:'center'}, padding:'15 0 0 0', 
height:65, items:[{xtype:'button', scale:'medium', ui:'grey', text:'Cancel', margin:'0 10 0 0', listeners:{click:function() {
  this.up('window').destroy();
}}}, {xtype:'savebutton', reference:'saveButton', disabled:true, bind:{processing:'{saving}', done:'{saveDone}', disabled:'{saveDisabled}'}, margin:'0 0 0 10', listeners:{click:'submitPhotos'}}]}], items:[{xtype:'container', layout:'column', defaults:{margin:'0 12 15 12', columnWidth:1}, padding:'20 12 0 12', scrollable:'y', maxHeight:600, reference:'mainContainer', loadMaskCls:'light-load-indicator', items:[{xtype:'detailformcombo', reference:'projects', id:'projectsComboBox', fieldLabel:'Project', 
emptyText:'- Select -', queryMode:'local', displayField:'ProjectName', valueField:'ProjectId', disabled:true, columnWidth:0.5, bind:{store:'{aconexProjects}', value:'{aconexSetting_projectID}', disabled:'{!projectsLoaded}'}, listeners:{change:'onProjectChange'}}, {xtype:'integrationtype', columnWidth:0.5}, {xtype:'container', layout:'card', margin:0, items:[{xtype:'aconexdefault'}, {xtype:'aconexphotodocument'}, {xtype:'aconexrficreate'}, {xtype:'aconexrfiupdate'}], bind:{activeItem:'{activeCardIndex}'}}, 
{xtype:'integrationcomments', reference:'aconexComments', height:100, hidden:true, allowBlank:true, setAllowBlank:function(allow) {
  if (allow != this.allowBlank) {
    this.allowBlank = allow;
    if (allow) {
      this.validateValue(this.getValue());
    }
  }
}, bind:{hidden:'{isPhotoEntityType}', fieldLabel:'{commentsFieldLabel}', allowBlank:'{isDocumentEntityType}'}}, {xtype:'integrationattachment', reference:'aconexAttachment', photoBinding:'{aconexSetting_attachAsPhoto}', pdfBinding:'{aconexSetting_attachAs4View}', hidden:true, bind:{hidden:'{isPhotoEntityType}'}}]}], doRealign:Ext.emptyFn, listeners:{boxready:'onBoxReady'}, setPosition:function(x, y, animate, force) {
  if (force) {
    return Ext.window.Window.prototype.setPosition.apply(this, arguments);
  }
}, destroy:function() {
  var entityStores = this.lookupController().entityStores;
  for (var i = 0; i < entityStores.length; i++) {
    entityStores[i].destroy();
  }
  return Ext.window.Window.prototype.destroy.apply(this, arguments);
}}, 0, ['aconexwindow'], ['component', 'box', 'container', 'panel', 'window', 'aconexwindow'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true, 'aconexwindow':true}, ['widget.aconexwindow'], 0, [aconex.view.aconexwindow, 'AconexWindow'], 0);
Ext.cmd.derive('bim360.model.Folder', Ext.data.Model, {fields:[{name:'id', type:'string'}, {name:'attributes'}, {name:'displayField', calculate:function(data) {
  return data.attributes ? data.attributes.name : '';
}}]}, 0, 0, 0, 0, 0, 0, [bim360.model, 'Folder'], 0);
Ext.cmd.derive('bim360.model.Hub', Ext.data.Model, {fields:[{name:'id', type:'string'}, {name:'attributes'}, {name:'name', calculate:function(data) {
  return data.attributes ? data.attributes.name : '';
}}]}, 0, 0, 0, 0, 0, 0, [bim360.model, 'Hub'], 0);
Ext.cmd.derive('bim360.model.Project', Ext.data.Model, {fields:[{name:'id', type:'string'}, {name:'attributes'}, {name:'name', calculate:function(data) {
  return data.attributes.name;
}}]}, 0, 0, 0, 0, 0, 0, [bim360.model, 'Project'], 0);
Ext.cmd.derive('bim360.store.Folders', Ext.data.Store, {model:'bim360.model.Folder', proxy:{api:{create:'/index.cfm?fuseaction\x3daBim360.createFolder', read:'/index.cfm?fuseaction\x3daBim360.getProjectFilesFolders'}, writer:{writeAllFields:false}}}, 0, 0, 0, 0, 0, 0, [bim360.store, 'Folders'], 0);
Ext.cmd.derive('bim360.store.Projects', Ext.data.Store, {model:'bim360.model.Project', proxy:{url:'/index.cfm?fuseaction\x3daBim360.getProjects'}}, 0, 0, 0, 0, 0, 0, [bim360.store, 'Projects'], 0);
Ext.cmd.derive('bim360.view.bim360window.Bim360WindowModel', Ext.app.ViewModel, {stores:{bim360Hubs:{model:'bim360.model.Hub', autoLoad:false, mvAutoLoadVars:true, proxy:{url:'/index.cfm?fuseaction\x3daBim360.getDocsHubs'}}, bim360Projects:{proxy:{type:'memory'}}, integrationEntityTypes:{proxy:{type:'memory'}, model:'formShared.model.IntegrationEntityType', data:[{id:'Documents', name:'Documents', createAction:'uploadDocuments', storeType:'bim360.store.Folders'}]}, bim360DocumentActions:{proxy:{type:'memory'}, 
data:[{id:'CreateNewFolder', name:'Create New Folder'}, {id:'AddToExistingFolder', name:'Add to Existing Folder'}]}}, data:{private_bim360Setting_hubID:null, private_bim360Setting_projectID:null, private_bim360Setting_entityType:null, private_integrationAttachAsPhoto:null, private_integrationAtachAs4View:null, private_bim360Setting_documentAction:null, private_bim360Setting_folderID:null, entityID:'', projectsLoaded:false, bim360ObservationStatus:'', entityStoreLoaded:false, cardHeight:500, warningHeight:0, 
saving:false, saveDone:false, errorMessage:'', showAlertMessage:false, integrationEntityType:'Documents', attachFloorplanOnly:false}, formulas:{bim360Setting_hubID:{get:function(get) {
  var bim360Setting_hubID = get('private_bim360Setting_hubID');
  if (bim360Setting_hubID !== null) {
    return bim360Setting_hubID;
  }
  if (!get('globalPreferencesReady')) {
    return null;
  }
  return mdsPreferences.ProjectPreferences.getBim360Setting_hubID();
}, set:function(value) {
  this.set('private_bim360Setting_hubID', value);
  mdsPreferences.ProjectPreferences.setBim360Setting_hubID(value);
}}, bim360Setting_projectID:{get:function(get) {
  var bim360Setting_projectID = get('private_bim360Setting_projectID');
  if (bim360Setting_projectID !== null) {
    return bim360Setting_projectID;
  }
  if (!get('globalPreferencesReady')) {
    return null;
  }
  return mdsPreferences.ProjectPreferences.getBim360Setting_projectID();
}, set:function(value) {
  this.set('private_bim360Setting_projectID', value);
  mdsPreferences.ProjectPreferences.setBim360Setting_projectID(value);
}}, integrationAttachAsPhoto:{get:function(get) {
  var integrationAttachAsPhoto = get('private_integrationAttachAsPhoto');
  if (integrationAttachAsPhoto !== null) {
    return integrationAttachAsPhoto;
  }
  if (!get('globalPreferencesReady')) {
    return null;
  }
  var pref = mdsPreferences.ProjectPreferences.getBim360Setting_attachAsPhoto();
  return pref === undefined ? false : pref;
}, set:function(value) {
  this.set('private_integrationAttachAsPhoto', value);
  mdsPreferences.ProjectPreferences.setBim360Setting_attachAsPhoto(value);
}}, integrationAtachAs4View:{get:function(get) {
  var integrationAtachAs4View = get('private_integrationAtachAs4View');
  if (integrationAtachAs4View !== null) {
    return integrationAtachAs4View;
  }
  if (!get('globalPreferencesReady')) {
    return null;
  }
  var pref = mdsPreferences.ProjectPreferences.getBim360Setting_attachAs4View();
  return pref === undefined ? true : pref;
}, set:function(value) {
  this.set('private_integrationAtachAs4View', value);
  mdsPreferences.ProjectPreferences.setBim360Setting_attachAs4View(value);
}}, bim360Setting_documentAction:{get:function(get) {
  var bim360Setting_documentAction = get('private_bim360Setting_documentAction');
  if (bim360Setting_documentAction !== null) {
    return bim360Setting_documentAction;
  }
  if (!get('globalPreferencesReady')) {
    return null;
  }
  var value = mdsPreferences.ProjectPreferences.getBim360Setting_documentAction();
  return value || 'AddToExistingFolder';
}, set:function(value) {
  this.set('private_bim360Setting_documentAction', value);
  mdsPreferences.ProjectPreferences.setBim360Setting_documentAction(value);
}}, bim360Setting_folderID:{get:function(get) {
  var bim360Setting_folderID = get('private_bim360Setting_folderID');
  if (bim360Setting_folderID !== null) {
    return bim360Setting_folderID;
  }
  if (!get('globalPreferencesReady')) {
    return null;
  }
  var value = mdsPreferences.ProjectPreferences.getBim360Setting_folderID();
  return value || undefined;
}, set:function(value) {
  var store = this.get('entityStore');
  if (store && store.$className == 'bim360.store.Folders' && store.isLoaded() && !store.getById(value)) {
    return;
  }
  this.set('private_bim360Setting_folderID', value);
  mdsPreferences.ProjectPreferences.setBim360Setting_folderID(value);
}}, entityType:function(get) {
  return get('integrationEntityTypes').getById(get('integrationEntityType'));
}, entity:function(get) {
  var entityTypeID = get('integrationEntityType');
  if (!entityTypeID) {
    return null;
  }
  var store = get('entityStore');
  if (!store || !get('entityStoreLoaded')) {
    return null;
  }
  return store.getById(get('calculatedEntityID'));
}, projectSelected:function(get) {
  return get('projectsLoaded') && get('bim360Setting_projectID');
}, subType:function(get) {
  var entityType = get('entityType');
  if (entityType) {
    var id = entityType.getId();
    if (id == 'Documents') {
      return get('bim360Setting_documentAction');
    }
  }
  return null;
}, calculatedEntityID:function(get) {
  if (get('subType') == 'AddToExistingFolder') {
    return get('bim360Setting_folderID');
  }
  return get('entityID');
}, dailyLogDateID:function(get) {
  return Ext.Date.format(get('dailyLogDate'), 'Ymd');
}, submitReady:function(get) {
  var entityType = get('entityType'), subType = get('subType');
  if (!entityType) {
    return false;
  }
  if (entityType.getId() == 'Documents' && subType == 'CreateNewFolder') {
    return !!get('bim360NewFolderName.value');
  }
  return get('calculatedEntityID') && (get('integrationAttachAsPhoto') || get('integrationAtachAs4View'));
}, entityStoreID:function(get) {
  var entityType = get('entityType'), project_id = get('bim360Setting_projectID');
  if (!entityType) {
    return null;
  }
  var storeId = 'bim360_' + entityType.get('name').replace(' ', '') + '_' + project_id;
  return storeId;
}, entityStore:function(get) {
  var entityType = get('entityType'), storeType = get('entityStoreType');
  if (!entityType || !storeType) {
    return Ext.create('Ext.data.Store', {proxy:'memory'});
  }
  var entityTypeID = get('entityType').getId(), storeId = get('entityStoreID'), store = Ext.getStore(storeId), controller = this.getView().lookupController();
  if (!store && get('bim360Setting_hubID') && get('bim360Setting_projectID')) {
    store = Ext.create(storeType, {storeId:storeId, autoLoad:true, proxy:{extraParams:controller.getEntityStoreParams(entityTypeID)}, listeners:{load:controller.onEntityStoreLoad, scope:controller}});
  }
  if (store) {
    this.set('entityStoreLoaded', store.isLoaded());
  }
  return store;
}, entityStoreType:function(get) {
  var entityType = get('entityType');
  if (!entityType) {
    return null;
  }
  var storeType = entityType.get('storeType');
  if (!storeType) {
    return 'bim360.store.' + entityType + 's';
  }
  return storeType;
}, card:function(get) {
  var controller = this.getView().lookupController(), entityTypeID = get('integrationEntityType'), subType = get('subType'), projectID = get('bim360Setting_projectID'), defaultCard = controller.lookupReference('card_default');
  return projectID ? controller.lookupReference('card_' + entityTypeID + '_' + subType) || controller.lookupReference('card_' + entityTypeID) || defaultCard : defaultCard;
}, itemDescription:function(get) {
  return 'item';
}, lowercaseEntityName:function(get) {
  var entityType = get('entityType');
  if (!entityType) {
    return '';
  }
  var name = entityType.get('name');
  return name.toLowerCase();
}, emptyText:function(get) {
  var entityStore = get('entityStore'), entityStoreLoaded = get('entityStoreLoaded');
  if (get('submitReady') || !entityStore || !entityStoreLoaded || entityStore.getCount()) {
    return '- Select -';
  }
  return 'No ' + get('itemDescription') + 's available.';
}, noItemsAvailable:function(get) {
  var entityStore = get('entityStore'), entityStoreLoaded = get('entityStoreLoaded');
  return !(get('submitReady') || !entityStore || !entityStoreLoaded || entityStore.getCount());
}, warningMessage:function(get) {
  var entityStore = get('entityStore'), entityStoreLoaded = get('entityStoreLoaded'), storeType = get('entityStoreType'), errorMessage = get('errorMessage'), message = '', showAlertMessage = !!(get('showAlertMessage') || errorMessage);
  if (!showAlertMessage || get('submitReady') || storeType && !entityStore || storeType && !entityStoreLoaded) {
    message = '';
  } else {
    if (!entityStore.getCount()) {
      message = 'You cannot complete the ' + get('lowercaseEntityName') + ' submission because there are no ' + get('itemDescription') + 's to select.';
    } else {
      if (!get('integrationAttachAsPhoto') && !get('integrationAtachAs4View')) {
        message = 'You cannot complete the export process until you have chosen what files to attach.';
      } else {
        if (get('singlePhotoTitle').trim() == '') {
          message = 'You cannot complete the export process until you have chosen a title.';
        } else {
          if (get('subType') == 'AddToExistingFolder' && !get('bim360Setting_folderID')) {
            message = 'You cannot complete the export process until you have chosen a folder.';
          }
        }
      }
    }
  }
  if (message) {
    this.set('errorMessage', '');
  } else {
    if (errorMessage) {
      message = errorMessage;
    }
  }
  this.set('warningHeight', message ? 41 : 0);
  if (!message) {
    this.set('showAlertMessage', false);
  }
  return message;
}, windowHeight:function(get) {
  return get('cardHeight') + get('warningHeight');
}, multiplePhotosSelected:function(get) {
  return this.getView().getPhotos().length > 1;
}}}, 0, 0, 0, 0, ['viewmodel.bim360window'], 0, [bim360.view.bim360window, 'Bim360WindowModel'], 0);
Ext.cmd.derive('bim360.view.bim360window.Bim360WindowController', Ext.app.ViewController, {init:function() {
  var vm = this.getViewModel();
  vm.bind('{bim360Setting_hubID}', this.onHubChange, this);
  vm.bind({_bim360HubsLoaded:'{_bim360HubsLoaded}', private_bim360Setting_hubID:'{bim360Setting_hubID}', singlePhotoTitle:'{singlePhotoTitle}'}, function(data) {
    if (data._bim360HubsLoaded && data.bim360Setting_hubID !== null && data.singlePhotoTitle) {
      this.onDataReady();
    }
  }, this);
  vm.bind('{card}', this.onCardChange, this);
  vm.bind('{windowHeight}', this.onWindowHeightChange, this);
  vm.bind('{entityStore}', this.onEntityStoreChange, this);
  Ext.defer(function() {
    this.getView().showBy(Ext.getBody(), 't-t?', [0, this.getWindowY(Ext.getBody().getHeight())], false);
  }, 1, this);
  Ext.getBody().addListener('resize', function(component, dimensions) {
    this.getView().setPosition(this.getWindowX(dimensions.width), this.getWindowY(dimensions.height), false, true);
  }, this, {buffer:200});
  var bim360Hubs = this.getStore('bim360Hubs');
  bim360Hubs.load({callback:Ext.bind(function(records, operation, success) {
    var responseJSON = null;
    if (!success) {
      try {
        responseJSON = Ext.decode(operation.getResponse().responseText);
      } catch (e$8) {
      }
      var msg = responseJSON && responseJSON.message ? responseJSON.message : mvstr.G_UnexpectedError;
      Ext.Msg.alert('Error', msg);
      this.getView().destroy();
    }
  }, this)});
  var view = this.getView(), photos = this.getView().getPhotos();
  if (photos.length == 1) {
    Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daPlanGrid.getPhotoTitle', params:{ProjectUID:this.getViewModel().get('ProjectUID'), photos:photos[0]}, successCallback:function(data) {
      this.getViewModel().set('singlePhotoTitle', data);
    }, scope:this});
  } else {
    this.getViewModel().set('singlePhotoTitle', view.fileTitle ? view.fileTitle : '-1');
  }
  if (view.attachFloorplanOnly !== undefined) {
    vm.set('attachFloorplanOnly', view.attachFloorplanOnly);
  }
}, onBoxReady:function() {
  this.lookupReference('cards').setLoading(true);
}, getWindowX:function(bodyWidth) {
  return Math.max(0, (bodyWidth - this.getView().el.getWidth()) / 2);
}, getWindowY:function(bodyHeight) {
  var topOffset = (bodyHeight - 699) / 2, currentHeight = this.getView().el.getHeight();
  if (topOffset + currentHeight > bodyHeight) {
    topOffset = (bodyHeight - currentHeight) / 2;
  }
  return Math.max(0, topOffset);
}, onDataReady:function() {
  this.lookupReference('cards').setLoading(false);
}, onProjectsLoaded:function(projects) {
  var viewModel = this.getViewModel(), savedProjectID = viewModel.get('bim360Setting_projectID');
  viewModel.set('projectsLoaded', true);
  if (savedProjectID && projects.getById(savedProjectID)) {
    this.lookupReference('projects').setValue(savedProjectID);
  } else {
    this.lookupReference('projects').setValue('');
  }
}, onHubChange:function(hubID) {
  if (hubID) {
    this.getViewModel().set('bim360Projects', this.getProjectStore(hubID));
  }
  this.getViewModel().set('showAlertMessage', false);
}, onProjectChange:function(combo, projectID) {
  if (projectID) {
    this.getViewModel().set('bim360Setting_projectID', projectID);
  } else {
    this.getViewModel().set('entityID', '');
  }
  this.getViewModel().set('showAlertMessage', false);
}, getProjectStoreID:function(hubID) {
  return 'bim360ProjectStore-' + hubID;
}, getProjectStore:function(hubID) {
  if (!hubID) {
    return Ext.create('Ext.data.Store', {proxy:{type:'memory'}});
  }
  var storeID = this.getProjectStoreID(hubID), store = Ext.getStore(storeID);
  this.getViewModel().set('projectsLoaded', store && store.isLoaded());
  return store || Ext.create('bim360.store.Projects', {autoLoad:true, proxy:{extraParams:{hub_id:hubID}}, listeners:{load:{fn:this.onProjectsLoaded, scope:this}}});
}, getEntityStoreId:function(entityTypeID) {
  var entityType = this.getStore('integrationEntityTypes').getById(entityTypeID), project_id = this.getViewModel().get('bim360Setting_projectID');
  var storeId = 'bim360_' + entityType.get('name').replace(' ', '') + '_' + project_id;
  if (entityType.get('subCreateActions')) {
    storeId += '_' + this.getViewModel().get('subType');
  }
  return storeId;
}, getEntityStoreParams:function(entityTypeID) {
  var viewModel = this.getViewModel(), extraParams = {project_id:viewModel.get('bim360Setting_projectID'), hub_id:viewModel.get('bim360Setting_hubID')};
  return extraParams;
}, getCreateAction:function() {
  var entityType = this.getStore('integrationEntityTypes').getById(this.getViewModel().get('integrationEntityType')), subType = this.getViewModel().get('subType'), subCreateActions = entityType.get('subCreateActions');
  return subCreateActions ? entityType.get('subCreateActions')[subType] : entityType.get('createAction');
}, getSubmitParams:function(data) {
  var viewModel = this.getViewModel(), photos = this.getView().getPhotos(), entityID = data && data.id ? data.id : viewModel.get('calculatedEntityID'), card = viewModel.get('card'), pushpinUID = this.getView().getPushpinUID(), entity = viewModel.get('entity'), displayField = data && data.displayField ? data.displayField : entity ? entity.get('displayField') : '', params = {ProjectUID:viewModel.get('ProjectUID'), photos:photos.join(','), hub_id:viewModel.get('bim360Setting_hubID'), project_id:viewModel.get('bim360Setting_projectID'), 
  id:entityID, dateString:Ext.Date.format(new Date, 'ymd'), includeAnnotations:this.getView().getIncludeAnnotations(), displayName:displayField, projectName:viewModel.get('bim360Projects').getById(viewModel.get('bim360Setting_projectID')).get('name'), asynchronous:this.isAsyncUpload()};
  if (pushpinUID) {
    params.PushpinUID = pushpinUID;
  }
  if (!viewModel.get('multiplePhotosSelected')) {
    params.title = viewModel.get('singlePhotoTitle');
  }
  params.attachAsPhoto = viewModel.get('integrationAttachAsPhoto');
  params.attachAs4View = viewModel.get('integrationAtachAs4View');
  params.attachAsFloorplan = viewModel.get('attachFloorplanOnly');
  if (params.attachAsFloorplan) {
    params.attachAsPhoto = params.attachAs4View = false;
    params.FloorplanUID = viewModel.get('FloorplanUID');
    params.displayHeader = card.down('#headerCheckbox').getValue();
    params.displayHotspots = card.down('#hotspotsCheckbox').getValue();
    params.displayPushpins = card.down('#pushpinsCheckbox').getValue();
  }
  return params;
}, isAsyncUpload:function() {
  var viewModel = this.getViewModel(), asyncUpload = viewModel.get('account.features.uploadscenterVisible');
  return asyncUpload;
}, submitPhotos:function(data) {
  var viewModel = this.getViewModel(), asyncUpload = this.isAsyncUpload();
  if (!viewModel.get('submitReady')) {
    viewModel.set('showAlertMessage', true);
    return;
  }
  viewModel.set('showAlertMessage', false);
  viewModel.set('saving', true);
  if (viewModel.get('subType') == 'CreateNewFolder' && !data) {
    this.createNewFolder();
    return;
  }
  var params = this.getSubmitParams(data);
  Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daBim360.' + this.getCreateAction(), params:params, successCallback:function(data) {
    if (asyncUpload) {
      window.app.fireEvent('reloadfileuploads', {sourceType:'integration', responseData:data, photos:params.photos.split(',')});
    } else {
      viewModel.set('saveDone', true);
    }
    if (data && data.callback) {
      data.callback();
    }
    Ext.defer(function() {
      this.getView().destroy();
    }, 1000, this);
  }, afterFailMessageCallback:function(data, message) {
    viewModel.set('saving', false);
    viewModel.set('errorMessage', message ? message : mvstr.G_UnexpectedError);
  }, noAlert:true, scope:this});
}, createNewFolder:function() {
  var viewModel = this.getViewModel(), store = viewModel.get('entityStore'), record = Ext.create('bim360.model.Folder', {attributes:{name:this.lookupReference('bim360NewFolderName').getValue()}});
  store.add(record);
  store.sync({success:function() {
    var id = record.getId();
    this.submitPhotos({id:id, displayField:record.get('displayField'), callback:function() {
      viewModel.set('bim360Setting_documentAction', 'AddToExistingFolder');
      viewModel.set('bim360Setting_folderID', id);
    }});
  }, afterFailMessageCallback:function(batch, message) {
    store.rejectChanges();
    viewModel.set('saving', false);
    viewModel.set('errorMessage', message ? message : mvstr.G_UnexpectedError);
  }, scope:this, noAlert:true});
}, onCardChange:function(card) {
  if (card) {
    this.lookupReference('cards').setActiveItem(card);
    this.getViewModel().set('cardHeight', card.getWindowHeight());
  }
  this.getViewModel().set('showAlertMessage', false);
}, onWarningResize:function(component) {
  this.getViewModel().set('warningHeight', component.el.getHeight());
}, onEntityStoreLoad:function(store) {
  if (store == this.getViewModel().get('entityStore')) {
    this.getViewModel().set('entityStoreLoaded', true);
  }
  this.updateDefaultFolder();
}, updateDefaultFolder:function() {
  var store = this.getViewModel().get('entityStore');
  if (!store) {
    return;
  }
  if (store.$className == 'bim360.store.Folders') {
    var id = this.getViewModel().get('bim360Setting_folderID');
    if (!store.getById(id)) {
      var count = store.getCount();
      for (var i = 0; i < count; i++) {
        var folder = store.getAt(i);
        if (folder.get('displayField') == 'Multivista') {
          this.getViewModel().set('bim360Setting_folderID', folder.getId());
          break;
        }
      }
    }
  }
}, onWindowHeightChange:function(windowHeight) {
  this.getView().setHeight(windowHeight);
}, onEntityStoreChange:function(entityStore) {
  this.updateDefaultFolder();
}}, 0, 0, 0, 0, ['controller.bim360window'], 0, [bim360.view.bim360window, 'Bim360WindowController'], 0);
Ext.cmd.derive('bim360.view.cards.DocumentsNewFolder', Ext.Container, {reference:'card_Documents_CreateNewFolder', layout:'vbox', getWindowHeight:function() {
  var photos = this.up('bim360window').getPhotos();
  return photos.length > 1 ? 531 : 561;
}, items:[{xtype:'integrationssubtype', fieldLabel:'Action', margin:'0 0 28 0', bind:{store:'{bim360DocumentActions}', value:'{bim360Setting_documentAction}'}}, {xtype:'detailformtextfield', reference:'bim360NewFolderName', fieldLabel:'Name New Folder', emptyText:'Enter new folder name', margin:'0 0 28 0', width:'100%', publishes:'value'}, {xtype:'detailformtextfield', reference:'bim360DocumentTitleNew', fieldLabel:'Title', emptyText:'Enter title', margin:'0 0 28 0', width:'100%', publishes:'value', 
hidden:true, bind:{hidden:'{multiplePhotosSelected}', value:'{singlePhotoTitle}'}}, {xtype:'integrationattachment', photoBinding:'{integrationAttachAsPhoto}', pdfBinding:'{integrationAtachAs4View}'}]}, 0, ['bim360documentsnewfolder'], ['component', 'box', 'container', 'bim360documentsnewfolder'], {'component':true, 'box':true, 'container':true, 'bim360documentsnewfolder':true}, ['widget.bim360documentsnewfolder'], 0, [bim360.view.cards, 'DocumentsNewFolder'], 0);
Ext.cmd.derive('bim360.view.cards.DocumentsExistingFolder', Ext.Container, {reference:'card_Documents_AddToExistingFolder', layout:'vbox', getWindowHeight:function() {
  var photos = this.up('bim360window').getPhotos();
  return photos.length > 1 ? 450 : 480;
}, items:[{xtype:'container', layout:'hbox', width:'100%', items:[{xtype:'integrationssubtype', fieldLabel:'Action', margin:'0 0 28 0', bind:{store:'{bim360DocumentActions}', value:'{bim360Setting_documentAction}'}}, {xtype:'component', flex:1}, {xtype:'detailformcombo', width:202, fieldLabel:'Folder', emptyText:'Loading ...', displayField:'displayField', valueField:'id', bind:{value:'{bim360Setting_folderID}', store:'{entityStore}', disabled:'{!entityStoreLoaded}'}}]}, {xtype:'detailformtextfield', 
reference:'bim360DocumentTitleExisting', fieldLabel:'Title', emptyText:'Enter title', margin:'0 0 28 0', width:'100%', publishes:'value', hidden:true, bind:{hidden:'{multiplePhotosSelected}', value:'{singlePhotoTitle}'}}, {xtype:'integrationattachment', photoBinding:'{integrationAttachAsPhoto}', pdfBinding:'{integrationAtachAs4View}'}]}, 0, ['bim360documentsexistingfolder'], ['component', 'box', 'container', 'bim360documentsexistingfolder'], {'component':true, 'box':true, 'container':true, 'bim360documentsexistingfolder':true}, 
['widget.bim360documentsexistingfolder'], 0, [bim360.view.cards, 'DocumentsExistingFolder'], 0);
Ext.cmd.derive('bim360.view.cards.Default', Ext.Container, {config:{windowHeight:312}, reference:'card_default'}, 0, ['bim360default'], ['component', 'box', 'container', 'bim360default'], {'component':true, 'box':true, 'container':true, 'bim360default':true}, ['widget.bim360default'], 0, [bim360.view.cards, 'Default'], 0);
Ext.cmd.derive('bim360.view.bim360window.Bim360Window', Ext.window.Window, {ui:'orange', cls:'integration-window', modalMaskCls:'dark-mask', viewModel:{type:'bim360window'}, controller:'bim360window', config:{photos:null, includeAnnotations:true, PushpinUID:''}, width:488, modal:true, title:'Add to BIM 360', layout:{type:'fit'}, bind:{height:'{windowHeight}', disabled:'{saving}'}, dockedItems:[{xtype:'container', reference:'warning', dock:'top', cls:'warning', layout:{type:'hbox', align:'center'}, 
minHeight:41, padding:10, hidden:true, bind:{hidden:'{!warningMessage}'}, listeners:{'resize':'onWarningResize', 'show':'onWarningResize'}, items:[{xtype:'component', flex:1, bind:{html:'\x3cspan\x3e{warningMessage}\x3c/span\x3e'}}]}], items:[{xtype:'panel', padding:25, layout:'card', reference:'cards', loadMaskCls:'light-load-indicator', dockedItems:[{xtype:'container', dock:'top', layout:'hbox', margin:'0 0 28 0', items:[{xtype:'detailformcombo', width:202, fieldLabel:'Company', emptyText:'- Select -', 
queryMode:'local', displayField:'name', valueField:'id', disabled:true, bind:{store:'{bim360Hubs}', value:'{bim360Setting_hubID}', disabled:'{!_bim360HubsLoaded}'}}, {xtype:'component', flex:1}, {xtype:'detailformcombo', width:202, reference:'projects', fieldLabel:'Project', emptyText:'- Select -', queryMode:'local', displayField:'name', valueField:'id', disabled:true, bind:{store:'{bim360Projects}', disabled:'{!_bim360HubsLoaded}'}, listeners:{change:'onProjectChange'}}]}, {xtype:'container', dock:'bottom', 
layout:{type:'hbox', pack:'center'}, padding:'25 0 0 0', items:[{xtype:'button', scale:'medium', ui:'grey', text:'Cancel', margin:'0 12 0 12', listeners:{click:function() {
  this.up('window').destroy();
}}}, {xtype:'savebutton', reference:'saveButton', bind:{processing:'{saving}', done:'{saveDone}'}, margin:'0 12 0 12', listeners:{click:function() {
  this.lookupController().submitPhotos();
}}}]}], items:[{xtype:'bim360default'}, {xtype:'bim360documentsexistingfolder'}, {xtype:'bim360documentsnewfolder'}]}], doRealign:Ext.emptyFn, setPosition:function(x, y, animate, force) {
  if (force) {
    return Ext.window.Window.prototype.setPosition.apply(this, arguments);
  }
}, listeners:{boxready:'onBoxReady'}}, 0, ['bim360window'], ['component', 'box', 'container', 'panel', 'window', 'bim360window'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true, 'bim360window':true}, ['widget.bim360window'], 0, [bim360.view.bim360window, 'Bim360Window'], 0);
Ext.cmd.derive('bluebeam.model.Project', Ext.data.Model, {idProperty:'Id', fields:[{name:'$id', type:'string'}, {name:'Id', type:'string'}, {name:'Guid', type:'string'}, {name:'Name', type:'string'}, {name:'Restricted', type:'boolean'}, {name:'Created', type:'string'}, {name:'OwnerEmail', type:'string'}, {name:'PrimeId', type:'int'}]}, 0, 0, 0, 0, 0, 0, [bluebeam.model, 'Project'], 0);
Ext.cmd.derive('bluebeam.model.User', Ext.data.Model, {idProperty:'UserId', fields:[{name:'$id', type:'int'}, {name:'UserId', type:'int'}, {name:'Email', type:'int'}, {name:'DisplayName', type:'int'}, {name:'PrimeMemberRole', type:'int'}, {name:'UserRole', type:'int'}]}, 0, 0, 0, 0, 0, 0, [bluebeam.model, 'User'], 0);
Ext.cmd.derive('bluebeam.view.bluebeamwindow.BluebeamWindowModel', Ext.app.ViewModel, {stores:{bluebeamProjects:{model:'bluebeam.model.Project', proxy:{url:'/index.cfm?fuseaction\x3daBluebeam.getProjects'}, autoLoad:true, listeners:{load:'onProjectsLoaded'}}, integrationEntityTypes:{proxy:{type:'memory'}, model:'formShared.model.IntegrationEntityType', data:[{id:'Photo', name:'Photo', createAction:'uploadPhotos'}, {id:'Document', name:'Photo W/ Floorplan', createAction:'uploadDocuments'}]}, bluebeamUsers:{storeId:'bluebeamUsers', 
model:'bluebeam.model.User', proxy:{url:'/index.cfm?fuseaction\x3daBluebeam.getUser'}, autoLoad:false, listeners:{load:'onUsersLoaded'}}}, data:{private_bluebeamSetting_projectID:null, private_bluebeamSetting_entityType:null, private_bluebeamSetting_attachAsPhoto:null, private_bluebeamSetting_attachAs4View:null, private_bluebeamSetting_rfiFilterValue:null, singlePhotoTitle:'', projectsLoaded:false, usersLoaded:false, saving:false, saveDone:false, errorMessage:'', attachFloorplanOnly:false, flooplanTitle:''}, 
formulas:{bluebeamSetting_projectID:{get:function(get) {
  var bluebeamSetting_projectID = get('private_bluebeamSetting_projectID');
  if (bluebeamSetting_projectID !== null) {
    return bluebeamSetting_projectID;
  }
  if (!get('globalPreferencesReady')) {
    return null;
  }
  return mdsPreferences.ProjectPreferences.getBluebeamSetting_projectID();
}, set:function(value) {
  this.set('private_bluebeamSetting_projectID', value);
  mdsPreferences.ProjectPreferences.setBluebeamSetting_projectID(value);
}}, integrationEntityType:{get:function(get) {
  var bluebeamSetting_entityType = get('private_bluebeamSetting_entityType');
  if (bluebeamSetting_entityType !== null) {
    return bluebeamSetting_entityType;
  }
  if (!get('globalPreferencesReady')) {
    return null;
  }
  return mdsPreferences.ProjectPreferences.getBluebeamSetting_entityType();
}, set:function(value) {
  this.set('private_bluebeamSetting_entityType', value);
  mdsPreferences.ProjectPreferences.setBluebeamSetting_entityType(value);
}}, bluebeamSetting_attachAsPhoto:{get:function(get) {
  var bluebeamSetting_attachAsPhoto = get('private_bluebeamSetting_attachAsPhoto');
  if (bluebeamSetting_attachAsPhoto !== null) {
    return bluebeamSetting_attachAsPhoto;
  }
  if (!get('globalPreferencesReady')) {
    return null;
  }
  var pref = mdsPreferences.ProjectPreferences.getBluebeamSetting_attachAsPhoto();
  return pref === undefined ? false : pref;
}, set:function(value) {
  this.set('private_bluebeamSetting_attachAsPhoto', value);
  mdsPreferences.ProjectPreferences.setBluebeamSetting_attachAsPhoto(value);
}}, bluebeamSetting_attachAs4View:{get:function(get) {
  var bluebeamSetting_attachAs4View = get('private_bluebeamSetting_attachAs4View');
  if (bluebeamSetting_attachAs4View !== null) {
    return bluebeamSetting_attachAs4View;
  }
  if (!get('globalPreferencesReady')) {
    return null;
  }
  var pref = mdsPreferences.ProjectPreferences.getBluebeamSetting_attachAs4View();
  return pref === undefined ? true : pref;
}, set:function(value) {
  this.set('private_bluebeamSetting_attachAs4View', value);
  mdsPreferences.ProjectPreferences.setBluebeamSetting_attachAs4View(value);
}}, entityType:function(get) {
  return get('integrationEntityTypes').getById(get('integrationEntityType'));
}, activeCardIndex:function(get) {
  return 1;
}, projectSelected:function(get) {
  return get('projectsLoaded') && get('bluebeamSetting_projectID');
}, singlePhotoSelected:function(get) {
  return this.getView().getPhotos().length === 1;
}, multiplePhotosSelected:function(get) {
  return this.getView().getPhotos().length > 1;
}, isPhotoEntityType:function(get) {
  return get('integrationEntityType') == 'Photo';
}, isDocumentEntityType:function(get) {
  return get('integrationEntityType') == 'Document';
}, submitReady:function(get) {
  var projectsLoaded = get('projectsLoaded');
  var project_id = get('bluebeamSetting_projectID');
  return projectsLoaded && project_id !== '';
}, saveDisabled:function(get) {
  return !get('submitReady');
}}}, 0, 0, 0, 0, ['viewmodel.bluebeamwindow'], 0, [bluebeam.view.bluebeamwindow, 'BluebeamWindowModel'], 0);
Ext.cmd.derive('bluebeam.view.bluebeamwindow.BluebeamWindowController', Ext.app.ViewController, {entityStores:[], init:function() {
  window.bwc = this;
  var vm = this.getViewModel();
  this.datePhotoWasTaken = Ext.Date.format(new Date, 'Y-m-d');
  vm.bind({singlePhotoSelected:'{singlePhotoSelected}', ProjectUID:'{ProjectUID}'}, function(data) {
    var photos = this.getView().getPhotos();
    vm.set('singlePhotoTitle', '');
    if (data.singlePhotoSelected) {
      Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daBluebeam.getPhotoTitle', params:{ProjectUID:data.ProjectUID, photos:photos[0]}, scope:this, successCallback:function(data) {
        vm.set('singlePhotoTitle', data);
        var photoDate = data.split('-')[2].trim();
        this.datePhotoWasTaken = '20' + photoDate.substr(0, 2) + '-' + photoDate.substr(2, 2) + '-' + photoDate.substr(4);
      }});
    }
  }, this);
  Ext.defer(function() {
    this.getAttachFloorplanOnly();
  }, 1, this);
  Ext.defer(function() {
    this.getView().showBy(Ext.getBody(), 't-t?', [0, this.getWindowY(Ext.getBody().getHeight())], false);
  }, 1, this);
  Ext.getBody().addListener('resize', function(component, dimensions) {
    this.getView().setPosition(this.getWindowX(dimensions.width), this.getWindowY(dimensions.height), false, true);
  }, this, {buffer:200});
}, getWindowX:function(bodyWidth) {
  return Math.max(0, (bodyWidth - this.getView().el.getWidth()) / 2);
}, getWindowY:function(bodyHeight) {
  var topOffset = (bodyHeight - 699) / 2, currentHeight = this.getView().el.getHeight();
  if (topOffset + currentHeight > bodyHeight) {
    topOffset = (bodyHeight - currentHeight) / 2;
  }
  return Math.max(0, topOffset);
}, onBoxReady:function() {
  this.lookup('mainContainer').setLoading(true);
}, onProjectsLoaded:function(store, records, successful, operation) {
  this.lookup('mainContainer').setLoading(false);
  if (successful) {
    var viewModel = this.getViewModel();
    var savedProjectID = viewModel.get('bluebeamSetting_projectID');
    viewModel.set('projectsLoaded', true);
    var projectsCombo = this.lookup('projects');
    if (savedProjectID && store.getById(savedProjectID)) {
      projectsCombo.setValue(savedProjectID);
    } else {
      if (store.getCount() == 1) {
        var firstProject = store.getAt(0);
        viewModel.set('bluebeamSetting_projectID', firstProject.id);
        projectsCombo.setValue(firstProject.id);
      } else {
        viewModel.set('bluebeamSetting_projectID', 0);
        projectsCombo.clearValue();
      }
    }
  } else {
    var msg = 'Failed to load Bluebeam projects';
    Ext.Msg.alert('Error', msg);
    this.getView().destroy();
  }
}, onUsersLoaded:function(store, records, successful) {
  this.getViewModel().set('usersLoaded', successful);
}, onProjectChange:function(combo, bluebeamProjectId) {
  var vm = this.getViewModel();
  vm.set({bluebeamSetting_projectID:bluebeamProjectId, errorMessage:''});
  vm.notify();
  if (bluebeamProjectId > 0) {
    this.getBluebeamUsers(bluebeamProjectId);
  }
}, getBluebeamUsers:function(bluebeamProjectId) {
  this.getStore('bluebeamUsers').load({scope:this, callback:function(records, operation, success) {
    if (!success) {
      var vm = this.getViewModel();
    }
  }});
}, getCreateAction:function() {
  var createAction = 'uploadDocuments';
  return createAction;
}, getSubmitParams:function() {
  var viewModel = this.getViewModel(), photos = this.getView().getPhotos(), pushpinUID = this.getView().getPushpinUID();
  var projects = viewModel.get('bluebeamProjects');
  if (!projects.isLoaded() || projects.getCount() == 0) {
    viewModel.set('errorMessage', 'There are no projects available');
    return null;
  }
  var bluebeamProjectId = viewModel.get('bluebeamSetting_projectID');
  var project = projects.getById(bluebeamProjectId);
  if (!project) {
    viewModel.set('errorMessage', 'Please select a Project');
    return null;
  }
  var attachments = this.lookup('bluebeamAttachment');
  var params = {ProjectUID:viewModel.get('ProjectUID'), photos:photos.join(','), project_id:bluebeamProjectId, includeAnnotations:this.getView().getIncludeAnnotations(), projectName:project.get('Name'), attachAsPhoto:attachments.down('#attachPhoto').getValue(), attachAs4View:attachments.down('#attachDetails').getValue(), attachAsFloorplan:this.getViewModel().get('attachFloorplanOnly'), comment:this.lookup('bluebeamComments').getValue()};
  if (params.attachAsFloorplan) {
    params.attachAsPhoto = params.attachAs4View = false;
    params.FloorplanUID = viewModel.get('FloorplanUID');
    params.displayHeader = attachments.down('#headerCheckbox').getValue();
    params.displayHotspots = attachments.down('#hotspotsCheckbox').getValue();
    params.displayPushpins = attachments.down('#pushpinsCheckbox').getValue();
    params.title = viewModel.get('bluebeamPhotoTitle').value;
  }
  if (pushpinUID) {
    params.PushpinUID = pushpinUID;
  }
  params = this.addPhotoDocumentParams(params, photos.length === 1);
  return params;
}, addPhotoDocumentParams:function(params, isSinglePhoto) {
  var viewModel = this.getViewModel();
  if (isSinglePhoto) {
    params.title = viewModel.get('singlePhotoTitle');
  }
  return params;
}, submitPhotos:function() {
  var viewModel = this.getViewModel();
  var params = this.getSubmitParams();
  if (!params) {
    return;
  }
  if (location.href.indexOf('test\x3dtrue') !== -1) {
    params.test = true;
  }
  var asyncUploads = viewModel.get('account.features.uploadscenterVisible');
  params.asynchronous = asyncUploads;
  console.log('Uploading photos/documents', params);
  viewModel.set({saving:true, errorMessage:''});
  Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daBluebeam.' + this.getCreateAction(), jsonData:params, successCallback:function(data) {
    if (asyncUploads) {
      app.fireEvent('reloadfileuploads');
    } else {
      viewModel.set('saveDone', true);
    }
    if (data && data.callback) {
      data.callback();
    }
    Ext.defer(function() {
      viewModel.set('saving', false);
      this.getView().destroy();
    }, 1000, this);
    this.getView().fireEvent('submissioncomplete');
  }, afterFailMessageCallback:function(data, message) {
    viewModel.set({saving:false, errorMessage:message || mvstr.G_UnexpectedError});
  }, noAlert:true, scope:this});
}, getAttachFloorplanOnly:function() {
  var vm = this.getViewModel();
  var isFloorplanOnly = vm.get('flooplanTitle');
  if (isFloorplanOnly) {
    vm.set('integrationEntityType', 'Document');
  }
}}, 0, 0, 0, 0, ['controller.bluebeamwindow'], 0, [bluebeam.view.bluebeamwindow, 'BluebeamWindowController'], 0);
Ext.cmd.derive('bluebeam.view.cards.Default', Ext.Container, {reference:'card_default'}, 0, ['bluebeamdefault'], ['component', 'box', 'container', 'bluebeamdefault'], {'component':true, 'box':true, 'container':true, 'bluebeamdefault':true}, ['widget.bluebeamdefault'], 0, [bluebeam.view.cards, 'Default'], 0);
Ext.cmd.derive('bluebeam.view.cards.PhotoDocument', Ext.Container, {reference:'card_PhotoDocument', layout:'column', items:[{xtype:'detailformtextfield', reference:'bluebeamPhotoTitle', fieldLabel:'Title', emptyText:'Enter title', margin:'0 12 15 12', columnWidth:1, publishes:'value', hidden:true, bind:{hidden:'{multiplePhotosSelected}', value:['{singlePhotoTitle}{flooplanTitle}']}}]}, 0, ['bluebeamphotodocument'], ['component', 'box', 'container', 'bluebeamphotodocument'], {'component':true, 'box':true, 
'container':true, 'bluebeamphotodocument':true}, ['widget.bluebeamphotodocument'], 0, [bluebeam.view.cards, 'PhotoDocument'], 0);
Ext.cmd.derive('bluebeam.view.bluebeamwindow.BluebeamWindow', Ext.window.Window, {ui:'orange', cls:'integration-window', modalMaskCls:'dark-mask', viewModel:{type:'bluebeamwindow'}, controller:'bluebeamwindow', config:{photos:null, includeAnnotations:true, PushpinUID:'', attachFloorplanOnly:false, flooplanTitle:''}, updateAttachFloorplanOnly:function(floorplanOnly) {
  this.getViewModel().set('attachFloorplanOnly', floorplanOnly);
}, updateFlooplanTitle:function(flooplanTitle) {
  this.getViewModel().set('flooplanTitle', flooplanTitle);
}, width:532, maxHeight:710, modal:true, title:'Add to Bluebeam Studio Project', layout:{type:'vbox', align:'stretch'}, bind:{disabled:'{saving}'}, dockedItems:[{xtype:'container', reference:'warning', dock:'top', cls:'warning', layout:{type:'hbox', align:'center'}, minHeight:41, padding:10, hidden:true, bind:{hidden:'{!errorMessage}'}, items:[{xtype:'component', flex:1, bind:{html:'\x3cspan\x3e{errorMessage}\x3c/span\x3e'}}]}, {xtype:'container', dock:'bottom', layout:{type:'hbox', pack:'center'}, 
padding:'15 0 0 0', height:65, items:[{xtype:'button', scale:'medium', ui:'grey', text:'Cancel', margin:'0 10 0 0', listeners:{click:function() {
  this.up('window').destroy();
}}}, {xtype:'savebutton', reference:'saveButton', disabled:true, bind:{processing:'{saving}', done:'{saveDone}', disabled:'{saveDisabled}'}, margin:'0 0 0 10', listeners:{click:'submitPhotos'}}]}], items:[{xtype:'container', layout:'column', defaults:{margin:'0 12 15 12', columnWidth:1}, padding:'20 12 0 12', scrollable:'y', maxHeight:600, reference:'mainContainer', loadMaskCls:'light-load-indicator', items:[{xtype:'detailformcombo', reference:'projects', id:'projectsComboBox', fieldLabel:'Studio Project', 
emptyText:'- Select -', queryMode:'local', displayField:'Name', valueField:'Id', disabled:true, columnWidth:0.5, bind:{store:'{bluebeamProjects}', value:'{bluebeamSetting_projectID}', disabled:'{!projectsLoaded}'}, listeners:{change:'onProjectChange'}}, {xtype:'container', layout:'card', margin:0, items:[{xtype:'bluebeamdefault'}, {xtype:'bluebeamphotodocument'}], bind:{activeItem:'{activeCardIndex}'}}, {xtype:'integrationcomments', reference:'bluebeamComments', height:100, hidden:true, bind:{hidden:'{isPhotoEntityType}', 
fieldLabel:'{commentsFieldLabel}'}}, {xtype:'integrationattachment', reference:'bluebeamAttachment', photoBinding:'{bluebeamSetting_attachAsPhoto}', pdfBinding:'{bluebeamSetting_attachAs4View}', hidden:true, bind:{hidden:'{isPhotoEntityType}'}}]}], doRealign:Ext.emptyFn, listeners:{boxready:'onBoxReady'}, setPosition:function(x, y, animate, force) {
  if (force) {
    return Ext.window.Window.prototype.setPosition.apply(this, arguments);
  }
}, destroy:function() {
  var entityStores = this.lookupController().entityStores;
  for (var i = 0; i < entityStores.length; i++) {
    entityStores[i].destroy();
  }
  return Ext.window.Window.prototype.destroy.apply(this, arguments);
}}, 0, ['bluebeamwindow'], ['component', 'box', 'container', 'panel', 'window', 'bluebeamwindow'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true, 'bluebeamwindow':true}, ['widget.bluebeamwindow'], 0, [bluebeam.view.bluebeamwindow, 'BluebeamWindow'], 0);
Ext.cmd.derive('analytics.Ctrl', Ext.Base, {singleton:true, _optionalDefaultEventProperties:{}, _mandatoryDefaultEventProperties:{}, _debugMode:false, constructor:function() {
  this._mandatoryDefaultEventProperties['URL String'] = window.location.href;
  this.callParent(arguments);
}, updateAmpProject:function(ampProject) {
  if (!window.amplitude) {
    return;
  }
  amplitude.getInstance().init(ampProject.ampProject, null, null);
  amplitude.getInstance().setGroup('projectCompany', ampProject.projectCompany);
  amplitude.getInstance().setGroup('projectTitle', ampProject.projectTitle);
}, updateAmpProfile:function(ampProfile) {
  if (!window.amplitude) {
    return;
  }
  var companies = ampProfile.memberCompanies.split(',');
  amplitude.getInstance().setUserProperties(ampProfile);
  amplitude.getInstance().init(ampProfile.ampProject, null, null);
  amplitude.getInstance().setUserId(ampProfile.memberUID);
  amplitude.getInstance().setUserProperties(ampProfile);
  amplitude.getInstance().setGroup('memberCompany', companies);
}, log:function(eventName, eventProperties, defaultPropertyNames) {
  eventProperties = eventProperties || {};
  eventProperties = Ext.clone(eventProperties);
  for (var propertyName in this._mandatoryDefaultEventProperties) {
    if (eventProperties[propertyName] === undefined) {
      eventProperties[propertyName] = this._mandatoryDefaultEventProperties[propertyName];
    }
  }
  if (defaultPropertyNames) {
    for (var i = 0; i < defaultPropertyNames.length; i++) {
      propertyName = defaultPropertyNames[i];
      if (this._optionalDefaultEventProperties[propertyName] === undefined) {
        return;
      }
      if (eventProperties[propertyName] === undefined) {
        eventProperties[propertyName] = this._optionalDefaultEventProperties[propertyName];
      }
    }
  }
  if (this._debugMode) {
    console.log(eventName, eventProperties);
  } else {
    if (window.amplitude) {
      amplitude.getInstance().logEvent(eventName, eventProperties);
    }
  }
}, setMandatoryDefaultEventProperties:function(properties) {
  if (this._debugMode) {
    console.log('Setting analytics mandatory defaults', properties);
  }
  for (var propName in properties) {
    this._mandatoryDefaultEventProperties[propName] = properties[propName];
  }
}, setOptionalDefaultEventProperties:function(properties) {
  if (this._debugMode) {
    console.log('Setting analytics mandatory defaults', properties);
  }
  for (var propName in properties) {
    this._optionalDefaultEventProperties[propName] = properties[propName];
  }
}, getDateString:function(date) {
  return Ext.Date.format(date, 'Y-m-d');
}}, 1, 0, 0, 0, 0, 0, [analytics, 'Ctrl'], 0);
Ext.cmd.derive('floorplanViewer.FilesValues', Ext.Base, {singleton:true, FILTERS:{'file':'Documents (.pdf,.doc,.docx)|*.pdf;*.doc;*.docx|Excel (.xls,.xlsx)|*.xls;*.xlsx|Powerpoint (.ppt,.pptx)|*.ppt;*.pptx|Images (.jpg,.png,.gif,.tif(f))|*.jpg;*.png;*.gif;*.tif;*.tiff|Autocad (.dwg,.dxf,.dwf)|*.dwg;*.dxf;*.dwf|Video (.mpg,.mp4,.avi,.mov)|*.mpg;*.mp4;*.avi;*.movRevit (.rvt)|*.rvt', 'photo':'Images (*.jpg, *.png, *.gif, *.tif, *.tiff)|*.jpg;*.png;*.gif;*.tif;*.tiff'}, MAX_FILE_SIZE:{'file':100 * 1024 * 
1024, 'photo':10 * 1024 * 1024}, ACCEPTED_FILES:{'file':'.pdf,.doc,.docx,.xls,.xlsx,.ppt,.pptx,.jpg,.jpeg,.png,.gif,.tif,.tiff,.dwg,.dxf,.dwf,.mpg,.mp4,.avi,.mov,.rvt,.ifc', 'photo':'.jpg,.jpeg,.png,.gif,.tif,.tiff'}, PHOTO_SELECTION_MODE:{'SELECT_BY_PHOTO':0, 'SELECT_BY_FLOORPLAN':1}}, 0, 0, 0, 0, 0, 0, [floorplanViewer, 'FilesValues'], 0);
Ext.cmd.derive('floorplanViewer.PhotoSelectionData', Ext.Base, {maximumNumberOfPhotos:2100, warningLevelNumberOfPhotos:100, initialDrawPosition:null, layer:null, rectangle:null, selectionMade:false, selectionMenuActive:false, cancellable:false, floorplanViewer:null, map:null, photosBeingSelected:false, records:null, constructor:function() {
  this.callParent(arguments);
  this.mouseDownFunction = Ext.bind(function(e) {
    if (this.selectionMade) {
      if (this.rectangle.getBounds().contains(e.latlng)) {
        return;
      }
      this.map.removeLayer(this.rectangle);
      this.initialDrawPosition = null;
      this.cancellable = false;
      this.layer.on('mouseup', this.mouseUpFunction);
      this.selectionMade = false;
      var selectedIcons = this.floorplanViewer.lookupController().lookupReference('selectHotspotsPopup');
      selectedIcons.setHtml("\x3cspan class\x3d'selectedHotspotText'\x3e" + mvstr['FV_Click and drag to sel'] + '\x3c/span\x3e');
      this.floorplanViewer.lookupController().lookupReference('selectHotspotsViewBtn').disable();
    }
    this.photosBeingSelected = true;
    this.initialDrawPosition = e.latlng;
    var bounds = MVLeaflet.latLngBounds(this.initialDrawPosition, e.latlng);
    this.rectangle = MVLeaflet.rectangle(bounds, {color:'#ff7800', weight:1, className:'no-pointer-drag'});
    this.layer.addLayer(this.rectangle);
    var fpvEl = this.floorplanViewer.getEl();
    var resize = fpvEl.select('.leaflet-clickable');
    resize.setStyle('cursor', 'crosshair');
    this.layer.on('mousemove', this.dragFunction);
  }, this);
  this.mouseClickFunction = Ext.bind(function(e) {
    if (this.cancellable) {
      this.map.removeLayer(this.rectangle);
      this.initialDrawPosition = null;
      this.cancellable = false;
      this.layer.off('click', this.mouseClickFunction);
      this.enableDragging();
      this.selectionMade = false;
      var selectedIcons = this.floorplanViewer.lookupController().lookupReference('selectHotspotsPopup');
      selectedIcons.setHtml("\x3cspan class\x3d'selectedHotspotText'\x3e" + mvstr['FV_Click and drag to sel'] + '\x3c/span\x3e');
      this.floorplanViewer.lookupController().lookupReference('selectHotspotsViewBtn').disable();
    } else {
      this.cancellable = true;
    }
  }, this);
  this.dragFunction = Ext.bind(function(e) {
    var bounds = MVLeaflet.latLngBounds(this.initialDrawPosition, e.latlng);
    this.rectangle.setBounds(bounds);
  }, this);
  this.mouseUpFunction = Ext.bind(function(e) {
    this.removeListeners(false);
    var hits = this.getItemsInSelection();
    this.photosBeingSelected = false;
    if (hits == 0) {
      this.map.removeLayer(this.rectangle);
      this.layer.on('mouseup', this.mouseUpFunction);
      return;
    }
    this.selectionMade = true;
    var selectedIcons = this.floorplanViewer.lookupController().lookupReference('selectHotspotsPopup');
    selectedIcons.setHtml("\x3cspan class\x3d'selectedHotspotText'\x3e" + mvstr['FV_{x} hotspots selected'].replace('{x}', '\x3cb\x3e' + hits.length + '\x3c/b\x3e') + '\x3c/span\x3e');
    this.floorplanViewer.lookupController().lookupReference('selectHotspotsViewBtn').enable();
    if (hits.length != 0) {
      var me = this;
      var rectangleClickHandler = function(e) {
        me.rectangle.off('click', rectangleClickHandler);
        me.getIdsAndPost();
      };
      this.rectangle.on('click', rectangleClickHandler);
    }
    var fpvEl = this.floorplanViewer.getEl();
    var resize = fpvEl.select('.no-pointer-drag');
    resize.setStyle('cursor', 'pointer');
  }, this);
}, removeListeners:function(removeMouseDown) {
  if (this.layer != null) {
    this.layer.off('mousemove', this.dragFunction);
    this.layer.off('mouseup', this.mouseUpFunction);
    if (removeMouseDown) {
      this.layer.off('mousedown', this.mouseDownFunction);
    }
    this.cancellable = false;
  }
}, enableDragging:function() {
  this.layer.on('mousedown', this.mouseDownFunction);
  this.layer.on('mouseup', this.mouseUpFunction);
}, getItemsInSelection:function() {
  var hsa = this.floorplanViewer.getHotspotsArray();
  var bounds = this.rectangle.getBounds();
  var hits = [];
  for (var i in hsa) {
    var hs = hsa[i];
    var hsb = new MVLeaflet.LatLng(hs.geometry.coordinates[1], hs.geometry.coordinates[0]);
    if (bounds.contains(hsb)) {
      hits.push(hs);
    }
  }
  return hits;
}, getPhotoIDs:function(hotspotIDs, callback) {
  var numericIDArray = hotspotIDs.split(','), vm = this.floorplanViewer.lookupViewModel();
  if (vm.get('account.features.photoviewerVisible')) {
    for (var i = 0; i < numericIDArray.length; i++) {
      numericIDArray[i] = Number(numericIDArray[i]);
    }
    var photoGroup = Ext.create('floorplanViewer.model.PhotoGroup', {IdentifierArray:numericIDArray, Type:'I'}), photoStore = photoGroup.getPhotoStore(vm.get('ProjectUID'), vm.get('storeSession'));
    if (!photoStore.isLoading() && !photoStore.isLoaded()) {
      photoStore.load();
    }
    app.getMainView().add({xtype:'photoviewer', photoGroup:photoGroup}).show();
    return;
  }
  Ext.define('PhotoID', {extend:'Ext.data.Model', fields:[{name:'photoID', type:'auto'}]});
  var theStore = Ext.create('Ext.data.Store', {model:'PhotoID', proxy:{type:'ajax', url:'/index.cfm?fuseaction\x3daClientFloorplanViewer.getPhotoIDsByHotspotIDs', actionMethods:{create:'POST'}, reader:{type:'json', rootProperty:'users'}}, autoLoad:false});
  theStore.load({params:{hotspotIDs:hotspotIDs}, callback:function(records, operation, success) {
    if (!success) {
      console.error('error', records, operation, success);
      return;
    }
    if (records.length == 0) {
    }
    this.records = records;
    if (callback) {
      callback(records, success);
    }
  }, scope:this});
}, asyncGetSelectedHotspotPhotoIDs:function(callback) {
  if (this.selectionMade) {
    var hits = this.getItemsInSelection();
    var ida = [];
    for (var i in hits) {
      ida[i] = hits[i].id;
    }
    var hsids = ida.join();
    if (ida.length > this.maximumNumberOfPhotos) {
      Ext.MessageBox.alert('Status', mvstr['FV_You have selected too'], function(res) {
      });
    } else {
      if (ida.length > this.warningLevelNumberOfPhotos) {
        var str = mvstr['FV_You have selected {x}'].replace('{x}', ida.length);
        Ext.MessageBox.confirm('Confirm', str, Ext.bind(function(res) {
          if (res == 'yes') {
            this.getPhotoIDs(hsids, callback);
          } else {
            this.floorplanViewer.lookupController().resetPhotoSelectionMenu();
          }
        }, this));
      } else {
        this.getPhotoIDs(hsids, callback);
      }
    }
  }
}, getIdsAndPost:function() {
  if (this.selectionMade) {
    this.asyncGetSelectedHotspotPhotoIDs(function(records) {
      var ids = [];
      for (var i in records) {
        ids[i] = records[i].get('photoID');
      }
      Ext.Ajax.postFormData(mdslink.clientPhotoViewer + 'ProjectUID\x3d' + Ext.Object.fromQueryString(document.location.search).ProjectUID + '\x26PhotoGroupType\x3dX', {PhotoIDs:ids.join(','), UDEFPhotoUIDs:'', WebcamPhotoUIDs:''});
    });
  } else {
    Ext.log('no records selected');
  }
  this.floorplanViewer.lookupController().resetPhotoSelectionMenu();
}}, 1, 0, 0, 0, 0, 0, [floorplanViewer, 'PhotoSelectionData'], 0);
Ext.cmd.derive('floorplanViewer.controller.HoverTimer', Ext.app.Controller, {constructor:function() {
  Ext.app.Controller.prototype.constructor.apply(this, arguments);
  this.TIMER_ENABLED = 0;
  this.TIMER_DISABLED = 1;
  this.map = null;
  this.status = this.TIMER_DISABLED;
  this.timer = null;
}, setMap:function(map) {
  this.map = map;
  this.addMouseEventsToPopupLayer();
}, clearPopupTimer:function() {
  clearTimeout(this.timer);
  this.status = this.TIMER_DISABLED;
  if (this.status == this.TIMER_ENABLED) {
  }
}, addMouseEventsToPopupLayer:function() {
  var me = this, popup = document.getElementsByClassName('leaflet-popup-pane');
  for (var i = 0; i < popup.length; i++) {
    popup[i].addEventListener('mouseover', function() {
      me.clearPopupTimer();
    });
    popup[i].addEventListener('mouseleave', function() {
      me.closePopup(me.mouseout);
    });
  }
}, openPopup:function(callback, when) {
  this.clearPopupTimer();
  this.status = this.TIMER_ENABLED;
  var thisHoverTimer = this;
  this.timer = setTimeout(function() {
    callback();
    thisHoverTimer.status = thisHoverTimer.TIMER_DISABLED;
  }, when);
}, closePopup:function(when) {
  this.clearPopupTimer();
  var thisHoverTimer = this;
  if (when) {
    this.status = this.TIMER_ENABLED;
    this.timer = setTimeout(function() {
      thisHoverTimer.map.closePopup();
      thisHoverTimer.status = thisHoverTimer.TIMER_DISABLED;
    }, when);
  } else {
    if (this.map) {
      this.map.closePopup();
    }
  }
}, getStatus:function() {
  return this.status;
}, mouseover:250, mouseout:500, state:this.status}, 1, 0, 0, 0, 0, 0, [floorplanViewer.controller, 'HoverTimer'], 0);
Ext.cmd.derive('floorplanViewer.model.Floorplan', Ext.data.Model, {fields:['FloorplanUID', 'FPID', 'floorplanTitle', {name:'commentIcons'}, {name:'overlayInt'}, 'imagePath', 'imageIntPath', 'imageType', 'imageWidth', 'imageHeight', 'tileSize', 'numTiles', 'IsWorkingPlan', 'ProjectShootTypeUID', {name:'CanHaveHotspots', mapping:function(data) {
  return config.ISARCHIVE ? true : !!data.CanHaveHotspots;
}}, {name:'CanHavePhotos', calculate:function(data) {
  return data.CanHaveHotspots;
}}], idProperty:'FloorplanUID', proxy:{type:'jsonp', reader:{type:'json', rootProperty:'data'}, api:{read:'index.cfm?fuseaction\x3daClientFloorplanViewer.getFloorplanDetail'}}}, 0, 0, 0, 0, 0, 0, [floorplanViewer.model, 'Floorplan'], 0);
Ext.cmd.derive('floorplanViewer.model.FloorplanLegend', Ext.data.Model, {fields:[{name:'type'}, {name:'features'}]}, 0, 0, 0, 0, 0, 0, [floorplanViewer.model, 'FloorplanLegend'], 0);
Ext.cmd.derive('files.model.PhotoCategory', Ext.data.Model, {fields:[{name:'value', mapping:'text'}, {name:'count'}, {name:'text', convert:function(value, record) {
  var _type = record.get('type');
  var text = mvstr['PUL_PhotoCategory' + _type] || value;
  if (_type == 'U' || _type == 'V' || _type == 'Y' || _type == 'P') {
    return "\x3cspan class\x3d'photoCategoryName' title\x3d'" + text + ' (' + record.get('count') + " photos)'\x3e" + text + "\x3c/span\x3e\x3cspan class\x3d'photoCategoryCount'\x3e (" + record.get('count') + ')\x3c/span\x3e';
  } else {
    return "\x3cspan class\x3d'photoGroupName' title\x3d'" + text + ' (' + record.get('count') + " photos)'\x3e" + text + "\x3c/span\x3e\x3cspan class\x3d'photoCategoryCount'\x3e (" + record.get('count') + ')\x3c/span\x3e';
  }
}}, 'type', 'id', {name:'leaf', type:'boolean'}, {name:'expanded', type:'boolean'}, 'photoURL']}, 0, 0, 0, 0, 0, 0, [files.model, 'PhotoCategory'], 0);
Ext.cmd.derive('floorplanViewer.view.files.multivistaPhoto.Values', Ext.Base, {singleton:true, PC_TYPES:{'ALL':'X', 'MULTIVISTA':'M', 'SHOOT_TYPE':'C', 'SECONDARY_SLIDESHOW_TYPE':'K', 'MY_ALBUMS':'Y', 'PROJECT_TEAM_ALBUMS':'P', 'PROJECT_TEAM_PHOTOS':'V', 'TEAM_MEMBER_PHOTOS':'Z', 'SHOOT':'D', 'HOTSPOT':'H', 'SECONDARY_SLIDESHOW':'L', 'ALBUM':'A', 'UDEFPHOTOS':'U', 'WEBCAM_PHOTOS':'W', 'PUSHPIN_PHOTOS':'N', 'SPECIAL':'S'}}, 0, 0, 0, 0, 0, 0, [floorplanViewer.view.files.multivistaPhoto, 'Values'], 
0);
Ext.cmd.derive('floorplanViewer.store.MultivistaPhotos', Ext.data.Store, {model:'mdsData.model.Photo', proxy:{type:'jsonp', reader:{type:'json', root:'data'}, url:'/index.cfm?fuseaction\x3daClientPhotoList.getPhotos2', actionMethods:{read:'POST'}}, autoLoad:false}, 0, 0, 0, 0, 0, 0, [floorplanViewer.store, 'MultivistaPhotos'], 0);
Ext.cmd.derive('floorplanViewer.model.PhotoGroup', Ext.data.Model, {fields:['Identifier', {name:'PhotoCount', mapping:'count', type:'int'}, {name:'StartDate', type:'tzadate'}, {name:'EndDate', type:'tzadate', mapping:function(data) {
  return data.EndDate || data.StartDate;
}}, {name:'Type'}, {name:'Description'}, {name:'GroupLabel', calculate:function(data) {
  var type = data.Type;
  if (type == floorplanViewer.view.files.multivistaPhoto.Values.PC_TYPES.SHOOT_TYPE) {
    return 'Multivista Photos';
  } else {
    if (type == floorplanViewer.view.files.multivistaPhoto.Values.PC_TYPES.SECONDARY_SLIDESHOW_TYPE) {
      return 'Multivista - ' + data.Description;
    }
  }
  return 'Other Photos';
}}, {name:'IsMine', type:'boolean', defaultValue:false}, {name:'Ranking', mapping:function(data) {
  var type = data.Type, itemStr = '', ranking = String(data.Ranking);
  while (ranking.length < 4) {
    ranking = '0' + ranking;
  }
  if (type == floorplanViewer.view.files.multivistaPhoto.Values.PC_TYPES.SHOOT_TYPE) {
    itemStr += '0' + ranking;
  }
  if (type == floorplanViewer.view.files.multivistaPhoto.Values.PC_TYPES.SECONDARY_SLIDESHOW_TYPE) {
    itemStr += '1' + ranking;
  } else {
    itemStr += '6';
  }
  return itemStr;
}}, {name:'id', calculate:function(data) {
  if (data.IdentifierArray && data.IdentifierArray.length) {
    return data.Type + '_' + Ext.Array.sort(data.IdentifierArray).join('_');
  }
  var id = data.Type + '_' + data.Identifier;
  if (data.StartDate && data.Type != 'H') {
    id += '_' + Ext.Date.format(data.StartDate, 'Y-m-d');
  }
  if (data.ArchivePositionID) {
    id += '_' + data.ArchivePositionID;
  }
  if (data.SlideshowDetails) {
    Ext.Object.eachValue(data.SlideshowDetails, function(detail) {
      if (detail !== undefined) {
        id += '_' + detail;
      }
    });
  }
  return id;
}}, {name:'ImageURL', type:'string'}, {name:'Title', type:'string'}, {name:'Locations'}, {name:'Title2', type:'string', calculate:function(data) {
  var dateStr = Ext.Date.format(data.StartDate, mvstr['DATE_Full']);
  if (data.Type == 'D' && data.Locations[0]) {
    return data.Locations[0] + ' - ' + dateStr;
  }
  return dateStr;
}}, {name:'ProjectShootTypeUID'}, {name:'IdentifierArray'}, {name:'ArchivePositionID', defaultValue:0}, {name:'SlideshowDetails'}, {name:'ParentPhoto', defaultValue:null}], getPhotoGroupStoreId:function() {
  return 'photoGroup_' + this.getId();
}, getPhotoStore:function(ProjectUID, storeSession, selectedPhotos, listeners) {
  var storeId = this.getPhotoGroupStoreId(), store = Ext.getStore(storeId);
  if (!store) {
    var extraParams = {ProjectUID:ProjectUID, Identifier:this.get('Identifier'), LookupDate:Ext.Date.format(this.get('StartDate'), 'Y-m-d')}, identifierArray = this.get('IdentifierArray');
    if (identifierArray && identifierArray.length) {
      extraParams.Identifier = identifierArray.join(',');
    }
    if (this.get('ArchivePositionID')) {
      if (this.get('SlideshowDetails')) {
        extraParams.SlideshowParams = Ext.JSON.encode(this.get('SlideshowDetails'));
      }
    }
    store = Ext.create('floorplanViewer.store.MultivistaPhotos', {storeId:storeId, session:storeSession, proxy:{extraParams:extraParams, reader:{transform:{fn:function(data) {
      for (var i = 0; i < data.data.length; i++) {
        var item = data.data[i];
        if (!item.Description && this.get('Title')) {
          item.Description = this.get('Title');
        }
        if (this.get('Type') == 'L' && this.get('Description')) {
          item.Description = this.get('Description');
        }
        if (!item.Location && this.get('Locations') && this.get('Locations').length) {
          item.Location = this.get('Locations')[0] || '';
        }
        if (!item.PhotoDate && this.get('StartDate')) {
          item.PhotoDate = this.get('StartDate');
        }
        if (this.get('Type') == 'N') {
          item.PushpinUID = this.get('Identifier');
        }
        if (selectedPhotos && selectedPhotos.getById(item.Identifier)) {
          item.Selected = true;
        }
      }
      return data;
    }, scope:this}}}, mvCanAbort:true, listeners:listeners});
    store.record = this;
  }
  if (this.get('Type') === 'W' && !this.get('StartDate')) {
    store.addListener('load', function() {
      if (store.getCount()) {
        this.set('StartDate', Ext.Date.format(store.getAt(0).get('PhotoDate'), 'Y-m-d'));
        store.setStoreId(this.getPhotoGroupStoreId());
      }
    }, this, {single:true});
  }
  return store;
}}, 0, 0, 0, 0, 0, 0, [floorplanViewer.model, 'PhotoGroup'], 0);
Ext.cmd.derive('floorplanViewer.model.PushpinType', Ext.data.Model, {fields:[{name:'PushpinTypeID', type:'int'}, {name:'PushpinTypeName', type:'string', convert:function(value) {
  var translationID = 'FV_' + value;
  return mvstr[translationID] || value;
}}, {name:'PushpinSymbol', type:'string'}, {name:'PushpinTypeUID', type:'string'}, {name:'OrderBy', type:'int'}], idProperty:'PushpinTypeID'}, 0, 0, 0, 0, 0, 0, [floorplanViewer.model, 'PushpinType'], 0);
Ext.cmd.derive('floorplanViewer.store.PhotoCategories', Ext.data.Store, {model:'floorplanViewer.model.PhotoGroup', proxy:{url:'/index.cfm?fuseaction\x3daClientPhotoList.getPhotoGroups2', extraParams:{SkipProtected:1}}, sorters:[{property:'Ranking'}], getDateRange:function() {
  var records = this.getRange(), dateRange = {startDate:null, endDate:null};
  for (var i = 0; i < records.length; i++) {
    var startDate = records[i].get('StartDate'), endDate = records[i].get('EndDate');
    if (!dateRange.startDate || startDate < dateRange.startDate) {
      dateRange.startDate = startDate;
    }
    if (!dateRange.endDate || endDate > dateRange.endDate) {
      dateRange.endDate = endDate;
    }
  }
  return dateRange;
}, getLocations:function() {
  var locations = [];
  this.each(function(item) {
    locations = Ext.Array.merge(locations, item.get('Locations'));
  });
  return locations;
}}, 0, 0, 0, 0, ['store.photocategories'], 0, [floorplanViewer.store, 'PhotoCategories'], 0);
Ext.cmd.derive('floorplanViewer.store.PhotoSelectionMode', Ext.data.Store, {proxy:{type:'memory'}, constructor:function() {
  this.config.data = [{value:floorplanViewer.FilesValues.PHOTO_SELECTION_MODE.SELECT_BY_PHOTO, text:mvstr['FVCPD_Select by photo']}, {value:floorplanViewer.FilesValues.PHOTO_SELECTION_MODE.SELECT_BY_FLOORPLAN, text:mvstr['FVCPD_Select by floorplan']}];
  Ext.data.Store.prototype.constructor.apply(this, arguments);
}}, 1, 0, 0, 0, ['store.photoselectionmode'], 0, [floorplanViewer.store, 'PhotoSelectionMode'], 0);
Ext.cmd.derive('floorplanViewer.store.ProjectPhotos', Ext.data.Store, {model:'mdsData.model.Photo', proxy:{type:'ajax', url:'/index.cfm?fuseaction\x3daClientPhotoList.getPushpinDialogPhotos', rootProperty:'data'}, statics:{getDefaultStoreId:function(Type, Identifier) {
  return Type + Identifier;
}}}, 0, 0, 0, 0, ['store.projectphotos'], 0, [floorplanViewer.store, 'ProjectPhotos'], 0);
Ext.cmd.derive('floorplanViewer.store.PushpinTypes', Ext.data.Store, {proxy:{type:'jsonp', url:'/index.cfm?fuseaction\x3daClientFloorplanViewer.getPushpinTypesJSON', reader:{type:'json'}}, model:'floorplanViewer.model.PushpinType', sortRoot:'OrderBy', sortOnLoad:true, sorters:[{property:'OrderBy', direction:'ASC'}], autoLoad:false}, 0, 0, 0, 0, ['store.pushpintypes'], 0, [floorplanViewer.store, 'PushpinTypes'], 0);
Ext.cmd.derive('floorplanViewer.view.ExportMenu', Ext.Container, {cls:'flyout-menu-wrap', floating:true, shrinkWrap:3, hidden:true, defaultType:'button', defaults:{width:110, scale:'medium', textAlign:'left', hidden:true, listeners:{click:{fn:function(e) {
  this.up('exportmenu').hide();
  this.lookupController().openExportWindow(e.text);
}}}}, renderTo:Ext.getBody(), x:69, y:143, layout:'vbox', padding:2, items:[{text:'Procore', icon:'mds/image/icon/procore_white.png', itemCls:'toolmenu-item', overCls:'toolmenu-item-over', bind:{hidden:'{!account.procoreEnabled}'}}, {text:'PlanGrid', icon:'mds/image/icon/plangrid_white.png', itemCls:'toolmenu-item', overCls:'toolmenu-item-over', bind:{hidden:'{!account.planGridEnabled}'}}, {text:'Aconex', icon:'mds/image/icon/aconex_white.png', itemCls:'toolmenu-item', overCls:'toolmenu-item-over', 
bind:{hidden:'{!account.aconexEnabled}'}}, {text:'BIM 360', cls:'bim-360', icon:'mds/image/icon/bim360_white.png', itemCls:'toolmenu-item', overCls:'toolmenu-item-over', bind:{hidden:'{!account.bim360Enabled}'}}, {text:'Bluebeam', icon:'mds/image/icon/bluebeam_white.png', itemCls:'toolmenu-item', overCls:'toolmenu-item-over', bind:{hidden:'{!account.bluebeamEnabled}'}}]}, 0, ['exportmenu'], ['component', 'box', 'container', 'exportmenu'], {'component':true, 'box':true, 'container':true, 'exportmenu':true}, 
['widget.exportmenu'], 0, [floorplanViewer.view, 'ExportMenu'], 0);
Ext.cmd.derive('floorplanViewer.view.Floorplan', Ext.Container, {reference:'floorplanViewer', config:{map:null, tileLayer:null, miniTileLayer:null, highlightLayer:null, hotspotLayer:null, hotspotCommentLayer:null, hotspotMouseMoveEvent:null, hotspotMouseOutEvent:null, hotspotLayers:[], pushpinLayer:null, pushpinSelectionLayer:null, floorplanRecord:null, zoomControl:null, hotspotsArray:[], pushpinsArray:[], hotspotsLoaded:false, pushpinsLoaded:false, _selectedPushpin:{}, _tilePathInt:'', _tilePath:'', 
_numbersVisible:false, _floorplanViewerMode:{mode:'view'}, deselectInteriorPanoHotspots:false, highlightInteriorPanoHotspots:true, zoomOutInteriorPanoHotspots:false, showInteriorPanoHotspots:true, panoScanLocations:[], panoScanMarkers:[], panoHotspotMarkers:{}, animateOptions:null}, listeners:{afterrender:function(t, eOpts) {
  var leafletRef = window.MVLeaflet;
  if (leafletRef == null) {
    this.update('No leaflet library loaded');
  } else {
    this.map = null;
  }
  var cursor = 'move';
  this.setStyle('cursor', cursor);
  this.lookupController().originalMouseCursor = cursor;
}, onResize:function(w, h, oW, oH) {
  var map = this.getMap();
  if (map) {
    map.invalidateSize();
  }
}, map_click:'map_click', map_move_start:'map_move_start', map_ready:'map_ready', map_mouseover:'closeHover', map_move_end:'map_move_end', pin_mover_move:'pin_mover_move', pushpin_click:'pushpin_click', pushpin_mouseover:'pushpin_mouseover', pushpin_mouseout:'closeHover', pushpin_mousedown:'closeHover', pushpin_dragend:'closePopupAndMoveSelectedPushpin', pushpin_dragstart:'closePopupAndMoveSelectedPushpin', pushpin_drag:'moveSelectedPushpin', pushpin_new:'pushpin_new', update_pushpin_position:'update_pushpin_position', 
hotspot_click:'hotspot_click', hotspot_mouseover:'hotspot_mouseover', hotspot_mouseout:'hotspot_mouseout', backpack_marker_clicked:'backpackMarkerClicked', getHotspotColorsOrIcons:'getHotspotColorsOrIcons'}, bind:{floorplan:'{floorplan}', commentsOn:'{toggleCommentsEnabled}'}, setCoordinateSpace:function(factor) {
  MVLeaflet.CRS.Multivista = null;
  MVLeaflet.CRS.Multivista = MVLeaflet.extend({}, MVLeaflet.CRS, {projection:MVLeaflet.Projection.LonLat, transformation:new MVLeaflet.Transformation(factor, 0, factor, 0), scale:function(zoom) {
    return Math.pow(2, zoom);
  }, distance:function(latlng1, latlng2) {
    var dx = latlng2.lng - latlng1.lng, dy = latlng2.lat - latlng1.lat;
    return Math.sqrt(dx * dx + dy * dy);
  }, infinite:true});
}, setFloorplan:function(floorplanRecord) {
  this.hotspotsLoaded = false;
  if (!floorplanRecord || this.lookupViewModel().get('FloorplanUID') != floorplanRecord.getId()) {
    return;
  }
  var me = this, tilePath = '';
  this.setFloorplanRecord(floorplanRecord);
  this._numbersVisible = floorplanRecord.get('overlayInt');
  this._tilePathInt = floorplanRecord.get('imageIntPath');
  this._tilePath = floorplanRecord.get('imagePath');
  if (this._numbersVisible) {
    tilePath = this._tilePathInt;
  } else {
    tilePath = this._tilePath;
  }
  var imageWidth = floorplanRecord.get('imageWidth'), imageHeight = floorplanRecord.get('imageHeight'), tileSize = floorplanRecord.get('tileSize'), tileExtension = '.' + floorplanRecord.get('imageType'), tileLevels = Math.ceil(Math.log(Math.max(imageWidth, imageHeight) / tileSize) / Math.log(2)), projectionFactor = 1 / Math.pow(2, tileLevels);
  this.setCoordinateSpace(projectionFactor);
  if (this.map !== null) {
    this.map.remove();
    this.map = null;
  }
  this.map = MVLeaflet.map(this.getId(), {zoomControl:false, boxZoom:true, touchZoom:true, keyboard:true, attributionControl:false, fadeAnimation:false, crs:MVLeaflet.CRS.Multivista, minZoom:0, bounceAtZoomLimits:true});
  this.tileLayer = MVLeaflet.tileLayer.zoomify(tilePath, {width:imageWidth, height:imageHeight, tileSize:tileSize, tileExtension:tileExtension, tileMaxZoom:null, tolerance:0.8, attribution:'Photo: Multivista'});
  if (this.showMiniMap) {
    this.miniTileLayer = MVLeaflet.tileLayer.zoomify(this._tilePath, {width:imageWidth, height:imageHeight, tileSize:tileSize, tileExtension:tileExtension, tileMaxZoom:4, tolerance:0.8, attribution:'Photo: Multivista'});
  }
  this.tileLayer.once('loading', function(e) {
    me.setDisabled(true);
  });
  this.tileLayer.once('load', function(e) {
    me.setDisabled(false);
  });
  this.tileLayer.addTo(this.map);
  this.map.fitWorld();
  if (this.showHotspots) {
    this.hotspotLayer = null;
    this.hotspotLayer = new MVLeaflet.layerGroup;
    this.hotspotLayer.addTo(this.map);
    if (this.showHotspotComments) {
      this.hotspotCommentLayer = null;
      this.hotspotCommentLayer = new MVLeaflet.layerGroup;
      this.hotspotCommentLayer.addTo(this.map);
    }
  }
  this.pushpinLayer = null;
  this.pushpinLayer = new MVLeaflet.layerGroup;
  this.pushpinLayer.addTo(this.map);
  if (this.hasUnsavedPinLayer) {
    this.unsavedPinLayer = null;
    this.unsavedPinLayer = new MVLeaflet.layerGroup;
    this.unsavedPinLayer.addTo(this.map);
  }
  if (this.showSelectionLayer) {
    this.pushpinSelectionLayer = new MVLeaflet.layerGroup;
    this.pushpinSelectionLayer.addTo(this.map);
  }
  this.highlightLayer = null;
  this.highlightLayer = new MVLeaflet.layerGroup;
  this.highlightLayer.addTo(this.map);
  if (this.showZoomControls) {
    this.tileLayer.options.maxZoom = this.map.getMaxZoom();
    this.map.options.maxZoom = this.map.getMaxZoom();
    this.zoomControl = new MVLeaflet.Control.Zoomslider({position:'topright'});
    this.map.addControl(this.zoomControl);
    Ext.select('.leaflet-top.leaflet-right').elements[0].style.zIndex = 1;
  }
  this.map.on('movestart', function(e) {
    var map = me.map || this;
    me.fireEvent('map_move_start', e);
    map.closePopup();
  });
  this.map.on('moveend', function(e) {
    me.fireEvent('map_move_end', e);
  });
  this.map.on('click', function(e) {
    me.fireEvent('map_click', e);
  });
  this.map.on('mouseover', function(e) {
    me.fireEvent('map_mouseover', e);
  });
  this.map.on('zoomend', this.mapZoomEndHandler.bind(this));
  if (this.showMiniMap) {
    this.addMiniMap();
  }
  if (this.showHotspots) {
    this.loadHotspots(floorplanRecord);
  }
  if (this.lookupViewModel().get('account.canRead')) {
    this.pushpinsLoaded = false;
    this.loadPushpins(floorplanRecord);
  }
  if (this.backpackPanoActiveInViewer) {
    this.clearFloorplanLayersForBackpackPanos();
    this.lookupController().loadBackpackFloorplanLocations(this.backpackPanoActiveInViewer.walkID);
  }
  this.lookupViewModel().set('floorplanInitialized', true);
  this.up('clientFloorplanViewerDisp').unmask();
  this.fireEvent('afterinitfloorplan');
}, loadPushpins:function(floorplanRecord) {
  if (!floorplanRecord) {
    floorplanRecord = this.getFloorplanRecord();
  }
  var viewModel = this.lookupViewModel();
  if (this.hasUnsavedPinLayer) {
    var ListTypeID = this.lookupViewModel().get('ListTypeID'), loadUnsavedPins = function() {
      if (!viewModel.get('unsaved')) {
        this.highlightLayer.clearLayers();
        this.unsavedPinLayer.clearLayers();
        return;
      }
      var unsavedPins = viewModel.get('pins').query('FloorplanUID', floorplanRecord.get('FloorplanUID'));
      this.addPinsFromData(floorplanList.PlanUtil.pinsToFeatures(unsavedPins), ListTypeID, undefined, undefined, this.unsavedPinLayer);
    }, success = function() {
      loadUnsavedPins.call(this);
      this.lookupController().getView().unmask();
      this.onLoadPushpinSuccess();
    };
    if (!this.pushpinsLoaded) {
      this.continueLoadingPushpins(viewModel.get('ProjectUID'), floorplanRecord.get('FloorplanUID'), ListTypeID, success);
    } else {
      loadUnsavedPins.call(this);
    }
  } else {
    this.continueLoadingPushpins(viewModel.get('ProjectUID'), floorplanRecord.get('FloorplanUID'), this.lookupViewModel().get('ListTypeID'), this.onLoadPushpinSuccess, Ext.bind(this.pushpinAddEvent, this));
  }
}, onLoadPushpinSuccess:function() {
  if (this.getFloorplanViewerMode().mode === 'dropNewPin') {
    this.setSelectedPushpin(this.getSelectedPushpin().pushpinID);
  } else {
    if (this.getFloorplanViewerMode().mode === 'viewAfterUpload' && this._selectedPushpin !== '') {
      this.setFloorplanViewerMode('view');
      this.setSelectedPushpin(this.getSelectedPushpin().pushpinID);
    }
  }
  if (this.editPinOnLoad) {
    this.lookupController().lookupReference('pushpinFlyout').lookupController().setPushpinFlyoutState('edit');
    this.editPinOnLoad = false;
  }
  if (this.getSelectedPushpin().pushpinID) {
    this.setSelectedPushpin(this.getSelectedPushpin().pushpinID);
  }
  if (this.lookupController().getViewModel().get('punchpinsEnabled') || this.lookupViewModel().get('HidePushpins')) {
    this.lookupController().updatePunchpinVisibility();
  }
  this.fireEvent('pinsloaded');
}, addPinsFromData:function(pushpinJSON, ListTypeID, onSuccess, onEachFeature, layer) {
  layer = layer || this.pushpinLayer;
  floorplanList.PlanUtil.filterPushpinData(pushpinJSON, !!ListTypeID);
  if (this.highlightLayer) {
    this.highlightLayer.clearLayers();
  }
  if (layer) {
    layer.clearLayers();
  }
  var options = {controller:this, style:function(feature) {
    return feature.properties && feature.properties.style;
  }, pointToLayer:floorplanList.PlanUtil.pinPointToLayer};
  if (onEachFeature) {
    options.onEachFeature = onEachFeature;
  }
  MVLeaflet.geoJson([pushpinJSON], options).addTo(layer);
  if (onSuccess) {
    onSuccess.call(this, pushpinJSON);
  }
}, continueLoadingPushpins:function(projectUID, floorplanUID, ListTypeID, onSuccess, onEachFeature) {
  var ctrl = this;
  ctrl.pushpinsArray = [];
  var params = {floorplanUID:floorplanUID};
  if (ListTypeID) {
    params.ListTypeID = ListTypeID;
  }
  mdsAjax.doAjaxRequest({url:'index.cfm?fuseaction\x3daClientFloorplanViewer.getPushpinsByFloorplanGEOJSON\x26ProjectUID\x3d' + projectUID + '\x26floorplanUID\x3d' + floorplanUID, method:'GET', successCallback:function(pushpinJSON) {
    if (ctrl.isDestroyed) {
      return;
    }
    ctrl.addPinsFromData(pushpinJSON, ListTypeID, onSuccess, onEachFeature);
    ctrl.pushpinsLoaded = true;
    if (ctrl.checkMapReady) {
      ctrl.checkMapReady();
    }
  }, failure:function() {
    Ext.Msg.alert('Error', 'Error loading Pushpin data.');
  }, scope:ctrl});
}, addMiniMap:function() {
  (new MVLeaflet.Control.MiniMap(this.miniTileLayer, {toggleDisplay:true, width:250, height:250, hideText:mvstr['FV_Hide Mini-map'], showText:mvstr['FV_Show Mini-map']})).addTo(this.map);
}, addSeparateMiniMap:function(map) {
  var floorplanRecord = this.getFloorplanRecord();
  this.miniTileLayer = MVLeaflet.tileLayer.zoomify(this._tilePath, {width:floorplanRecord.get('imageWidth'), height:floorplanRecord.get('imageHeight'), tileSize:floorplanRecord.get('tileSize'), tileExtension:'.' + floorplanRecord.get('imageType'), tileMaxZoom:4, tolerance:0.8, attribution:'Photo: Multivista', crs:MVLeaflet.CRS.Multivista});
  (new MVLeaflet.Control.MiniMapSeparate(this.miniTileLayer, {toggleDisplay:true, mainMap:this.map, crs:MVLeaflet.CRS.Multivista})).addTo(map);
}, checkMapReady:function() {
  if ((!this.lookupViewModel().get('account.canRead') || this.pushpinsLoaded) && this.hotspotsLoaded) {
    this.fireEvent('map_ready', this);
    this.up('clientFloorplanViewerDisp').setLegendPosition();
  }
}, loadPanoScanLocations:function(floorplanUID) {
  var vm = this.lookupViewModel();
  vm.set('hasPanoScanLocations', false);
  mdsAjax.doAjaxRequest({url:'/index.cfm?fuseaction\x3daClientPanorama.getFloorplanInteriorPanos\x26floorplanUID\x3d' + floorplanUID, success:function(response, opts) {
    try {
      var result = Ext.decode(response.responseText);
      if (result && result.success) {
        this.removePanoScanMarkers();
        var scanLocations = [];
        for (var i = 0; i < result.data.length; i++) {
          var pano = result.data[i];
          if (pano.photoThumbUrl == null) {
            scanLocations.push(pano);
          }
        }
        vm.set('hasPanoScanLocations', scanLocations.length > 0);
        this.setPanoScanLocations(scanLocations);
      } else {
        throw new Error('Error loading interior panorama hotspots: ' + (result ? result.message : 'Unknown error'));
      }
    } catch (ex) {
      console.error('Error loading interior panorama hotspots', ex.message);
      Ext.Msg.alert('Error', 'Unable to load interior panorama hotspots');
    }
  }, failure:function(response) {
    console.error(arguments);
    Ext.Msg.alert('Error', 'Failed to load interior panorama hotspots');
  }, scope:this});
}, showPanoScanMarkers:function() {
  var panos = this.getPanoScanLocations();
  var panoScanLayer = this.createPanoScanLayer();
  this.setPanoScanMarkers([]);
  for (var i = 0; i < panos.length; i++) {
    var pano = panos[i];
    this.createPanoScanMarker(panoScanLayer, pano.x, pano.y);
  }
}, removePanoScanMarkers:function() {
  if (this.panoScanLayer && this.hotspotLayer) {
    this.hotspotLayer.removeLayer(this.panoScanLayer);
    this.panoScanLayer.clearLayers();
    this.panoScanLayer = null;
  }
}, createPanoScanLayer:function() {
  if (this.panoScanLayer == null) {
    this.panoScanLayer = new MVLeaflet.layerGroup;
    this.panoScanLayer.addTo(this.hotspotLayer);
  } else {
    this.panoScanLayer.clearLayers();
  }
  return this.panoScanLayer;
}, createPanoScanMarker:function(layer, x, y) {
  var radius = this.getPanoMarkerRadius();
  var marker = MVLeaflet.panoScanMarker({lat:y, lng:x}, {className:'panoMarker', radius:radius, opacity:1, fillOpacity:1, fill:true, clickable:false, riseOnHover:true});
  layer.addLayer(marker);
  this.getPanoScanMarkers().push(marker);
  return marker;
}, createPanoHotspotMarker:function(panoUuid, x, y, layers) {
  var marker = MVLeaflet.panoMarker({lat:y, lng:x}, {radius:this.getPanoMarkerRadius(), color:'#E65E25', clickable:false, layers:layers});
  this.addPanoMarkerEventListeners(marker);
  if (panoUuid) {
    this.getPanoHotspotMarkers()[panoUuid] = marker;
  }
  return marker;
}, removePanoHotspotMarkers:function() {
  if (this.panoHotspotLayer && this.hotspotLayer) {
    this.hotspotLayer.removeLayer(this.panoHotspotLayer);
    this.panoHotspotLayer.clearLayers();
    this.panoHotspotLayer = null;
  }
}, createPanoHotspotLayer:function() {
  if (this.panoHotspotLayer == null) {
    this.panoHotspotLayer = new MVLeaflet.layerGroup;
    this.panoHotspotLayer.addTo(this.hotspotLayer);
  } else {
    this.panoHotspotLayer.clearLayers();
  }
  return this.panoHotspotLayer;
}, setPanoHotspotLayerVisible:function(visible) {
  if (!this.panoHotspotLayer) {
    return;
  }
  if (visible) {
    this.panoHotspotLayer.addTo(this.hotspotLayer);
  } else {
    this.hotspotLayer.removeLayer(this.panoHotspotLayer);
  }
}, getPanoHotspotMarker:function(panoUuid) {
  var markers = this.getPanoHotspotMarkers();
  if (markers.hasOwnProperty(panoUuid)) {
    return markers[panoUuid];
  }
  console.log("Warning - couldn't find pano marker for " + panoUuid);
  return null;
}, addPanoMarkerEventListeners:function(marker) {
  marker.on('mouseover', function(e) {
    marker.setRadius(this.getPanoMarkerRadius(true));
    marker.bringToFront();
  }, this);
  marker.on('mouseout', function(e) {
    marker.setRadius(this.getPanoMarkerRadius());
  }, this);
}, getPanoMarkerRadius:function(hover) {
  var radius = Math.min(15, 6 + this.map.getZoom() * 3);
  if (hover === true) {
    radius = Math.round(radius * 1.2);
  }
  return radius;
}, mapZoomEndHandler:function(e) {
  var zoom = e.target.getZoom();
  var radius = this.getPanoMarkerRadius();
  var markersMap = this.getPanoHotspotMarkers();
  for (var uuid in markersMap) {
    var marker = markersMap[uuid];
    marker.setRadius(radius);
  }
  var markers = this.getPanoScanMarkers();
  for (var i = 0; i < markers.length; i++) {
    markers[i].setRadius(radius);
  }
}, loadHotspots:function(floorplanRecord) {
  var ctrl = this;
  floorplanRecord = floorplanRecord || ctrl.floorplanRecord;
  var floorplanUID = floorplanRecord.get('FloorplanUID'), projectUID = ctrl.lookupViewModel().get('ProjectUID');
  ctrl.hotspotsArray = [];
  ctrl.setPanoHotspotMarkers({});
  mdsAjax.doAjaxRequest({url:'index.cfm?fuseaction\x3daClientFloorplanViewer.getHotspotsByFloorplanGEOJSON\x26ProjectUID\x3d' + projectUID + '\x26floorplanUID\x3d' + floorplanUID, method:'GET', successCallback:function(hotspotJSON) {
    var me = ctrl;
    ctrl.fireEvent('getHotspotColorsOrIcons', hotspotJSON);
    var panoHotspots = [];
    if (hotspotJSON && hotspotJSON.features) {
      for (var i = hotspotJSON.features.length - 1; i >= 0; i--) {
        var feature = hotspotJSON.features[i];
        if (feature.properties.hotspotType == 'interiorPano' || feature.properties.hotspotType == 'mport') {
          panoHotspots.push(hotspotJSON.features[i]);
          hotspotJSON.features.splice(i, 1);
        }
      }
    }
    MVLeaflet.geoJson([hotspotJSON], {style:function(feature) {
      return feature.properties && feature.properties.style;
    }, onEachFeature:Ext.bind(ctrl.hotspotAddEvent, ctrl), pointToLayer:function(feature, latlng) {
      var hotspotType = feature.properties.hotspotType;
      var rotation = 0;
      var width = 0;
      var height = 0;
      if (hotspotType == 'arrow' || hotspotType == 'm_arrow') {
        rotation = feature.properties.media.split('_')[1];
        return MVLeaflet.hotspotMarker(latlng, {opacity:0, fillOpacity:0, halo:3, rotation:rotation});
      } else {
        if (hotspotType == 'hotarea') {
          rotation = feature.properties.rotation;
          width = feature.properties.width;
          height = feature.properties.height;
          return MVLeaflet.hotareaMarker(latlng, {opacity:0, fillOpacity:0, rotation:rotation, width:width, height:height});
        } else {
          if (hotspotType == 'pano') {
            return MVLeaflet.hotCircleMarker(latlng, {radius:22, opacity:0, fillOpacity:0, halo:3, rotation:rotation});
          } else {
            if (hotspotType == 'spherical') {
              return MVLeaflet.hotCircleMarker(latlng, {radius:22, opacity:0, fillOpacity:0, halo:3, rotation:rotation});
            } else {
              if (hotspotType == '360pano') {
                return MVLeaflet.hotCircleMarker(latlng, {radius:22, opacity:0, fillOpacity:0, halo:3, rotation:rotation});
              } else {
                if (hotspotType == 'down') {
                  return MVLeaflet.hotCircleMarker(latlng, {radius:16, opacity:0, fillOpacity:0, halo:3, rotation:rotation});
                }
              }
            }
          }
        }
      }
    }}).addTo(ctrl.hotspotLayer);
    if (ctrl.getShowInteriorPanoHotspots()) {
      MVLeaflet.geoJson([{type:'FeatureCollection', features:panoHotspots}], {style:function(feature) {
        return feature.properties && feature.properties.style;
      }, onEachFeature:Ext.bind(ctrl.hotspotAddEvent, ctrl), pointToLayer:function(feature, latlng) {
        var rotation = 0, hotCircleMarker = MVLeaflet.hotCircleMarker(latlng, {radius:22, opacity:0, fillOpacity:0, halo:3, rotation:rotation});
        if (feature.properties.panoDropSpot === true) {
          return me.createPanoHotspotMarker(feature.properties.panoUuid, latlng.lng, latlng.lat, [hotCircleMarker]);
        }
        return hotCircleMarker;
      }}).addTo(ctrl.createPanoHotspotLayer());
    }
    if (ctrl.showHotspotComments) {
      MVLeaflet.geoJson([hotspotJSON], {style:function(feature) {
        return feature.properties && feature.properties.style;
      }, onEachFeature:Ext.bind(ctrl.hotspotAddEvent, ctrl), filter:function(feature) {
        return feature.properties.numComments ? true : false;
      }, pointToLayer:function(feature, latlng) {
        return MVLeaflet.marker(latlng, {icon:new MVLeaflet.NumberedDivIcon({number:feature.properties.numComments})});
      }}).addTo(ctrl.hotspotCommentLayer);
    }
    ctrl.hotspotsLoaded = true;
    ctrl.fireEvent('hotspotsLoaded');
    ctrl.checkMapReady();
  }, useDefaultXhrHeader:false, disableCaching:true, withCredentials:true, scope:ctrl});
  if (ctrl.getShowInteriorPanoHotspots()) {
  }
}, hotspotAddEvent:function(feature, layer) {
  Ext.Array.include(this.hotspotsArray, feature);
  layer.on('click', Ext.bind(function(e) {
    if (feature.properties.hotspotType == 'hotarea') {
      this.fireEvent('hotspot_click', feature, this);
      this.setSelectedHotarea(feature);
    } else {
      this.fireEvent('hotspot_click', feature, this);
      this.setSelectedHotspot(feature.id);
    }
  }, this));
  if (this.showHovers) {
    if (this.hotspotMouseOverEvent == null) {
      this.hotspotMouseOverEvent = Ext.bind(function(e) {
        this.fireEvent('hotspot_mouseover', e);
      }, this);
      this.hotspotMouseMoveEvent = Ext.bind(function(e) {
        this.fireEvent('hotspot_mousemove', e);
      }, this);
      this.hotspotMouseOutEvent = Ext.bind(function(e) {
        this.fireEvent('hotspot_mouseout', e);
      }, this);
    }
    layer.on('mouseover', this.hotspotMouseOverEvent);
    layer.on('mousemove', this.hotspotMouseMoveEvent);
    layer.on('mouseout', this.hotspotMouseOutEvent);
  }
  if (this.hotspotLayers) {
    this.hotspotLayers.push(layer);
  }
}, dragend:function(e) {
  e.target.setLatLng(e.target._latlng);
  e.target.update();
  this.fireEvent('pushpin_dragend', e);
  this.moveSelectedPushpin();
}, dragstart:function(e) {
  this.highlightLayer.clearLayers();
  this.fireEvent('pushpin_dragstart', e);
}, drag:function(e) {
  this.fireEvent('pushpin_drag', e);
  this.moveSelectedPushpin();
}, pushpinAddEvent:function(feature, layer) {
  if (!this.pushpinsArray) {
    return;
  }
  Ext.Array.include(this.pushpinsArray, feature);
  var me = this;
  layer.on('click', Ext.bind(function(e) {
    if (me.openPins && me.lookupController().lookupReference('pushpinFlyout').isDisabled()) {
      return;
    }
    me.fireEvent('pushpin_click', e, feature);
    me.setSelectedPushpin(feature.id);
  }, me));
  if (me.showHovers) {
    layer.on('mouseover', function(e) {
      me.fireEvent('pushpin_mouseover', e);
    });
    layer.on('mousemove', function(e) {
      me.fireEvent('pushpin_mousemove', e);
    });
    layer.on('mouseout', function(e) {
      me.fireEvent('pushpin_mouseout', e);
    });
    layer.on('mousedown', function(e) {
      me.fireEvent('pushpin_mousedown', e);
    });
  }
  layer.on('dragend', Ext.bind(me.dragend, me));
  layer.on('dragstart', Ext.bind(me.dragstart, me));
  layer.on('drag', Ext.bind(me.drag, me));
}, addNewPushpin:function(pushpinType, optionalData) {
  if (!optionalData) {
    optionalData = {};
  }
  if (!optionalData.PushpinSymbol) {
    optionalData.PushpinSymbol = 'mds/module/clientFileManager/image/pin_red.png';
  }
  if (!optionalData.iconAnchor) {
    optionalData.iconAnchor = [5, 26];
  }
  var me = this;
  me.setFloorplanViewerMode('addNewPin');
  var pushpinType = pushpinType;
  var latlng = this.map.getCenter();
  var pushpinJSON = {'type':'FeatureCollection', 'features':[{'properties':{'ShareMembers':'', 'PushpinLabel':'', 'ShareTypeID':2, 'PushpinTypeUID':pushpinType, 'PushpinType':pushpinType, 'PushpinCreationDate':'March, 13 2015 13:05:43 -0700', 'PushpinSymbol':optionalData.PushpinSymbol, 'IsOwner':1}, 'id':'0000', 'type':'Feature', 'geometry':{'coordinates':[latlng.lng, latlng.lat], 'type':'Point'}}]};
  if (optionalData.PunchItemID) {
    pushpinJSON.features[0].properties.PunchItemID = optionalData.PunchItemID;
  }
  if (optionalData.IsNewItem) {
    pushpinJSON.features[0].properties.IsNewItem = optionalData.IsNewItem;
  }
  MVLeaflet.geoJson([pushpinJSON], {style:function(feature) {
    return feature.properties && feature.properties.style;
  }, onEachFeature:Ext.bind(function(feature, layer) {
    Ext.Array.include(this.pushpinsArray, feature);
    layer.on('dragend', Ext.bind(this.dragend, this));
    layer.on('dragstart', Ext.bind(this.dragstart, this));
    layer.on('drag', Ext.bind(this.drag, this));
  }, this), pointToLayer:function(feature, latlng) {
    var pushpinType = feature.properties.PushpinType;
    var pushpinSymbol = feature.properties.PushpinSymbol;
    var iconSize = [33, 33];
    var iconAnchor = optionalData.iconAnchor;
    switch(pushpinType) {
      case 1:
        iconSize = [33, 33];
        iconAnchor = [5, 26];
        pushpinSymbol = 'mds/image/clientFileManager/pin_red.png';
        break;
      case 3:
        iconSize = [33, 33];
        iconAnchor = [5, 26];
        pushpinSymbol = 'mds/image/clientFileManager/pin_green.png';
        break;
      case 4:
        iconSize = [33, 33];
        iconAnchor = [5, 26];
        pushpinSymbol = 'mds/image/clientFileManager/pin_blue.png';
        break;
      case 2:
        iconSize = [33, 33];
        iconAnchor = [5, 26];
        pushpinSymbol = 'mds/image/clientFileManager/pin_yellow.png';
        break;
      case 5:
        iconSize = [33, 33];
        iconAnchor = [17, 4];
        pushpinSymbol = 'mds/image/clientFileManager/n_pink.png';
        break;
      case 6:
        iconSize = [33, 33];
        iconAnchor = [29, 17];
        pushpinSymbol = 'mds/image/clientFileManager/e_pink.png';
        break;
      case 7:
        iconSize = [33, 33];
        iconAnchor = [17, 29];
        pushpinSymbol = 'mds/image/clientFileManager/s_pink.png';
        break;
      case 8:
        iconSize = [33, 33];
        iconAnchor = [4, 17];
        pushpinSymbol = 'mds/image/clientFileManager/w_pink.png';
        break;
    }
    var markerIcon = MVLeaflet.icon({iconUrl:pushpinSymbol, iconSize:iconSize, iconAnchor:iconAnchor});
    return MVLeaflet.marker(latlng, {icon:markerIcon, draggable:true});
  }}).addTo(this.hasUnsavedPinLayer ? this.unsavedPinLayer : this.pushpinLayer);
  me.setSelectedPushpin('0000');
  me.moveSelectedPushpin();
  me.fireEvent('pushpin_new');
}, toggleTileLayer:function() {
  var tilePath = '';
  this._numbersVisible = !this._numbersVisible;
  if (this._numbersVisible) {
    tilePath = this._tilePathInt;
  } else {
    tilePath = this._tilePath;
  }
  this.tileLayer.setUrl(tilePath);
}, setSelectedHotspot:function(hotspotId) {
  if (this.getFloorplanViewerMode().mode === 'view') {
    var highlight = this.highlightLayer;
    this._selectedPushpin = {};
    var return_item = null;
    Ext.Array.forEach(this.hotspotsArray, function(item) {
      if (item.id == hotspotId) {
        this.highlightMarker(item);
        return_item = item;
      }
    }, this);
    return return_item;
  }
}, setSelectedHotarea:function(feature) {
}, getSelectedPushpin:function() {
  return this._selectedPushpin;
}, setSelectedPushpin:function(pushpinId) {
  this.lookupViewModel().set('PushpinUID', pushpinId);
  if (pushpinId === null) {
    this._selectedPushpin = '';
    this.highlightLayer.clearLayers();
    this.map.closePopup();
  } else {
    var pushpinObject = {};
    pushpinObject.projectID = this.floorplanProjectID;
    pushpinObject.pushpinID = pushpinId;
    pushpinObject.floorplanID = this.getFloorplanRecord().get('FloorplanUID');
    Ext.Array.forEach(this.pushpinsArray, function(item) {
      if (item.id === pushpinId) {
        pushpinObject.properties = item.properties;
        pushpinObject.geometry = item.geometry;
        this.highlightMarker(item);
      }
    }, this);
    this._selectedPushpin = pushpinObject;
  }
}, getSwirlyMarker:function(latlng) {
  var markerIcon = MVLeaflet.icon({iconUrl:this.up('pinwizard') ? 'mds/image/clientFloorplanViewer/orange_selector.gif' : 'mds/image/clientFloorplanViewer/swirlyThing.gif', iconSize:[70, 70], iconAnchor:[35, 35], className:'add-pushpin-target'});
  return theMarker = MVLeaflet.marker(latlng, {icon:markerIcon, draggable:true});
}, moveSelectedPushpin:function() {
  var me = this, highlight = this.highlightLayer, pinLayer = this.hasUnsavedPinLayer ? this.unsavedPinLayer : this.pushpinLayer;
  pinLayer.eachLayer(function(layers) {
    layers.eachLayer(function(marker) {
      if (marker.feature.id === me.getSelectedPushpin().pushpinID) {
        marker.dragging.enable();
        marker.setZIndexOffset(10000);
        highlight.clearLayers();
        var s_marker = me.getSwirlyMarker(marker._latlng);
        s_marker.on('drag', function(e) {
          marker.setLatLng(e.target._latlng);
          marker.update();
          me.fireEvent('pin_mover_move', e.target._latlng);
        });
        highlight.addLayer(s_marker);
        me.fireEvent('pin_mover_move', marker._latlng);
      }
    });
  });
}, updatePushpinPosition:function() {
  var me = this, floorplanUID = this.getFloorplanRecord().get('FloorplanUID'), projectUID = Ext.Object.fromQueryString(document.location.search).ProjectUID, centrePoint = this.map.getBounds().getCenter(), serviceURL = '', params = {}, selectedPushpin = me.getSelectedPushpin();
  this.pushpinLayer.eachLayer(function(layers) {
    layers.eachLayer(function(marker) {
      if (marker.feature.id === selectedPushpin.pushpinID) {
        centrePoint = marker.getLatLng();
      }
    });
  });
  if (centrePoint.lng < this.getFloorplanRecord().get('imageWidth') && centrePoint.lat < this.getFloorplanRecord().get('imageHeight') && centrePoint.lng > 0 && centrePoint.lat > 0) {
    if (this.getFloorplanViewerMode().mode === 'movePin') {
      serviceURL = '/index.cfm?fuseaction\x3daClientFloorplanViewer.updatePushpinPosition';
      params = {FloorplanID:floorplanUID, ProjectUID:projectUID, PushpinID:selectedPushpin.pushpinID, PushpinTypeUID:selectedPushpin.properties.PushpinTypeUID, PushpinXCoordinate:centrePoint.lng, PushpinYCoordinate:centrePoint.lat};
    } else {
      if (this.getFloorplanViewerMode().mode === 'addNewPin') {
        var viewModel = this.up('clientviewport').getViewModel();
        serviceURL = selectedPushpin.properties.PunchItemID ? '/index.cfm?fuseaction\x3daClientPunchlist.addPunchPinsToPunchItem' : '/index.cfm?fuseaction\x3daClientFloorplanViewer.addPushpinToFloorplan';
        params = selectedPushpin.properties.PunchItemID ? {ProjectUID:projectUID, PunchItemID:selectedPushpin.properties.PunchItemID, FloorplanUID:floorplanUID, PushpinXCoordinate:centrePoint.lng, PushpinYCoordinate:centrePoint.lat, IsNewItem:selectedPushpin.properties.IsNewItem ? 1 : 0} : {FloorplanUID:floorplanUID, ProjectUID:projectUID, PushpinID:selectedPushpin.pushpinID, PushpinTypeUID:selectedPushpin.properties.PushpinTypeUID, PushpinLabel:selectedPushpin.properties.PushpinLabel, PushpinXCoordinate:centrePoint.lng, 
        PushpinYCoordinate:centrePoint.lat, ShareTypeID:viewModel.get('selectedShareTypeID'), MemberList:viewModel.get('selectedShareMemberUIDList')};
      }
    }
    mdsAjax.doAjaxRequest({url:serviceURL, successCallback:function(data) {
      me.loadPushpins(me.getFloorplanRecord());
      me.setFloorplanViewerMode('view');
      me.fireEvent('update_pushpin_position', data.length ? data[0] : data);
      data.length ? me.setSelectedPushpin(data[0].PushpinUID) : me.setSelectedPushpin(data.PushpinUID);
    }, params:params});
  } else {
    var message = 'You cannot move a pushpin outside the edges of the floorplan.';
    alert('Outside range', message, function() {
    }, this, 'OK');
  }
}, setFloorplanViewerMode:function(mode) {
  this._floorplanViewerMode.mode = mode;
  this.lookupViewModel().set('floorplanViewerMode', mode);
}, getFloorplanViewerMode:function() {
  return this._floorplanViewerMode;
}, highlight:function(record, zoomAndCenter) {
  var pushpin = record.get('pushpin');
  this.highlight2(record.get('hotspotID'), pushpin ? pushpin.PushpinUID : undefined, zoomAndCenter);
}, highlight2:function(hotspotID, pushpinUID, zoomAndCenter) {
  var selectedItem;
  if (hotspotID) {
    Ext.Array.forEach(this.hotspotsArray, function(item, index, allItems) {
      if (hotspotID == item.id) {
        selectedItem = item;
      }
    });
  }
  if (pushpinUID) {
    Ext.Array.forEach(this.pushpinsArray, function(item, index, allItems) {
      if (pushpinUID == item.id) {
        selectedItem = item;
      }
    });
  }
  if (selectedItem) {
    var zoomOutInteriorPanoHotspots = this.getZoomOutInteriorPanoHotspots();
    var hotspotType = selectedItem.properties.hotspotType;
    var isInteriorPano = hotspotType == 'interiorPano' || hotspotType == 'mport';
    this.highlightMarker(selectedItem);
    if (zoomAndCenter || zoomOutInteriorPanoHotspots && isInteriorPano) {
      var zoom = this.map.getMaxZoom();
      if (zoomOutInteriorPanoHotspots && isInteriorPano) {
        zoom--;
      }
      this.zoomToMarker(selectedItem, zoom);
    }
  }
}, zoomToMarker:function(item, zoom) {
  var animateOptions = this.getAnimateOptions();
  if (animateOptions) {
    this.map.setView({lon:item.geometry.coordinates[0], lat:item.geometry.coordinates[1]}, zoom, animateOptions);
  } else {
    this.map.setView({lon:item.geometry.coordinates[0], lat:item.geometry.coordinates[1]}, undefined, true);
    this.map.setZoom(zoom, {animate:false});
  }
}, highlightMarker:function(item) {
  var hotspotType = item.properties.hotspotType;
  var isInteriorPano = hotspotType == 'interiorPano' || hotspotType == 'mport';
  var isPano = hotspotType == 'pano' || isInteriorPano;
  var highlightInteriorPanoHotspots = this.getHighlightInteriorPanoHotspots();
  if (isInteriorPano && !highlightInteriorPanoHotspots) {
    return;
  }
  var highlight = this.highlightLayer;
  highlight.clearLayers();
  var markerLayer = MVLeaflet.circleMarker({lon:item.geometry.coordinates[0], lat:item.geometry.coordinates[1]}, {radius:isPano ? 22 : 16, color:'#E86FD2', clickable:false, weight:6, fill:true, fillOpacity:0.4});
  highlight.addLayer(markerLayer);
}, panToMarker:function(x, y, animate) {
  this.map.panTo({lon:x, lat:y}, {animate:!!animate});
}, setCommentsOn:function(on) {
  if (this.hotspotCommentLayer) {
    if (on) {
      this.getMap().addLayer(this.hotspotCommentLayer);
    } else {
      this.getMap().removeLayer(this.hotspotCommentLayer);
    }
  }
}, addBackpackPanoMarker:function(lat, lng, locationObj, walkName, prefix, backpackWalkID) {
  var marker = MVLeaflet.marker([lat, lng], {icon:this.backpackIcon, locationObj:locationObj});
  if (this.backpackPanoActiveInViewer) {
    marker.on('click', function(locationObj, walkName, prefix) {
      var viewModel = this.lookupViewModel();
      var projectUID = viewModel.get('ProjectUID');
      this.fireEvent('backpackPanoMarkerClick', locationObj);
    }.bind(this, locationObj, walkName, prefix));
  } else {
    var makeBubble = function() {
      var path = prefix + '/backpack/pano/' + walkName + '/' + locationObj.ImageName + '_thumb.jpg';
      return '\x3cdiv class\x3d"photoBubble_outer"\x3e\x3cb\x3e' + walkName + ' - ' + locationObj.ImageName + '\x3c/b\x3e\x3c/br\x3e\x3cimg src\x3d"' + path + '" style\x3d"border-color: ##000000; border-width: 1;" width\x3d"300px" height\x3d"150px"\x3e\x3c/img\x3e\x3c/div\x3e';
    };
    marker.on('mouseover', function() {
      marker.bindPopup(makeBubble()).openPopup();
    });
    marker.on('click', function(locationObj, walkName, prefix) {
      var viewModel = this.lookupViewModel();
      var projectUID = viewModel.get('ProjectUID');
      this.fireEvent('backpack_marker_clicked', locationObj, walkName, prefix, projectUID, backpackWalkID);
    }.bind(this, locationObj, walkName, prefix));
  }
  marker.addTo(this.backpackPanoLayer);
  this.panoMarkers.push();
}, clearFloorplanLayersForBackpackPanos:function() {
  if (this.hotspotLayer) {
    this.hotspotLayer.eachLayer(function(layer) {
      this.getMap().removeLayer(layer);
    }.bind(this));
  }
  this.highlightLayer.clearLayers();
  this.backpackPanoLayer = null;
  this.backpackPanoLayer = new MVLeaflet.layerGroup;
  this.backpackPanoLayer.addTo(this.getMap());
  this.panoMarkers = [];
  this.backpackIcon = MVLeaflet.icon({iconUrl:'resources/images/sm_orange_point.png', shadowUrl:null, iconSize:new MVLeaflet.Point(10, 10), iconAnchor:new MVLeaflet.Point(5, 5), popupAnchor:new MVLeaflet.Point(0, -10)});
}, resetFloorplanLayersAfterBackpackPanos:function() {
  this.hotspotLayer.eachLayer(function(layer) {
    this.getMap().addLayer(layer);
  }.bind(this));
  this.getMap().removeLayer(this.backpackPanoLayer);
  this.panoMarkers = [];
}}, 0, ['fvFloorplanViewer'], ['component', 'box', 'container', 'fvFloorplanViewer'], {'component':true, 'box':true, 'container':true, 'fvFloorplanViewer':true}, ['widget.fvFloorplanViewer'], 0, [floorplanViewer.view, 'Floorplan'], 0);
Ext.cmd.derive('floorplanViewer.view.FloorplanExportWindow', Ext.window.Window, {ui:'orange', layout:'fit', width:420, height:280, modal:true, localized:{title:'FV_Export Floorplan To P'}, items:[{xtype:'container', layout:{type:'vbox', align:'stretch'}, cls:'export-window-body', items:[{xtype:'component', localized:{html:'FV_The floorplan will be'}, margin:'0 0 15 0'}, {xtype:'checkboxfield', ui:'plain-16', localized:{boxLabel:'FV_Display project name '}, itemId:'headerCheckbox', value:true}, {xtype:'checkboxfield', 
ui:'plain-16', localized:{boxLabel:'FV_Display Multivista co'}, itemId:'hotspotsCheckbox', value:true, hidden:true, bind:{hidden:'{!account.MultivistaContentPermission}'}}, {xtype:'checkboxfield', ui:'plain-16', localized:{boxLabel:'FV_Display user defined '}, itemId:'pushpinsCheckbox', value:true, hidden:true, bind:{hidden:'{!account.canRead}'}}]}], dockedItems:[{xtype:'toolbar', dock:'bottom', ui:'footer', height:56, layout:{pack:'center', type:'hbox'}, items:[{xtype:'button', ui:'grey', scale:'medium', 
localized:{text:'G_Cancel'}, width:90, handler:function() {
  this.up('window').close();
}}, {xtype:'tbspacer', width:5}, {xtype:'button', ui:'green', scale:'medium', localized:{text:'G_OK'}, width:90, handler:function(btn) {
  var wind = this.up('window');
  var displayHeader = wind.down('#headerCheckbox').getValue();
  var displayHotspots = wind.down('#hotspotsCheckbox').getValue();
  var displayPushpins = wind.down('#pushpinsCheckbox').getValue();
  wind.fireEvent('exportfloorplan', displayHeader, displayHotspots, displayPushpins);
  wind.close();
}}]}]}, 0, 0, ['component', 'box', 'container', 'panel', 'window'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true}, 0, 0, [floorplanViewer.view, 'FloorplanExportWindow'], 0);
Ext.cmd.derive('floorplanViewer.view.FloorplanLegend', Ext.panel.Panel, {width:138, floating:true, cls:'floorplan-legend', closeAction:'hide', collapsible:true, defaultAlign:'bl-bl', border:true, layout:{type:'vbox', align:'stretch'}, localized:{title:'FV_Legend'}, header:{titleAlign:'center', cls:'floorplan-legend-header'}, items:[{xtype:'button', localized:{text:'FV_Wall / Horizontal'}, ui:'plain', iconCls:'toolicon-wall-horizontal', itemId:'orange', hidden:true, textAlign:'left'}, {xtype:'button', 
localized:{text:'FV_UAV Photos'}, ui:'plain', iconCls:'toolicon-uav-photos', itemId:'green', hidden:true, textAlign:'left'}, {xtype:'button', localized:{text:'FV_Ceiling / Upward'}, ui:'plain', iconCls:'toolicon-plain', itemId:'blue', hidden:true, textAlign:'left'}, {xtype:'button', localized:{text:'FV_Floor / Downward'}, ui:'plain', iconCls:'toolicon-floor-down', itemId:'red', hidden:true, textAlign:'left'}, {xtype:'button', localized:{text:'FV_360 Immersive'}, ui:'plain', iconCls:'toolicon-360-immersive', 
itemId:'pano_orange', hidden:true, textAlign:'left'}, {xtype:'button', localized:{text:'FV_UAV/Pano'}, ui:'plain', iconCls:'toolicon-uav-pano', itemId:'pano_green', hidden:true, textAlign:'left'}, {xtype:'button', localized:{text:'FV_Aerial Downward'}, ui:'plain', iconCls:'toolicon-aerial-downward', itemId:'down_green', hidden:true, textAlign:'left'}, {xtype:'button', localized:{text:'FV_360 Photo'}, ui:'plain', iconCls:'toolicon-360-photo', itemId:'photo_360', hidden:true, textAlign:'left'}, {xtype:'button', 
localized:{text:'FV_360 Measurable'}, ui:'plain', iconCls:'toolicon-360-measurable', itemId:'m_arrow', hidden:true, textAlign:'left'}]}, 0, ['fvLegend'], ['component', 'box', 'container', 'panel', 'fvLegend'], {'component':true, 'box':true, 'container':true, 'panel':true, 'fvLegend':true}, ['widget.fvLegend'], 0, [floorplanViewer.view, 'FloorplanLegend'], 0);
Ext.cmd.derive('floorplanViewer.view.FloorplanViewerTitle', Ext.Container, {layout:'hbox', items:[{xtype:'container', baseCls:'floorplanTitleListLink', margin:'0 0 0 5', bind:{hidden:'{!punchpinsEnabled}', html:"\x3ca href\x3d'{backToPlansLink}'\x3e\x26lt; {backToPlansText}\x3c/a\x3e"}}, {xtype:'container', flex:1, reference:'floorplanTitle', bind:{html:'{floorplanTitle}'}}]}, 0, ['floorplanviewertitle'], ['component', 'box', 'container', 'floorplanviewertitle'], {'component':true, 'box':true, 'container':true, 
'floorplanviewertitle':true}, ['widget.floorplanviewertitle'], 0, [floorplanViewer.view, 'FloorplanViewerTitle'], 0);
Ext.cmd.derive('floorplanViewer.view.MenuCheckItem', Ext.button.Button, {width:172, height:32, scale:'medium', textAlign:'left', cls:'toggle-enabled', itemCls:'toolmenu-item', overCls:'toolmenu-item-over', setCheckboxStyle:function(enabled) {
  if (enabled) {
    this.addCls('toggle-enabled');
    this.removeCls('toggle-disabled');
  } else {
    this.addCls('toggle-disabled');
    this.removeCls('toggle-enabled');
  }
}}, 0, ['mvmenucheckitem'], ['component', 'box', 'button', 'mvmenucheckitem'], {'component':true, 'box':true, 'button':true, 'mvmenucheckitem':true}, ['widget.mvmenucheckitem'], 0, [floorplanViewer.view, 'MenuCheckItem'], 0);
Ext.cmd.derive('floorplanViewer.view.LayerMenuItem', Ext.Container, {defaultType:'button', layout:'hbox', defaults:{width:172, scale:'medium', textAlign:'left', itemCls:'toolmenu-item', overCls:'toolmenu-item-over'}, listeners:{afterrender:function() {
  this.ownerCt.manageMouseEvents(this);
}}}, 0, ['layermenuitem'], ['component', 'box', 'container', 'layermenuitem'], {'component':true, 'box':true, 'container':true, 'layermenuitem':true}, ['widget.layermenuitem'], 0, [floorplanViewer.view, 'LayerMenuItem'], 0);
Ext.cmd.derive('floorplanViewer.view.LayerMenu', Ext.Container, {cls:'flyout-menu-wrap', floating:true, shrinkWrap:3, hidden:true, defaultType:'button', defaults:{width:200, scale:'medium', textAlign:'left'}, renderTo:Ext.getBody(), x:69, y:140, layout:'vbox', padding:3, backgroundStyle:null, manageMouseEvents:function(managedObj) {
  var overBg = '#454776';
  var overStyle = {'background':overBg, 'background-repeat':'no-repeat'};
  managedObj.items.items[0].relayEvents(managedObj.items.items[1].getEl(), ['click']);
  managedObj.items.items[1].relayEvents(managedObj.items.items[0].getEl(), ['click']);
  var pushpinEnabled = managedObj.items.items[1].getEl();
  var visToggle = managedObj.items.items[0].getEl();
  if (this.backgroundStyle == null) {
    this.backgroundStyle = visToggle.getStyle('background');
  }
  var outStyle = {'background':this.backgroundStyle, 'background-repeat':'no-repeat'};
  pushpinEnabled.addListener('mouseenter', function() {
    visToggle.setStyle({'background':overBg});
  });
  pushpinEnabled.addListener('mouseleave', function() {
    visToggle.setStyle({'background':this.backgroundStyle});
  });
  visToggle.addListener('mouseenter', function() {
    overStyle['background-image'] = pushpinEnabled.getStyle('background-image');
    pushpinEnabled.setStyle(overStyle);
  });
  visToggle.addListener('mouseleave', function() {
    outStyle['background-image'] = pushpinEnabled.getStyle('background-image');
    outStyle['background'] = this.backgroundStyle;
    pushpinEnabled.setStyle(outStyle);
  });
}, initComponent:function() {
  var items = [];
  var punchpinFilters = [{label:mvstr['FVTL_Overdue Pins'], iconCls:'toolicon-punchpin-overdue', value:'showOverduePunchpins'}, {label:mvstr['FVTL_Not Started Pins'], iconCls:'toolicon-punchpin-notstarted', value:'showNotStartedPunchpins'}, {label:mvstr['FVTL_In Progress Pins'], iconCls:'toolicon-punchpin-progress', value:'showInProgressPunchpins'}, {label:mvstr['FVTL_Completed Pins'], iconCls:'toolicon-punchpin-complete', value:'showCompletedPunchpins'}, {label:mvstr['FVTL_On-Hold Pins'], iconCls:'toolicon-punchpin-onhold', 
  value:'showOnHoldPunchpins'}, {label:mvstr['FVTL_Closed Pins'], iconCls:'toolicon-punchpin-closed', value:'showClosedPunchpins'}];
  Ext.each(punchpinFilters, function(filter) {
    items.push({xtype:'layermenuitem', bind:{hidden:'{!punchpinsEnabled}'}, items:[{text:filter.label, iconCls:filter.iconCls, listeners:{click:{fn:'togglePunchpinVisibility', args:[filter.value]}}}, {xtype:'mvmenucheckitem', bind:{checkboxStyle:'{' + filter.value + '}'}}]});
  });
  items.push({xtype:'layermenuitem', hidden:true, bind:{hidden:'{!canSeeMVPhotos}'}, items:[{localized:{text:'FV_Photo Numbers'}, iconCls:'toolicon-numbervis', listeners:{click:'toggleNumberVisibility'}}, {xtype:'mvmenucheckitem', itemId:'toggleNumbersEnabled', bind:{checkboxStyle:'{toggleNumbersEnabled}'}}]}, {xtype:'layermenuitem', hidden:true, bind:{hidden:'{!canSeeMVPhotosAndComments}'}, items:[{localized:{text:'FV_Photo Comments'}, iconCls:'toolicon-commentvis', listeners:{click:'toggleCommentsVisibility'}}, 
  {xtype:'mvmenucheckitem', itemId:'toggleCommentsEnabled', bind:{checkboxStyle:'{toggleCommentsEnabled}'}}]}, {xtype:'layermenuitem', hidden:true, bind:{hidden:'{!canTogglePushpins}'}, items:[{iconCls:'toolicon-pushpinvis', localized:{text:'FV_Pushpins'}, listeners:{click:'togglePinVisibility'}}, {xtype:'mvmenucheckitem', itemId:'togglePushpinsEnabled', bind:{checkboxStyle:'{togglePushpinsEnabled}'}}]}, {xtype:'layermenuitem', name:'backpackpano', hidden:true, bind:{hidden:'{!toggleBackpackPanoEnabled}'}, 
  items:[{text:'Backpack Panos', iconCls:'toolicon-commentvis', listeners:{click:'toggleBackpackPanoVisibility'}}, {xtype:'mvmenucheckitem', itemId:'toggleBackpackPanoEnabled', bind:{checkboxStyle:'{toggleBackpackPanoEnabled}'}}]}, {xtype:'layermenuitem', bind:{visible:'{hasPanoScanLocations}'}, items:[{iconCls:'toolicon-panovis', text:'Scan Locations', listeners:{click:'togglePanoVisibility'}}, {xtype:'mvmenucheckitem', itemId:'togglePanosEnabled', bind:{checkboxStyle:'{togglePanosEnabled}'}}]});
  this.items = items;
  Ext.container.Container.prototype.initComponent.apply(this, arguments);
}}, 0, ['layermenu'], ['component', 'box', 'container', 'layermenu'], {'component':true, 'box':true, 'container':true, 'layermenu':true}, ['widget.layermenu'], 0, [floorplanViewer.view, 'LayerMenu'], 0);
Ext.cmd.derive('floorplanViewer.view.MapToolsMenu', Ext.toolbar.Toolbar, {floating:true, x:12, y:11, padding:'1 0 1 0', shadow:false, defaultType:'button', hidden:true, viewModel:{formulas:{addPinVisible:function(get) {
  return get('account.canWrite') && !config.ISARCHIVE;
}, exportVisible:function(get) {
  var account = get('account');
  if (account && account.features && account.features.badgesVisible && account.features.integrationsVisible && !config.ISARCHIVE && (account.procoreEnabled || account.planGridEnabled || account.aconexEnabled || account.bluebeamEnabled)) {
    return true;
  }
  return false;
}, printVisible:function(get) {
  return get('account.features.badgesVisible') && !config.ISARCHIVE;
}}}, defaults:{scale:'large', textAlign:'left', toggleGroup:'mapTools', width:53, height:58, cls:'toolmenu-tool', overCls:'toolmenu-tool-over', iconAlign:'top', listeners:{click:{fn:function(e) {
  var floorplanViewer = this.up('clientFloorplanViewerDisp');
  var menu = null;
  var openMenu = null;
  var controller = this.lookupController();
  if (e.itemId === 'menu_vis_toggles') {
    menu = floorplanViewer.down('layermenu');
  } else {
    if (e.itemId === 'menu_add_pushpin') {
      if (!this.lookupViewModel().get('punchpinsEnabled')) {
        this.lookupController().addPushPin(1);
      } else {
        console.log('adding pushpin');
        this.up('maptoolsmenu').fireEvent('startaddpunchpin');
      }
    } else {
      if (e.itemId === 'menu_search') {
        menu = floorplanViewer.down('searchcontainer');
      } else {
        if (e.itemId === 'menu_select') {
          menu = floorplanViewer.down('selectmenu');
        } else {
          if (e.itemId === 'menu_print') {
            controller.openPrintFloorplanWindow();
          } else {
            if (e.itemId === 'menu_export') {
              menu = floorplanViewer.down('exportmenu');
            } else {
              if (e.itemId === 'menu_add_arrow') {
                if (!this.lookupViewModel().get('punchpinsEnabled')) {
                  menu = floorplanViewer.down('pushpinmenu');
                } else {
                  this.up('maptoolsmenu').fireEvent('startaddpunchpin');
                }
              }
            }
          }
        }
      }
    }
  }
  var isVisible = false;
  if (menu != null) {
    isVisible = !menu.isVisible();
    if (isVisible) {
      menu.showBy(e, 'tl-tr', [2, 0]);
      openMenu = menu;
    }
    menu.setVisible(isVisible);
  }
  controller.initPhotoSelection(e.itemId == 'menu_select' ? isVisible : false);
  controller.setSelectedMapToolAndMenu(e.enableToggle && e.pressed ? e : null, openMenu);
}}}}, layout:'vbox', items:[{itemId:'menu_export', reference:'menuExport', localized:{text:'FV_Export', tooltip:'FV_Export'}, iconCls:'toolicon-export', hidden:true, bind:{hidden:'{!exportVisible}'}}, {itemId:'menu_print', reference:'menuPrint', localized:{text:'FV_Print', tooltip:'FV_Print'}, iconCls:'toolicon-print', enableToggle:false, toggleGroup:null, hidden:true, bind:{hidden:'{!printVisible}'}}, {itemId:'menu_vis_toggles', localized:{text:'FV_Visibility', tooltip:'FV_Visibility'}, iconCls:'toolicon-layer'}, 
{itemId:'menu_search', localized:{text:'FV_Search', tooltip:'FV_Search'}, iconCls:'toolicon-search', hidden:false}, {itemId:'menu_select', reference:'menuSelect', localized:{text:'FV_Select', tooltip:'FV_Select'}, iconCls:'toolicon-select', hidden:true}, {itemId:'menu_add_pushpin', reference:'menuAddPushpin', localized:{text:'FV_Add pin', tooltip:'FV_Add pin'}, iconCls:'toolicon-pushpin', hidden:true, bind:{hidden:'{!addPinVisible}'}}, {itemId:'menu_add_arrow', reference:'menuAddArrow', localized:{text:'FV_Arrows', 
tooltip:'FV_Arrows'}, iconCls:'toolicon-fp-arrow', hidden:true, bind:{hidden:'{!addPinVisible}'}}], listeners:{startaddpunchpin:'startAddPunchPin'}}, 0, ['maptoolsmenu'], ['component', 'box', 'container', 'toolbar', 'maptoolsmenu'], {'component':true, 'box':true, 'container':true, 'toolbar':true, 'maptoolsmenu':true}, ['widget.maptoolsmenu'], 0, [floorplanViewer.view, 'MapToolsMenu'], 0);
Ext.cmd.derive('floorplanViewer.view.PhotoThumbContainer', Ext.Container, {width:133, height:'100%', style:'background-color: #2D2D2D', overflowY:'auto', load:function(hotspotObject) {
  this.lookupViewModel().set('HotspotID', hotspotObject.hotspotID);
}, initComponent:function() {
  this.items = [];
  this.items.push({xtype:'fvPhotoThumbDataView', cls:this.selectPhotoThumbs ? 'thumbsSelect' : 'thumbsView', selectPhotoThumbs:this.selectPhotoThumbs, bind:{store:'{hotspotPhotos}'}});
  Ext.container.Container.prototype.initComponent.apply(this, arguments);
}, viewModel:{formulas:{hotspotPhotoGroup:function(get) {
  var hotspotID = get('HotspotID');
  return hotspotID ? Ext.create('floorplanViewer.model.PhotoGroup', {'Identifier':hotspotID, 'Type':'H'}) : null;
}, hotspotPhotos:function(get) {
  var photoGroup = get('hotspotPhotoGroup');
  if (!photoGroup) {
    return Ext.create('Ext.data.Store', {proxy:'memory'});
  }
  var store = photoGroup.getPhotoStore(get('ProjectUID'), get('storeSession'));
  store.sort({property:'PhotoDate', direction:'DESC'});
  if (!store.isLoaded() && !store.isLoading()) {
    store.load();
  }
  return store;
}}}}, 0, ['photothumbcontainer'], ['component', 'box', 'container', 'photothumbcontainer'], {'component':true, 'box':true, 'container':true, 'photothumbcontainer':true}, ['widget.photothumbcontainer'], 0, [floorplanViewer.view, 'PhotoThumbContainer'], 0);
Ext.cmd.derive('floorplanViewer.view.PinPositionDialog', Ext.Container, {floating:true, shadow:false, x:800, y:400, layout:{type:'hbox'}, initComponent:function() {
  this.items = [{xtype:'container', layout:'hbox', shadow:true, defaults:{xtype:'button', ui:'pin-action', scale:'large', overCls:'', height:42}, items:[Ext.merge({cls:'cancel', localized:{text:'G_Cancel', width:{de:90, es:85, 'default':63}}, listeners:{click:'cancelPinPosition'}}, this.cancelConf || {}), Ext.merge({cls:'save', localized:{text:'G_Save', width:{de:90, es:85, 'default':63}}, margin:'0 0 0 3', listeners:{click:'savePinPosition'}}, this.saveConf || {})]}];
  Ext.container.Container.prototype.initComponent.apply(this, arguments);
}, listeners:{show:function() {
  var xOffset = this.getWidth() / 2;
  app.fireEvent('pinPositionOffsetXReady', xOffset);
}}}, 0, ['pinpositiondialog'], ['component', 'box', 'container', 'pinpositiondialog'], {'component':true, 'box':true, 'container':true, 'pinpositiondialog':true}, ['widget.pinpositiondialog'], 0, [floorplanViewer.view, 'PinPositionDialog'], 0);
Ext.cmd.derive('floorplanViewer.view.PunchItemSummary', Ext.Component, {viewModel:{data:{}, mvRecords:{PunchItem:{idName:['PunchItemID', 'ProjectUID'], modelName:'clientPunchlist.model.PunchItem'}}}, bind:{data:'{PunchItem}'}, tpl:['\x3cdiv\x3e\x3cspan class\x3d"field-label"\x3emvstr[TL_Category]:\x3c/span\x3e {CategoryLabel}\x3c/div\x3e', '\x3cdiv\x3e\x3cspan class\x3d"field-label"\x3emvstr[TL_Description]:\x3c/span\x3e {Description}\x3c/div\x3e', '\x3cdiv\x3e\x3cspan class\x3d"field-label"\x3emvstr[TL_Assignees]:\x3c/span\x3e {AssigneeList}\x3c/div\x3e', 
'\x3cdiv\x3e\x3cspan class\x3d"field-label"\x3emvstr[TL_Item Status]:\x3c/span\x3e {PunchStatusLabel}\x3c/div\x3e', '\x3cdiv\x3e\x3cspan class\x3d"field-label"\x3emvstr[TL_Work Status]:\x3c/span\x3e {WorkStatusLabel}\x3c/div\x3e', '\x3cdiv\x3e\x3cspan class\x3d"field-label"\x3emvstr[TL_Due Date]:\x3c/span\x3e {DueDate:date(mvstr["DATE_Full"])}\x3c/div\x3e']}, 0, ['punchitemsummary'], ['component', 'box', 'punchitemsummary'], {'component':true, 'box':true, 'punchitemsummary':true}, ['widget.punchitemsummary'], 
0, [floorplanViewer.view, 'PunchItemSummary'], 0);
Ext.cmd.derive('floorplanViewer.view.punchlistLocation.PinWizardController', Ext.app.ViewController, {init:function() {
  this.control({clientFloorplanViewerDisp:{pinsave:function() {
    var viewModel = this.getViewModel(), floorplanView = this.getView().down('fvFloorplanViewer'), floorplanRecord = floorplanView.getFloorplanRecord().getData(), floorplanUID = floorplanRecord['FloorplanUID'], centrePoint = floorplanView.map.getBounds().getCenter(), view = this.getView();
    floorplanView.unsavedPinLayer.eachLayer(function(layers) {
      layers.eachLayer(function(marker) {
        if (marker.feature.id === floorplanView.getSelectedPushpin().pushpinID) {
          centrePoint = marker.getLatLng();
        }
      });
    });
    if (centrePoint.lng < floorplanRecord['imageWidth'] && centrePoint.lng > 0 && centrePoint.lat < floorplanRecord['imageHeight'] && centrePoint.lat > 0) {
      var loc = floorplanRecord.floorplanTitle.split(' - '), pin = Ext.create('mdsData.model.Pushpin', {PunchItemID:viewModel.get('PunchItem.PunchItemID'), FloorplanUID:floorplanUID, PushpinXCoordinate:centrePoint.lng, PushpinYCoordinate:centrePoint.lat, floorplanImage:(floorplanRecord.imageIntPath.replace('/int_', '/int_tile_') + '.png').replace('/.png', '.png'), LocationName:loc.length > 1 ? loc[1] : ''});
      var pins = this.getViewModel().get('pins');
      pins.add(pin);
      var success = function(data) {
        floorplanView.highlightLayer.clearLayers();
        floorplanView.setFloorplanViewerMode('view');
        view.fireEvent('updated');
        this.getViewModel().set('addingPin', false);
        view.unmask();
      };
      success.call(this);
    } else {
      Ext.Msg.alert('Outside range', 'You cannot move a pin outside the edges of the plan.');
    }
  }}});
}, loadPunchlistPlan:function(dataview, record) {
  this.getViewModel().set('pinsReady', false);
  this.getView().mask('Loading');
  var floorplanViewer = this.getView().down('fvFloorplanViewer');
  this.getView().setActiveItem(this.lookupReference('floorplanPage'));
  floorplanViewer.lookupViewModel().set('_recordfloorplan', null);
  floorplanViewer.lookupViewModel().set('FloorplanUID', null);
  floorplanViewer.lookupViewModel().notify();
  floorplanViewer.lookupViewModel().set('FloorplanUID', record.get('FloorplanUID'));
}, addPunchPin:function() {
  var data = this.getViewModel().get('PunchItem').getData();
  data.iconAnchor = mdsData.FloorplanValues.PUNCHPIN_ICON_ANCHOR;
  this.getView().down('fvFloorplanViewer').addNewPushpin(this.getViewModel().get('PunchItem').get('PushpinTypeID'), data);
  this.getViewModel().set('addingPin', true);
}, afterPinPositionCancel:function() {
  this.getViewModel().set('addingPin', false);
}, onPinsLoaded:function() {
  this.getViewModel().set('pinsReady', true);
  this.getView().unmask();
}}, 0, 0, 0, 0, ['controller.pinwizard'], 0, [floorplanViewer.view.punchlistLocation, 'PinWizardController'], 0);
Ext.cmd.derive('floorplanViewer.view.punchlistLocation.PinWizardModel', Ext.app.ViewModel, {data:{pinsReady:false, addingPin:false}, formulas:{canAddPin:function(get) {
  return get('pinsReady') && !get('addingPin');
}}}, 0, 0, 0, 0, ['viewmodel.pinwizard'], 0, [floorplanViewer.view.punchlistLocation, 'PinWizardModel'], 0);
Ext.cmd.derive('floorplanViewer.view.punchlistLocation.PinWizard', Ext.Container, {layout:'card', viewModel:{type:'pinwizard'}, controller:'pinwizard', initComponent:function() {
  var floorplanListPage = {xtype:'panel', layout:'fit', reference:'floorplanListPage', items:[{xtype:'floorplanoverview', padding:'0 10 0 15', bind:{store:'{punchplans}'}, noLink:true, scrollable:{x:false, y:true}, listeners:{'itemclick':'loadPunchlistPlan'}}]};
  if (this.showFPListBackButton) {
    floorplanListPage.bbar = {padding:'5 5 8 5', layout:{type:'hbox', pack:'start'}, items:[{xtype:'button', ui:'grey', scale:'medium', text:'Back', height:31, listeners:{click:{fn:function() {
      this.getView().up().lookupController().closePinWizard();
    }, scope:'controller'}}}]};
  }
  this.items = [floorplanListPage, {xtype:'panel', reference:'floorplanPage', layout:'fit', items:[{xtype:'plFloorPlan', reference:'floorplan', listeners:{pinsloaded:'onPinsLoaded', afterpinpositioncancel:'afterPinPositionCancel'}}, {xtype:'toolbar', reference:'maptoolsMenu', cls:'maptoolsMenu', floating:true, shadow:false, x:10, y:10, height:62, maxWidth:57, layout:'vbox', autoShow:true, items:[{localized:{text:'FV_Add pin'}, iconCls:'toolicon-pushpin', scale:'large', width:53, cls:'toolmenu-tool', 
  overCls:'toolmenu-tool-over', iconAlign:'top', listeners:{click:'addPunchPin'}, bind:{disabled:'{!canAddPin}'}}]}], bbar:{padding:'5 5 8 5', items:[{xtype:'button', scale:'medium', ui:'grey', height:31, localized:{text:'G_Back'}, listeners:{click:{fn:function() {
    this.getView().up().down('fvFloorplanViewer').lookupController().cancelPinPosition();
    this.getView().setActiveItem(this.lookupReference('floorplanListPage'));
  }, scope:'controller'}}}, '-\x3e', {xtype:'button', scale:'medium', localized:{text:'G_Done'}, ui:'green', height:31, listeners:{click:{fn:function() {
    this.getView().up().doneAddingPins();
  }, scope:'controller'}}}]}}];
  Ext.container.Container.prototype.initComponent.apply(this, arguments);
}}, 0, ['pinwizard'], ['component', 'box', 'container', 'pinwizard'], {'component':true, 'box':true, 'container':true, 'pinwizard':true}, ['widget.pinwizard'], 0, [floorplanViewer.view.punchlistLocation, 'PinWizard'], 0);
Ext.cmd.derive('floorplanViewer.view.PunchlistWindow', Ext.window.Window, {layout:{type:'fit'}, width:1000, height:600, modal:true, loadMaskCls:'light-load-indicator', viewModel:{data:{PunchItemID:''}, formulas:{listItemDesc:function(get) {
  return mvstr['TL_ListItemDesc_' + get('ListTypeID')] || mvstr['TL_ListItemDesc'];
}, addToExistingText:function(get) {
  var pinDescription = get('pinDescription');
  return pinDescription == 'Photo' ? mvstr['FVTL_Save to selected item'] : mvstr['FVTL_Attach pin to this it'];
}}}, initComponent:function() {
  var me = this;
  me.setBind({'title':mvstr['FVTL_Select {listItemDesc}']});
  me.items = [{xtype:'tabpanel', items:[{xtype:'panel', layout:'card', controller:'detailform', viewModel:{type:'punchitemdetail', data:{objectDescription:'item'}}, photos:this.photos, items:[{xtype:'punchitemdetails', reference:'punchItemDetails', padding:5, scrollable:{x:false, y:true}}, {xtype:'pinwizard', reference:'pinWizard', layout:'card', showFPListBackButton:true}], bind:{title:mvstr['FVTL_Add to new {listItemD']}, doneAddingPins:function() {
    this.setActiveItem(this.lookupController().lookupReference('punchItemDetails'));
  }}, {bind:{title:mvstr['FVTL_Add to existing {list']}, viewModel:{type:'punchlist', data:{PunchStatusID:0}}, controller:'punchlist', scrollable:{x:false, y:true}, layout:{type:'hbox', align:'stretchmax'}, items:[{xtype:'punchitemfilters', width:175}, {xtype:'grid', buffered:true, purgePageCount:0, flex:1, reference:'punchItemGrid', bind:{store:'{punchitems}'}, viewConfig:{enableTextSelection:true, markDirty:false}, columns:[{dataIndex:'CategoryLabel', localized:{text:'TL_Category'}, width:90}, 
  {dataIndex:'Description', localized:{text:'TL_Description'}, flex:1}, {dataIndex:'AssigneeList', localized:{text:'TL_Assignees'}, width:110}, {dataIndex:'WorkStatusLabel', localized:{text:'TL_Work Status'}, width:100}, {dataIndex:'DueDate', localized:{text:'TL_Due Date'}, width:80, xtype:'templatecolumn', tpl:'{DueDate:date("DATE_Medium2")}'}, {dataIndex:'PunchStatusLabel', localized:{text:'TL_Item Status'}, width:80}]}], fbar:[{xtype:'button', bind:{disabled:'{!punchItemGrid.selection}', text:'{addToExistingText}'}, 
  listeners:{click:'onAddPinToExistingClick'}}]}]}];
  Ext.window.Window.prototype.initComponent.apply(this, arguments);
  me.mon(Ext.getBody(), 'click', function(el, e) {
    me.close(me.closeAction);
  }, me, {delegate:'.x-mask'});
}}, 0, ['punchlistwindow'], ['component', 'box', 'container', 'panel', 'window', 'punchlistwindow'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true, 'punchlistwindow':true}, ['widget.punchlistwindow'], 0, [floorplanViewer.view, 'PunchlistWindow'], 0);
Ext.cmd.derive('floorplanViewer.view.pushpinFlyout.PinSelection', Ext.form.field.ComboBox, {viewModel:{stores:{pushpinTypes:{type:'pushpintypes'}}}, config:{width:245, height:22, fieldLabelSeparator:':', labelAlign:'left', labelWidth:50, valueField:'PushpinTypeID', displayField:'PushpinTypeName', queryMode:'local', editable:false}, bind:{store:'{pushpinTypes}', value:'{pushpin.PushpinType}'}, fieldSubTpl:['\x3cdiv id\x3d"{id}" data-ref\x3d"inputEl"  role\x3d"{role}"', '\x3ctpl if\x3d"fieldStyle"\x3e style\x3d"{fieldStyle}"\x3c/tpl\x3e ', 
'class\x3d"{fieldCls} {typeCls} {typeCls}-{ui} {editableCls}"\x3e', '\x3c/div\x3e'], setRawValue:function(value) {
  var me = this;
  value = value ? value : '';
  me.rawValue = value;
  if (me.inputEl) {
    me.inputEl.dom.innerHTML = value;
  }
  return value;
}, getRawValue:function() {
  if (!this.inputEl || !this.inputEl.dom || !this.inputEl.dom.lastChild) {
    return '';
  }
  return this.inputEl.dom.lastChild.innerHTML;
}, constructor:function(config) {
  var pinDisp = '\x3cimg src\x3d"{PushpinSymbol}"/\x3e\x3cspan\x3e{PushpinTypeName}\x3c/span\x3e';
  config.fieldLabel = mvstr['FV_Pin'];
  config.displayTpl = ['\x3ctpl for\x3d"."\x3e' + pinDisp + '\x3c/tpl\x3e'];
  config.listConfig = {tpl:Ext.create('Ext.XTemplate', '\x3cul class\x3d"x-list-plain"\x3e\x3ctpl for\x3d"."\x3e', '\x3cli role\x3d"option" class\x3d"x-boundlist-item"\x3e' + pinDisp + '\x3c/li\x3e', '\x3c/tpl\x3e\x3c/ul\x3e')};
  Ext.form.field.ComboBox.prototype.constructor.apply(this, arguments);
}, getValue:function() {
  var rawValue = this.getRawValue(), store = this.getStore(), index = store.find(this.getDisplayField(), rawValue);
  return index != -1 ? store.getAt(index).get(this.getValueField()) : undefined;
}}, 1, ['pinselection'], ['component', 'box', 'field', 'textfield', 'pickerfield', 'combobox', 'combo', 'pinselection'], {'component':true, 'box':true, 'field':true, 'textfield':true, 'pickerfield':true, 'combobox':true, 'combo':true, 'pinselection':true}, ['widget.pinselection'], 0, [floorplanViewer.view.pushpinFlyout, 'PinSelection'], 0);
Ext.cmd.derive('floorplanViewer.view.PushpinEdit', Ext.container.Container, {items:[{xtype:'container', layout:'hbox', padding:5, items:[{xtype:'textfield', itemId:'labelField', reference:'pushpinLabelField', localized:{fieldLabel:'FV_Label'}, allowBlank:false, grow:false, labelWidth:50, width:243}, {xtype:'shareWithButton', reference:'pushpinShareButton', itemId:'pushpinShareButton', fieldLabel:'Shared with', margins:'0 0 0 0', ownerUID:'newfolder'}], bind:{hidden:'{punchpinsEnabled}'}}, {xtype:'pinselection', 
margin:'0 0 0 5', bind:{hidden:'{punchpinsEnabled}'}}, {xtype:'container', margin:'10 0 0 0', layout:{align:'stretch', type:'hbox'}, items:[{xtype:'container', flex:1, layout:{align:'stretch', padding:5, type:'hbox'}, items:[{xtype:'button', localized:{text:'FV_Delete'}, icon:'mds/image/icon/delete.png', listeners:{click:'deletePushpin'}}, {xtype:'button', localized:{text:'FV_Move'}, icon:'mds/image/icon/move.png', listeners:{click:'movePushpin'}}]}, {xtype:'container', flex:1, padding:0, layout:{align:'stretch', 
pack:'end', padding:5, type:'hbox'}, items:[{xtype:'button', localized:{text:'G_Cancel'}, icon:'mds/image/icon/cancel.png', listeners:{click:'cancelPushpin'}}, {xtype:'button', localized:{text:'G_Save'}, icon:'mds/image/icon/disk_blue.png', bind:{hidden:'{punchpinsEnabled}'}, listeners:{click:'savePushpin'}}]}]}]}, 0, ['fvPushpinEdit'], ['component', 'box', 'container', 'fvPushpinEdit'], {'component':true, 'box':true, 'container':true, 'fvPushpinEdit':true}, ['widget.fvPushpinEdit'], 0, [floorplanViewer.view, 
'PushpinEdit'], 0);
Ext.cmd.derive('floorplanViewer.view.PushpinMenu', Ext.Container, {cls:'flyout-menu-wrap', floating:true, shrinkWrap:3, hidden:true, defaultType:'button', defaults:{width:200, scale:'medium', textAlign:'left', listeners:{click:{fn:function(e) {
  this.up('pushpinmenu').hide();
}}}}, renderTo:Ext.getBody(), x:69, y:315, layout:'vbox', padding:2, items:[{localized:{text:'FV_North Arrow'}, iconCls:'pinicon-northpin', itemCls:'toolmenu-item', overCls:'toolmenu-item-over', listeners:{click:function() {
  this.lookupController().addPushPin(5);
  this.up('pushpinmenu').hide();
}}}, {localized:{text:'FV_East Arrow'}, iconCls:'pinicon-eastpin', itemCls:'toolmenu-item', overCls:'toolmenu-item-over', listeners:{click:function() {
  this.lookupController().addPushPin(6);
  this.up('pushpinmenu').hide();
}}}, {localized:{text:'FV_South Arrow'}, iconCls:'pinicon-southpin', itemCls:'toolmenu-item', overCls:'toolmenu-item-over', listeners:{click:function() {
  this.lookupController().addPushPin(7);
  this.up('pushpinmenu').hide();
}}}, {localized:{text:'FV_West Arrow'}, iconCls:'pinicon-westpin', itemCls:'toolmenu-item', overCls:'toolmenu-item-over', listeners:{click:function() {
  this.lookupController().addPushPin(8);
  this.up('pushpinmenu').hide();
}}}]}, 0, ['pushpinmenu'], ['component', 'box', 'container', 'pushpinmenu'], {'component':true, 'box':true, 'container':true, 'pushpinmenu':true}, ['widget.pushpinmenu'], 0, [floorplanViewer.view, 'PushpinMenu'], 0);
Ext.cmd.derive('floorplanViewer.view.files.BaseViewer', Ext.panel.Panel, {}, 0, 0, ['component', 'box', 'container', 'panel'], {'component':true, 'box':true, 'container':true, 'panel':true}, 0, 0, [floorplanViewer.view.files, 'BaseViewer'], 0);
Ext.cmd.derive('floorplanViewer.view.files.FileList', Ext.view.View, {border:true, padding:0, cls:'documentList', itemSelector:'.document', bind:{store:'{files}'}, tpl:['\x3ctpl for\x3d"."\x3e', '\x3cdiv class\x3d"document fileviewer-item"\x3e', '\x3cdiv class\x3d"photoRight"\x3e', '\x3cdiv class\x3d"fileListRemoveButton"\x3e', '\x3cbutton type\x3dbutton id\x3d"{DocumentUID}" class\x3d"remove-button"\x3ex\x3c/button\x3e', '\x3c/div\x3e', '\x3cimg class\x3d"documentSymbol" src\x3d"{DocumentSymbol}"\x3e', 
'\x3c/div\x3e', '\x3cdiv class\x3d"photoLeft"\x3e', '\x3cdiv class\x3d"desc-line-1"\x3e{DocumentFilename}\x3c/div\x3e', '\x3cdiv class\x3d"desc-line-2"\x3e{DocumentCreatorName}\x3c/div\x3e', '\x3cdiv class\x3d"photoLeftFooter"\x3e', '\x3cspan class\x3d"photoSize"\x3e{DocumentFileSize:fileSize}\x3c/span\x3e', '\x3cspan class\x3d"desc-line-3"\x3e{DocumentLastEditedDate:date("M d Y")}\x3c/span\x3e', '\x3c/div\x3e', '\x3c/div\x3e', '\x3cdiv class\x3d"x-clear"\x3e\x3c/div\x3e', '\x3c/div\x3e', '\x3c/tpl\x3e'], 
getMaskTarget:function() {
  return this.up().el;
}}, 0, ['filelist'], ['component', 'box', 'dataview', 'filelist'], {'component':true, 'box':true, 'dataview':true, 'filelist':true}, ['widget.filelist'], 0, [floorplanViewer.view.files, 'FileList'], 0);
Ext.cmd.derive('floorplanViewer.view.files.FolderFileList', Ext.view.View, {border:true, padding:0, cls:'documentList', itemSelector:'.document', bind:{store:'{folderFiles}'}, tpl:['\x3ctpl for\x3d"."\x3e', '\x3cdiv class\x3d"document fileviewer-item"\x3e', '\x3cdiv class\x3d"photoRight"\x3e', '\x3cimg class\x3d"documentSymbol" src\x3d"{DocumentSymbol}"\x3e', '\x3c/div\x3e', '\x3cdiv class\x3d"photoLeft"\x3e', '\x3cdiv class\x3d"desc-line-1"\x3e{DocumentFilename}\x3c/div\x3e', '\x3cdiv class\x3d"desc-line-2"\x3e{DocumentCreatorName}\x3c/div\x3e', 
'\x3cdiv class\x3d"photoLeftFooter"\x3e', '\x3cspan class\x3d"photoSize"\x3e{DocumentFileSize:fileSize}\x3c/span\x3e', '\x3cspan class\x3d"desc-line-3"\x3e{DocumentLastEditedDate:date("M d Y")}\x3c/span\x3e', '\x3c/div\x3e', '\x3c/div\x3e', '\x3cdiv class\x3d"x-clear"\x3e\x3c/div\x3e', '\x3c/div\x3e', '\x3c/tpl\x3e'], getMaskTarget:function() {
  return this.up().el;
}}, 0, ['folderfilelist'], ['component', 'box', 'dataview', 'folderfilelist'], {'component':true, 'box':true, 'dataview':true, 'folderfilelist':true}, ['widget.folderfilelist'], 0, [floorplanViewer.view.files, 'FolderFileList'], 0);
Ext.cmd.derive('floorplanViewer.view.files.fileViewer.FileNavModel', Ext.app.ViewModel, {data:{folderNameStack:[]}, formulas:{folderTrail:function(get) {
  var folderTrail = '', folderNameStack = get('folderNameStack');
  for (var i = 0; i <= folderNameStack.length - 1; i++) {
    if (i === folderNameStack.length - 1) {
      folderTrail += '\x3cb\x3e' + folderNameStack[i] + '\x3cb\x3e';
    } else {
      folderTrail += folderNameStack[i] + '/';
    }
  }
  return folderTrail;
}, upButtonVisible:function(get) {
  var nameStack = get('folderNameStack');
  return nameStack && nameStack.length ? true : false;
}}}, 0, 0, 0, 0, ['viewmodel.filenav'], 0, [floorplanViewer.view.files.fileViewer, 'FileNavModel'], 0);
Ext.cmd.derive('floorplanViewer.view.files.fileViewer.FileViewerModel', floorplanViewer.view.files.fileViewer.FileNavModel, {stores:{projectFiles:{type:'files', proxy:{api:{read:'/index.cfm?fuseaction\x3daClientFileManager.getProjectFilesLite'}}, listeners:{load:'onProjectFilesStoreLoad', beforeload:'beforeProjectFilesStoreLoad'}}, folderFiles:{type:'files', proxy:{api:{read:'/index.cfm?fuseaction\x3daClientFileManager.getProjectFilesLite'}, extraParams:{ProjectUID:'{ProjectUID}'}}, listeners:{load:'onFolderFilesStoreLoad', 
beforeload:'beforeFolderFilesStoreLoad'}}}, data:{nFiles:0, itemDesc:'file', itemDescPlural:'files'}}, 0, 0, 0, 0, ['viewmodel.fileviewer'], 0, [floorplanViewer.view.files.fileViewer, 'FileViewerModel'], 0);
Ext.cmd.derive('floorplanViewer.view.files.PhotoDialogTree', Ext.tree.Panel, {rootVisible:false, useArrows:true, frame:false, border:false, hideHeaders:true, cls:'no-leaf-icons no-parent-icons sideNavPanel', bind:{store:'{projectPhotoCategories}'}, listeners:{viewready:{fn:'onPhotoDialogTreeReady', delay:1}, select:'onPhotoCategorySelect'}}, 0, ['pushpinDialogTree'], ['component', 'box', 'container', 'panel', 'tablepanel', 'treepanel', 'pushpinDialogTree'], {'component':true, 'box':true, 'container':true, 
'panel':true, 'tablepanel':true, 'treepanel':true, 'pushpinDialogTree':true}, ['widget.pushpinDialogTree'], 0, [floorplanViewer.view.files, 'PhotoDialogTree'], 0);
Ext.cmd.derive('floorplanViewer.view.files.PhotoDialogDataView', Ext.grid.Panel, {id:'pushpinDialogDataView', viewConfig:{emptyText:'No Photos', deferEmptyText:false, style:{'text-align':'center'}}, selModel:{selType:'checkboxmodel', mode:'SIMPLE', injectCheckbox:'last', allowDeselect:true}, columns:[{localized:{text:'FVCPD_Image'}, width:136, dataIndex:'ImageURLThumb', renderer:function(value) {
  return '\x3cimg src\x3d"' + value + '"/\x3e';
}}, {localized:{text:'FVCPD_File Name'}, flex:1, dataIndex:'FileName'}, {localized:{text:'FVCPD_Created By'}, width:136, dataIndex:'CreatorName'}, {localized:{text:'FVCPD_Photo Date'}, width:134, dataIndex:'PhotoDate', renderer:function(value) {
  return Ext.Date.format(value, mvstr['DATE_Medium'] + ' - g:i a');
}}]}, 0, ['pushpinDialogDataView'], ['component', 'box', 'container', 'panel', 'tablepanel', 'gridpanel', 'grid', 'pushpinDialogDataView'], {'component':true, 'box':true, 'container':true, 'panel':true, 'tablepanel':true, 'gridpanel':true, 'grid':true, 'pushpinDialogDataView':true}, ['widget.pushpinDialogDataView'], 0, [floorplanViewer.view.files, 'PhotoDialogDataView'], 0);
Ext.cmd.derive('floorplanViewer.view.files.ChoosePhotoFBar', Ext.toolbar.Toolbar, {padding:10, initComponent:function() {
  var addPhotosButtonConf = this.addPhotosButtonConf || {}, backButtonConf = this.backButtonConf || {};
  this.items = [{xtype:'container', layout:{type:'hbox'}, flex:1, items:[Ext.merge({xtype:'button', ui:'grey', text:mvstr['G_Back'], height:31, scale:'medium', hideMode:'visibility', hidden:true}, backButtonConf)]}, {xtype:'container', layout:{type:'hbox', pack:'end'}, flex:1, items:[Ext.merge({xtype:'button', ui:'green', text:mvstr['G_Done'], height:31, scale:'medium', hideMode:'visibility'}, addPhotosButtonConf)]}];
  Ext.toolbar.Toolbar.prototype.initComponent.apply(this, arguments);
}}, 0, ['choosephotofbar'], ['component', 'box', 'container', 'toolbar', 'choosephotofbar'], {'component':true, 'box':true, 'container':true, 'toolbar':true, 'choosephotofbar':true}, ['widget.choosephotofbar'], 0, [floorplanViewer.view.files, 'ChoosePhotoFBar'], 0);
Ext.cmd.derive('floorplanViewer.view.files.ChoosePhotoWindow', Ext.window.Window, {localized:{title:'FVCPD_Choose Photo'}, modal:true, uploadConfig:{}, resizable:true, layout:'fit', height:700, width:1050, canChooseMultivistaPhotos:false, renderTo:Ext.getBody(), initComponent:function() {
  var me = this;
  var items = [{xtype:'uploadPanel', id:'choosePhotoUpload', localized:{title:'FVCPD_Upload New Photo'}, style:'background-color: white', uploadConfig:Ext.apply({}, me.uploadConfig, {localized:{uploadMessage:'FVCPDU_Drop photos here or c', addFilesLabel:'FVCPDU_Add Photo'}}), fbar:{xtype:'choosephotofbar', addPhotosButtonConf:{listeners:{click:function(button) {
    var store = Ext.getStore('pushPinFlyOutDialogPhotosStore');
    store.load();
    var photoFileListView = Ext.ComponentQuery.query('photofilelist');
    photoFileListView.refresh;
    button.up('window').destroy();
  }}}}}, {xtype:'panel', itemId:'chooseProjectPhotos', localized:{title:'FVCPD_Choose From Project T'}, requires:['Ext.panel.Panel', 'Ext.resizer.Splitter'], layout:'border', items:[{xtype:'pushpinDialogTree', width:196, style:'background-color: white', autoScroll:true, region:'west', split:true}, {xtype:'pushpinDialogDataView', itemId:'pushpinDialogDataView', reference:'projectFileGrid', flex:1, region:'center', bind:{store:'{projectPhotos}'}}], fbar:{xtype:'choosephotofbar', addPhotosButtonConf:{itemId:'addSelectedFiles', 
  hidden:false, bind:{disabled:'{!projectFileGrid.selection}'}}}}];
  if (this.canChooseMultivistaPhotos) {
    items.push({xtype:'multivistaphoto', localized:{title:'FVCPD_Choose A Multivista P'}});
  }
  Ext.applyIf(me, {items:[{xtype:'tabpanel', activeTab:0, items:items}]});
  Ext.window.Window.prototype.initComponent.apply(this, arguments);
}}, 0, ['choosePhotoWindow'], ['component', 'box', 'container', 'panel', 'window', 'choosePhotoWindow'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true, 'choosePhotoWindow':true}, ['widget.choosePhotoWindow'], 0, [floorplanViewer.view.files, 'ChoosePhotoWindow'], 0);
Ext.cmd.derive('floorplanViewer.view.files.ProjectFileList', Ext.grid.Panel, {bind:{store:'{projectFiles}'}, sortOnLoad:true, rowLines:true, selModel:{selType:'checkboxmodel', mode:'SIMPLE', injectCheckbox:'last', allowDeselect:true}, viewConfig:{loadMask:true}, listeners:{cellclick:function(view, cell, cellIndex, record, row, rowIndex, e) {
  var linkClicked = e.getTarget(null, 1, true).hasCls('x-file-icon') || e.getTarget(null, 1, true).hasCls('x-file-name');
  if (linkClicked) {
    this.getSelectionModel().deselectAll();
    this.fireEvent('fileclicked', view, record);
  }
}, selectionChange:function(grid, selection, opts) {
  var btn = this.down('#addSelectedFiles');
  btn.setDisabled(selection.length == 0);
}}, columns:[{text:'', width:40, sortable:false, hideable:false, menuDisabled:true, renderer:function(value) {
  return '\x3cimg class\x3d"x-file-icon" src\x3d"' + value + '"\x3e';
}, dataIndex:'DocumentSymbol'}, {localized:{text:'FVCFD_File Name'}, dataIndex:'DocumentFilename', flex:1, renderer:function(value) {
  return '\x3ca class\x3d"x-file-name"\x3e' + value + '\x3c/a\x3e';
}}, {localized:{text:'FVCFD_Updated date'}, dataIndex:'DocumentLastEditedDate', xtype:'datecolumn', width:180, renderer:function(value) {
  return Ext.Date.format(value, mvstr['DATE_Medium'] + ' - g:i a');
}}, {localized:{text:'FVCFD_Created by'}, dataIndex:'DocumentCreatorName', width:120}, {localized:{text:'FVCFD_File type'}, dataIndex:'DocumentTypeName'}, {localized:{text:'FVCFD_Size'}, dataIndex:'DocumentFileSize', renderer:Ext.util.Format.fileSize}], initComponent:function() {
  var me = this;
  Ext.grid.Panel.prototype.initComponent.apply(this, arguments);
}}, 0, ['projectfilegrid'], ['component', 'box', 'container', 'panel', 'tablepanel', 'gridpanel', 'grid', 'projectfilegrid'], {'component':true, 'box':true, 'container':true, 'panel':true, 'tablepanel':true, 'gridpanel':true, 'grid':true, 'projectfilegrid':true}, ['widget.projectfilegrid'], 0, [floorplanViewer.view.files, 'ProjectFileList'], 0);
Ext.cmd.derive('floorplanViewer.view.files.FileNavToolbar', Ext.toolbar.Toolbar, {items:[{xtype:'tbtext', padding:10, style:{backgroundColor:'#eeeeee'}, bind:{text:'{folderTrail}'}}]}, 0, ['filenavtoolbar'], ['component', 'box', 'container', 'toolbar', 'filenavtoolbar'], {'component':true, 'box':true, 'container':true, 'toolbar':true, 'filenavtoolbar':true}, ['widget.filenavtoolbar'], 0, [floorplanViewer.view.files, 'FileNavToolbar'], 0);
Ext.cmd.derive('floorplanViewer.view.files.ChooseFileWindow', Ext.window.Window, {localized:{title:'FVCFD_Choose File'}, modal:true, uploadConfig:{}, resizable:true, layout:'fit', height:500, width:820, renderTo:Ext.getBody(), initComponent:function() {
  var me = this;
  Ext.applyIf(me, {items:[{xtype:'tabpanel', activeTab:0, items:[{xtype:'uploadPanel', id:'chooseFileUpload', localized:{title:'FVCFD_Upload new file'}, uploadConfig:me.uploadConfig}, {xtype:'panel', localized:{title:'FVCFD_Choose from project f'}, itemId:'projectListPanel', layout:'fit', viewModel:{type:'filenav'}, tbar:{xtype:'filenavtoolbar'}, items:[{xtype:'projectfilegrid', reference:'projectFileGrid', style:'background-color: white', dock:'bottom', bbar:[{xtype:'button', ui:'grey', height:31, 
  width:60, margin:'5 5 8 5', scale:'medium', localized:{text:'G_Back'}, itemId:'folderUp', hidden:true, bind:{hidden:'{!upButtonVisible}'}}, '-\x3e', {xtype:'button', itemId:'addSelectedFiles', ui:'green', height:31, width:60, margin:'5 5 8 5', scale:'medium', localized:{text:'G_Done'}, bind:{disabled:'{!projectFileGrid.selection}'}}]}]}]}]});
  Ext.window.Window.prototype.initComponent.apply(this, arguments);
}, destroy:function() {
  1;
  Ext.window.Window.prototype.destroy.apply(this, arguments);
}}, 0, ['chooseFileWindow'], ['component', 'box', 'container', 'panel', 'window', 'chooseFileWindow'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true, 'chooseFileWindow':true}, ['widget.chooseFileWindow'], 0, [floorplanViewer.view.files, 'ChooseFileWindow'], 0);
Ext.cmd.derive('floorplanViewer.view.files.fileViewer.FileViewerController', Ext.app.ViewController, {init:function() {
  this.drilling = false;
  this.pushpinFolderStack = [];
  this.folderStack = [];
  this.photoStores = [];
  this.control({'#chooseFileWindow':{close:this.onChooseFileWindowClose}, '#chooseFileWindow #projectListPanel':{activate:this.onProjectListPanelActivate}, '#chooseFileWindow #addSelectedFiles':{click:this.onAddSelectedFilesClick}, '#chooseFileWindow #folderUp':{click:this.onProjectFilesFolderUp}, 'projectfilegrid':{fileclicked:this.openProjectFolder}, '#fileViewerNavToolbar #folderUp':{click:'onFolderUpClick'}, '#chooseFileUpload':{addUploadFormData:this.addUploadFormData, fileUploadedAndAccepted:this.onFileUploadedAndAccepted}, 
  '#choosePhotoUpload':{addUploadFormData:this.addUploadFormData, fileUploadedAndAccepted:this.onFileUploadedAndAccepted}});
  Ext.defer(this.addStoreListeners, 1, this);
}, getRootFileStore:function() {
  var viewModel = this.getViewModel(), storeName = viewModel.get('itemDescPlural');
  while (viewModel && viewModel.getParent()) {
    var store = viewModel.getParent().getStore(storeName);
    if (store) {
      return store;
    }
    viewModel = viewModel.getParent();
  }
  return null;
}, addStoreListeners:function() {
  if (!this.getView()) {
    return;
  }
  var fileStore = this.getRootFileStore();
  if (!fileStore) {
    return;
  }
  fileStore.addListener('beforeload', this.beforeFilesStoreLoad, this);
  fileStore.addListener('datachanged', this.onFilesStoreDataChanged, this);
}, onFilesStoreDataChanged:function(store) {
  this.getViewModel().set('nFiles', store.getCount());
}, beforeFilesStoreLoad:function() {
  this.drilling = false;
  this.drillParent = 0;
  var folderFileList = this.lookupReference('folderFileList');
  if (folderFileList) {
    folderFileList.hide();
    this.lookupReference('fileList').show();
    this.getViewModel().set('folderNameStack', []);
  }
}, getRootZipURL:function() {
  var viewModel = this.getViewModel(), PushpinUID = viewModel.get('PushpinUID'), ProjectUID = viewModel.get('ProjectUID'), PunchItemID = viewModel.get('PunchItemID'), itemDesc = Ext.String.capitalize(viewModel.get('itemDescPlural')), url = '/index.cfm?fuseaction\x3d';
  if (PunchItemID) {
    url += 'aClientPunchlist.zipPunchItem' + itemDesc + '\x26PunchItemID\x3d' + PunchItemID;
  } else {
    url += 'aClientFloorplanViewer.zipPushpin' + itemDesc + '\x26PushpinID\x3d' + PushpinUID;
  }
  return url + '\x26ProjectUID\x3d' + ProjectUID;
}, onZipFilesClick:function() {
  var viewModel = this.getViewModel(), fileStore = this.getRootFileStore(), itemDesc = viewModel.get('itemDescPlural');
  if (fileStore.getCount()) {
    Ext.MessageBox.alert('Preparing ' + itemDesc + '...', 'The selected ' + itemDesc + ' are being zipped up, and your download will begin automatically when finished.');
    var zipURL = '';
    if (!this.drilling) {
      zipURL = mdslink.server + this.getRootZipURL();
    } else {
      var documentUID = this.pushpinFolderStack[this.pushpinFolderStack.length - 1];
      zipURL = mdslink.server + '/index.cfm?fuseaction\x3daClientFloorplanViewer.zipFolderFiles\x26ProjectUID\x3d' + ProjectUID + '\x26Documents\x3d' + documentUID;
    }
    window.location = zipURL;
  } else {
    Ext.MessageBox.alert('No ' + itemDesc + ' found', 'No ' + itemDesc + ' are currently attached to this marker.');
  }
}, onZipSingleItemSelected:function(selectedPhoto) {
  var viewModel = this.getViewModel(), fileStore = this.getRootFileStore(), itemDesc = viewModel.get('itemDescPlural');
  if (fileStore.getCount()) {
    Ext.MessageBox.alert('Preparing ' + itemDesc + '...', 'The selected ' + itemDesc + ' are being zipped up, and your download will begin automatically when finished.');
    var zipURL = '';
    if (!this.drilling) {
      zipURL = mdslink.server + this.getRootZipURL() + '\x26PhotoUID\x3d' + selectedPhoto;
    } else {
      var documentUID = this.pushpinFolderStack[this.pushpinFolderStack.length - 1];
      zipURL = mdslink.server + '/index.cfm?fuseaction\x3daClientFloorplanViewer.zipFolderFiles\x26ProjectUID\x3d' + ProjectUID + '\x26Documents\x3d' + documentUID;
    }
    window.location = zipURL;
  } else {
    Ext.MessageBox.alert('No ' + itemDesc + ' found', 'No ' + itemDesc + ' are currently attached to this marker.');
  }
}, openFileUpload:function() {
  var viewModel = this.getViewModel(), itemDesc = viewModel.get('itemDesc');
  multiupload.Panel.doUploaderCheck(function() {
    var fileWindow = this.getView().add({xtype:'choose' + Ext.String.capitalize(itemDesc) + 'Window', uploadConfig:{fileFilters:floorplanViewer.FilesValues.FILTERS[itemDesc], uploadUrl:'/index.cfm?fuseaction\x3daClientFloorplanViewer.uploadFile', acceptedFiles:floorplanViewer.FilesValues.ACCEPTED_FILES[itemDesc], dropzoneUploadUrl:mdslink.server + '/index.cfm?fuseaction\x3daClientFloorplanViewer.uploadAndAcceptFile', maxFileSize:floorplanViewer.FilesValues.MAX_FILE_SIZE[itemDesc], maxQueueLength:20}, 
    canChooseMultivistaPhotos:!!(viewModel.get('PunchItem') || viewModel.get('PunchItemID')), reference:'chooseFileWindow', itemId:'chooseFileWindow'});
    fileWindow.showBy(this.getView().up('clientviewport'), 'c-c?');
  }, this);
}, onFolderFilesStoreLoad:function(store) {
  if (this.pushpinFolderStack[this.pushpinFolderStack.length - 1] != store.getProxy().extraParams.parentFolderID) {
    this.pushpinFolderStack.push(store.getProxy().extraParams.parentFolderID);
  }
  this.getViewModel().set('nFiles', store.getCount());
}, beforeFolderFilesStoreLoad:function(store) {
  this.lookupReference('folderFileList').show();
  this.lookupReference('fileList').hide();
  if (typeof store.getProxy().extraParams.parentFolderID === 'undefined') {
    store.getProxy().setExtraParam('parentFolderID', 0);
  }
}, onFileItemClick:function(view, record, h, ind, evt) {
  var me = this;
  var fly = Ext.fly(evt.getTarget());
  var viewModel = me.getViewModel(), itemDesc = viewModel.get('itemDesc'), longDesc = itemDesc == 'file' ? 'file/folder' : itemDesc, location = itemDesc == 'file' ? 'file repository' : 'project', doDelete = Ext.bind(function() {
    me.getRootFileStore().remove(record);
    me.doRemoveSync();
  }, me);
  if (fly.hasCls('remove-button')) {
    if (me.checkSave()) {
      Ext.Msg.confirm('Confirm', 'Are you sure you want to remove this ' + longDesc + ' from the ' + viewModel.get('objectDescription') + '?' + (itemDesc == 'file' ? ' \x3cbr\x3e(The file will remain in your ' + location + ')' : ''), Ext.bind(function(btn) {
        if (btn == 'yes') {
          doDelete();
        }
      }, me));
    } else {
      doDelete();
    }
    return false;
  } else {
    if (fly.hasCls('download-button')) {
      var selectedPhoto = record.get('UDEFPhotoUID');
      me.onZipSingleItemSelected(selectedPhoto);
      return false;
    } else {
      if (fly.hasCls('dotted-menu')) {
        evt.stopEvent();
        var menu = Ext.create('Ext.menu.Menu', {bodyStyle:'backgroundColor: #ffffff; padding: 0px;', showSeparator:false, floating:true, width:'70px', items:[{text:'download', plain:true, style:{'text-align':'left', 'line-height':'24px', 'padding':'0px 5px 0px 5px', 'background-image':'none'}, cls:'menu-item', handler:function() {
          var selectedPhoto = record.get('UDEFPhotoUID');
          me.onZipSingleItemSelected(selectedPhoto);
        }}, {text:'delete', plain:true, style:{'text-align':'left', 'line-height':'24px', 'padding':'0px 5px 0px 5px', 'margin-bottom':'0px', 'background-image':'none'}, cls:'menu-item', handler:function() {
          if (me.checkSave()) {
            Ext.Msg.confirm('Confirm', 'Are you sure you want to remove this ' + longDesc + ' from the ' + viewModel.get('objectDescription') + '?' + (itemDesc == 'file' ? ' \x3cbr\x3e(The file will remain in your ' + location + ')' : ''), Ext.bind(function(btn) {
              if (btn == 'yes') {
                doDelete();
              }
            }, me));
          } else {
            doDelete();
          }
        }}]});
        menu.showBy(fly, 'tr-br', [-8, -6]);
        return false;
      }
    }
  }
  me.chooseFile(record, true);
}, onFolderFileItemClick:function(view, record) {
  this.chooseFile(record, false);
}, onChooseFileWindowClose:function() {
  for (var i = 0; i < this.photoStores.length; i++) {
    this.photoStores[i].destroy();
  }
  this.photoStores = [];
}, onProjectFilesStoreLoad:function(store) {
  this.folderStack.push(store.getProxy().extraParams.parentFolderID);
}, beforeProjectFilesStoreLoad:function(store) {
  if (typeof store.getProxy().extraParams.parentFolderID === 'undefined') {
    store.getProxy().setExtraParam('parentFolderID', 0);
  }
}, storeHasParams:function() {
  var store = this.getRootFileStore(), params = store.getProxy().getExtraParams();
  for (var key in params) {
    if (params[key] === '') {
      return false;
    }
  }
  return true;
}, checkSave:function() {
  return this.getRootFileStore().allowAutoSave !== false && this.storeHasParams();
}, onAddSelectedFilesClick:function(button) {
  this.addSelectedFiles(this.lookupReference('projectFileGrid').getSelectionModel().getSelection());
  var store = Ext.getStore('pushPinFlyOutDialogPhotosStore');
  if (store) {
    store.load();
  }
  button.up('window').destroy();
}, addSelectedFiles:function(selection) {
  var store = this.getRootFileStore(), copies = [];
  for (var i = 0; i < selection.length; i++) {
    if (store.getById(selection[i].getId())) {
      continue;
    }
    var copy = selection[i].copy();
    copy.phantom = true;
    copies.push(copy);
  }
  if (!copies.length) {
    return;
  }
  store.add(copies);
  this.doAddSync(selection.length);
}, doAddSync:function(count) {
  this.doSync(count, 'add');
}, doRemoveSync:function(count) {
  this.doSync(count, 'remove');
}, doSync:function(count, actionDesc) {
  if (!this.checkSave()) {
    return;
  }
  var store = this.getRootFileStore(), view = this.getView(), viewModel = this.getViewModel(), itemDesc = Ext.String.capitalize(count == 1 ? viewModel.get('itemDesc') : viewModel.get('itemDescPlural'));
  view.mask('Saving ...');
  store.sync({failure:function() {
    view.unmask();
    store.rejectChanges();
    var msg = store.getProxy().getReader().mvMessage;
    if (!msg) {
      msg = mvstr.G_UnexpectedError + ' Unable to ' + actionDesc + ' ' + itemDesc.toLowerCase();
    }
    Ext.Msg.alert('Error', msg);
  }, success:function() {
    view.unmask();
  }, scope:this});
}, onProjectFilesFolderUp:function(button) {
  this.goUpAFolder(this.getViewModel().get('projectFiles'), this.folderStack, button.lookupViewModel());
}, onFolderUpClick:function() {
  var viewModel = this.getViewModel(), projectUID = viewModel.get('ProjectUID');
  if (this.pushpinFolderStack[this.pushpinFolderStack.length - 1] === this.drillParent) {
    var fileStore = viewModel.get('files');
    fileStore.getProxy().setExtraParam('ProjectUID', projectUID);
    fileStore.load();
  } else {
    if (this.drilling) {
      this.goUpAFolder(viewModel.get('folderFiles'), this.pushpinFolderStack, viewModel);
    }
  }
}, goUpAFolder:function(fileStore, folderStack, folderNameViewModel) {
  folderStack.pop();
  folderNameViewModel.doArrayPop('folderNameStack');
  this.loadFolder(fileStore, folderStack.pop());
}, chooseFile:function(record, doSetDrilling) {
  var viewModel = this.getViewModel(), projectUID = viewModel.get('ProjectUID');
  if (!record.get('DocumentUID')) {
    var pushpinUID = viewModel.get('PushpinUID'), punchItemID = viewModel.get('PunchItemID'), listTypeID = viewModel.get('ListTypeID');
    if (pushpinUID) {
      if (viewModel.get('account.features.photoviewerVisible')) {
        app.getMainView().add({xtype:'photoviewer', photoId:record.get('id'), ListTypeID:listTypeID, photoGroup:Ext.create('floorplanViewer.model.PhotoGroup', {'Identifier':pushpinUID, 'Type':'N'})}).show();
      } else {
        var location = mdslink.clientPhotoViewer + 'ProjectUID\x3d' + projectUID + '\x26PhotoGroupType\x3dP\x26PushpinUID\x3d' + pushpinUID;
        if (punchItemID) {
          location += '\x26PunchItemID\x3d' + punchItemID;
        }
        if (listTypeID) {
          location += '\x26ListTypeID\x3d' + listTypeID;
        }
        location += '#SelectedPhotoID\x3d' + record.get('UDEFPhotoID');
        window.location = location;
      }
      return;
    }
    var store = this.getRootFileStore(), count = store.getCount(), PhotoList = [], UDEFPhotoList = [], WebcamPhotoList = [];
    for (var i = 0; i < count; i++) {
      var photo = store.getAt(i), UDEFPhotoUID = photo.get('UDEFPhotoUID');
      var type = photo.get('Type'), identifier = photo.get('Identifier');
      if (type == 'P') {
        PhotoList.push(identifier);
      } else {
        if (type == 'W') {
          WebcamPhotoList.push(identifier);
        } else {
          UDEFPhotoList.push(UDEFPhotoUID);
        }
      }
    }
    if (this.storeHasParams()) {
      if (viewModel.get('account.features.photoviewerVisible')) {
        app.getMainView().add({xtype:'photoviewer', photoId:record.get('id'), ListTypeID:listTypeID, photoGroup:Ext.create('floorplanViewer.model.PhotoGroup', {'Identifier':punchItemID, 'Type':'Q'})}).show();
      } else {
        window.location = mdslink.clientPhotoViewer + 'ProjectUID\x3d' + projectUID + '\x26PhotoGroupType\x3dQ\x26PunchItemID\x3d' + punchItemID + (listTypeID ? '\x26ListTypeID\x3d' + listTypeID : '');
      }
    }
    return;
  }
  if (record.get('DocumentMimeType') === 'folder') {
    viewModel.doArrayPush('folderNameStack', record.get('DocumentFilename'));
    if (doSetDrilling) {
      this.pushpinFolderStack = [];
      this.drilling = true;
      this.drillParent = record.get('DocumentUID');
      var view = this.getView();
      if (!view.getScrollable()) {
        view.setHeight(view.el.getHeight());
        view.setScrollable(true);
      }
    }
    this.loadFolder(viewModel.get('folderFiles'), record.get('DocumentUID'));
  } else {
    if (this.storeHasParams()) {
      if (!config.ISARCHIVE) {
        window.location = mdslink.server + '/index.cfm' + record.get('DocumentURL');
      } else {
        window.location = mdslink.clientFileManager + 'ProjectUID\x3d' + projectUID;
      }
    }
  }
}, onProjectListPanelActivate:function() {
  this.loadFolder(this.getViewModel().get('projectFiles'), 0);
}, openProjectFolder:function(view, record) {
  if (record.get('DocumentMimeType') === 'folder') {
    view.lookupViewModel().doArrayPush('folderNameStack', record.get('DocumentFilename'));
    this.loadFolder(this.getViewModel().get('projectFiles'), record.get('DocumentUID'));
  }
}, loadFolder:function(fileStore, parentFolderID) {
  fileStore.getProxy().setExtraParam('ProjectUID', this.getViewModel().get('ProjectUID'));
  fileStore.getProxy().setExtraParam('parentFolderID', parentFolderID);
  fileStore.removeAll();
  fileStore.load();
}, addUploadFormData:function(formData) {
  var viewModel = this.getViewModel(), projectUID = viewModel.get('ProjectUID'), pushpinUID = viewModel.get('PushpinUID'), PunchItemID = viewModel.get('PunchItemID'), shareBtn = this.lookupReference('chooseFileWindow').down('#fileUploadShareWithButton'), parentFolderID = 0;
  if (this.drilling) {
    pushpinUID = 0;
    parentFolderID = this.pushpinFolderStack[this.pushpinFolderStack.length - 1];
  }
  formData.ProjectUID = projectUID;
  if (pushpinUID) {
    formData.PushpinUID = pushpinUID;
  }
  if (PunchItemID && !pushpinUID && this.getRootFileStore().allowAutoSave !== false) {
    formData.PunchItemID = PunchItemID;
  }
  formData.ShareTypeID = shareBtn.getSelectedShareType();
  formData.MemberList = shareBtn.getSelectedMemberList();
  formData.ParentFolderID = parentFolderID;
  formData.IsPhoto = viewModel.get('itemDesc') == 'photo' ? true : false;
}, getContextualFileStore:function() {
  return this.drilling ? this.getViewModel().get('folderFiles') : this.getRootFileStore();
}, loadContextualFileStore:function() {
  this.getContextualFileStore().load();
}, onPhotoDialogTreeReady:function(theTree) {
  var rtNode = theTree.getRootNode(), theChild = rtNode.getChildAt(0), viewModel = this.getViewModel(), projectPhotos = viewModel.get('projectPhotos'), thePath = theChild.getPath();
  theTree.selectPath(thePath);
}, onPhotoCategorySelect:function(tree, record) {
  var viewModel = this.getViewModel(), list = this.lookupReference('projectFileGrid'), store = list.getStore(), Identifier = record.get('id'), Type = record.get('type'), storeId = floorplanViewer.store.ProjectPhotos.getDefaultStoreId(Type, Identifier), savedStore = Ext.getStore(storeId);
  if (savedStore) {
    list.bindStore(savedStore);
  } else {
    var newStore = Ext.create('floorplanViewer.store.ProjectPhotos', {storeId:storeId});
    this.photoStores.push(newStore);
    newStore.getProxy().setExtraParams({ProjectUID:viewModel.get('ProjectUID'), Identifier:Type === 'V' ? '' : Identifier, Type:Type});
    list.bindStore(newStore);
    newStore.load();
  }
}, onFileUploadedAndAccepted:function(data) {
  var store = this.getRootFileStore(), record = Ext.create(store.config.model, data);
  record.phantom = true;
  store.add(record);
  this.doAddSync(1);
}, onListViewRender:function() {
  console.log('viewModel:\t', this.getViewModel());
  this.onImagesButtonClick();
}, onImagesButtonClick:function() {
  var pushPinFlyOutDialogPhotosStore = Ext.getStore('pushPinFlyOutDialogPhotosStore');
  if (pushPinFlyOutDialogPhotosStore) {
    this.photoStoreFilter(pushPinFlyOutDialogPhotosStore, 'images');
  }
}, on360ButtonClick:function() {
  var pushPinFlyOutDialogPhotosStore = Ext.getStore('pushPinFlyOutDialogPhotosStore');
  if (pushPinFlyOutDialogPhotosStore) {
    this.photoStoreFilter(pushPinFlyOutDialogPhotosStore, '360');
  }
}, photoStoreFilter:function(store, label) {
  store.clearFilter();
  store.filterBy(function(record) {
    var returnValue = false;
    var is360 = record.get('IsThreeSixty');
    if (label === 'images' && !is360) {
      returnValue = true;
    } else {
      if (label === '360' && is360) {
        returnValue = true;
      }
    }
    return returnValue;
  });
}, onButtonsRendered:function(component, eOpts) {
  if (component.id === 'imagesButton') {
    component.btnInnerEl.setStyle('color', 'black');
  }
  if (component.id === 'images360Button') {
    component.btnInnerEl.setStyle('color', 'blue');
  }
}, onButtonToggled:function(button, state) {
  var clickedButton = button.id;
  button.btnInnerEl.setStyle('color', 'black');
  if (clickedButton === 'imagesButton') {
    var btn360Images = Ext.getCmp('images360Button');
    btn360Images.btnInnerEl.setStyle('color', 'blue');
  } else {
    if (clickedButton === 'images360Button') {
      var btnImages = Ext.getCmp('imagesButton');
      btnImages.btnInnerEl.setStyle('color', 'blue');
    }
  }
}}, 0, 0, 0, 0, ['controller.fileviewer'], 0, [floorplanViewer.view.files.fileViewer, 'FileViewerController'], 0);
Ext.cmd.derive('floorplanViewer.view.files.fileViewer.FileViewer', floorplanViewer.view.files.BaseViewer, {controller:'fileviewer', viewModel:{type:'fileviewer', formulas:{viewHeight:{bind:{_filesDataChanged:'{_filesDataChanged}', files:'{files}'}, get:function(data) {
  return data.files.getCount() ? 302 : 104;
}}}}, height:302, bind:{height:'{viewHeight}'}, localized:{title:'FV_Files'}, scrollable:{x:false, y:true}, fileList:{xtype:'filelist'}, folderFileList:{xtype:'folderfilelist'}, addButton:{xtype:'button', localized:{text:'FVCFD_Add files'}, icon:'mds/image/clientFileManager/icons/folder_new.png'}, showDownloadButton:true, showTbarTitle:false, initComponent:function() {
  this.addButton.itemId = 'openPhotoUpload';
  this.addButton.listeners = {click:'openFileUpload'};
  this.addButton.bind = this.addButton.bind || {};
  if (!this.addButton.bind.hidden) {
    this.addButton.bind.hidden = '{!account.canWrite}';
  }
  this.fileList.reference = 'fileList';
  this.fileList.listeners = {itemclick:'onFileItemClick'};
  this.folderFileList.reference = 'folderFileList';
  this.folderFileList.listeners = {itemclick:'onFolderFileItemClick'};
  var subTbar = {xtype:'toolbar', items:['-\x3e', this.addButton]}, navTbar = {xtype:'filenavtoolbar', reference:'fileViewerNavToolbar', itemId:'fileViewerNavToolbar'};
  if (this.ui) {
    subTbar.ui = this.ui;
    navTbar.ui = this.ui;
  }
  if (this.showDownloadButton && !config.ISARCHIVE) {
    subTbar.items.unshift({xtype:'button', localized:{text:'FV_Download All'}, reference:'zipFiles', icon:'mds/image/clientFileManager/icons/download.png', listeners:{click:'onZipFilesClick'}, bind:{hidden:'{!nFiles}'}});
  }
  if (this.showTbarTitle) {
    subTbar.items.unshift({xtype:'component', cls:'x-panel-header-title-detail-form', html:mvstr['TL_Files']});
  }
  var tbarContainer = {xtype:'container', layout:{type:'vbox', align:'stretch'}, width:'100%', items:[subTbar, navTbar], dock:'top'};
  this.tbar = {};
  if (this.ui) {
    this.tbar.ui = this.ui;
  }
  this.tbar.items = [tbarContainer];
  this.items = [this.fileList, this.folderFileList];
  floorplanViewer.view.files.BaseViewer.prototype.initComponent.apply(this, arguments);
}, repositionFloatingItems:Ext.emptyFn}, 0, ['fileviewer'], ['component', 'box', 'container', 'panel', 'fileviewer'], {'component':true, 'box':true, 'container':true, 'panel':true, 'fileviewer':true}, ['widget.fileviewer'], 0, [floorplanViewer.view.files.fileViewer, 'FileViewer'], 0);
Ext.cmd.derive('floorplanViewer.view.PushpinView', Ext.tab.Panel, {id:'fvPushpinTabPanelView', height:350, initComponent:function() {
  var items = [{xtype:'photofileviewer', includeBBar:true}, {xtype:'fileviewer'}];
  if (this.lookupViewModel().get('ListTypeID')) {
    items.unshift({xtype:'panel', localized:{title:'FV_Punch Item'}, layout:{type:'fit'}, scrollable:{x:false, y:true}, items:[{xtype:'punchitemsummary', padding:10, width:'100%', reference:'punchItemSummary'}], tbar:[{xtype:'button', localized:{text:'FV_Go to Punch Item Entr'}, icon:'mds/image/icon/edit_task.png', bind:{href:'{mdslink_clientPunchlistEntry}ListTypeID\x3d{ListTypeID}\x26ProjectUID\x3d{ProjectUID}\x26PunchItemID\x3d{PunchItemID}'}}]});
  } else {
    items.push({xtype:'panel', localized:{title:'FV_Followers'}, reference:'pushpinFollowers', layout:{type:'fit'}, scrollable:{x:false, y:true}, tabBar:{bind:{hidden:'{!followControlsVisible}'}}, items:[{xtype:'followerGrid'}]});
  }
  Ext.applyIf(this, {items:items});
  Ext.tab.Panel.prototype.initComponent.apply(this, arguments);
}, bind:{activeTab:'{defaultPushpinViewTab}'}}, 0, ['fvPushpinView'], ['component', 'box', 'container', 'panel', 'tabpanel', 'fvPushpinView'], {'component':true, 'box':true, 'container':true, 'panel':true, 'tabpanel':true, 'fvPushpinView':true}, ['widget.fvPushpinView'], 0, [floorplanViewer.view, 'PushpinView'], 0);
Ext.cmd.derive('floorplanViewer.view.SearchContainer', Ext.Container, {floating:true, shrinkWrap:3, hidden:true, style:{background:'#0D014D'}, defaults:{width:125, textAlign:'left'}, renderTo:Ext.getBody(), x:69, y:198, width:204, height:90, layout:'vbox', padding:16, items:[{xtype:'combo', reference:'searchCombo', itemId:'searchCombo', width:'100%', localized:{fieldLabel:'FV_Go to photo number'}, labelAlign:'top', valueField:'itemId', displayField:'itemLabel', typeAhead:true, caseSensitive:false, 
valueNotFoundText:'not found', forceSelection:true, queryMode:'local', labelStyle:{color:'#999999', fontSize:'18px', fontWeight:'bold'}, listeners:{beforequery:function(q) {
  if (q.query) {
    var length = q.query.length;
    q.query = new RegExp(Ext.String.escapeRegex(q.query), 'i');
    q.query.length = length;
  }
}, select:'onSelectSearchPhoto'}}]}, 0, ['searchcontainer'], ['component', 'box', 'container', 'searchcontainer'], {'component':true, 'box':true, 'container':true, 'searchcontainer':true}, ['widget.searchcontainer'], 0, [floorplanViewer.view, 'SearchContainer'], 0);
Ext.cmd.derive('floorplanViewer.view.SelectMenu', Ext.Container, {cls:'flyout-menu-wrap', floating:true, shrinkWrap:true, hidden:true, renderTo:Ext.getBody(), x:69, y:256, layout:{type:'vbox', align:'stretchmax'}, padding:2, constructor:function() {
  this.items = [{xtype:'container', reference:'selectHotspotsPopup', cls:'selectedHotspotText', padding:4, html:"\x3cspan class\x3d'selectedHotspotText'\x3e" + mvstr['FV_Click and drag to sel'] + '\x3c/span\x3e'}, {xtype:'container', layout:'hbox', defaults:{xtype:'button', height:30, flex:1}, items:[{text:mvstr['G_Cancel'], ui:'red', listeners:{click:'resetPhotoSelectionMenu'}}, {reference:'selectHotspotsViewBtn', disabled:true, text:mvstr['G_View'], ui:'green', listeners:{click:function() {
    var photoSelectionData = this.lookupController().photoSelectionData;
    photoSelectionData.getIdsAndPost();
  }}}]}];
  Ext.container.Container.prototype.constructor.apply(this, arguments);
}}, 1, ['selectmenu'], ['component', 'box', 'container', 'selectmenu'], {'component':true, 'box':true, 'container':true, 'selectmenu':true}, ['widget.selectmenu'], 0, [floorplanViewer.view, 'SelectMenu'], 0);
Ext.cmd.derive('floorplanViewer.view.ThumbDataView', Ext.view.View, {itemSelector:'.thumbContainer', layout:'fit', selectionModel:{type:'dataviewmodel', mode:'SIMPLE'}, config:{tooltips:[]}, constructor:function() {
  this.tpl = new Ext.XTemplate('\x3ctpl for\x3d"."\x3e\x3cdiv class\x3d"thumbContainer {Orientation}" id\x3d"tmb_{id}"\x3e\x3ctpl if\x3d"HasAnnotations"\x3e\x3cdiv class\x3d"annotation" title\x3d"Photo has annotations"\x3e\x3c/div\x3e\x3c/tpl\x3e\x3cdiv class\x3d"comment" style\x3d"{[this.getCommentStyle(values)]}" title\x3d"{CommentCount:this.getCommentTooltip}"\x3e\x3cspan\x3e{CommentCount}\x3c/span\x3e\x3c/div\x3e\x3ctpl if\x3d"IsPano"\x3e\x3cdiv class\x3d"pano" title\x3d"This is an aerial panorama"\x3e\x3c/div\x3e\x3c/tpl\x3e\x3ctpl if\x3d"IsInteriorPano"\x3e\x3cdiv class\x3d"pano" title\x3d"This is an interior panorama"\x3e\x3c/div\x3e\x3c/tpl\x3e\x3ca href\x3d"{[this.getPhotoViewerURL(values)]}"\x3e{[this.wrapperStart(values)]}\x3cimg src\x3d"{ImageURLThumb}" alt\x3d"" title\x3d"{PhotoDate:date("DATE_Medium")} - mvstr[FV_Click to open]" class\x3d"imgTmb" /\x3e{[this.wrapperEnd()]}\x3c/a\x3e\x3c/div\x3e\x3cdiv class\x3d"thumbInfo"\x3e{PhotoDate:date("DATE_Medium")}\x3c/div\x3e\x3c/tpl\x3e', 
  {getCommentStyle:function(values) {
    if (values.CommentCount > 0 && values.HasAnnotations > 0) {
      return 'left:20px !important;';
    } else {
      if (values.CommentCount > 0 && !values.HasAnnotations) {
        return 'left:2px !important;';
      }
    }
    return 'display:none;';
  }, getCommentTooltip:function(commentCount) {
    if (commentCount == 1) {
      return mvstr['FV_Photo has 1 comment'];
    } else {
      return mvstr['FV_Photo has {x} comment'].replace('{x}', commentCount);
    }
  }, getPhotoViewerURL:function(values) {
    if (Ext.ComponentQuery.query('fvPhotoThumbDataView')[0].lookupViewModel().get('account.features.photoviewerVisible')) {
      return '#';
    }
    if (this.selectPhotoThumbs) {
      return '#';
    }
    var projectUID = Ext.Object.fromQueryString(document.location.search).ProjectUID;
    return mdslink.clientPhotoViewer + 'ProjectUID\x3d' + projectUID + '\x26PhotoGroupType\x3ds\x26ShootUID\x3d' + values.ShootUID + '\x26SelectedPhotoID\x3d' + values.Identifier;
  }, wrapperStart:function(values) {
    if (this.selectPhotoThumbs) {
      var qtip = '';
      return '\x3cdiv class\x3d"wrapper" ' + qtip + '\x3e';
    }
    return '';
  }, wrapperEnd:function() {
    if (this.selectPhotoThumbs) {
      return '\x3c/div\x3e';
    }
    return '';
  }});
  Ext.view.View.prototype.constructor.apply(this, arguments);
}, listeners:{beforerender:function() {
  this.tpl.selectPhotoThumbs = this.selectPhotoThumbs;
}, itemmouseenter:function(e, record, item, index) {
  if (!this.selectPhotoThumbs) {
    Ext.fly(item).addCls('thumbHover');
  }
}, itemmouseleave:function(e, record, item, index) {
  if (!this.selectPhotoThumbs) {
    Ext.fly(item).removeCls('thumbHover');
  }
}, itemmousedown:function(e, record, item, index) {
  var logProperties = record.getPhotoEventProperties();
  logProperties['Shoot UID'] = record.get('ShootUID');
  analytics.Ctrl.log('Clicked on Thumbnail', logProperties);
}, select:function(select, record) {
  var vm = this.lookupViewModel();
  if (this.selectPhotoThumbs) {
    var id = 'tmb_' + record.get('id');
    var cls = Ext.getElementById(id).className.indexOf('landscape') > -1 ? 'landscape' : 'portrait';
    Ext.ComponentQuery.query('multivistaphoto')[0].controller.onPhotoSelect(0, record);
    Ext.fly(Ext.getElementById(id)).addCls(cls);
  } else {
    if (vm.get('account.features.photoviewerVisible')) {
      var floorplan = vm.get('floorplan');
      app.getMainView().add({xtype:'photoviewer', photoId:record.get('id'), storeSession:vm.get('storeSession'), photoGroup:Ext.create('floorplanViewer.model.PhotoGroup', {Identifier:floorplan.get('ProjectShootTypeUID'), StartDate:record.get('PhotoDate'), 'Type':'D', Title:floorplan.get('ProjectShootTypeDisplayLabel'), Locations:floorplan.get('floorplanTitle') ? [floorplan.get('floorplanTitle')] : [], ShootUID:record.get('ShootUID')})}).show();
    }
  }
}, deselect:function(deselect, record) {
  if (this.selectPhotoThumbs) {
    Ext.ComponentQuery.query('multivistaphoto')[0].controller.onPhotoDeselect(0, record);
  }
}, refresh:function(view) {
  var elements = view.all.elements, tooltips = this.getTooltips(), floorplanEl = this.selectPhotoThumbs ? this.up('choosePhotoWindow').down('fvFloorplanViewer').getEl() : null, store = view.getStore();
  if (this.selectPhotoThumbs) {
    this.destroyTooltips();
  }
  for (var i = 0; i < elements.length; i++) {
    var img = Ext.select('#' + elements[i].id + ' img').elements[0];
    if (img) {
      img.onload = Ext.bind(view.onImageLoad, img, [this, store.getAt(i)]);
    }
    if (this.selectPhotoThumbs) {
      var record = store.getAt(i), tip = Ext.create('Ext.tip.ToolTip', {target:Ext.fly(elements[i]), trackMouse:false, anchor:'right', renderTo:floorplanEl, constrain:true, html:'\x3cimg src\x3d' + record.get('ImageURLMedium') + '\x3e', showDelay:300});
      tooltips.push(tip);
    }
  }
}, destroy:function() {
  this.destroyTooltips();
}}, onImageLoad:function(thumbDataView, record) {
  var imgDom = this, width = imgDom.naturalWidth, height = imgDom.naturalHeight;
  if (!width || !height) {
    var img = new Image;
    img.onload = function() {
      imgDom.naturalWidth = this.width;
      imgDom.naturalHeight = this.height;
      Ext.bind(thumbDataView.onImageLoad, imgDom)();
    };
    img.src = imgDom.src;
    return;
  }
  if (width > height) {
    record.set('Orientation', 'landscape');
  } else {
    record.set('Orientation', 'portrait');
  }
}, destroyTooltips:function() {
  var tooltips = this.getTooltips();
  for (var i = 0; i < tooltips.length; i++) {
    tooltips[i].destroy();
  }
}}, 1, ['fvPhotoThumbDataView'], ['component', 'box', 'dataview', 'fvPhotoThumbDataView'], {'component':true, 'box':true, 'dataview':true, 'fvPhotoThumbDataView':true}, ['widget.fvPhotoThumbDataView'], 0, [floorplanViewer.view, 'ThumbDataView'], 0);
Ext.cmd.derive('floorplanViewer.view.files.PhotoFileList', Ext.view.View, {border:true, padding:0, cls:'documentList', itemSelector:'.photo', bind:{store:'{photos}'}, tpl:['\x3ctpl for\x3d"."\x3e', '\x3cdiv class\x3d"photo fileviewer-item type-cls-{Type}"\x3e', '\x3cdiv class\x3d"photoLeft"\x3e', '\x3cdiv class\x3d"desc-line-1"\x3e{DescLine1}\x3c/div\x3e', '\x3cdiv class\x3d"desc-line-2"\x3e{DescLine2}\x3c/div\x3e', '\x3cdiv class\x3d"photoLeftFooter"\x3e', '\x3cspan class\x3d"photoSize"\x3e{FileSize:fileSize}\x3c/span\x3e', 
'\x3cspan class\x3d"desc-line-3"\x3e{DescLine3}\x3c/span\x3e', '\x3c/div\x3e', '\x3c/div\x3e', '\x3cdiv class\x3d"photoRight"\x3e', '\x3cimg class\x3d"photoThumb" src\x3d"{ImageURLThumb}" alt\x3d"Open in Photo Viewer"\x3e', '\x3c/div\x3e', '\x3cdiv class\x3d"fileListRemoveButton" id\x3d"dotted-menu"  style\x3d"vertical-align: middle;position:relative;"\x3e', '\x3cdiv style\x3d"font-size: 40px;vertical-align: middle;position:absolute;top:5px;font-family: mv-icons-font; margin-right: 24px; margin-top: 10px;"\x3e', 
'\x3cimg class\x3d"dotted-menu" src\x3d"mds/image/icon/pin_widget_menu.svg" alt\x3d"dotted menu" style\x3d"padding: 10px;"\x3e', '\x3c/div\x3e', '\x3c/div\x3e', '\x3c/div\x3e', '\x3c/tpl\x3e']}, 0, ['photofilelist'], ['component', 'box', 'dataview', 'photofilelist'], {'component':true, 'box':true, 'dataview':true, 'photofilelist':true}, ['widget.photofilelist'], 0, [floorplanViewer.view.files, 'PhotoFileList'], 0);
Ext.cmd.derive('floorplanViewer.view.files.multivistaPhoto.MultivistaPhotoModel', Ext.app.ViewModel, {data:{thumbSize:'medium', activeSelectionMode:floorplanViewer.FilesValues.PHOTO_SELECTION_MODE.SELECT_BY_PHOTO, dateFilter:{overallDateRange:{startDate:null, endDate:null}, contextDateRange:{startDate:null, endDate:null}, filterDateRange:{startDate:null, endDate:null}}, selectedPhotos:null, showButtons:null}, stores:{selectionMode:{type:'photoselectionmode'}, photoCategories:{type:'photocategories', 
proxy:{extraParams:{ProjectUID:'{ProjectUID}'}}, autoLoad:true, mvAutoLoadVars:true}, photoGroups:{model:'floorplanViewer.model.PhotoGroup', proxy:{url:'index.cfm?fuseaction\x3daClientPhotoList.getPhotoGroups2', extraParams:{ProjectUID:'{ProjectUID}', Type:'{photoGroupType}', Identifier:'{photoGroupIdentifier}'}}, autoLoad:true}, locations:{type:'locations'}, progressions:{}, floorplans:{type:'floorplans', proxy:{extraParams:{ProjectUID:'{ProjectUID}'}}, autoLoad:true, listeners:{load:'onFloorplansLoaded'}}}, 
formulas:{photoFilterEnabled:function(get) {
  return get('activeSelectionMode') == floorplanViewer.FilesValues.PHOTO_SELECTION_MODE.SELECT_BY_PHOTO && get('_photoCategoriesLoaded');
}, selectByShootTypeEnabled:function(get) {
  return get('activeSelectionMode') == floorplanViewer.FilesValues.PHOTO_SELECTION_MODE.SELECT_BY_FLOORPLAN;
}, hideFooterButtons:function(get) {
  return !get('showButtons');
}}}, 0, 0, 0, 0, ['viewmodel.multivistaphoto'], 0, [floorplanViewer.view.files.multivistaPhoto, 'MultivistaPhotoModel'], 0);
Ext.cmd.derive('floorplanViewer.view.files.multivistaPhoto.PhotoList', Ext.view.View, {loadMask:false, selectionModel:{type:'dataviewmodel', mode:'SIMPLE'}, tpl:['\x3ctpl for\x3d"."\x3e', '\x3ctpl if\x3d"LoadedImage"\x3e', '\x3cdiv class\x3d"photo thumb"\x3e\x3cdiv class\x3d"wrapper"\x3e\x3cimg src\x3d"{LoadedImage}"\x3e\x3c/div\x3e\x3c/div\x3e', '\x3ctpl elseif\x3d"LoadedImage\x3d\x3d\x3d0"\x3e', '\x3cdiv class\x3d"photo thumb error"\x3e', '\x3cdiv class\x3d"message"\x3emvstr[PT_Failed to load image]\x3c/div\x3e', 
'\x3c/div\x3e', '\x3ctpl else\x3e', '\x3cdiv class\x3d"photo thumb"\x3e', '\x3cdiv class\x3d"loading"\x3e\x3c/div\x3e', '\x3c/div\x3e', '\x3c/tpl\x3e', '\x3c/tpl\x3e'], itemSelector:'.photo', listeners:{beforeselect:function(view, record) {
  if (!record.get('LoadedImage')) {
    return false;
  }
  return true;
}}}, 0, ['photolist'], ['component', 'box', 'dataview', 'photolist'], {'component':true, 'box':true, 'dataview':true, 'photolist':true}, ['widget.photolist'], 0, [floorplanViewer.view.files.multivistaPhoto, 'PhotoList'], 0);
Ext.cmd.derive('floorplanViewer.view.files.multivistaPhoto.PhotoGroup', Ext.Container, {store:null, margin:'0 0 10 10', initComponent:function() {
  this.viewLoaded = false;
  var items = [{xtype:'component', cls:'photo-group-header mds-light-bg-list-header', html:this.record.get('Title') + ' - ' + Ext.Date.format(this.record.get('StartDate'), 'F j, Y')}];
  Ext.applyIf(this, {items:items});
  Ext.container.Container.prototype.initComponent.apply(this, arguments);
}, addView:function() {
  this.add({xtype:'photolist', store:this.store});
  if (!this.store.isLoaded() && !this.store.isLoading()) {
    this.store.load();
  }
  this.viewLoaded = true;
}}, 0, ['photogroup'], ['component', 'box', 'container', 'photogroup'], {'component':true, 'box':true, 'container':true, 'photogroup':true}, ['widget.photogroup'], 0, [floorplanViewer.view.files.multivistaPhoto, 'PhotoGroup'], 0);
Ext.cmd.derive('floorplanViewer.view.files.multivistaPhoto.SelectByPhotoList', Ext.panel.Panel, {reference:'photos', itemId:'photos', scrollable:{y:true, listeners:{scroll:{fn:function() {
  Ext.ComponentQuery.query('selectbyphoto')[0].lookupController().fireEvent('checkqueue');
}}}}, listeners:{destroy:'onLeaveSelectByPhoto'}}, 0, ['selectbyphotolist'], ['component', 'box', 'container', 'panel', 'selectbyphotolist'], {'component':true, 'box':true, 'container':true, 'panel':true, 'selectbyphotolist':true}, ['widget.selectbyphotolist'], 0, [floorplanViewer.view.files.multivistaPhoto, 'SelectByPhotoList'], 0);
Ext.cmd.derive('floorplanViewer.view.files.multivistaPhoto.MultivistaPhotoController', Ext.app.ViewController, {statics:{MAX_PHOTO_LOADS:18, PEEK_THRESHOLD:600}, init:function() {
  this.photoFilters = [];
  this.getViewModel().bind('{_photoCategoriesLoaded}', this.onPhotoCategoriesLoaded, this);
  this.addListener('checkqueue', this.checkQueue, this, {buffer:100});
  this.getViewModel().bind('{dateFilter.filterDateRange}', this.onDateChange, this);
  this.control({'photolist':{select:this.onPhotoSelect, deselect:this.onPhotoDeselect}});
}, onPhotoCategoriesLoaded:function(loaded) {
  if (!loaded) {
    return;
  }
  var store = this.getStore('photoCategories'), dateRange = store.getDateRange(), locations = this.getStore('locations'), locationArray = store.getLocations(), locationDataArray = [{Location:mvstr['FVCPD_All Locations']}];
  this.getViewModel().set('dateFilter.overallDateRange', {startDate:dateRange.startDate, endDate:dateRange.endDate});
  for (var i = 0; i < locationArray.length; i++) {
    locationDataArray.push({Location:locationArray[i]});
  }
  locations.loadRawData(locationDataArray);
  var combo = this.lookupReference('locationsCombo');
  combo.suspendEvent('change');
  combo.setStore(locations);
  combo.setValue(mvstr['FVCPD_All Locations']);
  combo.resumeEvent('change');
}, onFloorplansLoaded:function(store, records) {
  var progressionTypes = [];
  for (var i = records.length - 1; i >= 0; i--) {
    var prog = records[i].get('ProjectShootTypeLabel');
    var loc = records[i].get('FloorplanDescription');
    if (progressionTypes.indexOf(prog) === -1) {
      progressionTypes.splice(0, 0, prog);
    }
  }
  progressionTypes.splice(0, 0, mvstr['FVCPD_All Progressions']);
  var combo = this.lookupReference('progressionCombo');
  combo.suspendEvent('change');
  combo.setStore(progressionTypes);
  combo.setValue(mvstr['FVCPD_All Progressions']);
  combo.resumeEvent('change');
}, resetPhotoList:function() {
  this.photoStores = [];
  this.photoArray = [];
  this.photoLoads = [];
  this.startedPhotoChecks = false;
  this.photoLoadCancelled = false;
  this.photoGroupViewArray = [];
  this.loadingPhotoDataviews = [];
}, onChoosePhotoCategory:function(view, record) {
  this.resetPhotoList();
  this.getView().mask('Loading ...');
  this.photoGroupStore = this.getPhotoGroupStore(record);
  this.enteredPhotoListByFilter = false;
  this.photoFilters = [];
  var viewModel = this.getViewModel();
  viewModel.set('dateFilter.contextDateRange', {startDate:record.get('StartDate'), endDate:record.get('EndDate')});
  viewModel.set('dateFilter.filterDateRange', {startDate:null, endDate:null});
  if (!this.photoGroupStore.isLoaded()) {
    this.photoGroupStore.addListener('load', this.onPhotoGroupsLoad, this, {single:true});
    this.photoGroupStore.load();
  } else {
    this.onPhotoGroupsLoad(this.photoGroupStore);
  }
  this.getStore('locations').filter({filterFn:function(loc) {
    return !!(loc.get('Location') == mvstr['FVCPD_All Locations'] || Ext.Array.contains(record.get('Locations'), loc.get('Location')));
  }});
}, getPhotoGroupStore:function(record) {
  var viewModel = this.getViewModel(), storeId = 'photoCategory_' + record.getId(), store = Ext.getStore(storeId);
  if (!store) {
    store = Ext.create('Ext.data.Store', {model:'floorplanViewer.model.PhotoGroup', storeId:storeId, proxy:{url:'/index.cfm?fuseaction\x3daClientPhotoList.getPhotoGroups2', extraParams:{ProjectUID:viewModel.get('ProjectUID'), Type:record.get('Type'), Identifier:record.get('Identifier')}}});
  }
  store.clearFilter();
  store.addFilter(this.photoFilters);
  return store;
}, onPhotoGroupsLoad:function() {
  this.getViewModel().set('showButtons', true);
  if (this.photoLoadCancelled) {
    return;
  }
  var photoGroupsStore = this.photoGroupStore, photoGroupsStoreCount = photoGroupsStore.getCount(), ProjectUID = this.getViewModel().get('ProjectUID'), viewArray = [];
  for (var i = 0; i < photoGroupsStoreCount; i++) {
    var photoGroup = photoGroupsStore.getAt(i), storeId = 'photoGroup_' + photoGroup.getId(), store = Ext.getStore(storeId);
    if (!store) {
      store = Ext.create('floorplanViewer.store.MultivistaPhotos', {storeId:storeId, proxy:{extraParams:{ProjectUID:ProjectUID, Identifier:photoGroup.get('Identifier'), LookupDate:photoGroup.get('StartDate')}}, mvCanAbort:true});
    }
    this.photoStores.push(store);
    var photoGroup = Ext.create('floorplanViewer.view.files.multivistaPhoto.PhotoGroup', {store:store, record:photoGroup, itemId:store.getId()});
    store.photoGroup = photoGroup;
    viewArray.push(photoGroup);
    this.photoGroupViewArray.push(photoGroup);
  }
  var photosPage = Ext.create('floorplanViewer.view.files.multivistaPhoto.SelectByPhotoList', {items:viewArray}), selectByPhotoPage = this.lookupReference('selectByPhoto');
  selectByPhotoPage.add(photosPage);
  this.lookupReference('selectByPhoto').setActiveItem(this.lookupReference('photos'));
  if (viewArray.length) {
    this.fireEvent('checkqueue');
  } else {
    this.getView().unmask();
  }
}, loadPhotoStore:function(index, chained) {
  if (this.photoLoadCancelled) {
    return;
  }
  var store = this.photoStores[index];
  if (!store) {
    return;
  }
  if (store.isLoaded()) {
    this.onPhotoStoreLoad(store);
  } else {
    if (!store.isLoading()) {
      store.addListener('load', this.onPhotoStoreLoad, this, {single:true});
      store.load();
    }
  }
  if (!chained) {
    this.loadPhotoStore(index - 1, true);
    this.loadPhotoStore(index + 1, true);
  }
}, onPhotoStoreLoad:function(store) {
  if (this.photoLoadCancelled) {
    return;
  }
  if (!this.startedPhotoChecks) {
    this.startedPhotoChecks = true;
    this.getView().unmask();
  }
  var view = store.photoGroup, dataview = view.down('dataview');
  var count = store.getCount();
  for (var j = 0; j < count; j++) {
    this.photoArray.push({record:store.getAt(j), index:j, view:view});
  }
  this.fireEvent('checkqueue');
}, checkQueue:function() {
  if (this.photoLoadCancelled) {
    return;
  }
  if (this.photoLoads.length >= this.self.MAX_PHOTO_LOADS) {
    return;
  }
  for (var i = 0; i < this.photoGroupViewArray.length; i++) {
    if (!this.photoGroupViewArray[i].isHidden() && !this.photoGroupViewArray[i].viewLoaded && this.elInView(this.photoGroupViewArray[i].el)) {
      this.photoGroupViewArray[i].addListener('resize', function() {
        this.fireEvent('checkqueue');
      }, this, {single:true});
      this.photoGroupViewArray[i].addView();
      this.loadPhotoStore(i);
      return;
    }
  }
  var pendingPhotos = [], nWantedPhotos = this.self.MAX_PHOTO_LOADS - this.photoLoads.length, pendingPhotoIndices = [];
  for (var i = 0; i < this.photoArray.length && pendingPhotos.length < nWantedPhotos; i++) {
    var photo = this.photoArray[i];
    if (this.photoInView(photo)) {
      pendingPhotos.push(photo);
      pendingPhotoIndices.push(i);
      if (pendingPhotos.length == nWantedPhotos) {
        this.nextPhoto = this.photoArray[i + 1];
      }
    }
  }
  for (var j = 0; j < pendingPhotos.length; j++) {
    if (!pendingPhotos[j].record.get('LoadedImage')) {
      this.addPhotoLoad(pendingPhotos[j]);
    }
  }
  this.photoArray = Ext.Array.difference(this.photoArray, pendingPhotos);
}, photoInView:function(photo) {
  if (!photo || this.photoLoadCancelled || photo.view.isHidden()) {
    return false;
  }
  if (!photo.el && photo.view.getEl()) {
    var photoEls = photo.view.getEl().select('.photo', true).elements;
    if (!photoEls[photo.index]) {
      return;
    }
    photo.el = photoEls[photo.index];
    photo.index = undefined;
  }
  return this.elInView(photo.el);
}, elInView:function(el) {
  if (!el || !el.dom) {
    return false;
  }
  var view = this.lookupReference('selectByPhoto'), viewBox = view.getBox(), elBox = el.getBox();
  return !!(elBox.top <= viewBox.bottom + this.self.PEEK_THRESHOLD && elBox.bottom >= viewBox.top - this.self.PEEK_THRESHOLD);
}, addPhotoLoad:function(photo) {
  var photoDataview = photo.view.down('dataview');
  if (!Ext.Array.contains(this.loadingPhotoDataviews, photoDataview)) {
    photoDataview.suspendLayouts();
  }
  this.loadingPhotoDataviews.push(photoDataview);
  var load = new Image, src = photo.record.get('ImageURLMedium'), removeLoad = Ext.bind(function() {
    Ext.Array.remove(this.photoLoads, load);
    Ext.Array.removeAt(this.loadingPhotoDataviews, Ext.Array.indexOf(this.loadingPhotoDataviews, photoDataview));
    if (!Ext.Array.contains(this.loadingPhotoDataviews, photoDataview)) {
      photoDataview.resumeLayouts(true);
    }
    if (!this.photoLoads.length) {
      if (this.photoInView(this.nextPhoto)) {
        this.fireEvent('checkqueue');
      }
    }
  }, this), tryAgain = true;
  load.onload = Ext.bind(function() {
    photo.record.set('LoadedImage', src);
    removeLoad();
  }, this);
  load.onerror = Ext.bind(function() {
    if (tryAgain) {
      src = photo.record.get('ImageURLThumb');
      load.src = src;
      tryAgain = false;
    } else {
      photo.record.set('LoadedImage', 0);
      removeLoad();
    }
  }, this);
  this.photoLoads.push(load);
  load.src = src;
}, onLeaveSelectByPhoto:function() {
  this.photoLoadCancelled = true;
  if (!this.photoGroupStore) {
    return;
  }
  this.photoGroupStore.clearListeners();
  if (!this.photoGroupStore.storeId) {
    this.photoGroupStore.destroy();
  }
  this.photoGroupStore = null;
  for (var i = 0; i < this.photoStores.length; i++) {
    this.photoStores[i].mvAbort();
  }
  this.photoStores = [];
  for (var i = 0; i < this.photoLoads.length; i++) {
    this.photoLoads[i].onload = null;
    this.photoLoads[i].onerror = null;
    this.photoLoads[i].src = '';
  }
  this.getStore('locations').clearFilter();
  this.getViewModel().set('selectedPhotos', null);
  if (!this.reenteringPhotoList) {
    var viewModel = this.getViewModel();
    viewModel.set('dateFilter.contextDateRange', {startDate:null, endDate:null});
    viewModel.set('dateFilter.filterDateRange', {startDate:null, endDate:null});
    var locationsCombo = this.lookupReference('locationsCombo');
    if (locationsCombo) {
      locationsCombo.setRawValue(mvstr['FVCPD_All Locations']);
    }
    this.photoFilters = [];
  }
}, isInDateRange:function(containerStartDate, containerEndDate, itemStartDate, itemEndDate) {
  return !!(itemStartDate <= containerStartDate && itemEndDate >= containerStartDate || itemStartDate >= containerStartDate && itemEndDate <= containerEndDate || itemStartDate <= containerEndDate && itemEndDate >= containerEndDate);
}, onDateChange:function(filterDateRange) {
  var startDate = filterDateRange.startDate, endDate = filterDateRange.endDate, filter = {filterFn:Ext.bind(function(item) {
    return this.isInDateRange(startDate, endDate, item.get('StartDate'), item.get('EndDate'));
  }, this), id:'date'};
  if (!startDate || !endDate) {
    return;
  }
  if (this.photoGroupStore) {
    if (this.enteredPhotoListByFilter) {
      this.reenterPhotoListWithFilter(filter);
      return;
    }
    this.applyPhotoListFilter(filter);
  } else {
    this.enterPhotosViaFilter(filter);
  }
}, reenterPhotoListWithFilter:function(filter) {
  this.getView().mask('Loading ...');
  this.reenteringPhotoList = true;
  this.lookupReference('photos').destroy();
  Ext.defer(function() {
    this.enteredPhotoListByFilter = false;
    this.reenteringPhotoList = false;
    this.enterPhotosViaFilter(filter);
  }, 1, this);
}, noPhotosAlert:function() {
  var msg = Ext.Msg.alert(mvstr['PUL_No Photos Found'], mvstr['PUL_No photos match the f']);
  Ext.defer(function() {
    msg.alignTo(this.getView(), 'c-c?');
  }, 1, this);
}, onLocationChange:function(combo, location) {
  if (this.getViewModel().get('activeSelectionMode') == floorplanViewer.FilesValues.PHOTO_SELECTION_MODE.SELECT_BY_PHOTO) {
    this.onSelectByPhotoLocationChange(location);
  } else {
    this.onSelectByFloorplanLocationChange(location);
  }
}, onProgressionChange:function(combo, progression) {
  var store = this.getStore('floorplans');
  if (progression == mvstr['FVCPD_All Progressions']) {
    store.removeFilter('progression');
  } else {
    store.addFilter({id:'progression', property:'ProjectShootTypeLabel', value:progression});
  }
}, onSelectionModeChange:function(combo, mode) {
  if (mode == floorplanViewer.FilesValues.PHOTO_SELECTION_MODE.SELECT_BY_PHOTO) {
    this.lookupReference('selectByPhoto').setActiveItem(0);
  }
  this.lookupReference('locationsCombo').setValue(mvstr['FVCPD_All Locations']);
  this.getViewModel().set('selectedPhotos', null);
  this.getViewModel().set('showButtons', null);
}, onSelectByPhotoLocationChange:function(location) {
  var filter = {filterFn:Ext.bind(function(item) {
    if (location == mvstr['FVCPD_All Locations']) {
      return true;
    }
    var itemLocations = item.get('Locations');
    for (var i = 0; i < itemLocations.length; i++) {
      if (itemLocations[i] == location) {
        return true;
      }
    }
    return false;
  }, this), id:'location'};
  if (this.photoGroupStore) {
    if (this.enteredPhotoListByFilter) {
      this.reenterPhotoListWithFilter(filter);
      return;
    }
    this.applyPhotoListFilter(filter);
  } else {
    this.enterPhotosViaFilter(filter);
  }
}, applyPhotoListFilter:function(filter) {
  this.lookupReference('photos').getScrollable().scrollTo(0, 0);
  var toHide = [], toShow = [], nVisible = 0, filters = this.photoFilters;
  this.addFilter(filters, filter);
  for (var i = 0; i < this.photoGroupViewArray.length; i++) {
    var rec = this.photoGroupViewArray[i].record, passedFilters = true;
    for (var j = 0; j < filters.length; j++) {
      if (!filters[j].filterFn(rec)) {
        passedFilters = false;
        break;
      }
    }
    if (passedFilters) {
      nVisible++;
      if (this.photoGroupViewArray[i].isHidden()) {
        toShow.push(this.photoGroupViewArray[i]);
      }
    } else {
      if (!this.photoGroupViewArray[i].isHidden()) {
        toHide.push(this.photoGroupViewArray[i]);
      }
    }
  }
  if (!nVisible) {
    this.noPhotosAlert();
  }
  if (toShow.length || toHide.length) {
    Ext.suspendLayouts();
    for (var i = 0; i < toShow.length; i++) {
      toShow[i].show();
    }
    for (var i = 0; i < toHide.length; i++) {
      toHide[i].hide();
    }
    Ext.resumeLayouts();
  }
  this.fireEvent('checkqueue');
}, enterPhotosViaFilter:function(filter) {
  this.addFilter(this.photoFilters, filter);
  this.resetPhotoList();
  var photoCategories = this.getStore('photoCategories'), photoGroupStores = [];
  photoCategories.each(function(photoCategory) {
    for (var i = 0; i < this.photoFilters.length; i++) {
      if (!this.photoFilters[i].filterFn(photoCategory)) {
        return;
      }
    }
    photoGroupStores.push(this.getPhotoGroupStore(photoCategory));
  }, this);
  var nLoadedPhotoGroupStores = 0, increment = Ext.bind(function() {
    nLoadedPhotoGroupStores++;
    if (nLoadedPhotoGroupStores >= photoGroupStores.length) {
      var photoGroupArray = [];
      for (var i = 0; i < photoGroupStores.length; i++) {
        var photoGroupRecords = photoGroupStores[i].getRange();
        for (var j = 0; j < photoGroupRecords.length; j++) {
          photoGroupArray.push(photoGroupRecords[j]);
        }
      }
      this.photoGroupStore = Ext.create('Ext.data.Store', {model:'floorplanViewer.model.PhotoGroup', proxy:{type:'memory'}, data:photoGroupArray});
      this.enteredPhotoListByFilter = true;
      this.photoGroupStore.sort([{property:'StartDate', direction:'DESC'}]);
      this.onPhotoGroupsLoad();
    }
  }, this);
  if (!photoGroupStores.length) {
    increment();
    this.noPhotosAlert();
    return;
  }
  this.getView().mask('Loading ...');
  for (var i = 0; i < photoGroupStores.length; i++) {
    if (photoGroupStores[i].isLoaded()) {
      increment();
    } else {
      photoGroupStores[i].load({callback:increment});
    }
  }
}, mvPhotoBackBtnClick:function(button) {
  this.getViewModel().set('showButtons', null);
  this.getViewModel().set('selectedPhotos', null);
  if (this.getViewModel().get('activeSelectionMode') == floorplanViewer.FilesValues.PHOTO_SELECTION_MODE.SELECT_BY_PHOTO) {
    this.lookupReference('selectByPhoto').setActiveItem(0);
  } else {
    this.getView().down('fvPhotoThumbDataView').getStore().removeAll();
    this.lookupReference('multivistaPhotoTBar').show();
    this.lookupReference('selectByFloorplan').setActiveItem(0);
  }
}, addFilter:function(filterArr, filter) {
  for (var i = 0; i < filterArr.length; i++) {
    if (filterArr[i].id == filter.id) {
      filterArr[i] = filter;
      return;
    }
  }
  filterArr.push(filter);
}, onPhotoSelect:function(view, record) {
  if (!record.get('PhotoDate')) {
    record.set('PhotoDate', record.store.getProxy().getExtraParams().LookupDate);
  }
  var selected = this.getViewModel().get('selectedPhotos');
  if (!selected) {
    selected = [];
  }
  Ext.Array.include(selected, record);
  this.getViewModel().set('selectedPhotos', selected);
}, onPhotoDeselect:function(view, record) {
  var selected = this.getViewModel().get('selectedPhotos');
  Ext.Array.remove(selected, record);
  if (!selected.length) {
    selected = null;
  }
  this.getViewModel().set('selectedPhotos', selected);
}, addPhotos:function() {
  var photos = this.getViewModel().get('selectedPhotos');
  if (photos) {
    this.getView().up('window').lookupController().addSelectedFiles(photos);
  }
  this.getView().up('window').destroy();
}, onSelectByFloorplanLocationChange:function(location) {
  var store = this.getStore('floorplans');
  if (location == mvstr['FVCPD_All Locations']) {
    store.removeFilter('location');
  } else {
    store.addFilter({id:'location', property:'FloorplanDescription', value:location});
  }
}, onChooseFloorplan:function(view, record) {
  this.lookupReference('multivistaPhotoTBar').hide();
  this.getViewModel().set('showButtons', true);
  var floorplanViewer = this.lookupReference('floorplanViewer'), viewModel = floorplanViewer.lookupViewModel();
  if (viewModel.get('FloorplanUID')) {
    floorplanViewer.mask('Loading');
    viewModel.set('_recordfloorplan', null);
    viewModel.set('FloorplanUID', null);
    viewModel.notify();
  }
  viewModel.set('FloorplanUID', record.get('FloorplanUID'));
  this.lookupReference('selectByFloorplan').setActiveItem(floorplanViewer);
}}, 0, 0, 0, 0, ['controller.multivistaphoto'], 0, [floorplanViewer.view.files.multivistaPhoto, 'MultivistaPhotoController'], 0);
Ext.cmd.derive('floorplanViewer.view.files.multivistaPhoto.SelectByPhotoView', Ext.view.View, {scrollable:true, groupField:'GroupLabel', groupTpl:"\x3cdiv class\x3d'mds-light-bg-list-header'\x3e{GroupLabel}\x3c/div\x3e", tpl:['\x3ctpl for\x3d"."\x3e', '\x3cdiv class\x3d"photo-category"\x3e', '\x3cdiv class\x3d"photo thumb"\x3e\x3cimg src\x3d"{ImageURLMedium}"\x3e\x3c/div\x3e', '\x3cdiv class\x3d"title"\x3e{Title}\x3c/div\x3e', '\x3c/div\x3e', '\x3c/tpl\x3e'], itemSelector:'.photo-category', listeners:{'itemclick':'onChoosePhotoCategory'}}, 
0, ['selectbyphotoview'], ['component', 'box', 'dataview', 'selectbyphotoview'], {'component':true, 'box':true, 'dataview':true, 'selectbyphotoview':true}, ['widget.selectbyphotoview'], 0, [floorplanViewer.view.files.multivistaPhoto, 'SelectByPhotoView'], 0);
Ext.cmd.derive('floorplanViewer.view.files.multivistaPhoto.SelectByPhoto', Ext.Container, {layout:{type:'card'}, items:[{xtype:'panel', layout:{type:'fit'}, items:[{xtype:'selectbyphotoview', bind:'{photoCategories}', margin:'0 0 10 10'}]}]}, 0, ['selectbyphoto'], ['component', 'box', 'container', 'selectbyphoto'], {'component':true, 'box':true, 'container':true, 'selectbyphoto':true}, ['widget.selectbyphoto'], 0, [floorplanViewer.view.files.multivistaPhoto, 'SelectByPhoto'], 0);
Ext.cmd.derive('floorplanViewer.view.pushpinFlyout.PushpinFlyoutController', Ext.app.ViewController, {init:function() {
  var viewModel = this.getViewModel();
  viewModel.bind('{pushpin}', this.onPushpinLoaded, this);
  viewModel.bind('{floorplanInitialized}', this.onPushpinLoaded, this);
  viewModel.bind('{followControlsVisible}', this.onFollowControlsVisibilityChange, this);
  viewModel.bind('{_photosLoaded}', function(loaded) {
    if (loaded) {
      viewModel.set('nPushpinPhotos', viewModel.get('photos').getCount());
    }
  }, this);
}, setPushpinFlyoutState:function(state) {
  var tip = this.getView(), record = this.getViewModel().get('pushpin');
  this.recordClone = this.getViewModel().get('pushpin').clone();
  if (this.newPushpin) {
    state = 'edit';
    this.newPushpin = undefined;
  }
  switch(state) {
    case 'edit':
      tip.setActiveItem(1);
      var pushpinShareButton = this.lookupReference('pushpinShareButton');
      this.lookupReference('pushpinShareButton').initialize(record.get('ShareTypeID'), record.get('MemberList'));
      this.lookupReference('pushpinLabelField').setValue(tip.title);
      if (!record.get('IsOwner')) {
        pushpinShareButton.disable();
      }
      break;
    default:
      tip.setActiveItem(0);
  }
  tip.showAt(this.pinCoords);
}, onPushpinEdit:function() {
  this.setPushpinFlyoutState('edit');
}, hidePushpinFlyout:function() {
  this.getView().hide();
}, deletePushpin:function() {
  var pushpin = this.getViewModel().get('pushpin'), pushpinUID = pushpin.get('PushpinUID');
  Ext.MessageBox.confirm('Confirm Delete', 'Are you sure you want to delete this pin? This action cannot be undone. \x3cbr\x3e NOTE: Attached photos and files will not be deleted from the system.', function(btn) {
    if (btn === 'yes') {
      pushpin.erase({success:function() {
        this.getView().fireEvent('pushpindestroy', pushpinUID);
      }, scope:this});
      this.hidePushpinFlyout();
    }
  }, this);
}, movePushpin:function() {
  var floorplanViewer = this.getFloorplanViewer();
  this.hidePushpinFlyout();
  this.getView().disable();
  if (floorplanViewer) {
    floorplanViewer.setFloorplanViewerMode('movePin');
    floorplanViewer.moveSelectedPushpin();
    floorplanViewer.lookupController().positionPinMover(new MVLeaflet.LatLng(floorplanViewer.getSelectedPushpin().geometry.coordinates[1], floorplanViewer.getSelectedPushpin().geometry.coordinates[0]));
  } else {
    this.getView().fireEvent('movepushpin', this.getViewModel().get('pushpin'));
  }
}, savePushpin:function() {
  var newTitle = this.lookupReference('pushpinLabelField').value;
  if (newTitle === '(New pushpin)' || newTitle === '') {
    newTitle = ' ';
  }
  var record = this.getViewModel().get('pushpin'), pushpinShareButton = this.lookupReference('pushpinShareButton');
  record.set('PushpinLabel', newTitle);
  record.set('ShareTypeID', pushpinShareButton.getSelectedShareType());
  record.set('MemberList', pushpinShareButton.getSelectedMemberList());
  if (!record.dirty) {
    this.cancelEditPushpin();
    this.getView().enable();
  } else {
    record.save({success:function(record) {
      this.getView().setTitle(record.get('PushpinLabel'));
      this.setPushpinFlyoutState('view');
      this.getView().fireEvent('pushpinupdate', record);
    }, scope:this});
  }
}, onPushpinLoaded:function() {
  var map = this.getFloorplanViewer().getMap();
  var pushpin = this.getViewModel().get('pushpin');
  if (!pushpin || !map) {
    return;
  }
  if (!this.pinCoords) {
    var localPoint = this.getFloorplanViewer().getMap().latLngToContainerPoint(new MVLeaflet.LatLng(pushpin.get('PushpinYCoordinate'), pushpin.get('PushpinXCoordinate')));
    this.pinCoords = [localPoint.x + 25, localPoint.y - 25];
  }
  this.getViewModel().set('PunchItemID', pushpin.get('PunchItemID'));
  var tip = this.getView(), pinTitle = pushpin.get('PushpinLabel'), floorplanViewer = this.getFloorplanViewer();
  if (pinTitle.toString() == '') {
    tip.setTitle('(New pushpin)');
    this.setPushpinFlyoutState('edit');
  } else {
    tip.setTitle(pinTitle);
  }
  if (!floorplanViewer || floorplanViewer.lookupController().alreadyLoaded) {
    this.setPushpinFlyoutState('view');
  }
  this.getViewModel().set('isPhotos360Enabled', this.getViewModel().get('isPhotos360Enabled'));
}, cancelEditPushpin:function() {
  if (this.getViewModel().get('pushpin')) {
    record = this.getViewModel().get('pushpin');
    record.set('PushpinType', this.recordClone.get('PushpinType'));
    this.setPushpinFlyoutState('view');
  }
}, showPushpinFlyout:function(tipObj, coords) {
  var pushpinFlyout = this.getView();
  pushpinFlyout.show();
  pushpinFlyout.hide();
  var pushpinFlyoutTabPanelView = Ext.getCmp('fvPushpinTabPanelView');
  if (pushpinFlyoutTabPanelView) {
    pushpinFlyoutTabPanelView.setActiveTab(0);
  }
  if (coords) {
    this.pinCoords = coords;
  } else {
    this.pinCoords = undefined;
  }
  var viewModel = this.getViewModel();
  viewModel.set('_recordpushpin', null);
  viewModel.set('PushpinUID', tipObj.pushpinUID);
  var punchItemSummary = this.lookupReference('punchItemSummary');
  if (punchItemSummary) {
    viewModel.notify();
    punchItemSummary.getViewModel().set('_recordPunchItem', null);
  }
}, updatePushpinPosition:function(params) {
  this.getView().enable();
  var tipObj = {pushpinUID:params.PushpinUID};
  this.showPushpinFlyout(tipObj);
  this.newPushpin = true;
}, getFloorplanViewer:function() {
  var disp = this.getView().up('clientFloorplanViewerDisp');
  return disp ? disp.down('fvFloorplanViewer') : null;
}, cancelPushpin:function() {
  this.cancelEditPushpin();
  this.getView().enable();
}, onFollowersLoad:function(store) {
  var viewModel = this.getViewModel(), MemberUID = viewModel.get('account.MemberUID'), userFollowerModel = store.getById(MemberUID);
  if (!userFollowerModel) {
    userFollowerModel = Ext.create('sharedLookup.model.Follower', {MemberUID:MemberUID, IsSubscriber:viewModel.get('pushpin.IsSubscriber'), IsCreator:viewModel.get('pushpin.IsOwner'), NoAccess:false, MemberFirstName:viewModel.get('account.MemberUsername')});
    store.add(userFollowerModel);
  }
  viewModel.set('userFollowerModel', userFollowerModel);
}, onFollowClick:function() {
  var viewModel = this.getViewModel(), userFollowerModel = viewModel.get('userFollowerModel'), following = userFollowerModel.get('IsSubscriber');
  userFollowerModel.set('IsSubscriber', !following);
}, onFollowControlsVisibilityChange:function(visible) {
  var defaultTab = this.getViewModel().get('defaultPushpinViewTab'), pushpinView = this.getView().down('fvPushpinView'), pushpinFollowers = this.lookupReference('pushpinFollowers');
  if (!pushpinFollowers) {
    return;
  }
  if (visible) {
    pushpinFollowers.tab.show();
  } else {
    pushpinView.setActiveTab(defaultTab);
    pushpinFollowers.tab.hide();
  }
}}, 0, 0, 0, 0, ['controller.pushpinflyout'], 0, [floorplanViewer.view.pushpinFlyout, 'PushpinFlyoutController'], 0);
Ext.cmd.derive('floorplanViewer.view.pushpinFlyout.PushpinFlyoutModel', Ext.app.ViewModel, {config:{mvRecords:{pushpin:{idName:['pushpinID', 'ProjectUID'], modelName:'mdsData.model.Pushpin'}}}, data:{userFollowerModel:null}, formulas:{canEditPin:function(get) {
  return get('account.canWrite') && get('pushpin.IsOwner');
}, pushpinID:function(get) {
  return get('PushpinUID');
}, defaultPushpinViewTab:function(get) {
  return 0;
}, followControlsVisible:function(get) {
  return !!(get('project.pushpinAlbumFollowEnabled') && get('account.canWrite'));
}, followDisabled:function(get) {
  return !get('project.pushpinAlbumFollowEnabled') || get('pushpin.IsOwner');
}, isFollower:function(get) {
  return !!get('userFollowerModel.IsFollower');
}, _triggerLoad:function(get) {
  if (get('PushpinUID') && get('ProjectUID')) {
    if (get('PushpinUID') === '0000') {
      return;
    }
    get('files').load();
    get('photos').load();
  }
}, isPhotos360Enabled:function(get) {
  return get('project.isPhotos360Enabled');
}}, stores:{files:{type:'files', proxy:{type:'jsonp', api:{create:'/index.cfm?fuseaction\x3daClientFloorplanViewer.addDocumentsToPushpin', read:'/index.cfm?fuseaction\x3daClientFloorplanViewer.getPushpinFiles', destroy:'/index.cfm?fuseaction\x3daClientFloorplanViewer.removeDocumentsFromPushpin'}, extraParams:{PushpinUID:'{PushpinUID}', ProjectUID:'{ProjectUID}'}}}, photos:{model:'mdsData.model.Photo', proxy:{type:'jsonp', api:{create:'/index.cfm?fuseaction\x3daClientFloorplanViewer.addPhotosToPushpin', 
read:'/index.cfm?fuseaction\x3daClientFloorplanViewer.getPushpinPhotos', destroy:'/index.cfm?fuseaction\x3daClientFloorplanViewer.removePhotosFromPushpin', zip:'/index.cfm?fuseaction\x3daClientFloorplanViewer.zipFolderFiles'}, extraParams:{PushpinUID:'{PushpinUID}', ProjectUID:'{ProjectUID}'}}, mvAutoLoadVars:true, storeId:'pushPinFlyOutDialogPhotosStore'}, followers:{model:'sharedLookup.model.Follower', proxy:{api:{read:'/index.cfm?fuseaction\x3daClientFloorplanViewer.getPushpinFollowers', update:'/index.cfm?fuseaction\x3daClientFloorplanViewer.updatePushpinFollowers'}, 
extraParams:{PushpinID:'{PushpinUID}', PushpinUID:'{PushpinUID}', ProjectUID:'{ProjectUID}'}}, listeners:{update:function() {
  this.sync({silentSuccess:true});
}, load:'onFollowersLoad'}}}}, 0, 0, 0, 0, ['viewmodel.pushpinflyout'], 0, [floorplanViewer.view.pushpinFlyout, 'PushpinFlyoutModel'], 0);
Ext.cmd.derive('floorplanViewer.view.pushpinFlyout.PushpinFlyout', Ext.window.Window, {controller:'pushpinflyout', viewModel:{type:'pushpinflyout'}, layout:'card', title:'', anchor:'left', closeAction:'hide', width:341, maxHeight:400, autoHide:false, constrain:true, tools:[{xtype:'tool', type:'pushpin-edit', itemId:'pushpinEditTool', localized:{tooltip:'FV_Settings'}, width:15, height:15, cls:'pushpin-edit', renderTpl:['\x3cimg data-ref\x3d"toolEl" src\x3d"data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw\x3d\x3d" class\x3d"x-tool-img x-tool-gear" role\x3d"presentation"\x3e'], 
listeners:{click:'onPushpinEdit'}, bind:{hidden:'{!canEditPin}'}}, {xtype:'tool', type:'pushpin-close', localized:{tooltip:'G_Close'}, width:15, height:15, cls:'pushpin-close', renderTpl:['\x3cimg data-ref\x3d"toolEl" src\x3d"data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw\x3d\x3d" class\x3d"x-tool-img x-tool-close" role\x3d"presentation"\x3e'], listeners:{click:'hidePushpinFlyout'}}], closable:false, items:[{xtype:'fvPushpinView'}, {xtype:'fvPushpinEdit'}]}, 0, ['fvPushpinFlyout'], 
['component', 'box', 'container', 'panel', 'window', 'fvPushpinFlyout'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true, 'fvPushpinFlyout':true}, ['widget.fvPushpinFlyout'], 0, [floorplanViewer.view.pushpinFlyout, 'PushpinFlyout'], 0);
Ext.cmd.derive('floorplanViewer.view.floorplanViewer.FloorplanViewerController', Ext.app.ViewController, {hoverTimer:Ext.create('floorplanViewer.controller.HoverTimer'), photoSelectionData:Ext.create('floorplanViewer.PhotoSelectionData'), init:function() {
  var viewModel = this.getViewModel();
  viewModel.bind('{floorplan}', this.floorplanLoaded, this);
  if (app.getName() == 'clientFloorplanViewer') {
    app.addListener('startaddpunchpin', this.onStartAddPunchPin, this);
  }
  new Ext.util.KeyMap(Ext.getBody(), [{key:Ext.event.Event.ESC, handler:function() {
    var floorplanViewer = this.lookupReference('floorplanViewer');
    if (floorplanViewer.getFloorplanViewerMode().mode !== 'view') {
      floorplanViewer.setFloorplanViewerMode('view');
      floorplanViewer.loadPushpins(viewModel.get('floorplan'));
      this.lookupReference('pinPositionDialog').hide();
      this.cancelPinPosition();
    }
  }, defaultEventAction:'preventDefault', scope:this}]);
  app.addListener('photoviewerdestroy', this.onPhotoViewerDestroy, this);
  app.addListener('pinPositionOffsetXReady', this.setPinPositionOffsetX, this);
}, floorplanLoaded:function(floorplan) {
  if (!floorplan) {
    return;
  }
  var viewModel = this.getViewModel();
  viewModel.set('toggleNumbersEnabled', floorplan.get('overlayInt'));
  viewModel.set('toggleCommentsEnabled', floorplan.get('commentIcons'));
}, 'map_click':function() {
  if (this.getView().openPins) {
    this.lookupReference('pushpinFlyout').hide();
  }
}, 'map_ready':function(e) {
  var viewModel = this.getViewModel(), urlHotspot = viewModel.get('HotspotID'), urlPushpin = viewModel.get('PushpinUID'), floorplanViewer = this.lookupReference('floorplanViewer');
  if (!this.alreadyLoaded) {
    if (urlHotspot && urlHotspot != 0) {
      var hs = floorplanViewer.setSelectedHotspot(urlHotspot);
      floorplanViewer.getMap().setZoom(2, {animate:false});
      floorplanViewer.getMap().panTo({lon:hs.geometry.coordinates[0], lat:hs.geometry.coordinates[1]});
      var hotspotObject = {};
      hotspotObject.hotspotID = Number(urlHotspot);
      hotspotObject.projectID = floorplanViewer.lookupViewModel().get('floorplan').get('FPID');
      this.loadHotspotPhotos(hotspotObject);
    }
    if (urlPushpin && urlPushpin != 0) {
      floorplanViewer.setSelectedPushpin(urlPushpin);
      var pp = floorplanViewer.getSelectedPushpin();
      if (pp.geometry !== undefined) {
        floorplanViewer.getMap().setZoom(2, {animate:false});
        floorplanViewer.getMap().panTo({lon:pp.geometry.coordinates[0], lat:pp.geometry.coordinates[1]});
        var tipObj = {pushpinUID:urlPushpin};
        Ext.defer(function() {
          this.showPushpinFlyout(tipObj);
          this.alreadyLoaded = true;
        }, 500, this);
      }
    } else {
      this.alreadyLoaded = true;
    }
  }
  this.hoverTimer.setMap(floorplanViewer.getMap());
}, map_move_start:function() {
  this.lookupReference('pinPositionDialog').hide();
  if (this.getView().openPins) {
    this.lookupReference('pushpinFlyout').hide();
  }
}, 'map_move_end':function() {
  var floorplanViewer = this.lookupReference('floorplanViewer');
  if (floorplanViewer.getFloorplanViewerMode().mode !== 'view') {
    floorplanViewer.moveSelectedPushpin();
  }
}, 'pin_mover_move':function(e) {
  this.positionPinMover(e);
}, 'pushpin_click':function(e) {
  if (!this.getView().openPins || !this.lookupReference('pushpinFlyout').isDisabled()) {
    this.floorplanPushpinClick(e);
  }
}, 'pushpin_mouseover':function(e) {
  if (this.photoSelectionData.photosBeingSelected) {
    return;
  }
  var label = e.target.feature.properties.PushpinLabel, floorplanViewer = this.lookupReference('floorplanViewer');
  label = !label || !label.match(/[^\s]+/) ? mvstr['FV_No Label'] : label;
  if (floorplanViewer.getFloorplanViewerMode().mode === 'view') {
    this.hoverTimer.openPopup(Ext.bind(function() {
      (new MVLeaflet.Rrose({offset:new MVLeaflet.Point(0, 20), closeButton:false, autoPan:false})).setContent(label).setLatLng(e.latlng).openOn(floorplanViewer.getMap());
    }, this), 500);
  }
}, closeHover:function() {
  this.hoverTimer.closePopup();
}, moveSelectedPushpin:function() {
  this.lookupReference('floorplanViewer').moveSelectedPushpin();
}, closePopupAndMoveSelectedPushpin:function() {
  var floorplanViewer = this.lookupReference('floorplanViewer');
  floorplanViewer.getMap().closePopup();
  this.moveSelectedPushpin();
}, 'pushpin_new':function() {
  var floorplanViewer = this.lookupReference('floorplanViewer');
  if (this.getView().openPins) {
    this.lookupReference('pushpinFlyout').disable();
  }
  this.positionPinMover(floorplanViewer.getMap().getCenter());
  floorplanViewer.getMap().closePopup();
}, 'update_pushpin_position':function(params) {
  this.lookupReference('pushpinFlyout').lookupController().updatePushpinPosition(params);
}, 'hotspot_click':function(feature) {
  var hotspotObject = {};
  hotspotObject.hotspotID = feature.id;
  hotspotObject.projectID = this.lookupReference('floorplanViewer').lookupViewModel().get('floorplan').get('FPID');
  if (feature.properties.hotspotType == 'hotarea') {
    var URL = feature.properties.url, URLObj = Ext.Object.fromQueryString(URL.toLowerCase()), domain = Ext.Object.getKeys(URLObj)[0];
    if (domain.toLowerCase().indexOf('http') > -1) {
      window.open(URL);
    } else {
      window.location = URL;
    }
  } else {
    this.loadHotspotPhotos(hotspotObject);
  }
  if (this.getView().openPins) {
    this.lookupReference('pushpinFlyout').hide();
  }
  if (this.lookupReference('floorplanViewer').selectPhotoThumbs) {
    Ext.ComponentQuery.query('multivistaphoto')[0].getViewModel().set('selectedPhotos', null);
  }
}, 'hotspot_mouseover':function(e) {
  var ctrl = this;
  var feature = e.target.feature, targetGeo = e.target.feature.geometry;
  ctrl.hoverTimer.openPopup(Ext.bind(function() {
    this.hotspotBubble = (new MVLeaflet.Rrose({offset:new MVLeaflet.Point(0, 10), closeButton:false, autoPan:false, minWidth:300})).setContent('loading...').setLatLng([targetGeo.coordinates[1], targetGeo.coordinates[0]]);
    this.openHotspotBubble(feature);
  }, ctrl), ctrl.hoverTimer.mouseover);
}, 'hotspot_mouseout':function() {
  this.hoverTimer.closePopup(this.hoverTimer.mouseout);
}, loadHotspotPhotos:function(hotspotObject) {
  if (this.getView().showPhotoThumbs) {
    this.lookupReference('photoThumbContainer').load(hotspotObject);
  }
}, showPushpinFlyout:function(tipObj) {
  var pushpinFlyout = this.lookupReference('pushpinFlyout');
  if (pushpinFlyout) {
    pushpinFlyout.lookupController().showPushpinFlyout(tipObj);
  }
}, openHotspotBubble:function(feature) {
  var ctrl = this;
  var hotspotID = feature.id, floorplanViewer = ctrl.lookupReference('floorplanViewer'), viewModel = floorplanViewer.lookupViewModel(), projectUID = floorplanViewer.lookupViewModel().get('ProjectUID');
  if (ctrl.hoverTimer.getStatus() == ctrl.hoverTimer.TIMER_DISABLED) {
    return;
  }
  if (floorplanViewer.getFloorplanViewerMode().mode === 'view') {
    if (feature.properties.hotspotType === 'hotarea') {
      var bubbleHTML = '\x3cdiv class\x3d"photoBubble_outer"\x3e\x3cb\x3e' + feature.properties.toolTip + '\x3c/b\x3e\x3c/div\x3e';
      ctrl.hoverTimer.openPopup(Ext.bind(function() {
        (new MVLeaflet.Rrose({offset:new MVLeaflet.Point(feature.properties.width / 2, 40), closeButton:false, autoPan:false})).setContent(bubbleHTML).setLatLng(new MVLeaflet.latLng(feature.geometry.coordinates[1], feature.geometry.coordinates[0])).openOn(floorplanViewer.getMap());
      }, ctrl), 500);
    } else {
      mdsAjax.doAjaxRequest({url:'index.cfm?fuseaction\x3daClientFloorplanViewer.viewlastphotoJSON\x26hotspotID\x3d' + hotspotID + '\x26ProjectUID\x3d' + projectUID, successCallback:function(data) {
        if (!data.photoID) {
          ctrl.hoverTimer.closePopup();
          return;
        }
        if (ctrl.hoverTimer.getStatus() === ctrl.hoverTimer.TIMER_DISABLED) {
          var tpl = new Ext.XTemplate('\x3cb\x3emvstr[FV_Photo Number] {HotspotOrder} - {ShootDate:date("DATE_Full")}\x3c/b\x3e', '\x3ca class\x3d"hotspotBubblePV" href\x3d"{[this.getPhotoViewerURL(values)]}"\x3e\x3cimg class\x3d"hotspotBubblePV" width\x3d"{NewWidth}"  height\x3d"{NewHeight}" src\x3d"{ImageURL}"\x3e\x3c/a\x3e', '\x3ctpl for\x3d"comments"\x3e', '\x3cdiv class\x3d"hotspotCommentPreview"\x3e', '\x3cb\x3e{MemberFirstName} {MemberLastName}\x3c/b\x3e\x3cbr\x3e', '{CommentEntryDateTime:date("DATE_Full")}\x3cbr\x3e', 
          '{CommentEntryText}', '\x3c/div\x3e', '\x3c/tpl\x3e', '\x3ctpl if\x3d"commentCount \x26gt; 3"\x3e', '\x3ca class\x3d"hotspotBubblePV" href\x3d"{[this.getPhotoViewerURL(values)]}"\x3eView More\x3c/a\x3e', '\x3c/tpl\x3e', {getPhotoViewerURL:function(values) {
            if (viewModel.get('account.features.photoviewerVisible')) {
              return '#';
            }
            return mdslink.clientPhotoViewer + 'ProjectUID\x3d' + projectUID + '\x26PhotoGroupType\x3ds\x26ShootUID\x3d' + values.ShootUID + '\x26SelectedPhotoID\x3d' + values.photoID;
          }});
          var bubbleImg = new Image;
          bubbleImg.onload = function() {
            var newWidth = 300;
            var newHeight = newWidth * (bubbleImg.height / bubbleImg.width);
            data.NewWidth = newWidth;
            data.NewHeight = newHeight;
            ctrl.hotspotBubble.setContent(tpl.apply(data)).openOn(floorplanViewer.getMap());
            ctrl.hotspotBubble._contentNode.addEventListener('click', function(e) {
              var pvVisible = viewModel.get('account.features.photoviewerVisible');
              var pvLink = e.target.className.indexOf('hotspotBubblePV') > -1;
              if (pvVisible && pvLink) {
                app.getMainView().add({xtype:'photoviewer', photoId:'P' + data.photoID, photoGroup:Ext.create('floorplanViewer.model.PhotoGroup', {Identifier:viewModel.get('floorplan.ProjectShootTypeUID'), StartDate:data.ShootDate, 'Type':'D', Title:viewModel.get('floorplan.ProjectShootTypeDisplayLabel'), Locations:viewModel.get('floorplan.floorplanTitle') ? [viewModel.get('floorplan.floorplanTitle')] : []})}).show();
              }
            });
          };
          bubbleImg.src = data.ImageURL;
        }
        var photoID = data.photoID;
        window.openHotspotBubblePhotoID = photoID;
      }, scope:ctrl});
    }
  }
}, positionPinMover:function(mapPoint) {
  var floorplanViewer = this.lookupReference('floorplanViewer');
  if (floorplanViewer.getFloorplanViewerMode().mode == 'view') {
    return;
  }
  var map = floorplanViewer.getMap(), localPoint = map.latLngToContainerPoint(mapPoint), x = localPoint.x - floorplanViewer.pinPositionOffsetX, y = localPoint.y + floorplanViewer.pinPositionOffsetY;
  this.lookupReference('pinPositionDialog').showAt(x, y);
}, floorplanPushpinClick:function(e) {
  if (this.getView().openPins) {
    this.showPushpinFlyout({pushpinUID:e.target.feature.id, xMouse:e.originalEvent.x, yMouse:e.originalEvent.y});
  }
}, initPhotoSelection:function(menuSelection) {
  var fpv = this.lookupReference('floorplanViewer');
  this.photoSelectionData.floorplanViewer = fpv;
  this.photoSelectionData.map = fpv.getMap();
  var display = menuSelection && !this.photoSelectionData.selectionMenuActive;
  if (display) {
    var layers = fpv.hotspotLayers;
    for (var i = 0; i < layers.length; ++i) {
      layers[i].off('mouseover', fpv.hotspotMouseOverEvent);
      layers[i].off('mousemove', fpv.hotspotMouseMoveEvent);
      layers[i].off('mouseout', fpv.hotspotMouseOutEvent);
    }
    var fpvEl = this.lookupReference('floorplanViewer').getEl();
    var clickables = fpvEl.select('.leaflet-clickable');
    clickables.setStyle('cursor', 'crosshair');
    this.photoSelectionData.selectionMenuActive = true;
    fpvEl.setStyle('cursor', 'crosshair');
    var map = fpv.getMap();
    if (map) {
      map.dragging.disable();
    }
    this.photoSelectionData.layer = fpv.getMap().addLayer(fpv.pushpinSelectionLayer);
    this.photoSelectionData.enableDragging();
  } else {
    this.resetPhotoSelectionMenu();
  }
}, resetPhotoSelectionMenu:function() {
  this.photoSelectionData.removeListeners(true);
  if (this.originalMouseCursor != null) {
    this.lookupReference('floorplanViewer').getEl().setStyle('cursor', this.originalMouseCursor);
  }
  var fpv = this.lookupReference('floorplanViewer');
  var layers = fpv.hotspotLayers;
  for (var i = 0; i < layers.length; ++i) {
    layers[i].on('mouseover', fpv.hotspotMouseOverEvent);
    layers[i].on('mousemove', fpv.hotspotMouseMoveEvent);
    layers[i].on('mouseout', fpv.hotspotMouseOutEvent);
  }
  var fpvEl = this.lookupReference('floorplanViewer').getEl();
  var clickables = fpvEl.select('.leaflet-clickable');
  clickables.setStyle('cursor', 'pointer');
  var map = this.lookupReference('floorplanViewer').getMap();
  if (map) {
    map.dragging.enable();
  }
  if (this.photoSelectionData.rectangle != null) {
    this.lookupReference('floorplanViewer').getMap().removeLayer(this.photoSelectionData.rectangle);
  }
  this.lookupReference('floorplanViewer').getMap().removeLayer(this.lookupReference('floorplanViewer').pushpinSelectionLayer);
  this.lookupReference('menuSelect').toggle(false);
  this.lookupReference('selectMenu').hide();
  this.photoSelectionData.selectionMenuActive = false;
  this.photoSelectionData.selectionMade = false;
  var selectedIcons = this.lookupReference('selectHotspotsPopup');
  selectedIcons.setHtml("\x3cspan class\x3d'selectedHotspotText'\x3e" + mvstr['FV_Click and drag to sel'] + '\x3c/span\x3e');
  this.lookupReference('selectHotspotsViewBtn').disable();
}, addPushPin:function(id, optionalData) {
  var floorplanViewer = this.lookupReference('floorplanViewer'), viewModel = this.getViewModel();
  if (!viewModel.get('togglePushpinsEnabled')) {
    floorplanViewer.getMap().addLayer(floorplanViewer.pushpinLayer);
    viewModel.set('togglePushpinsEnabled', true);
  }
  if (optionalData && optionalData.WorkStatusID) {
    if (optionalData.WorkStatusID === mdsData.PunchlistValues.WORK_STATUS.NOT_STARTED) {
      viewModel.set('showNotStartedPunchpins', true);
    } else {
      if (optionalData.WorkStatusID === mdsData.PunchlistValues.WORK_STATUS.IN_PROGRESS) {
        viewModel.set('showInProgressPunchpins', true);
      } else {
        if (optionalData.WorkStatusID === mdsData.PunchlistValues.WORK_STATUS.COMPLETE) {
          viewModel.set('showCompletedPunchpins', true);
        } else {
          if (optionalData.WorkStatusID === mdsData.PunchlistValues.WORK_STATUS.ON_HOLD) {
            viewModel.set('showOnHoldPunchpins', true);
          }
        }
      }
    }
  }
  floorplanViewer.addNewPushpin(id, optionalData);
}, savePinPosition:function() {
  this.lookupReference('pinPositionDialog').hide();
  if (!this.lookupReference('floorplanViewer').hasUnsavedPinLayer) {
    this.lookupReference('floorplanViewer').updatePushpinPosition();
    this.lookupReference('pushpinFlyout').enable();
  } else {
    this.getView().fireEvent('pinsave');
  }
}, cancelPinPosition:function() {
  this.cancelPositionPushpin();
  if (this.getView().openPins) {
    this.lookupReference('pushpinFlyout').enable();
  }
}, onSearchContainerShow:function() {
  var floorplanViewer = this.lookupReference('floorplanViewer'), hotspotArray = floorplanViewer.getHotspotsArray(), pushpinArray = floorplanViewer.getPushpinsArray(), dataArray = [];
  Ext.Array.forEach(hotspotArray, function(item) {
    dataArray.push({itemLabel:mvstr['FV_Photo Number {x}'].replace('{x}', item.properties.name), itemType:'hotspot', itemId:item.id});
  });
  Ext.Array.forEach(pushpinArray, function(item) {
    dataArray.push({itemLabel:item.properties.PushpinLabel, itemType:'pushpin', itemId:item.id});
  });
  this.hotspotsStore = new Ext.data.Store({fields:[{name:'itemLabel'}, {name:'itemType'}, {name:'itemId'}], data:dataArray});
  this.lookupReference('searchCombo').bindStore(this.hotspotsStore);
}, onSelectSearchPhoto:function(comp, record, eOpts) {
  var selectedItem = record.getData(), hotspotObject = {}, floorplanViewer = this.lookupReference('floorplanViewer');
  var map = floorplanViewer.getMap();
  var item = null;
  if (selectedItem.itemType === 'hotspot') {
    hotspotObject.hotspotID = selectedItem.itemId;
    item = floorplanViewer.setSelectedHotspot(selectedItem.itemId);
    this.loadHotspotPhotos(hotspotObject);
  } else {
    if (selectedItem.itemType === 'pushpin') {
      floorplanViewer.setSelectedPushpin(selectedItem.itemId);
      item = floorplanViewer.getSelectedPushpin();
    } else {
      console.warn('** Unexpected item type: ' + selectedItem.itemType);
      return;
    }
  }
  map.setZoom(2, {animate:false});
  map.panTo({lon:item.geometry.coordinates[0], lat:item.geometry.coordinates[1]});
}, toggleNumberVisibility:function() {
  var floorplanViewer = this.lookupReference('floorplanViewer'), viewModel = floorplanViewer.lookupViewModel();
  viewModel.set('toggleNumbersEnabled', !viewModel.get('toggleNumbersEnabled'));
  this.lookupReference('floorplanViewer').toggleTileLayer();
}, displayBackpackMenuItem:function(display) {
  var layerMenu = Ext.ComponentQuery.query('layermenu')[0];
  var bpMenuItem = layerMenu.query('layermenuitem[name\x3d"backpackpano"]')[0];
  bpMenuItem.setVisible(display);
}, loadBackpackFloorplanLocations:function(backpackWalkID) {
  var ctrl = this;
  var floorplanViewer = ctrl.lookupReference('floorplanViewer');
  mdsAjax.doAjaxRequest({url:'/index.cfm?fuseaction\x3daBackpackPano.getFloorplanLocations\x26BackpackWalkID\x3d' + backpackWalkID, method:'GET', success:function(resp) {
    var obj = JSON.parse(resp.responseText);
    var d = obj.data;
    for (var i = 0; i < d.length; ++i) {
      var l = d[i];
      floorplanViewer.addBackpackPanoMarker(l.Lat, l.Lng, l, ctrl.floorplanWalks[0].WalkName, ctrl.floorplanWalks[0].UrlPrefix, backpackWalkID);
    }
  }.bind(ctrl), failure:function(resp) {
    console.error(resp);
  }.bind(ctrl)});
}, toggleBackpackPanoVisibility:function() {
  var enableMenuItems = function(enable) {
    var layerMenu = Ext.ComponentQuery.query('layermenu')[0];
    var layerMenuItems = layerMenu.query('layermenuitem');
    for (var i = 0; i < layerMenuItems.length; ++i) {
      var item = layerMenuItems[i];
      if (item.name && item.name == 'backpackpano') {
        continue;
      }
      item.setDisabled(!enable);
    }
  };
  enableMenuItems();
  var floorplanViewer = this.lookupReference('floorplanViewer');
  var viewModel = floorplanViewer.lookupViewModel();
  var enabled = viewModel.get('toggleBackpackPanoEnabled');
  if (!enabled) {
    floorplanViewer.clearFloorplanLayersForBackpackPanos();
    this.pushpinsWereVisible = viewModel.get('togglePushpinsEnabled');
    this.commentsWereVisible = viewModel.get('toggleCommentsEnabled');
    this.numbersWereVisible = viewModel.get('toggleNumbersEnabled');
    if (this.pushpinsWereVisible) {
      this.togglePinVisibility();
    }
    if (this.commentsWereVisible) {
      this.toggleCommentsVisibility();
    }
    if (this.numbersWereVisible) {
      this.toggleNumberVisibility();
    }
    enableMenuItems(false);
    this.loadBackpackFloorplanLocations(this.floorplanWalks[0].BackpackWalkID);
  } else {
    floorplanViewer.resetFloorplanLayersAfterBackpackPanos();
    if (this.pushpinsWereVisible) {
      this.togglePinVisibility();
    }
    if (this.commentsWereVisible) {
      this.toggleCommentsVisibility();
    }
    if (this.numbersWereVisible) {
      this.toggleNumberVisibility();
    }
    enableMenuItems(true);
  }
  viewModel.set('toggleBackpackPanoEnabled', !enabled);
}, backpackMarkerClicked:function(locationObj, walkName, prefix, projectUID, backpackWalkID) {
  var clientUrl = '/index.cfm?fuseaction\x3daClientPhotoViewer.view\x26ProjectUID\x3d' + projectUID + '\x26PhotoGroupType\x3dB\x26backpackWalkID\x3d' + backpackWalkID + '\x26selectedImageID\x3d' + locationObj.SphereImageID;
  window.location = clientUrl;
}, togglePinVisibility:function() {
  var floorplanViewer = this.lookupReference('floorplanViewer'), viewModel = floorplanViewer.lookupViewModel(), pushpinsVisible = !viewModel.get('togglePushpinsEnabled');
  viewModel.set('togglePushpinsEnabled', pushpinsVisible);
  if (!pushpinsVisible) {
    floorplanViewer.getMap().removeLayer(floorplanViewer.pushpinLayer);
  } else {
    floorplanViewer.getMap().addLayer(floorplanViewer.pushpinLayer);
  }
}, togglePanoVisibility:function() {
  var floorplan = this.lookupReference('floorplanViewer');
  var vm = floorplan.lookupViewModel();
  var panosVisible = !vm.get('togglePanosEnabled');
  vm.set('togglePanosEnabled', panosVisible);
  if (panosVisible) {
    floorplan.showPanoScanMarkers();
  } else {
    floorplan.removePanoScanMarkers();
  }
}, toggleCommentsVisibility:function() {
  var floorplanViewer = this.lookupReference('floorplanViewer'), viewModel = floorplanViewer.lookupViewModel();
  viewModel.set('toggleCommentsEnabled', !viewModel.get('toggleCommentsEnabled'));
  if (this._hotspotCommentsVisible) {
    floorplanViewer.getMap().removeLayer(floorplanViewer.hotspotCommentLayer);
  } else {
    floorplanViewer.getMap().addLayer(floorplanViewer.hotspotCommentLayer);
  }
  this._hotspotCommentsVisible = !this._hotspotCommentsVisible;
}, togglePunchpinVisibility:function(toggle) {
  var fpv = this.lookupReference('floorplanViewer'), viewModel = fpv.lookupViewModel(), itemId = '';
  viewModel.set(toggle, !viewModel.get(toggle));
  this.updatePunchpinVisibility();
}, updatePunchpinVisibility:function() {
  var fpv = this.lookupReference('floorplanViewer'), viewModel = fpv.lookupViewModel(), pushpins = fpv.pushpinLayer.getLayers()[0].getLayers();
  Ext.Array.forEach(pushpins, function(pin) {
    fpv.getMap().removeLayer(pin);
  });
  Ext.Array.forEach(pushpins, function(pin) {
    var pushpinType = pin.feature.properties.PushpinType;
    if (pushpinType === 9 && viewModel.get('showNotStartedPunchpins')) {
      fpv.getMap().addLayer(pin);
    } else {
      if (pushpinType === 10 && viewModel.get('showInProgressPunchpins')) {
        fpv.getMap().addLayer(pin);
      } else {
        if (pushpinType === 11 && viewModel.get('showCompletedPunchpins')) {
          fpv.getMap().addLayer(pin);
        } else {
          if (pushpinType === 12 && viewModel.get('showOnHoldPunchpins')) {
            fpv.getMap().addLayer(pin);
          } else {
            if (pushpinType === 14 && viewModel.get('showOverduePunchpins')) {
              fpv.getMap().addLayer(pin);
            } else {
              if (pushpinType === 13 && viewModel.get('showClosedPunchpins')) {
                fpv.getMap().addLayer(pin);
              }
            }
          }
        }
      }
    }
  });
}, startAddPunchPin:function() {
  this.getView().add({xtype:'punchlistwindow', renderTo:Ext.getBody(), listeners:{destroy:function() {
    this.lookupReference('menuAddPushpin').toggle();
  }, scope:this}}).showBy(Ext.getBody(), 'c-c');
}, onStartAddPunchPin:function(data) {
  if (Ext.ComponentQuery.query('photoviewer').length) {
    return;
  }
  this.addPushPin(data.PushpinTypeID, {PushpinSymbol:data.PushpinSymbol, iconAnchor:mdsData.FloorplanValues.PUNCHPIN_ICON_ANCHOR, PunchItemID:data.PunchItemID, WorkStatusID:data.WorkStatusID ? data.WorkStatusID : 0, IsNewItem:data.IsNewItem ? 1 : 0});
}, cancelPositionPushpin:function() {
  var floorplanViewer = this.lookupReference('floorplanViewer');
  if (floorplanViewer.getFloorplanViewerMode().mode !== 'view') {
    floorplanViewer.setFloorplanViewerMode('view');
    floorplanViewer.loadPushpins(floorplanViewer.lookupViewModel().get('floorplan'));
    this.lookupReference('pinPositionDialog').hide();
  }
  this.getView().fireEvent('afterpinpositioncancel');
}, reloadPins:function() {
  this.lookupReference('floorplanViewer').loadPushpins(this.getViewModel().get('floorplan'));
}, openPrintFloorplanWindow:function() {
  var wind = Ext.create('floorplanViewer.view.FloorplanExportWindow');
  wind.show();
  wind.on('exportfloorplan', function(displayHeader, displayHotspots, displayPushpins) {
    var params = Ext.Object.fromQueryString(location.search);
    var url = mdslink.server + '/index.cfm?fuseaction\x3daClientFloorplanViewer.floorplanExport2PDF\x26ProjectUID\x3d' + params.ProjectUID + '\x26FloorplanUID\x3d' + params.FloorplanUID;
    var data = {displayHeader:displayHeader, displayHotspots:displayHotspots, displayPushpins:displayPushpins};
    Ext.Ajax.postFormData(url, data, {target:'_blank'});
  });
}, getExportFileTitle:function() {
  var vm = this.getViewModel();
  return Ext.Date.format(new Date, 'ymd') + ' - Multivista - ' + vm.get('project.ProjectTitle') + ' - ' + vm.get('floorplanTitle');
}, openExportWindow:function(type) {
  if (type === 'Procore') {
    this.openExportToProcoreWindow();
  } else {
    if (type === 'PlanGrid') {
      this.openExportToPlanGridWindow();
    } else {
      if (type === 'Aconex') {
        this.openExportToAconexWindow();
      } else {
        if (type === 'BIM 360') {
          this.openBim360Window();
        } else {
          if (type === 'Bluebeam') {
            this.openExportToBluebeamWindow();
          }
        }
      }
    }
  }
}, openExportToProcoreWindow:function() {
  this.getView().add({xtype:'procorewindow-floorplanexport', renderTo:Ext.getBody(), photos:[], attachFloorplanOnly:true, fileTitle:this.getExportFileTitle()});
}, openExportToPlanGridWindow:function() {
  this.getView().add({xtype:'plangridwindow', renderTo:Ext.getBody(), photos:[], attachFloorplanOnly:true, fileTitle:this.getExportFileTitle()});
}, openExportToAconexWindow:function() {
  this.getView().add({xtype:'aconexwindow', renderTo:Ext.getBody(), photos:[], attachFloorplanOnly:true, fileTitle:this.getExportFileTitle()});
}, openExportToBluebeamWindow:function() {
  var container = this.lookupReference('floorplanTitle');
  var title = container.html;
  this.getView().add({xtype:'bluebeamwindow', renderTo:Ext.getBody(), photos:[], attachFloorplanOnly:true, flooplanTitle:title});
}, openBim360Window:function() {
  this.getView().add({xtype:'bim360window', renderTo:Ext.getBody(), photos:[], attachFloorplanOnly:true, fileTitle:this.getExportFileTitle()});
}, setSelectedMapToolAndMenu:function(mapTool, menu) {
  if (this.selectedMapTool != null && this.selectedMapTool != mapTool) {
    this.selectedMapTool.setPressed(false);
  }
  this.selectedMapTool = mapTool;
  if (this.selectedMapToolMenu != null && this.selectedMapToolMenu != menu) {
    this.selectedMapToolMenu.setVisible(false);
  }
  this.selectedMapToolMenu = menu;
}, floorplanMapClickHandler:function() {
  var cb = this.lookup('searchCombo');
  if (cb) {
    cb.collapse();
  }
  if (!this.selectedMapToolMenu || this.selectedMapToolMenu.xtype != 'selectmenu') {
    this.setSelectedMapToolAndMenu(null, null);
  }
}, getHotspotPhotoNumber:function(feature) {
  var photoNumber = feature.properties.name;
  return photoNumber;
}, 'getHotspotColorsOrIcons':function(hotspotJSON) {
  var hotspotColorsOrIcons = [];
  var legend = Ext.ComponentQuery.query('#legendImage');
  if (legend.length == 0) {
    return;
  }
  var features = hotspotJSON.features;
  features.forEach(function(element) {
    if (element.properties.hotspotType == '360pano') {
      hotspotColorsOrIcons.push('360');
    } else {
      if (element.properties.hotspotType == 'm_arrow') {
        hotspotColorsOrIcons.push('m_arrow');
      } else {
        hotspotColorsOrIcons.push(element.properties.hotspotArrowColor);
      }
    }
  });
  hotspotColorsOrIcons.forEach(function(element) {
    switch(element) {
      case 'green':
        legend[0].down('#green').setConfig({'hidden':false});
        break;
      case 'red':
        legend[0].down('#red').setConfig({'hidden':false});
        break;
      case 'blue':
        legend[0].down('#blue').setConfig({'hidden':false});
        break;
      case 'orange':
        legend[0].down('#orange').setConfig({'hidden':false});
        break;
      case 'pano_green':
        legend[0].down('#pano_green').setConfig({'hidden':false});
        break;
      case 'pano_orange':
        legend[0].down('#pano_orange').setConfig({'hidden':false});
        break;
      case 'mport_green':
        legend[0].down('#pano_green').setConfig({'hidden':false});
        break;
      case 'custom':
        break;
      case 'extra_pics':
        break;
      case 'down':
        legend[0].down('#down_green').setConfig({'hidden':false});
        break;
      case '360':
        legend[0].down('#photo_360').setConfig({'hidden':false});
        break;
      case 'm_arrow':
        legend[0].down('#m_arrow').setConfig({'hidden':false});
        break;
      default:
    }
  });
}, onPhotoViewerDestroy:function() {
  this.lookupReference('floorplanViewer').loadHotspots();
}, setPinPositionOffsetX:function(xOffset) {
  var fpv = this.lookupReference('floorplanViewer');
  fpv.pinPositionOffsetX = xOffset;
}}, 0, 0, 0, 0, ['controller.floorplanviewer'], 0, [floorplanViewer.view.floorplanViewer, 'FloorplanViewerController'], 0);
Ext.cmd.derive('floorplanViewer.view.floorplanViewer.FloorplanViewerModel', Ext.app.ViewModel, {data:{FloorplanUID:'', ProjectUID:'', PushpinUID:'', nPushpinPhotos:0, ListTypeID:'', PunchItemID:null, toggleNumbersEnabled:true, toggleCommentsEnabled:true, togglePushpinsEnabled:true, toggleBackpackPanoEnabled:false, togglePanosEnabled:false, hasPanoScanLocations:false, showNotStartedPunchpins:true, showInProgressPunchpins:true, showCompletedPunchpins:true, showOnHoldPunchpins:true, showClosedPunchpins:false, 
showOverduePunchpins:true, HotspotID:'', floorplanViewerMode:'view', floorplanInitialized:false, storeSession:Ext.create('Ext.data.Session')}, config:{mvRecords:{floorplan:{idName:['FloorplanUID', 'ProjectUID'], modelName:'floorplanViewer.model.Floorplan'}}}, formulas:{punchpinsEnabled:function(get) {
  return !!get('ListTypeID');
}, ListTypeName:function(get) {
  var ListTypeID = get('ListTypeID');
  return ListTypeID ? mdsData.PunchlistValues.LIST_DESC[ListTypeID] : '';
}, backToPlansLink:function(get) {
  return mdslink.clientPunchlistPlans + 'ListTypeID\x3d' + get('ListTypeID') + '\x26ProjectUID\x3d' + get('ProjectUID');
}, backToPlansText:function(get) {
  return mvstr['TL_Back_to_Plans_' + get('ListTypeID')];
}, floorplanTitle:function(get) {
  var fp = get('floorplan'), listType = get('ListTypeName'), displayLabel, fpTitle, shootType;
  if (fp) {
    if (fp.get) {
      displayLabel = fp.get('ProjectShootTypeDisplayLabel');
      fpTitle = fp.get('floorplanTitle');
      shootType = fp.get('ProjectShootTypeLabel');
    } else {
      if (fp.floorplanTitle) {
        fpTitle = fp.floorplanTitle;
      }
    }
  }
  fpTitle = shootType ? fpTitle ? shootType + ' - ' + fpTitle : shootType : fpTitle;
  if (config.ISARCHIVE) {
    return fpTitle;
  }
  if (listType) {
    fpTitle = listType + ' - ' + fpTitle;
  } else {
    if (displayLabel === 'Working Plans') {
      fpTitle = displayLabel + ' - ' + fpTitle;
    }
  }
  return fpTitle;
}, objIsPunchItem:function(get) {
  return get('punchpinsEnabled');
}, pinDescription:function(get) {
  return get('objIsPunchItem') ? 'Pin' : 'Pushpin';
}, _triggerPunchItemsLoad:function(get) {
  if (get('PunchItemID')) {
    get('punchItems').load();
  }
}, objectDescription:function(get) {
  return get('objIsPunchItem') ? 'item' : 'pushpin';
}, addingPushpin:function(get) {
  return get('floorplanViewerMode') == 'addNewPin';
}, canSeeMVPhotos:function(get) {
  return get('floorplan.CanHavePhotos') && get('account.MultivistaContentPermission');
}, canSeeMVPhotosAndComments:function(get) {
  return get('canSeeMVPhotos') && get('account.canRead');
}, canTogglePushpins:function(get) {
  return !get('punchpinsEnabled') && get('account.canRead');
}}, stores:{planGridProjects:{model:'planGrid.model.Project', proxy:{url:'/index.cfm?fuseaction\x3daPlanGrid.getProjects'}, autoLoad:false, listeners:{load:function(store) {
  console.log('PlanGrid projects loaded', store);
}}}}}, 0, 0, 0, 0, ['viewmodel.floorplanviewer'], 0, [floorplanViewer.view.floorplanViewer, 'FloorplanViewerModel'], 0);
Ext.cmd.derive('floorplanViewer.view.floorplanViewer.FloorplanViewer', Ext.container.Container, {controller:'floorplanviewer', viewModel:{type:'floorplanviewer'}, originalMouseCursor:null, showHotspots:true, showHotspotComments:true, hasUnsavedPinLayer:false, showMiniMap:true, showSelectionLayer:true, showZoomControls:true, showHovers:true, showMapTools:true, showPhotoThumbs:true, showTitle:true, showLegend:true, openPins:true, pinPositionOffsetY:164, pinPositionOffsetX:0, animateOptions:null, selectPhotoThumbs:false, 
flex:1, layout:{type:'vbox', align:'stretch'}, listeners:{boxready:function() {
  this.setLegendPosition();
}, resize:function(w, h, oW, oH) {
  this.setLegendPosition();
}}, bind:{legendPosition:'{!floorplan.CanHaveHotspots}', mapToolsVisible:'{floorplan}'}, setLegendPosition:function(noLegend) {
  if (noLegend || !this.showLegend) {
    return;
  }
}, setMapToolsVisible:function(visible) {
  if (visible && this.showMapTools) {
    this.down('maptoolsmenu').show();
  }
}, initComponent:function() {
  var items = [];
  var comp = this;
  if (comp.openPins) {
    items.push({xtype:'fvPushpinFlyout', reference:'pushpinFlyout', listeners:{close:'cancelEditPushpin', pushpindestroy:'reloadPins', pushpinupdate:'reloadPins'}});
  }
  if (comp.showLegend) {
    items.push({xtype:'fvLegend', itemId:'legendImage', renderTo:Ext.getBody()});
  }
  Ext.Array.push(items, [{xtype:'fvFloorplanViewer', style:'background-color: white', itemId:'floorplanViewer', height:'100%', flex:1, listeners:{map_click:'floorplanMapClickHandler', pinsloaded:function() {
    this.up('clientFloorplanViewerDisp').fireEvent('pinsloaded');
  }}, showHotspots:this.showHotspots, showHotspotComments:this.showHotspotComments, hasUnsavedPinLayer:this.hasUnsavedPinLayer, showMiniMap:this.showMiniMap, showSelectionLayer:this.showSelectionLayer, showZoomControls:this.showZoomControls, showHovers:this.showHovers, showMapTools:this.showMapTools, openPins:this.openPins, pinPositionOffsetY:this.pinPositionOffsetY, pinPositionOffsetX:this.pinPositionOffsetX, selectPhotoThumbs:this.selectPhotoThumbs, animateOptions:this.animateOptions}]);
  if (comp.showPhotoThumbs) {
    items.push({xtype:'photothumbcontainer', reference:'photoThumbContainer', selectPhotoThumbs:this.selectPhotoThumbs, bind:{hidden:'{!floorplan.CanHavePhotos}'}});
  }
  Ext.Array.push(items, [{xtype:'layermenu'}, {xtype:'selectmenu', reference:'selectMenu'}, {xtype:'pushpinmenu'}, {xtype:'exportmenu'}, {xtype:'searchcontainer', listeners:{show:'onSearchContainerShow'}}, {xtype:'pinpositiondialog', reference:'pinPositionDialog', renderTo:Ext.getBody(), hidden:true}]);
  var mainContainer = {xtype:'container', layout:{type:'hbox', align:'stretch'}, flex:1, style:'background-color: grey', items:items};
  if (comp.showMapTools) {
    mainContainer.items.push({xtype:'maptoolsmenu', reference:'mapToolsMenu', hidden:true, bind:{hidden:'{!floorplan}', disabled:'{addingPushpin}'}});
  }
  comp.items = [];
  if (comp.showTitle) {
    comp.items.push({xtype:'floorplanviewertitle'});
  }
  comp.items.push(mainContainer);
  comp.callParent(arguments);
}}, 0, ['clientFloorplanViewerDisp'], ['component', 'box', 'container', 'clientFloorplanViewerDisp'], {'component':true, 'box':true, 'container':true, 'clientFloorplanViewerDisp':true}, ['widget.clientFloorplanViewerDisp'], 0, [floorplanViewer.view.floorplanViewer, 'FloorplanViewer'], 0);
Ext.cmd.derive('floorplanViewer.view.files.multivistaPhoto.SelectByFloorplan', Ext.panel.Panel, {layout:{type:'card'}, items:[{xtype:'panel', layout:'fit', reference:'floorplanListPage', items:[{xtype:'panel', layout:'fit', items:[{xtype:'floorplanoverview', margin:'0 0 10 10', bind:{store:'{floorplans}'}, noLink:true, scrollable:{x:false, y:true}, listeners:{itemclick:'onChooseFloorplan'}}]}, {reference:'flooplanViewerPage', xtype:'panel', layout:'fit', items:[{xtype:'clientFloorplanViewerDisp', 
reference:'floorplanViewer', showMiniMap:false, selectPhotoThumbs:true, showLegend:false, viewModel:{data:{_recordfloorplan:null, FloorplanUID:null, _recordpushpin:null, PushpinUID:null, ListTypeID:0, HidePushpins:true}}}]}]}]}, 0, ['selectbyfloorplan'], ['component', 'box', 'container', 'panel', 'selectbyfloorplan'], {'component':true, 'box':true, 'container':true, 'panel':true, 'selectbyfloorplan':true}, ['widget.selectbyfloorplan'], 0, [floorplanViewer.view.files.multivistaPhoto, 'SelectByFloorplan'], 
0);
Ext.cmd.derive('floorplanViewer.view.files.multivistaPhoto.MultivistaPhoto', Ext.Panel, {controller:'multivistaphoto', viewModel:{type:'multivistaphoto'}, tbar:{ui:'white', padding:'0 20 10 10', reference:'multivistaPhotoTBar', items:[{xtype:'combo', valueField:'value', editable:false, localized:{fieldLabel:'FVCPD_Selection Mode'}, labelSeparator:'', labelAlign:'top', reference:'selectionModeCombo', bind:{store:'{selectionMode}', value:'{activeSelectionMode}'}, listeners:{change:'onSelectionModeChange'}, 
margin:'25 10 0 0'}, {xtype:'combo', localized:{fieldLabel:'FVCPD_Progression'}, labelSeparator:'', labelAlign:'top', reference:'progressionCombo', editable:false, cls:'combo-empty-black', bind:{hidden:'{!selectByShootTypeEnabled}'}, listeners:{change:'onProgressionChange'}}, '-\x3e', {xtype:'dateselectorwrapper', reference:'dateSelectorWrapper', selectorConfig:{cls:'combo-empty-black', localized:{fieldLabel:'FVCPD_Date'}, labelSeparator:'', labelAlign:'top', width:170, bind:{hidden:'{!photoFilterEnabled}'}}, 
margin:'0 10 0 0'}, {xtype:'combo', reference:'locationsCombo', queryMode:'local', localized:{fieldLabel:'FVCPD_Location', defaultValue:'FVCPD_All Locations'}, labelSeparator:'', labelAlign:'top', editable:false, displayField:'Location', valueField:'Location', bind:{hidden:'{!photoFilterEnabled}'}, listeners:{change:'onLocationChange'}}]}, fbar:{xtype:'choosephotofbar', reference:'multivistaPhotoFBar', backButtonConf:{hidden:true, reference:'mvPhotoBackBtn', bind:{hidden:'{hideFooterButtons}'}, listeners:{click:'mvPhotoBackBtnClick'}}, 
addPhotosButtonConf:{hidden:true, reference:'mvPhotoAddBtn', bind:{hidden:'{hideFooterButtons}'}, listeners:{click:'addPhotos'}}}, layout:{type:'card'}, items:[{xtype:'selectbyphoto', reference:'selectByPhoto'}, {xtype:'selectbyfloorplan', reference:'selectByFloorplan'}], bind:{activeItem:'{selectionModeCombo.selection.value}', cls:'photo-list size-{thumbSize}'}, setCls:function(cls) {
  if (!this.el) {
    this.addListener('afterrender', Ext.bind(this.setCls, this, [cls]), this, {single:true});
    return;
  }
  if (this.cls) {
    this.el.removeCls(this.cls);
  }
  this.cls = cls;
  this.el.addCls(this.cls);
}}, 0, ['multivistaphoto'], ['component', 'box', 'container', 'panel', 'multivistaphoto'], {'component':true, 'box':true, 'container':true, 'panel':true, 'multivistaphoto':true}, ['widget.multivistaphoto'], 0, [floorplanViewer.view.files.multivistaPhoto, 'MultivistaPhoto'], 0);
Ext.cmd.derive('floorplanViewer.view.files.photoFileViewer.PhotoFileViewerModel', Ext.app.ViewModel, {data:{Identifier:'', Type:'U', itemDesc:'photo', itemDescPlural:'photos', nFiles:0}, stores:{projectPhotoCategories:{type:'tree', model:'files.model.PhotoCategory', proxy:{type:'jsonp', url:'index.cfm?fuseaction\x3daClientPhotoList.getPushpinDialogTree', extraParams:{ProjectUID:'{ProjectUID}'}}, autoLoad:false, root:{text:'All Photos', expanded:true, loaded:false, type:'X', id:'X', cls:'photoCategoryRoot'}}}}, 
0, 0, 0, 0, ['viewmodel.photofileviewer'], 0, [floorplanViewer.view.files.photoFileViewer, 'PhotoFileViewerModel'], 0);
Ext.cmd.derive('floorplanViewer.view.files.photoFileViewer.PhotoFileViewer', floorplanViewer.view.files.BaseViewer, {viewModel:{type:'photofileviewer', formulas:{viewHeight:{bind:{_photosDataChanged:'{_photosDataChanged}', photos:'{photos}'}, get:function(data) {
  return data.photos.getCount() ? 370 : 104;
}}}}, height:370, bind:{height:'{viewHeight}'}, controller:'fileviewer', localized:{title:'FV_Photos'}, layout:'fit', scrollable:{x:false, y:true}, listView:{xtype:'photofilelist'}, addButton:{xtype:'button', localized:{text:'SP_Add Photo'}, ui:'orange'}, addDownloadAllButton:{xtype:'button', localized:{text:'FV_Download All'}, reference:'zipPhotos', itemId:'downloadAllButton', ui:'plain', iconCls:'icon-download-all', iconAlign:'right', listeners:{click:'onZipFilesClick'}, bind:{hidden:'{!nFiles}'}}, 
showDownloadButton:true, tbarTitle:'', initComponent:function() {
  this.addButton.itemId = 'openPhotoUpload';
  this.addButton.listeners = {click:'openFileUpload'};
  this.addButton.bind = this.addButton.bind || {};
  if (!this.addButton.bind.hidden) {
    this.addButton.bind.hidden = '{!account.canWrite}';
  }
  this.listView.reference = 'fileList';
  this.listView.listeners = {itemclick:'onFileItemClick', beforerender:'onListViewRender'};
  this.tbar = {items:['-\x3e', this.addButton]};
  if (!!this.config.includeBBar) {
    this.bbar = {items:['-\x3e', this.addDownloadAllButton]};
  }
  this.items = [this.listView];
  if (this.ui) {
    this.tbar.ui = this.ui;
  }
  if (this.showDownloadButton && !config.ISARCHIVE) {
    this.tbar.items.unshift({xtype:'button', localized:{text:'FV_Images'}, id:'imagesButton', ui:'plain', toggleGroup:'images360Toggle', listeners:{click:'onImagesButtonClick', afterrender:'onButtonsRendered'}, toggleHandler:'onButtonToggled'}, {xtype:'tbseparator', cls:'floorplanSpecific'}, {xtype:'button', text:'360', id:'images360Button', ui:'plain', toggleGroup:'images360Toggle', listeners:{click:'on360ButtonClick', afterrender:'onButtonsRendered'}, toggleHandler:'onButtonToggled', bind:{hidden:'{!isPhotos360Enabled}'}});
  }
  if (this.tbarTitle) {
    this.tbar.items.unshift({xtype:'component', cls:'x-panel-header-title-detail-form', html:this.tbarTitle});
  }
  floorplanViewer.view.files.BaseViewer.prototype.initComponent.apply(this, arguments);
}, repositionFloatingItems:Ext.emptyFn}, 0, ['photofileviewer'], ['component', 'box', 'container', 'panel', 'photofileviewer'], {'component':true, 'box':true, 'container':true, 'panel':true, 'photofileviewer':true}, ['widget.photofileviewer'], 0, [floorplanViewer.view.files.photoFileViewer, 'PhotoFileViewer'], 0);
Ext.cmd.derive('floorplanViewer.view.punchlistLocation.Floorplan', floorplanViewer.view.floorplanViewer.FloorplanViewer, {showHotspots:false, hasUnsavedPinLayer:true, showMiniMap:false, showSelectionLayer:false, showHovers:false, showMapTools:false, showPhotoThumbs:false, showTitle:false, showLegend:false, openPins:false, pinPositionOffsetY:37}, 0, ['plFloorPlan'], ['component', 'box', 'container', 'clientFloorplanViewerDisp', 'plFloorPlan'], {'component':true, 'box':true, 'container':true, 'clientFloorplanViewerDisp':true, 
'plFloorPlan':true}, ['widget.plFloorPlan'], 0, [floorplanViewer.view.punchlistLocation, 'Floorplan'], 0);
Ext.cmd.derive('photoActions.Msg', Ext.window.Window, {ui:'msgbox', buttonUi:{ok:'orange', yes:'orange', no:'orange', cancel:'grey', action:'green'}, alwaysOnTop:2, OK:1, YES:2, NO:4, CANCEL:8, OKCANCEL:9, YESNO:6, YESNOCANCEL:14, ACTION:16, CANCELACTION:24, INFO:'x-message-box-info', WARNING:'x-message-box-warning', QUESTION:'x-message-box-question', ERROR:'x-message-box-error', hideMode:'offsets', closeAction:'hide', resizable:false, scrollable:true, title:'\x26#160;', defaultMinWidth:250, defaultMaxWidth:600, 
defaultMinHeight:110, defaultMaxHeight:500, minWidth:null, maxWidth:null, minHeight:null, maxHeight:null, constrain:true, cls:['x-message-box', 'x-hidden-offsets'], layout:{type:'vbox', align:'stretch'}, shrinkWrapDock:true, defaultTextHeight:75, minProgressWidth:250, minPromptWidth:250, buttonText:{ok:'OK', yes:'Yes', no:'No', cancel:'Cancel', action:'Go'}, buttonIds:['ok', 'yes', 'no', 'cancel', 'action'], titleText:{confirm:'Confirm', prompt:'Prompt', wait:'Loading...', alert:'Attention'}, baseIconCls:'x-message-box-icon', 
ariaRole:'alertdialog', makeButton:function(btnIdx) {
  var btnId = this.buttonIds[btnIdx];
  return new Ext.button.Button({handler:this.btnCallback, itemId:btnId, scope:this, text:this.buttonText[btnId], ui:this.buttonUi[btnId], margin:'0 10 0 10', height:27, minWidth:57});
}, btnCallback:function(btn, event) {
  var me = this, value, field;
  if (event && event.type === 'keydown' && !event.isSpecialKey()) {
    event.getTarget(null, null, true).on({keyup:function(e) {
      me.btnCallback(btn, e);
    }, single:true});
    return;
  }
  if (me.cfg.prompt || me.cfg.multiline) {
    if (me.cfg.multiline) {
      field = me.textArea;
    } else {
      field = me.textField;
    }
    value = field.getValue();
    field.reset();
  }
  me.hide();
  me.userCallback(btn.itemId, value, me.cfg);
}, hide:function() {
  var me = this, cls = me.cfg ? me.cfg.cls : '';
  me.progressBar.reset();
  if (cls) {
    me.removeCls(cls);
  }
  Ext.window.Window.prototype.hide.apply(this, arguments);
}, constructor:function(cfg) {
  var me = this;
  Ext.window.Window.prototype.constructor.apply(this, arguments);
  me.minWidth = me.defaultMinWidth = me.minWidth || me.defaultMinWidth;
  me.maxWidth = me.defaultMaxWidth = me.maxWidth || me.defaultMaxWidth;
  me.minHeight = me.defaultMinHeight = me.minHeight || me.defaultMinHeight;
  me.maxHeight = me.defaultMaxHeight = me.maxHeight || me.defaultMaxHeight;
}, initComponent:function(cfg) {
  var me = this, baseId = me.id, i, button;
  me.title = me.title || '\x26#160;';
  me.iconCls = me.iconCls || '';
  me.topContainer = new Ext.container.Container({layout:'hbox', padding:10, style:{overflow:'hidden'}, items:[me.iconComponent = new Ext.Component({cls:me.baseIconCls}), me.promptContainer = new Ext.container.Container({flex:1, layout:{type:'vbox', align:'stretch'}, items:[me.msg = new Ext.Component({id:baseId + '-msg', cls:me.baseCls + '-text'}), me.textField = new Ext.form.field.Text({id:baseId + '-textfield', enableKeyEvents:true, ariaAttributes:{'aria-labelledby':me.msg.id}, listeners:{keydown:me.onPromptKey, 
  scope:me}}), me.textArea = new Ext.form.field.TextArea({id:baseId + '-textarea', height:75, ariaAttributes:{'aria-labelledby':me.msg.id}})]})]});
  me.progressBar = new Ext.ProgressBar({id:baseId + '-progressbar', margin:'0 10 10 10'});
  me.items = [me.topContainer, me.progressBar];
  me.msgButtons = [];
  for (i = 0; i < 5; i++) {
    button = me.makeButton(i);
    me.msgButtons[button.itemId] = button;
    me.msgButtons.push(button);
  }
  me.bottomTb = new Ext.toolbar.Toolbar({id:baseId + '-toolbar', ui:'footer', dock:'bottom', enableFocusableContainer:false, ariaRole:null, layout:{pack:'center'}, items:[me.msgButtons[0], me.msgButtons[1], me.msgButtons[2], me.msgButtons[3], me.msgButtons[4]]});
  me.dockedItems = [me.bottomTb];
  me.on('close', me.onClose, me);
  Ext.window.Window.prototype.initComponent.apply(this, arguments);
}, afterRender:function() {
  var me = this;
  Ext.window.Window.prototype.afterRender.apply(this, arguments);
  me.textField.labelEl.dom.removeAttribute('for');
  me.textArea.labelEl.dom.removeAttribute('for');
}, onClose:function() {
  var btn = this.msgButtons[3];
  if (btn) {
    this.btnCallback(btn);
  }
}, onPromptKey:function(textField, e) {
  var me = this;
  if (e.keyCode === e.RETURN || e.keyCode === 10) {
    if (me.msgButtons.ok.isVisible()) {
      me.msgButtons.ok.handler.call(me, me.msgButtons.ok);
    } else {
      if (me.msgButtons.yes.isVisible()) {
        me.msgButtons.yes.handler.call(me, me.msgButtons.yes);
      }
    }
  }
}, reconfigure:function(cfg) {
  var me = this, buttons = 0, hideToolbar = true, oldButtonText = me.buttonText, resizer = me.resizer, header = me.header, headerCfg = header && !header.isHeader, message = cfg && (cfg.message || cfg.msg), buttonTips = cfg.buttonTips, title, iconCls, resizeTracker, width, height, i, textArea, textField, msg, progressBar, msgButtons, wait, tool;
  me.updateButtonText();
  me.cfg = cfg = cfg || {};
  wait = cfg.wait;
  if (cfg.width) {
    width = cfg.width;
  }
  if (cfg.height) {
    height = cfg.height;
  }
  me.minWidth = cfg.minWidth || me.defaultMinWidth;
  me.maxWidth = cfg.maxWidth || me.defaultMaxWidth;
  me.minHeight = cfg.minHeight || me.defaultMinHeight;
  me.maxHeight = cfg.maxHeight || me.defaultMaxHeight;
  if ('maskClickAction' in cfg) {
    me.maskClickAction = cfg.maskClickAction;
  } else {
    delete me.maskClickAction;
  }
  if (resizer) {
    resizeTracker = resizer.resizeTracker;
    resizer.minWidth = resizeTracker.minWidth = me.minWidth;
    resizer.maxWidth = resizeTracker.maxWidth = me.maxWidth;
    resizer.minHeight = resizeTracker.minHeight = me.minHeight;
    resizer.maxHeight = resizeTracker.maxHeight = me.maxHeight;
  }
  delete me.defaultFocus;
  if (cfg.defaultFocus) {
    me.defaultFocus = cfg.defaultFocus;
  }
  me.animateTarget = cfg.animateTarget || undefined;
  me.modal = cfg.modal !== false;
  if (cfg.title != null) {
    title = cfg.title;
  } else {
    if (headerCfg && header.title != null) {
      title = header.title;
    } else {
      title = me.title;
    }
  }
  if (cfg.iconCls != null) {
    iconCls = cfg.iconCls;
  } else {
    if (headerCfg && header.iconCls != null) {
      iconCls = header.iconCls;
    } else {
      iconCls = me.iconCls;
    }
  }
  me.setTitle(title);
  me.setIconCls(iconCls);
  if (Ext.isObject(cfg.buttons)) {
    me.buttonText = cfg.buttons;
    buttons = 0;
  } else {
    me.buttonText = cfg.buttonText || me.buttonText;
    buttons = Ext.isNumber(cfg.buttons) ? cfg.buttons : 0;
  }
  Ext.each(me.buttonIds, function(buttonId) {
    me.msgButtons[buttonId].setTooltip(buttonTips && buttonTips[buttonId] || null);
  });
  buttons = buttons | me.updateButtonText();
  me.buttonText = oldButtonText;
  Ext.suspendLayouts();
  me.width = me.height = null;
  if (width || height) {
    if (width) {
      me.setWidth(width);
    }
    if (height) {
      me.setHeight(height);
    }
  }
  if (!me.rendered) {
    me.render(Ext.getBody());
  }
  me.closable = cfg.closable !== false && !wait;
  header = me.header;
  if (header) {
    tool = header.child('[type\x3dclose]');
    if (tool) {
      tool.setVisible(me.closable);
    }
    if (!cfg.title && !me.closable && !cfg.iconCls) {
      header.hide();
    } else {
      header.show();
    }
  }
  me.liveDrag = !cfg.proxyDrag;
  me.userCallback = Ext.Function.bindCallback(cfg.callback || cfg.fn || Ext.emptyFn, cfg.scope || Ext.global);
  me.setIcon(cfg.icon);
  msg = me.msg;
  if (message) {
    msg.setHtml(message);
    msg.show();
    me.ariaEl.dom.setAttribute('aria-describedby', msg.id);
  } else {
    msg.hide();
    me.ariaEl.dom.removeAttribute('aria-describedby');
  }
  textArea = me.textArea;
  textField = me.textField;
  if (cfg.prompt || cfg.multiline) {
    me.multiline = cfg.multiline;
    if (cfg.multiline) {
      textArea.setValue(cfg.value);
      textArea.setHeight(cfg.defaultTextHeight || me.defaultTextHeight);
      textArea.show();
      textField.hide();
      me.defaultFocus = textArea;
    } else {
      textField.setValue(cfg.value);
      textArea.hide();
      textField.show();
      me.defaultFocus = textField;
    }
    me.ariaEl.dom.removeAttribute('aria-describedby');
  } else {
    textArea.hide();
    textField.hide();
  }
  progressBar = me.progressBar;
  if (cfg.progress || wait) {
    progressBar.show();
    me.updateProgress(0, cfg.progressText);
    me.defaultFocus = progressBar;
    if (wait) {
      progressBar.wait(wait === true ? cfg.waitConfig : wait);
    }
  } else {
    progressBar.hide();
  }
  msgButtons = me.msgButtons;
  for (i = 0; i < 5; i++) {
    if (buttons & Math.pow(2, i)) {
      if (!me.defaultFocus) {
        me.defaultFocus = msgButtons[i];
      }
      msgButtons[i].show();
      hideToolbar = false;
    } else {
      msgButtons[i].hide();
    }
  }
  if (hideToolbar) {
    me.bottomTb.hide();
  } else {
    me.bottomTb.show();
  }
  if (cfg.transparentModal) {
    this.modalMaskCls = 'modal-transparent';
    if (this.zIndexManager.mask) {
      this.zIndexManager.mask.addCls('modal-transparent');
    }
  } else {
    this.modalMaskCls = 'dark-mask';
    if (this.zIndexManager.mask) {
      this.zIndexManager.mask.removeCls('modal-transparent');
    }
  }
  Ext.resumeLayouts(true);
}, updateButtonText:function() {
  var me = this, buttonText = me.buttonText, buttons = 0, btnId, btn;
  for (btnId in buttonText) {
    if (buttonText.hasOwnProperty(btnId)) {
      btn = me.msgButtons[btnId];
      if (btn) {
        if (me.cfg && me.cfg.buttonText) {
          buttons = buttons | Math.pow(2, Ext.Array.indexOf(me.buttonIds, btnId));
        }
        if (btn.text !== buttonText[btnId]) {
          btn.setText(buttonText[btnId]);
        }
      }
    }
  }
  return buttons;
}, show:function(cfg) {
  cfg = cfg || {};
  if (cfg.icon == 'warning') {
    this.addCls('left-align');
  } else {
    this.removeCls('left-align');
  }
  var me = this, visibleFocusables;
  cfg = cfg || {};
  if (Ext.Component.layoutSuspendCount) {
    Ext.on({resumelayouts:function() {
      me.show(cfg);
    }, single:true});
    return me;
  }
  me.reconfigure(cfg);
  if (cfg.cls) {
    me.addCls(cfg.cls);
  }
  visibleFocusables = me.query('textfield:not([hidden]),textarea:not([hidden]),button:not([hidden])');
  me.preventFocusOnActivate = !visibleFocusables.length;
  Ext.window.Window.prototype.show.call(this);
  return me;
}, onShow:function() {
  Ext.window.Window.prototype.onShow.apply(this, arguments);
  this.center();
}, updateText:function(text) {
  this.msg.setHtml(text);
}, setIcon:function(icon, width, height) {
  var me = this, iconCmp = me.iconComponent, cls = me.messageIconCls;
  if (cls) {
    iconCmp.removeCls(cls);
  }
  if (icon) {
    iconCmp.show();
    if (width || height) {
      iconCmp.setSize(width || iconCmp.getWidth(), height || iconCmp.getHeight());
    }
    iconCmp.addCls('x-dlg-icon');
    iconCmp.addCls(me.messageIconCls = icon);
  } else {
    iconCmp.removeCls('x-dlg-icon');
    iconCmp.hide();
  }
  return me;
}, updateProgress:function(value, progressText, message) {
  this.progressBar.updateProgress(value, progressText);
  if (message) {
    this.updateText(message);
  }
  return this;
}, onEsc:function() {
  if (this.closable !== false) {
    Ext.window.Window.prototype.onEsc.apply(this, arguments);
  }
}, confirm:function(cfg, message, fn, scope) {
  if (Ext.isString(cfg)) {
    cfg = {title:cfg, icon:this.QUESTION, message:message, buttons:this.YESNO, callback:fn, scope:scope};
  }
  return this.show(cfg);
}, prompt:function(title, message, fn, scope, multiline, value) {
  if (Ext.isString(title)) {
    title = {prompt:true, title:title, minWidth:this.minPromptWidth, message:message, buttons:this.OKCANCEL, callback:fn, scope:scope, multiline:multiline, value:value};
  }
  return this.show(title);
}, wait:function(message, title, config) {
  if (Ext.isString(message)) {
    message = {title:title, message:message, closable:false, wait:true, modal:true, minWidth:this.minProgressWidth, waitConfig:config};
  }
  return this.show(message);
}, alert:function(title, message, fn, scope) {
  if (Ext.isString(title)) {
    title = {title:title, message:message, buttons:this.OK, fn:fn, scope:scope, minWidth:this.minWidth};
  }
  return this.show(title);
}, progress:function(title, message, progressText) {
  if (Ext.isString(title)) {
    title = {title:title, message:message, progress:true, progressText:progressText};
  }
  return this.show(title);
}}, 1, ['mdsmessagebox'], ['component', 'box', 'container', 'panel', 'window', 'mdsmessagebox'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true, 'mdsmessagebox':true}, ['widget.mdsmessagebox'], 0, [photoActions, 'Msg'], function(MessageBox) {
  Ext.onInternalReady(function() {
    Ext.namespace('MDS');
    MDS.Msg = new MessageBox;
  });
});
Ext.cmd.derive('photoActions.view.widget.PrintSelectionWindow', Ext.window.Window, {id:'printSelectionWindow', config:{action:'print'}, localized:{title:'PUL_Select Export Layout'}, modal:true, modalMaskCls:'dark-mask', resizable:false, layout:{type:'hbox', pack:'stretch'}, closeAction:'hide', defaults:{xtype:'panel', layout:{type:'vbox', align:'center'}, style:'cursor: pointer'}, alwaysOnTop:2, items:[{localized:{title:'PUL_Photo Only'}, items:[{xtype:'label', localized:{text:'PUL_Photo with caption'}, 
margin:10}, {xtype:'image', src:'mds/image/pdftype_standard.png', width:274, height:265, margin:'0 10px 10px 10px'}]}, {localized:{title:'PUL_Photo \x26 Info'}, items:[{xtype:'label', localized:{text:'PUL_Siteplan / Floorplan '}, margin:10}, {xtype:'image', src:'mds/image/pdftype_4view.png', width:247, height:265, margin:'0 0 10px 0'}]}], listeners:{afterrender:function(printSelectionWindow) {
  printSelectionWindow.items.getAt(0).el.addListener('click', function() {
    printSelectionWindow.fireEvent('choosetype', 'standard', printSelectionWindow);
  });
  printSelectionWindow.items.getAt(1).el.addListener('click', function() {
    printSelectionWindow.fireEvent('choosetype', '4view', printSelectionWindow);
  });
}}}, 0, 0, ['component', 'box', 'container', 'panel', 'window'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true}, 0, 0, [photoActions.view.widget, 'PrintSelectionWindow'], 0);
Ext.cmd.derive('photoActions.model.Album', Ext.data.Model, {fields:[{name:'AlbumUID', type:'string', defaultValue:''}, {name:'AlbumName', type:'string'}, {name:'AlbumDescription', type:'string', defaultValue:''}, {name:'photos', type:'auto', defaultValue:[]}, {name:'ShareTypeID', type:'int', defaultValue:1}, {name:'MemberArray', type:'auto', defaultValue:[]}, {name:'IsSystemAlbum', type:'boolean'}, {name:'IsFavouritesAlbum', type:'boolean'}, {name:'IsUserAlbum', type:'boolean'}], idProperty:'AlbumUID', 
proxy:{api:{create:'/index.cfm?fuseaction\x3daClientPhotoList.createAlbum', update:'/index.cfm?fuseaction\x3daClientPhotoList.updateAlbum'}, writer:{writeAllFields:true}}}, 0, 0, 0, 0, 0, 0, [photoActions.model, 'Album'], 0);
Ext.cmd.derive('photoActions.view.widget.CreateAlbumWindow', Ext.window.Window, {id:'createAlbumWindow', title:'Album Settings', layout:{type:'vbox', align:'stretch'}, modal:true, modalMaskCls:'dark-mask', closeAction:'destroy', bodyPadding:5, defaults:{labelWidth:110}, items:[{id:'newAlbumName', itemId:'albumName', xtype:'textfield', fieldLabel:'Album Name', allowBlank:false, maxLength:255, enforceMaxLength:true, width:380}, {id:'newAlbumDescription', itemId:'albumDescription', xtype:'textareafield', 
fieldLabel:'Album Description', maxLength:255, enforceMaxLength:true, width:380}, {xtype:'container', layout:'hbox', margin:'10 0 10 0', items:[{xtype:'component', html:'Sharing Settings:', margin:'2 20 0 0'}, {xtype:'shareWithButton', id:'shareWithButton', fieldLabel:'Sharing Settings'}]}, {xtype:'container', layout:{type:'hbox', align:'stretch'}, margin:'5 0 0 0', items:[{id:'deleteAlbumAction', xtype:'button', text:'Delete Album', icon:'mds/image/icon/delete.png', hidden:true}, {xtype:'tbfill'}, 
{id:'saveNewAlbumAction', xtype:'button', text:'Save', icon:'mds/image/icon/disk_blue.png'}]}], constructor:function(config) {
  Ext.window.Window.prototype.constructor.apply(this, arguments);
  var eventProperties = {'Object Type':'Album', 'Context':'Album Settings Dialog (New Album)'};
  if (config && config.album) {
    eventProperties['Context'] = 'Album Settings Dialog (Existing Album)';
    this.down('#albumName').setValue(config.album.get('AlbumName'));
    this.down('#albumDescription').setValue(config.album.get('AlbumDescription'));
    this.down('shareWithButton').initialize(config.album.get('ShareTypeID'), config.album.get('MemberArray'));
  }
  analytics.Ctrl.setOptionalDefaultEventProperties(eventProperties);
}}, 1, ['createAlbumWindow'], ['component', 'box', 'container', 'panel', 'window', 'createAlbumWindow'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true, 'createAlbumWindow':true}, ['widget.createAlbumWindow'], 0, [photoActions.view.widget, 'CreateAlbumWindow'], 0);
Ext.cmd.derive('photoActions.view.photosettings.PhotoSettingsModel', Ext.app.ViewModel, {data:{saving:false, saveDone:false, _photoDate:-1, shareSettingsDirty:false}, formulas:{photoDate:{get:function(get) {
  var photoDate = get('_photoDate');
  if (photoDate != -1) {
    return photoDate;
  }
  return get('initialDate');
}, set:function(value) {
  this.set('_photoDate', value);
}}, initialDate:function(get) {
  var store = get('selectedPhotos'), count = store.getCount();
  if (!count) {
    return null;
  }
  var date = store.getAt(0).get('PhotoDate');
  for (var i = 1; i < count; i++) {
    var dateI = store.getAt(i).get('PhotoDate');
    if (!Ext.Date.isEqual(date, dateI)) {
      return null;
    }
  }
  return date;
}, dateEntryOK:function(get) {
  if (!get('dateEntry.dirty')) {
    return true;
  }
  return get('dateEntry.valid');
}, hasChanges:function(get) {
  return !!(get('dateEntry.dirty') || get('shareSettingsDirty'));
}, canSave:function(get) {
  return get('hasChanges') && get('dateEntryOK');
}}}, 0, 0, 0, 0, ['viewmodel.photosettings'], 0, [photoActions.view.photosettings, 'PhotoSettingsModel'], 0);
Ext.cmd.derive('photoActions.view.photosettings.PhotoSettingsController', Ext.app.ViewController, {config:{initialShareTypeID:null, initialMemberUIDList:null}, init:function() {
  analytics.Ctrl.setOptionalDefaultEventProperties({'Object Type':'Photo', 'Context':'Edit Date and Sharing Dialog'});
  var b1 = this.getViewModel().bind('{selectedPhotos}', function(selectedPhotos) {
    if (!selectedPhotos) {
      return;
    }
    var count = selectedPhotos.getCount();
    if (!count) {
      return;
    }
    var shareTypeID = selectedPhotos.getAt(0).get('ShareTypeID'), memberUIDs = selectedPhotos.getAt(0).get('MemberUIDs') || [];
    for (var i = 1; i < count; i++) {
      var shareTypeIdI = selectedPhotos.getAt(i).get('ShareTypeID');
      if (shareTypeIdI != shareTypeID) {
        shareTypeID = -1;
      }
      var memberUIDsI = selectedPhotos.getAt(i).get('MemberUIDs') || [];
      if (!Ext.Array.equals(Ext.Array.sort(memberUIDs), Ext.Array.sort(memberUIDsI))) {
        memberUIDs = [];
      }
    }
    this.setInitialShareTypeID(shareTypeID);
    this.setInitialMemberUIDList(memberUIDs.join(','));
    b1.destroy();
  }, this);
}, updateInitialShareTypeID:function(value) {
  this.lookupReference('shareWithButton').getViewModel().set('initialShareTypeID', value);
}, updateInitialMemberUIDList:function(value) {
  this.lookupReference('shareWithButton').getViewModel().set('initalShareMemberList', value);
}, onShareTypeSelectionChange:function(selectionData) {
  var shareTypeID = selectionData.selectedShareType, memberUIDList = selectionData.selectedMemberList;
  memberUIDList = memberUIDList || '';
  memberUIDList = Ext.Array.sort(memberUIDList.split(','));
  this.getViewModel().set('shareSettingsDirty', !!(shareTypeID != this.getInitialShareTypeID() || memberUIDList != this.getInitialMemberUIDList()));
}, save:function() {
  var vm = this.getViewModel(), params = {}, eventProperties = {};
  if (vm.get('shareSettingsDirty')) {
    var shareButton = this.lookupReference('shareWithButton'), shareMemberUIDs = shareButton.getSelectedMemberArray();
    params.ShareTypeID = shareButton.getSelectedShareType();
    if (params.ShareTypeID == 3) {
      params.MemberUIDs = Ext.encode(shareMemberUIDs);
    } else {
      shareMemberUIDs = [];
    }
    eventProperties = permissions.Values.getPermissionEventProperties(params.ShareTypeID);
    if (shareMemberUIDs.length) {
      eventProperties['Member UIDs'] = shareMemberUIDs.join(',');
    }
  }
  var date = this.lookupReference('dateEntry').getDate();
  if (vm.get('dateEntry.dirty')) {
    params.UDEFPhotoDate = Ext.Date.format(date, 'Y-m-d');
    eventProperties['Date'] = analytics.Ctrl.getDateString(date);
  }
  var UDEFPhotoUIDs = [];
  vm.get('selectedPhotos').each(function(rec) {
    UDEFPhotoUIDs.push(rec.get('Identifier'));
  });
  params.UDEFPhotoUIDs = Ext.encode(UDEFPhotoUIDs);
  analytics.Ctrl.log('Confirmed Photo Properties', eventProperties);
  vm.set('saving', true);
  Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daClientPhotoList.updatePhotos', params:params, successCallback:function() {
    vm.set('saveDone', true);
    this.getView().fireEvent('changedphotos', {date:params.UDEFPhotoDate ? date : null, photoIdentifiers:UDEFPhotoUIDs, ShareTypeID:params.ShareTypeID, MemberUIDs:params.ShareTypeID ? shareMemberUIDs : null});
    Ext.defer(function() {
      var view = this.getView();
      if (view) {
        view.destroy();
      }
    }, 1000, this);
  }, afterFailMessageCallback:function(data, message) {
    vm.set('saving', false);
    vm.set('errorMessage', message ? message : mvstr.G_UnexpectedError);
  }, scope:this});
}}, 0, 0, 0, 0, ['controller.photosettings'], 0, [photoActions.view.photosettings, 'PhotoSettingsController'], 0);
Ext.cmd.derive('photoActions.view.photosettings.PhotoSettings', Ext.window.Window, {viewModel:{type:'photosettings'}, controller:'photosettings', ui:'orange', cls:'photo-actions-window', title:'Edit Date and Sharing', modal:true, padding:'28 20 24 20', width:426, height:336, layout:{type:'hbox'}, items:[{xtype:'container', height:'100%', width:230, layout:{type:'vbox'}, items:[{xtype:'component', cls:'instructions', html:"\x3cb\x3eSet a new date\x3c/b\x3e\x3cbr/\x3e\x3cdiv\x3eThis will make the date of the photos you've selected the same.\x3c/div\x3e", 
width:230, margin:'0 0 30 0'}, {xtype:'textdate', margin:'0 0 45 0', reference:'dateEntry', bind:{date:'{photoDate}', initialDate:'{initialDate}'}}, {xtype:'container', layout:{type:'hbox'}, items:[{xtype:'component', html:'\x3cb\x3eShare Settings\x3c/b\x3e', padding:'2 0 0 0'}, {xtype:'shareWithButton', reference:'shareWithButton', menuUi:'white', ui:'plain', margin:'0 0 0 25', listeners:{selectionChange:'onShareTypeSelectionChange'}}], width:230}]}, {xtype:'container', width:154, items:[{xtype:'photoselectionthumb'}]}], 
dockedItems:[{xtype:'container', dock:'bottom', layout:{type:'hbox', pack:'center'}, padding:'25 0 0 0', items:[{xtype:'button', scale:'medium', ui:'grey', text:'Cancel', margin:'0 12 0 12', listeners:{click:function() {
  this.up('window').destroy();
}}}, {xtype:'savebutton', reference:'saveButton', bind:{processing:'{saving}', done:'{saveDone}', disabled:'{!canSave}'}, margin:'0 12 0 12', listeners:{click:'save'}}]}]}, 0, ['photosettings'], ['component', 'box', 'container', 'panel', 'window', 'photosettings'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true, 'photosettings':true}, ['widget.photosettings'], 0, [photoActions.view.photosettings, 'PhotoSettings'], 0);
Ext.cmd.derive('photoActions.controller.ToolbarActions', Ext.app.Controller, {MAXSAVEDPHOTOS:Infinity, MAXEXPORTPHOTOS:25, MAXPRINTPHOTOS:Infinity, MAXDIRECTEXPORTPHOTOS:10, MAXDIRECTSAVEPHOTOS:10, MAXINTEGRATIONPHOTOS:10, statics:{PHOTOSPERPDF:100, PHOTOSPERZIP:1000, getTimeEstimate:function(totalSeconds) {
  var hours = Math.floor(totalSeconds / 3600), minutes = Math.ceil((totalSeconds - hours * 3600) / 60), minuteDesc = '', hoursDesc = '', descs = [];
  if (minutes == 1) {
    minuteDesc = '1 min';
  }
  if (minutes > 1 && minutes != 60) {
    minuteDesc = minutes + ' mins';
  }
  if (minutes == 60) {
    hours++;
  }
  if (hours == 1) {
    hoursDesc = '1 hr';
  }
  if (hours > 1) {
    hoursDesc = hours + ' hrs';
  }
  if (hoursDesc) {
    descs.push(hoursDesc);
  }
  if (minuteDesc) {
    descs.push(minuteDesc);
  }
  return descs.join(' ');
}, doEmailPDF:function(url, params) {
  var message = mvstr['PA_The photo export PDF '] + '\x3cbr\x3e\x3cbr\x3e' + mvstr['PA_Estimated time'] + ': ', photosPerPDF = photoActions.controller.ToolbarActions.PHOTOSPERPDF;
  if (params.photos && params.photos.length > photosPerPDF) {
    var nPDFs = Math.ceil(params.photos.length / photosPerPDF);
    message = mvstr['PA_The photo export PDFs'] + '\x3cbr\x3e' + mvstr['PA_Because a high number'].replace('{x}', nPDFs) + '\x3cbr\x3e\x3cbr\x3e' + mvstr['PA_Estimated time'] + ': ';
  }
  if (params.photos) {
    params.photos = params.photos.join(',');
  }
  Ext.Ajax.request({url:url, jsonData:params, successCallback:function(data) {
    var timeEstimate = photoActions.controller.ToolbarActions.getTimeEstimate(data.TotalTimeEstimate);
    if (data.AlreadyExists) {
      message = mvstr['PA_Please wait for your '] + '\x3cbr\x3e\x3cbr\x3e' + mvstr['PA_Estimated time for al'] + ': ' + timeEstimate;
    } else {
      message = message + timeEstimate;
    }
    if (nPDFs > 1) {
      message += '\x3cbr\x3e\x3ci\x3e' + mvstr['PA_BatchDelayWarning'] + '\x3c/i\x3e';
    } else {
      if (data.Priority > 1) {
        message += '\x3cbr\x3e\x3ci\x3e' + mvstr['PA_QueueDelayWarning'] + '\x3c/i\x3e';
      }
    }
    photoActions.controller.ToolbarActions.showOrangeMessage(mvstr['PA_Emailing Large Photo '], message);
  }});
}, doEmailZip:function(url, params) {
  var message = mvstr['PA_The photos will be em'] + '\x3cbr\x3e\x3cbr\x3e' + mvstr['PA_Estimated time'] + ': ', photosPerZIP = photoActions.controller.ToolbarActions.PHOTOSPERZIP;
  if (params.photos && params.photos.length > photosPerZIP) {
    var nZIPs = Math.ceil(params.photos.length / photosPerZIP);
    message = mvstr['PA_The photos will be em'] + '\x3cbr\x3e' + mvstr['PA_LargeZIPMessage'].replace('{x}', nZIPs) + '\x3cbr\x3e\x3cbr\x3e' + mvstr['PA_Estimated time'] + ': ';
  }
  if (params.photos) {
    params.photos = params.photos.join(',');
  }
  Ext.Ajax.request({url:url, jsonData:params, successCallback:function(data) {
    if (data.AlreadyExists) {
      message = mvstr['PA_Please wait for your '] + '\x3cbr\x3e\x3cbr\x3e' + mvstr['PA_Estimated time for al'] + ': ' + photoActions.controller.ToolbarActions.getTimeEstimate(data.TotalTimeEstimate);
    } else {
      message = message + photoActions.controller.ToolbarActions.getTimeEstimate(data.TotalTimeEstimate);
    }
    if (nZIPs > 1) {
      message += '\x3cbr\x3e\x3ci\x3e' + mvstr['PA_BatchDelayWarning'] + '\x3c/i\x3e';
    } else {
      if (data.Priority > 1) {
        message += '\x3cbr\x3e\x3ci\x3e' + mvstr['PA_QueueDelayWarning'] + '\x3c/i\x3e';
      }
    }
    photoActions.controller.ToolbarActions.showOrangeMessage(mvstr['PA_EmailPhotoZIP'], message);
  }});
}, showOrangeMessage:function(title, message, buttonText, buttonConfig) {
  buttonText = buttonText || {ok:Ext.Msg.buttonText.ok};
  buttonConfig = buttonConfig || 1;
  Ext.Msg.show({title:title, message:message, buttonText:buttonText, buttons:buttonConfig});
}, showLimitMessage:function(actionName, nPhotos, maxPhotos) {
  var nToRemove = nPhotos - maxPhotos;
  Ext.Msg.alert(mvstr['PA_Limit Exceeded'], mvstr['PA_Limit_' + actionName].replace('{x}', maxPhotos) + ' Please remove ' + nToRemove + ' photos and try again.');
}}, init:function() {
  this.control({'#emailPhotosAction':{click:function() {
    var photos = this.interfaceControl.getSelectedPhotoIDs();
    var nPhotos = photos.length;
    if (nPhotos > this.MAXEXPORTPHOTOS) {
      this.self.showLimitMessage('email', nPhotos, this.MAXEXPORTPHOTOS);
      return;
    }
    this.getExportWindow('email').show();
  }}, '#printPhotosAction':{click:function() {
    var photos = this.interfaceControl.getSelectedPhotoIDs();
    var nPhotos = photos.length;
    if (nPhotos > this.MAXPRINTPHOTOS) {
      this.self.showLimitMessage('print', nPhotos, this.MAXPRINTPHOTOS);
      return;
    }
    var psWindow = this.getExportWindow('print');
    psWindow.show();
  }}, '#printSelectionWindow':{choosetype:function(printType, printSelectionWindow) {
    var photos = this.interfaceControl.getSelectedPhotoIDs();
    var snapshotType = this.getSnapshotType();
    var printAction = printSelectionWindow.action;
    printSelectionWindow.hide();
    if (snapshotType) {
      var photo360 = {};
      if (snapshotType == '360Pano') {
        photo360.PhotoID = photos[0];
        var angle = this.interfaceControl.getPannellumViewerAngle();
        if (Ext.isNumber(angle)) {
          photo360.FOVAngle = angle;
        }
      }
      this.saveSnapshotToUDEF('', function(success, photos) {
        if (success) {
          this.performPrintAction(printAction, printType, photos, photo360);
        }
      }.bind(this));
    } else {
      this.performPrintAction(printAction, printType, photos);
    }
  }}, '#viewPhotosAction':{click:function() {
    Ext.Ajax.postFormData(mdslink.clientPhotoViewer + 'ProjectUID\x3d' + this.getView().getViewModel().get('ProjectUID') + '\x26PhotoGroupType\x3dX', {PhotoIDs:this.interfaceControl.getPhotoIDsByType('P').join(','), UDEFPhotoUIDs:this.interfaceControl.getPhotoIDsByType('U').join(','), WebcamPhotoUIDs:this.interfaceControl.getPhotoIDsByType('W').join(',')});
  }}, '#saveToAlbumAction':{click:function() {
    if (!this.checkSnapshotMaxPhotos('save')) {
      return;
    }
    var newPhotoViewer = this.getViewport().lookupViewModel().get('account.features.photoviewerVisible');
    if (this.interfaceControl.albumStore.hasNonSystemAlbums()) {
      if (newPhotoViewer) {
        this.getViewport().add({xtype:'photovieweralbumadd', store:this.interfaceControl.albumStore}).show();
      } else {
        var albumWindow = this.getViewport().add({xtype:'addphotostoalbum', store:this.interfaceControl.albumStore});
        albumWindow.show();
      }
    } else {
      if (newPhotoViewer) {
        this.getViewport().add({xtype:'photovieweralbumadd', store:this.interfaceControl.albumStore}).show();
      } else {
        this.makeAlbum();
      }
    }
  }}, '#saveNewAlbumAction':{click:function() {
    if (this.albumSettingsAreValid()) {
      this.saveAlbum();
    }
  }}, '#shareWithButton':{selectionChange:function(data) {
    this.interfaceControl.editAlbum.set('MemberArray', data.selectedMemberList ? data.selectedMemberList.split(',') : []);
    this.interfaceControl.editAlbum.set('ShareTypeID', data.selectedShareType);
  }}, '#saveToComputerAction':{click:function() {
    if (!this.checkSnapshotMaxPhotos('save')) {
      return;
    }
    var callback = this.savePhotoToComputer.bind(this);
    if (this.isWebcamLiveStream()) {
      this.interfaceControl.saveWebcamStreamSnapshot(callback);
    } else {
      if (this.isInteriorPano()) {
        this.interfaceControl.saveInteriorPanoSnapshotToComputer(callback);
      } else {
        if (this.is360Pano()) {
          this.interfaceControl.save360PanoSnapshotToComputer(callback);
        } else {
          this.interfaceControl.getSelectedPhotoIDs(callback);
        }
      }
    }
  }}, '#saveTimelapseAction':{click:function() {
    var vm = this.interfaceControl.getViewModel(), timelapse = vm.get('activeTimelapse');
    if (!timelapse) {
      return;
    }
    Ext.Ajax.postFormData(mdslink.server + '/index.cfm?fuseaction\x3daClientWebcam.saveTimelapse', {ProjectUID:vm.get('ProjectUID'), PhotoGroupType:'W', WebcamUID:timelapse.get('WebcamUID'), ArchivePositionID:timelapse.get('ArchivePositionID')});
  }}, '#saveMenu [cls\x3d"add-to-list-report-action"]':{click:this.onAddToListReportClick}, '#procoreButton':{click:function() {
    this.openIntegrationWindow('procorewindow');
  }}, '#aconexButton':{click:function() {
    this.openIntegrationWindow('aconexwindow');
  }}, '#planGridButton':{click:function() {
    this.openIntegrationWindow('plangridwindow');
  }}, '#bim360Button':{click:function() {
    this.openIntegrationWindow('bim360window');
  }}, '#bluebeamButton':{click:function() {
    this.openIntegrationWindow('bluebeamwindow');
  }}, '#addCommentAction':{click:'openAddComment'}, '#editDateAndSharingAction':{click:function() {
    this.openPhotoSettings();
  }}, '#deleteAction':{click:function() {
    this.deletePhotosWithCheck();
  }}, '#photoListSettings':{click:function() {
    this.openAlbumSettings(this.interfaceControl.getOpenAlbum());
  }}});
  app.addListener('startaddphototopunchitem', this.savePhotosToPunchItem, this);
  app.addListener('startaddpunchpin', function() {
    if (!this.isInteriorPano() && !this.is360Pano()) {
      Ext.Msg.alert(mvstr['G_Success'], mvstr['G_SuccessMsgShort']);
    }
  }, this);
  app.addListener('savingnewpunchitem', this.savingNewPunchItem, this);
  app.addListener('savednewpunchitem', this.savedNewPunchItem, this);
}, checkSnapshotMaxPhotos:function(actionName) {
  if (!this.canSnapshot() || this.isWebcamLiveStream()) {
    return true;
  }
  var activePhoto = this.interfaceControl.getActivePhoto(), photos = this.interfaceControl.getSelectedPhotos(), hasSnapshot = false;
  for (var i = 0; i < photos.length; i++) {
    if (photos[i].get('CanSnapshot')) {
      hasSnapshot = true;
      break;
    }
  }
  if (hasSnapshot) {
    if (photos.length > 1) {
      Ext.Msg.alert(mvstr['PA_Limit Exceeded'], mvstr['PA_Limit1_' + actionName]);
      return false;
    }
    if (photos[0].getId() != activePhoto.getId()) {
      Ext.Msg.alert(mvstr['PA_Photo Selection'], mvstr['PA_Please view the selec']);
      return false;
    }
  }
  return true;
}, performPrintAction:function(printAction, printType, photos, photo360) {
  var ProjectUID = this.getView().getViewModel().get('ProjectUID');
  if (printAction == 'print') {
    if (this.interfaceControl.print) {
      this.interfaceControl.print(printType, photos, this.MAXDIRECTEXPORTPHOTOS);
    } else {
      if (printType == '4view') {
        if (photos.length <= this.MAXDIRECTEXPORTPHOTOS) {
          Ext.Ajax.postFormData('/index.cfm?fuseaction\x3daClientPhotoList.4ViewPDF\x26ProjectUID\x3d' + ProjectUID, {photos:photos}, {target:'_blank'});
        } else {
          photoActions.controller.ToolbarActions.doEmailPDF('/index.cfm?fuseaction\x3daClientPhotoList.4ViewPDF\x26ProjectUID\x3d' + ProjectUID, {photos:photos});
        }
      } else {
        if (photos.length <= this.MAXDIRECTEXPORTPHOTOS) {
          Ext.Ajax.postFormData('/index.cfm?fuseaction\x3daClientPhotoList.4ViewPDF\x26ProjectUID\x3d' + ProjectUID + '\x26forcePhotoOnly\x3dtrue', {photos:photos}, {target:'_blank'});
        } else {
          photoActions.controller.ToolbarActions.doEmailPDF('/index.cfm?fuseaction\x3daClientPhotoList.4ViewPDF\x26ProjectUID\x3d' + ProjectUID + '\x26forcePhotoOnly\x3dtrue', {photos:photos});
        }
      }
    }
    this.logAnalyticsEvent('Printed Photos', photos);
  } else {
    if (printAction == 'email') {
      this.requestEmailExport(printType, photos, photo360);
      this.logAnalyticsEvent('Emailed Photos', photos);
    }
  }
}, requestEmailExport:function(type, photos, photo360) {
  var me = this, pushpinUID = this.getView().getViewModel().get('PushpinUID'), photosObjects = this.interfaceControl.getSelectedPhotos(), photo = photosObjects[0], photoTitle = photo.get('title'), projectTitle = me.getViewport().getViewModel().get('project.ProjectTitle'), subject = projectTitle, photoType = photo.get('Type');
  if (photoTitle) {
    if (photoType == 'P') {
      subject = subject + ' - ' + photoTitle.replace(/ - Photo \d+$/, '');
    } else {
      if (photoType == 'W') {
        subject = subject + ' - ' + photoTitle.replace(photo.get('DescLine3'), Ext.Date.format(photo.get('PhotoDate'), 'M d Y'));
      } else {
        subject = subject + ' - ' + mvstr['PAE_Photo Export'] + ' - ' + Ext.Date.format(photo.get('PhotoDate'), 'M d Y');
      }
    }
  } else {
    subject = mvstr['PAE_Multivista Photo Expo'];
  }
  subject = encodeURIComponent(subject);
  Ext.Ajax.request({useDefaults:true, url:'/index.cfm?fuseaction\x3daClientPhotoList.requestEmailExport', params:{ProjectUID:this.getView().getViewModel().get('ProjectUID'), PushpinUID:pushpinUID ? pushpinUID : '', photos:photos, Photo360:Ext.JSON.encode(photo360), type:type}, successCallback:function(data) {
    me.continueEmailExport(this.params.ProjectUID, this.params.PushpinUID, data.photoExportID, this.params.photos, this.params.type, this.params.Photo360);
    photoActions.controller.ToolbarActions.showOrangeMessage(mvstr['PAE_Export Successful!'], mvstr['PAE_Your image may be vie'] + ': \x3cbr/\x3e\x3cbr/\x3e\x3ca href\x3d"' + data.URL + '" target\x3d"_blank"\x3e' + data.URL + '\x3c/a\x3e\x3cbr/\x3e\x3cbr/\x3e\x3ca href\x3d"mailto:?body\x3dDear%20Colleague,%0A%0AThis%20link%20will%20take%20you%20to%20a%20photo%20of%20our%20project%20currently%20under%20construction:%0A%0A' + data.URL + '\x26subject\x3d' + subject + '" target\x3d"_blank"\x3e' + mvstr['PAE_Click here to send th'] + 
    '\x3c/a\x3e');
  }});
}, continueEmailExport:function(projectUID, pushpinUID, photoExportID, photos, type, photo360) {
  Ext.Ajax.request({url:'/index.cfm', params:{fuseaction:'aClientPhotoList.continueEmailExport', ProjectUID:projectUID, PushpinUID:pushpinUID, photoExportID:photoExportID, photos:photos, Photo360:photo360, type:type}});
}, getExportWindow:function(action) {
  var exportWindow = Ext.getCmp('printSelectionWindow');
  if (!exportWindow) {
    exportWindow = Ext.create('photoActions.view.widget.PrintSelectionWindow', {action:action});
  } else {
    exportWindow.action = action;
  }
  return exportWindow;
}, isWebcamLiveStream:function() {
  return !!this.interfaceControl.getViewModel().get('activeStream');
}, isInteriorPano:function() {
  return this.interfaceControl.isInteriorPano ? this.interfaceControl.isInteriorPano() : false;
}, is360Pano:function() {
  return this.interfaceControl.is360Pano ? this.interfaceControl.is360Pano() : false;
}, getSnapshotType:function() {
  if (this.isInteriorPano()) {
    return 'InteriorPano';
  }
  if (this.is360Pano()) {
    return '360Pano';
  }
  return '';
}, saveSnapshotToUDEF:function(AlbumUID, callback) {
  var type = this.getSnapshotType();
  this.turnLoadingOn(mvstr['PA_Saving snapshot...']);
  this.interfaceControl['save' + type + 'SnapshotToUDEF'](AlbumUID || '', function(success, data) {
    this.turnLoadingOff();
    var photos;
    if (success && data && data.PhotoID > 0) {
      photos = ['U' + data.PhotoID];
    } else {
      var errorMsg = Ext.isString(data) ? data : mvstr['PA_Error saving snapshot'];
      Ext.Msg.alert(mvstr['G_Error'], errorMsg);
      photos = errorMsg;
    }
    callback(success, photos);
  }.bind(this));
}, makeAlbum:function(AlbumUID) {
  var addPhotosToAlbumWindow = Ext.getCmp('addPhotosToAlbumWindow');
  if (addPhotosToAlbumWindow) {
    addPhotosToAlbumWindow.destroy();
  }
  var me = this;
  var callback = function(photos) {
    var albumData = {};
    albumData.photos = photos;
    if (AlbumUID) {
      albumData.AlbumUID = AlbumUID;
    }
    me.interfaceControl.editAlbum = Ext.create('photoActions.model.Album', albumData);
    var newPhotoViewer = me.getViewport().lookupViewModel().get('account.features.photoviewerVisible');
    if (!AlbumUID) {
      if (newPhotoViewer) {
        if (me.albumSettingsAreValid()) {
          me.saveAlbum();
        }
      } else {
        me.getViewport().add({xtype:'createAlbumWindow'}).show();
      }
    } else {
      me.saveAlbum();
    }
  };
  me.interfaceControl.getSelectedPhotoIDs(callback);
}, albumSettingsAreValid:function() {
  if (!Ext.getCmp('newAlbumName').isValid()) {
    Ext.Msg.alert(mvstr['PA_Invalid Input'], mvstr['PA_Please enter a valid ']);
    return false;
  }
  this.interfaceControl.editAlbum.set('AlbumName', Ext.getCmp('newAlbumName').value);
  if (Ext.getCmp('newAlbumDescription')) {
    this.interfaceControl.editAlbum.set('AlbumDescription', Ext.getCmp('newAlbumDescription').value);
  }
  return true;
}, saveAlbum:function() {
  var me = this, createAlbumWindow = Ext.getCmp('createAlbumWindow') || Ext.ComponentQuery.query('photovieweralbumadd')[0];
  if (createAlbumWindow) {
    this.turnLoadingOn(mvstr['G_Saving ...'], createAlbumWindow);
  }
  if (this.interfaceControl.editAlbum.phantom) {
    var viewModel = me.getViewport().getViewModel(), memberList = viewModel.get('selectedShareMemberUIDList');
    this.interfaceControl.editAlbum.set('ShareTypeID', viewModel.get('account.canShare') ? viewModel.get('selectedShareTypeID') : 2);
    this.interfaceControl.editAlbum.set('MemberArray', memberList ? memberList.split(',') : []);
  }
  var isInteriorPano = this.isInteriorPano();
  var is360Pano = this.is360Pano();
  if (isInteriorPano || is360Pano) {
    this.interfaceControl.editAlbum.set('photos', []);
  }
  var photos = this.interfaceControl.editAlbum.get('photos');
  var isNewAlbum = this.interfaceControl.editAlbum.phantom;
  this.interfaceControl.editAlbum.getProxy().setExtraParams({ProjectUID:this.getViewport().getViewModel().get('ProjectUID')});
  this.interfaceControl.editAlbum.save({success:function(record, operation, data) {
    if (createAlbumWindow) {
      me.turnLoadingOff(createAlbumWindow);
    }
    var AlbumUID = data.AlbumUID ? data.AlbumUID : me.interfaceControl.editAlbum.get('AlbumUID');
    if (me.getSnapshotType()) {
      me.saveSnapshotToUDEF(AlbumUID, function(success) {
        me.albumSaved(AlbumUID, record, data, success);
      });
    } else {
      me.albumSaved(data.AlbumUID, record, data, true);
    }
    if (createAlbumWindow) {
      createAlbumWindow.destroy();
    }
    var addPhotosToAlbumWindow = Ext.getCmp('addPhotosToAlbumWindow');
    if (addPhotosToAlbumWindow) {
      addPhotosToAlbumWindow.destroy();
    }
    me.logAnalyticsEvent(isNewAlbum ? 'Saved Photos to New Album' : 'Saved Photos to Existing Album', photos, {'Album UID':record.get('AlbumUID'), 'Album Name':record.get('AlbumName')});
  }, afterFailMessageCallback:function() {
    if (createAlbumWindow) {
      me.turnLoadingOff(createAlbumWindow);
    }
  }});
}, albumSaved:function(AlbumUID, record, data, showConfirm) {
  var message, title;
  if (AlbumUID) {
    record.set('AlbumUID', AlbumUID);
    this.getApplication().fireEvent('newalbum', record, data);
    message = mvstr['PA_Album was successfull'];
    title = mvstr['PA_Album created'];
  } else {
    var userCanShare = this.mainView.getViewModel().get('account.canShare');
    message = mvstr['PA_AlbumUpdatedMsg'];
    title = mvstr['PA_Album updated'];
    if (!userCanShare) {
      if (record.get('ShareTypeID') != 2) {
        message = mvstr['GSS_This user account can'];
        title = mvstr['GSS_Sharing not changed'];
      }
      record.set('ShareTypeID', 2);
    }
    this.getApplication().fireEvent('updatedalbum', record, data);
  }
  if (showConfirm) {
    this.showAddPhotosConfirm(AlbumUID, message, title);
  }
  if (this.interfaceControl.albumStore) {
    this.interfaceControl.albumStore.load();
  }
}, showAddPhotosConfirm:function(AlbumUID, msg, title) {
  title = title || ' ';
  var buttonText = {ok:mvstr['PA_View Album'], cancel:Ext.Msg.buttonText.ok}, buttons = Ext.MessageBox.OKCANCEL;
  if (!AlbumUID) {
    buttonText = {cancel:Ext.Msg.buttonText.ok};
    buttons = Ext.MessageBox.CANCEL;
  }
  Ext.MessageBox.show({title:title, msg:msg, buttons:buttons, buttonText:buttonText, fn:Ext.bind(function(btn) {
    if (btn == 'ok') {
      var newPhotoViewer = this.getViewport().lookupViewModel().get('account.features.photoviewerVisible');
      if (newPhotoViewer && this.interfaceControl.openNewAlbumInViewer) {
        this.interfaceControl.openNewAlbumInViewer(AlbumUID);
      } else {
        document.location = mdslink.clientPhotoViewer + 'ProjectUID\x3d' + this.getView().getViewModel().get('ProjectUID') + '\x26PhotoGroupType\x3dA\x26AlbumUID\x3d' + AlbumUID;
      }
    }
  }, this)});
}, getView:function() {
  var viewport = Ext.ComponentQuery.query('photoviewer')[0];
  if (!viewport) {
    viewport = Ext.ComponentQuery.query('clientPhotoViewer')[0];
  }
  if (!viewport) {
    viewport = Ext.ComponentQuery.query("component[xtype^\x3d'clientWebcamLive']")[0];
  }
  if (!viewport) {
    viewport = Ext.ComponentQuery.query('clientPhotoList')[0];
  }
  return viewport;
}, getViewport:function() {
  var viewport = Ext.ComponentQuery.query('clientviewport')[0];
  if (!viewport) {
    viewport = this.getView();
  }
  if (!viewport) {
    viewport = this.mainView;
  }
  return viewport;
}, onAddToListReportClick:function(menuItem) {
  var photos = this.interfaceControl.getSelectedPhotos(), listTypeId = menuItem.ListTypeID, snapshotType = this.getSnapshotType();
  if (snapshotType) {
    if (this.checkSnapshotMaxPhotos('save')) {
      delete this.panoPhotoRecord;
      this.turnLoadingOn(mvstr['PA_Taking snapshot...']);
      var snapshotFn = Ext.bind(this.interfaceControl['take' + snapshotType + 'SnapshotForPunchlist'], this.interfaceControl);
      snapshotFn(function(success, base64, panoUuid) {
        this.turnLoadingOff();
        if (success) {
          this.panoPhotoRecord = Ext.create('viewerPhoto.model.Photo', {med:base64, dateTaken:new Date, panoUuid:panoUuid});
          this.showAddToPunchlistWindow(listTypeId, [this.panoPhotoRecord]);
        } else {
          Ext.Msg.alert(mvstr['G_Error'], base64);
        }
      }.bind(this));
    }
  } else {
    if (this.isWebcamLiveStream()) {
      var wcSnapshotFn = Ext.bind(this.interfaceControl.saveWebcamStreamSnapshot, this.interfaceControl);
      wcSnapshotFn(function(photo) {
        this.showAddToPunchlistWindow(listTypeId, [photo]);
        this.interfaceControl.getViewModel().set('webcamStreamSnapshot', photo);
      }.bind(this), true);
    } else {
      this.showAddToPunchlistWindow(listTypeId, photos);
    }
  }
}, showAddToPunchlistWindow:function(listTypeId, photos) {
  this.getView().add({xtype:'punchlistwindow', renderTo:Ext.getBody(), photos:photos, viewModel:{data:{ListTypeID:listTypeId, onPhotoPage:true}}}).showBy(Ext.getBody(), 'c-c?');
}, savingNewPunchItem:function(photoStore) {
  if (this.isInteriorPano()) {
    photoStore.remove(photoStore.getNewRecords());
  }
}, savedNewPunchItem:function(punchItemId) {
  if (this.isInteriorPano()) {
    this.savePanoUDEFPhotoThenAddToPunchItem(punchItemId);
  } else {
    if (this.is360Pano()) {
      this.save360PanoUDEFPhotoThenAddToPunchItem(punchItemId);
    }
  }
}, savePanoUDEFPhotoThenAddToPunchItem:function(punchItemId) {
  var jsonData = {base64Photo:this.panoPhotoRecord.get('med'), PanoUUID:this.panoPhotoRecord.get('panoUuid')};
  Ext.getBody().mask(mvstr['PA_Saving snapshot...']);
  this.interfaceControl.saveBase64ToUDEFPhoto(jsonData, function(success, data) {
    Ext.getBody().unmask();
    if (success && data && data.PhotoID > 0) {
      var photoId = 'U' + data.PhotoID;
      this.savePhotoIdsToPunchItem(punchItemId, photoId);
    } else {
      var errorMsg = Ext.isString(data) ? data : mvstr['PA_Error saving snapshot'];
      Ext.Msg.alert(mvstr['G_Error'], errorMsg);
    }
  }.bind(this));
  delete this.panoPhotoRecord;
}, save360PanoUDEFPhotoThenAddToPunchItem:function(punchItemId) {
  var jsonData = {base64Photo:this.panoPhotoRecord.get('med'), PanoUUID:this.panoPhotoRecord.get('panoUuid')};
  Ext.getBody().mask(mvstr['PA_Saving snapshot...']);
  this.interfaceControl.saveBase64ToUDEFPhoto(jsonData, function(success, data) {
    Ext.getBody().unmask();
    if (success && data && data.PhotoID > 0) {
      var photoId = 'U' + data.PhotoID;
      this.savePhotoIdsToPunchItem(punchItemId, photoId);
    } else {
      var errorMsg = Ext.isString(data) ? data : mvstr['PA_Error saving snapshot'];
      Ext.Msg.alert(mvstr['G_Error'], errorMsg);
    }
  }.bind(this));
  delete this.panoPhotoRecord;
}, savePhotosToPunchItem:function(punchItemData) {
  if (this.isInteriorPano()) {
    this.savePanoUDEFPhotoThenAddToPunchItem(punchItemData.PunchItemID);
  } else {
    if (this.is360Pano()) {
      this.save360PanoUDEFPhotoThenAddToPunchItem(punchItemData.PunchItemID);
    } else {
      if (this.isWebcamLiveStream()) {
        var snapshot = this.interfaceControl.getViewModel().get('webcamStreamSnapshot');
        this.savePhotoIdsToPunchItem(punchItemData.PunchItemID, snapshot.get('id'));
      } else {
        this.savePhotoIdsToPunchItem(punchItemData.PunchItemID, this.interfaceControl.getSelectedPhotoIDs().join(','));
      }
    }
  }
}, savePhotoIdsToPunchItem:function(punchItemId, photoIds) {
  console.log('Saving photo ids to punch item', photoIds);
  Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daClientPunchlist.addPhotosToPunchItem', jsonData:{PunchItemID:punchItemId, ProjectUID:this.getView().getViewModel().get('ProjectUID'), Photos:photoIds}, successCallback:function() {
    Ext.Msg.alert(mvstr['G_Success'], mvstr['G_SuccessMsgShort']);
  }});
}, openIntegrationWindow:function(xtype) {
  if (!this.checkSnapshotMaxPhotos('export')) {
    return;
  }
  this.getSelectedPhotoIDs().then(Ext.bind(function(photoIds) {
    var nPhotos = photoIds.length;
    if (nPhotos > this.MAXINTEGRATIONPHOTOS) {
      this.self.showLimitMessage('export', nPhotos, this.MAXINTEGRATIONPHOTOS);
      return;
    }
    var view = this.getView(), annosOn = this.getViewport().getViewModel().get('annoProps.toggledOn'), windowConfig = {xtype:xtype, renderTo:Ext.getBody(), photos:photoIds, includeAnnotations:annosOn === null ? true : annosOn, PushpinUID:this.getView().getViewModel().get('PushpinUID'), datePhoto:null}, selectedPhotos = this.interfaceControl.getSelectedPhotos();
    if (selectedPhotos.length == 1 && selectedPhotos[0].get('Type') == 'W' && selectedPhotos[0].get('PhotoDate')) {
      windowConfig.PhotoDate = selectedPhotos[0].get('PhotoDate');
    } else {
      if (selectedPhotos.length == 1 && selectedPhotos[0].get('Is360Pano')) {
        windowConfig.datePhoto = selectedPhotos[0];
        if (selectedPhotos[0].get('Type') === 'P') {
          windowConfig.Photo360ID = Number(selectedPhotos[0].getId());
        }
      }
    }
    view.add(windowConfig);
  }, this));
}, savePhotosToAlbums:function(AlbumUIDs, view, callback) {
  var albumUidList = AlbumUIDs ? AlbumUIDs.join(',') : '';
  var albumNamesList = [];
  if (AlbumUIDs.length < 1) {
    Ext.Msg.alert(mvstr['G_Error'], mvstr['PA_No album selected.']);
    return;
  }
  if (AlbumUIDs && AlbumUIDs.length && this.interfaceControl.albumStore) {
    for (var i = 0; i < AlbumUIDs.length; i++) {
      var uid = AlbumUIDs[i];
      var album = this.interfaceControl.albumStore.getById(uid);
      if (album) {
        albumNamesList.push(album.get('AlbumName'));
      }
    }
  }
  albumNamesList = albumNamesList.join(',');
  if (this.getSnapshotType()) {
    view.destroy();
    var start = (new Date).getTime();
    this.saveSnapshotToUDEF(albumUidList, Ext.bind(function(success, photos) {
      if (success) {
        if (AlbumUIDs.length === 1) {
          this.showAddPhotosConfirm(AlbumUIDs[0], mvstr['PA_The photo was success'], mvstr['PA_Photo added']);
        } else {
          Ext.Msg.alert('', mvstr['PA_AddedToAlbums'].replace('{x}', AlbumUIDs.length));
        }
        console.log('Saved snapshot, took ' + ((new Date).getTime() - start) + ' ms');
        this.logAnalyticsEvent('Saved Photos to Existing Album', photos, {'Album UIDs':albumUidList, 'Album Names':albumNamesList});
      }
    }, this));
  } else {
    if (this.isWebcamLiveStream()) {
      this.interfaceControl.saveWebcamStreamSnapshot(callback);
    } else {
      this.interfaceControl.getSelectedPhotoIDs(function(photos) {
        callback(photos);
        this.logAnalyticsEvent('Saved Photos to Existing Album', photos, {'Album UIDs':albumUidList, 'Album Names':albumNamesList});
      }.bind(this));
    }
  }
}, logAnalyticsEvent:function(eventName, photos, extraProperties) {
  if (Ext.isArray(photos)) {
    photos = photos.join(', ');
  }
  if (this.isInteriorPano()) {
    if (!extraProperties) {
      extraProperties = {};
    }
    extraProperties['Site Walk 360'] = true;
  }
  if (this.interfaceControl.$className == 'clientPhotoListNew.view.main.MainController') {
    analytics.Ctrl.log(eventName, Ext.apply({'Photo List':photos}, extraProperties), ['Photo Action Element']);
  } else {
    analytics.Ctrl.log(eventName, Ext.apply({'Photo List':photos, 'Photo Action Element':'Photo Viewer Menu'}, extraProperties));
  }
}, openAddComment:function() {
  var changedPhotos = this.interfaceControl.getViewModel().get('selectedPhotos').getRange(), nPhotos = changedPhotos.length;
  if (nPhotos > comments.view.batchaddcomment.AddCommentController.MAX_PHOTOS) {
    photoActions.controller.ToolbarActions.showLimitMessage('comment', nPhotos, comments.view.batchaddcomment.AddCommentController.MAX_PHOTOS);
    return;
  }
  this.getView().add({xtype:'batchaddcomment', listeners:{changedphotos:{fn:function(data) {
    for (var i = 0; i < changedPhotos.length; i++) {
      changedPhotos[i].set('CommentCount', changedPhotos[i].get('CommentCount') + 1);
    }
    if (this.interfaceControl.onBatchAddComments) {
      this.interfaceControl.onBatchAddComments(changedPhotos);
    }
    if (this.interfaceControl.onSelectedPhotosChange) {
      this.interfaceControl.onSelectedPhotosChange();
    }
  }, scope:this}}}).show();
}, openPhotoSettings:function() {
  var changedPhotos = this.interfaceControl.getViewModel().get('selectedPhotos').getRange();
  this.getView().add({xtype:'photosettings', listeners:{changedphotos:{fn:function(data) {
    if (this.interfaceControl.reloadPhotosAfterGroupChange) {
      this.interfaceControl.reloadPhotosAfterGroupChange(data);
    }
    for (var i = 0; i < changedPhotos.length; i++) {
      if (data.date) {
        changedPhotos[i].set('PhotoDate', data.date);
      }
      if (data.ShareTypeID) {
        changedPhotos[i].set('ShareTypeID', data.ShareTypeID);
      }
      if (data.MemberUIDs) {
        changedPhotos[i].set('MemberUIDs', data.MemberUIDs);
      }
    }
    if (this.interfaceControl.onSelectedPhotosChange) {
      this.interfaceControl.onSelectedPhotosChange();
    }
  }, scope:this}}}).show();
}, deletePhotosWithCheck:function() {
  var selectedPhotos = this.interfaceControl.getViewModel().get('selectedPhotos'), photoCount = selectedPhotos.getCount(), hasUnownedPhotos = false;
  for (var i = 0; i < photoCount; i++) {
    if (!selectedPhotos.getAt(i).get('IsOwnedByUser')) {
      hasUnownedPhotos = true;
      break;
    }
  }
  if (hasUnownedPhotos) {
    MDS.Msg.show({xtype:'mmvmsgbox', title:mvstr['PA_Delete Photos'], message:'\x3cb\x3e' + mvstr["PA_Some photos you've se"] + '\x3c/b\x3e\x3cbr/\x3e' + mvstr['PA_You are only able to '], buttonText:{action:mvstr['PA_Delete Photos'], cancel:mvstr['G_Cancel']}, icon:'warning', maxWidth:435, fn:function(btn) {
      if (btn == 'action') {
        this.deletePhotosNoCheck();
      }
    }, scope:this, transparentModal:true});
  } else {
    this.deletePhotosNoCheck();
  }
}, deletePhotosNoCheck:function() {
  var UDEFPhotoUIDs = [], selectedPhotos = this.interfaceControl.getViewModel().get('selectedPhotos');
  selectedPhotos.each(function(rec) {
    if (rec.get('Type') == 'U' && rec.get('IsOwnedByUser')) {
      UDEFPhotoUIDs.push(rec.getId());
    }
  });
  analytics.Ctrl.log('Deleted Photos', {}, ['Photo List', 'Photo Action Element']);
  Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daClientPhotoList.deletePhotos', params:{UDEFPhotoUIDs:Ext.encode(UDEFPhotoUIDs)}, successCallback:function(data) {
    if (data.UDEFPhotoUIDs.length != UDEFPhotoUIDs.length) {
      if (data.UDEFPhotoUIDs.length && data.UDEFPhotoUIDs.length < UDEFPhotoUIDs.length) {
        Ext.Msg.alert(mvstr['G_Warning'], mvstr['PA_Not all photos could ']);
      } else {
        Ext.Msg.alert(mvstr['G_Error'], mvstr['PA_No photos could be de']);
        return;
      }
    }
    if (this.interfaceControl.onPhotosDeleted) {
      this.interfaceControl.onPhotosDeleted(data);
    }
    if (this.interfaceControl.onSelectedPhotosChange) {
      this.interfaceControl.onSelectedPhotosChange();
    }
    if (this.interfaceControl.reloadPhotosAfterGroupChange) {
      this.interfaceControl.reloadPhotosAfterGroupChange({photoIdentifiers:UDEFPhotoUIDs, remove:true});
    }
  }, scope:this});
}, openAlbumSettings:function(record) {
  var memberList = record.get('memberList');
  this.interfaceControl.editAlbum = record.$className == 'clientPhotoListNew.model.PhotoCategory' ? Ext.create('photoActions.model.Album', {AlbumUID:record.get('Identifier'), AlbumName:record.get('rawText'), AlbumDescription:record.get('description'), ShareTypeID:record.get('ShareTypeID'), MemberArray:memberList ? memberList.split(',') : []}) : record;
  var albumEditWindow = this.getView().add({xtype:'plcreateAlbumWindow', album:this.interfaceControl.editAlbum});
  albumEditWindow.show();
  if (this.interfaceControl.$className == 'clientPhotoListNew.view.main.MainController') {
    Ext.getCmp('deleteAlbumAction').show();
  }
}, savePhotoToComputer:function(photos, base64Photo) {
  var nPhotos = photos.length, view = this.getView() || this.getViewport(), ProjectUID = view.getViewModel().get('ProjectUID'), activeStream = view.getViewModel().get('activeStream');
  if (nPhotos > this.MAXSAVEDPHOTOS) {
    this.self.showLimitMessage('download', nPhotos, this.MAXSAVEDPHOTOS);
    return;
  }
  if (nPhotos > this.MAXDIRECTSAVEPHOTOS) {
    photoActions.controller.ToolbarActions.doEmailZip('/index.cfm?fuseaction\x3daClientPhotoList.savePhotos\x26ProjectUID\x3d' + ProjectUID, {photos:photos});
  } else {
    if (activeStream || app.getName().indexOf('WebcamLive') !== -1) {
      var webcamUID = this.interfaceControl.WebcamUID || activeStream.WebcamUID;
      Ext.Ajax.postFormData('/index.cfm?fuseaction\x3daClientPhotoViewer.downloadCurrentImage', {id:photos, projectUID:ProjectUID, webcamUID:webcamUID});
    } else {
      Ext.Ajax.postFormData(mdslink.server + '/index.cfm?fuseaction\x3daClientPhotoList.savePhotos', {photos:photos, base64Photo:base64Photo, ProjectUID:ProjectUID});
    }
  }
  this.logAnalyticsEvent('Save Photos To Computer', photos);
}, saveSinglePhoto:function(photoId) {
  var savePhotoToComputerFn = this.savePhotoToComputer.bind(this);
  if (this.isInteriorPano()) {
    this.interfaceControl.saveInteriorPanoSnapshotToComputer(savePhotoToComputerFn, [photoId]);
  } else {
    savePhotoToComputerFn([photoId]);
  }
}, turnLoadingOn:function(text, cmp) {
  if (this.getView().xtype == 'photoviewer') {
    cmp = cmp || this.getView();
    cmp.setLoading(true);
  } else {
    cmp = cmp || Ext.getBody();
    cmp.mask(text);
  }
}, turnLoadingOff:function(cmp) {
  if (this.getView().xtype == 'photoviewer') {
    cmp = cmp || this.getView();
    cmp.setLoading(false);
  } else {
    cmp = cmp || Ext.getBody();
    cmp.unmask();
  }
}, getSelectedPhotoIDs:function() {
  return new Ext.Promise(Ext.bind(function(resolve, reject) {
    var snapshotType = this.getSnapshotType();
    if (snapshotType) {
      this.saveSnapshotToUDEF('', Ext.bind(function(success, photos) {
        if (success) {
          resolve(photos);
        } else {
          reject();
        }
      }, this));
    } else {
      resolve(this.interfaceControl.getSelectedPhotoIDs());
    }
  }, this));
}, canSnapshot:function() {
  return this.interfaceControl.canSnapshot;
}}, 0, 0, 0, 0, 0, 0, [photoActions.controller, 'ToolbarActions'], 0);
Ext.cmd.derive('photoActions.store.Albums', Ext.data.Store, {model:'photoActions.model.Album', proxy:{type:'ajax', url:'/index.cfm?fuseaction\x3daClientPhotoViewer.getAccessibleAlbums', reader:{type:'json'}}, filters:[{property:'IsSystemAlbum', value:false}, function(record) {
  var pageAlbumUID = Ext.Object.fromQueryString(document.location.search).AlbumUID;
  return pageAlbumUID && pageAlbumUID == record.get('AlbumUID') ? false : true;
}], hasNonSystemAlbums:function() {
  return this.count() ? true : false;
}, doInit:function(photoCategoriesStore, account) {
  var records = photoCategoriesStore.getRange();
  this.account = account;
  this.addRecords(records);
  photoCategoriesStore.addListener('add', function(store, records) {
    this.addRecords(records);
  }, this);
}, addRecords:function(records) {
  var userCanShare = this.account.canShare;
  for (var i = 0; i < records.length; i++) {
    if (records[i].parentNode.get('value') == 'My Albums' || userCanShare && records[i].parentNode.get('value') == 'Project Team Albums') {
      this.add({AlbumUID:records[i].get('id'), AlbumName:records[i].get('value'), IsSystemAlbum:records[i].get('type') == 'S', IsFavouritesAlbum:records[i].get('type') == 'S' && records[i].get('value') == 'My Favorites', IsUserAlbum:records[i].parentNode.get('value') == 'My Albums'});
    }
  }
  this.loadCount++;
}, reinit:function(photoCategoriesStore) {
  this.removeAll();
  this.doInit(photoCategoriesStore, this.account);
}}, 0, 0, 0, 0, ['store.albums'], 0, [photoActions.store, 'Albums'], 0);
Ext.cmd.derive('photoActions.view.IntegrationMenuItemDark', Ext.menu.Item, {cls:'save-button', localized:{text:'PUL_Export'}, iconCls:'', iconAlign:'left', menuAlign:'tr-tl?', config:{menu:{xtype:'menu', cls:'photo-actions-menu', ui:'dark2', itemId:'integrationMenu', showSeparator:false, shadow:false, items:[{itemId:'procoreButton', cls:'has-icon procore', icon:'mds/image/icon/procore_white.png', text:'Procore', bind:{hidden:'{!account.procoreEnabled}'}}, {itemId:'planGridButton', cls:'has-icon plangrid', 
icon:'mds/image/icon/plangrid_white.png', text:'PlanGrid', hidden:true, bind:{hidden:'{!account.planGridEnabled}'}}, {itemId:'aconexButton', cls:'has-icon', icon:'mds/image/icon/aconex_white.png', text:'Aconex', bind:{hidden:'{!account.aconexEnabled}'}}, {itemId:'bim360Button', cls:'has-icon bim360', icon:'mds/image/icon/bim360_white.png', text:'BIM 360', hidden:true, bind:{hidden:'{!account.bim360Enabled}'}}, {itemId:'bluebeamButton', cls:'has-icon', icon:'mds/image/icon/bluebeam_white.png', text:'Bluebeam', 
bind:{hidden:'{!account.bluebeamEnabled}'}}], scrollable:false}}}, 0, ['integrationmenuitemdark'], ['component', 'box', 'menuitem', 'integrationmenuitemdark'], {'component':true, 'box':true, 'menuitem':true, 'integrationmenuitemdark':true}, ['widget.integrationmenuitemdark'], 0, [photoActions.view, 'IntegrationMenuItemDark'], 0);
Ext.cmd.derive('photoActions.view.SaveMenuItemDark', Ext.menu.Item, {cls:'save-button', ui:'plain', localized:{text:'PUL_Save'}, iconAlign:'left', menuAlign:'tr-tl?', config:{menu:{xtype:'menu', ui:'dark2', cls:'photo-actions-menu', itemId:'saveMenu', showSeparator:false, shadow:false, items:[{itemId:'saveToComputerAction', localized:{text:'PUL_To Computer'}, listeners:{}}, {itemId:'saveToAlbumAction', localized:{text:'PUL_To Album'}, hidden:true, bind:{hidden:'{!account.canWrite}'}}], scrollable:false}}, 
bind:{listsAndReports:'{writeableListsAndReports}'}, setListsAndReports:function(listsAndReports) {
  var items = [];
  for (var i = 0; i < listsAndReports.length; i++) {
    items.push({cls:'add-to-list-report-action', text:mvstr['PUL_To_Task_List_' + listsAndReports[i].get('ListTypeID')], ListTypeID:listsAndReports[i].get('ListTypeID')});
  }
  this.menu.add(items);
}}, 0, ['photosavemenuitemdark'], ['component', 'box', 'menuitem', 'photosavemenuitemdark'], {'component':true, 'box':true, 'menuitem':true, 'photosavemenuitemdark':true}, ['widget.photosavemenuitemdark'], 0, [photoActions.view, 'SaveMenuItemDark'], 0);
Ext.cmd.derive('photoActions.view.addPhotosToAlbum.AddPhotosToAlbumModel', Ext.app.ViewModel, {data:{albumChoice:{createNewAlbum:false}, lastAlbumUIDChange:null}, formulas:{selectedAlbumUIDs:{get:function(get) {
  if (!get('preferencesReady')) {
    return null;
  }
  var lastAlbumUIDChange = get('lastAlbumUIDChange'), defaultAlbumUIDs = mdsPreferences.ProjectPreferences.getAlbumUIDArray(), albumUIDs = [], store = this.getView().store;
  for (var i = 0; i < defaultAlbumUIDs.length; i++) {
    if (store.getById(defaultAlbumUIDs[i])) {
      albumUIDs.push(defaultAlbumUIDs[i]);
    }
  }
  if (albumUIDs.length != defaultAlbumUIDs.length) {
    mdsPreferences.ProjectPreferences.setAlbumUIDArray(albumUIDs);
  }
  return albumUIDs;
}, set:function(value) {
  mdsPreferences.ProjectPreferences.setAlbumUIDArray(value);
  this.set('lastAlbumUIDChange', (new Date).getTime());
}}, nextButtonText:function(get) {
  return get('albumChoice.createNewAlbum') ? mvstr['G_Next'] + ' \x3e' : mvstr['G_Save'];
}, nextButtonEnabled:function(get) {
  var creatingAlbum = get('albumChoice.createNewAlbum'), albumUIDs = get('selectedAlbumUIDs');
  return !!(creatingAlbum || albumUIDs.length);
}}}, 0, 0, 0, 0, ['viewmodel.addphotostoalbum'], 0, [photoActions.view.addPhotosToAlbum, 'AddPhotosToAlbumModel'], 0);
Ext.cmd.derive('photoActions.view.addPhotosToAlbum.AddPhotosToAlbumController', Ext.app.ViewController, {onExistingAlbumClick:function(dataview, record, item, index, e, eOpts) {
  if (e.getTarget().tagName != 'INPUT') {
    var checkbox = Ext.fly(item).select('input').elements[0];
    checkbox.checked = !checkbox.checked;
  }
  var selectedAlbumUIDs = this.getView().getSelectedAlbumUIDs();
  if (selectedAlbumUIDs.length) {
    this.lookupReference('addPhotosToAlbumNextAction').enable();
  } else {
    this.lookupReference('addPhotosToAlbumNextAction').disable();
  }
  this.getViewModel().set('selectedAlbumUIDs', selectedAlbumUIDs);
}, onAddPhotosToAlbumNextActionClick:function() {
  var viewModel = this.getViewModel();
  if (viewModel.get('albumChoice.createNewAlbum')) {
    this.getToolbarActionsController().makeAlbum();
  } else {
    this.savePhotosToAlbums();
  }
}, savePhotosToAlbums:function(photos) {
  var viewModel = this.getViewModel(), view = this.getView(), albumUIDs = viewModel.get('selectedAlbumUIDs');
  if (!photos) {
    this.getToolbarActionsController().savePhotosToAlbums(albumUIDs, view, this.savePhotosToAlbums.bind(this));
    return;
  }
  Ext.getBody().mask();
  view.mask('Saving ...');
  Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daClientPhotoList.savePhotosToAlbums', params:{ProjectUID:viewModel.get('ProjectUID'), albumUIDs:albumUIDs.join(','), photos:photos.join(',')}, successCallback:function(data) {
    this.afterAddPhotosToAlbum(data);
    Ext.Msg.alert(mvstr['PA_Photos added'], mvstr['PA_The photos were succe']);
    Ext.getBody().unmask();
    view.destroy();
  }, afterFailMessageCallback:function(data) {
    this.afterAddPhotosToAlbum(data);
    Ext.getBody().unmask();
    view.unmask();
  }, scope:this});
}, afterAddPhotosToAlbum:function(data) {
  if (!data) {
    return;
  }
  var interfaceControl = this.getToolbarActionsController().interfaceControl;
  if (!interfaceControl.afterAddPhotosToAlbum) {
    return;
  }
  for (var i = 0; i < data.length; i++) {
    var response = data[i], count = response.data.count ? response.data.count : 0;
    interfaceControl.afterAddPhotosToAlbum(response.AlbumUID, count);
  }
}, getToolbarActionsController:function() {
  return app.getController('photoActions.controller.ToolbarActions');
}}, 0, 0, 0, 0, ['controller.addphotostoalbum'], 0, [photoActions.view.addPhotosToAlbum, 'AddPhotosToAlbumController'], 0);
Ext.cmd.derive('photoActions.view.addPhotosToAlbum.AddPhotosToAlbum', Ext.window.Window, {id:'addPhotosToAlbumWindow', bind:{selectedAlbumUIDs:'{selectedAlbumUIDs}'}, viewModel:{type:'addphotostoalbum'}, controller:'addphotostoalbum', localized:{title:'PUL_Add Photos To Album'}, layout:{type:'vbox', align:'stretchmax'}, modal:true, modalMaskCls:'dark-mask', bodyPadding:5, items:[{xtype:'radiogroup', layout:'vbox', columns:2, bind:{value:'{albumChoice}'}, defaults:{name:'createNewAlbum'}, items:[{localized:{boxLabel:'PUL_Create New Album'}, 
inputValue:true}, {localized:{boxLabel:'PUL_Add to Existing Album'}, inputValue:false}]}, {xtype:'panel', layout:'fit', width:500, height:200, items:[{id:'existingAlbumsCheckboxes', xtype:'dataview', itemSelector:'.album', reference:'existingAlbums', cls:'choose-album-view', itemId:'existingAlbums', tpl:['\x3ctpl for\x3d"."\x3e', '    \x3cdiv class\x3d"album"\x3e', '        \x3cdiv class\x3d"lhs"\x3e\x3cinput type\x3d"checkbox"\x3e\x3c/div\x3e', '        \x3cdiv class\x3d"rhs"\x3e{AlbumName}\x3c/div\x3e', 
'    \x3c/div\x3e    ', '\x3c/tpl\x3e'], autoScroll:true, listeners:{itemclick:'onExistingAlbumClick'}}], bind:{disabled:'{albumChoice.createNewAlbum}'}}, {xtype:'container', flex:1, layout:{type:'hbox', pack:'end'}, margin:'5 0 0 0', items:[{reference:'addPhotosToAlbumNextAction', xtype:'button', bind:{text:'{nextButtonText}', disabled:'{!nextButtonEnabled}'}, listeners:{click:'onAddPhotosToAlbumNextActionClick'}}]}], constructor:function(config) {
  Ext.window.Window.prototype.constructor.apply(this, arguments);
  this.down('#existingAlbums').setStore(config.store);
}, getSelectedAlbumUIDs:function() {
  var albumView = this.lookupReference('existingAlbums'), albums = albumView.getStore().getRange(), checkboxes = albumView.el.select('input').elements, uids = [];
  for (var i = 0; i < checkboxes.length; i++) {
    if (checkboxes[i].checked) {
      uids.push(albums[i].get('AlbumUID'));
    }
  }
  return uids;
}, setSelectedAlbumUIDs:function(albumUIDs) {
  var albumView = this.lookupReference('existingAlbums'), albums = albumView.getStore().getRange(), checkboxes = albumView.el.select('input').elements;
  for (var i = 0; i < checkboxes.length; i++) {
    checkboxes[i].checked = Ext.Array.contains(albumUIDs, albums[i].get('AlbumUID'));
  }
}}, 1, ['addphotostoalbum'], ['component', 'box', 'container', 'panel', 'window', 'addphotostoalbum'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true, 'addphotostoalbum':true}, ['widget.addphotostoalbum'], 0, [photoActions.view.addPhotosToAlbum, 'AddPhotosToAlbum'], 0);
Ext.cmd.derive('webcamShared.view.PTZ.PTZStreamMask', Ext.Component, {controller:'ptzstreammask', autoEl:{tag:'canvas'}, style:{position:'absolute', cursor:'crosshair', zIndex:2}, listeners:{afterrender:'ptzMaskRendered', resize:'ptzMaskResize'}}, 0, ['ptzstreammask'], ['component', 'box', 'ptzstreammask'], {'component':true, 'box':true, 'ptzstreammask':true}, ['widget.ptzstreammask'], 0, [webcamShared.view.PTZ, 'PTZStreamMask'], 0);
Ext.cmd.derive('webcamShared.view.PTZ.PTZStreamMaskController', Ext.app.ViewController, {startX:null, startY:null, isDrawing:false, getStream:function() {
  return this.getView().lookupViewModel().get('activeStream');
}, ptzMaskRendered:function() {
  this.initPTZMask();
}, ptzMaskResize:function() {
  var mask = this.getView(), canvas = mask.getEl().dom;
  canvas.width = mask.getWidth();
  canvas.height = mask.getHeight();
}, initPTZMask:function() {
  var mask = this.getView(), canvas = mask.getEl().dom, context = canvas.getContext('2d'), controller = this;
  canvas.onmousedown = function(e) {
    e.stopPropagation();
    this.isDrawing = true;
    this.startX = e.clientX - mask.getX();
    this.startY = e.clientY - mask.getY();
    canvas.onmousemove = function(e) {
      if (this.isDrawing) {
        var boxWidth = parseInt(e.clientX - mask.getX() - this.startX);
        var boxHeight = parseInt(e.clientY - mask.getY() - this.startY);
        context.clearRect(0, 0, mask.getWidth(), mask.getHeight());
        context.beginPath();
        context.strokeStyle = '#E47911';
        context.lineWidth = 2;
        context.rect(this.startX, this.startY, boxWidth, boxHeight);
        context.stroke();
      }
    };
    canvas.onmouseup = function(e) {
      if (this.isDrawing) {
        this.isDrawing = false;
        var xDiff = Math.abs(this.startX - (e.clientX - mask.getX()));
        var yDiff = Math.abs(this.startY - (e.clientY - mask.getY()));
        if (xDiff < 10 || yDiff < 10) {
          controller.ptzMaskPanTilt(e.clientX - mask.getX(), e.clientY - mask.getY());
        } else {
          var x = (e.clientX + this.startX - mask.getX()) / 2;
          var y = (e.clientY + this.startY - mask.getY()) / 2;
          var zoomFactor = (Math.abs(xDiff) / mask.getWidth() + Math.abs(yDiff) / mask.getHeight()) / 2;
          controller.ptzMaskZoom(x, y, 100 / zoomFactor);
        }
        context.clearRect(0, 0, mask.getWidth(), mask.getHeight());
      }
    };
  };
  canvas.onmouseout = function() {
    this.isDrawing = false;
    context.clearRect(0, 0, mask.getWidth(), mask.getHeight());
  };
}, ptzMaskPanTilt:function(x, y) {
  analytics.Ctrl.setOptionalDefaultEventProperties({'Method':'Stream Interaction', 'Sub Method':'Click'});
  var width = this.getView().getWidth(), height = this.getView().getHeight(), stream = this.getStream();
  Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daClientWebcam.move\x26center\x3d' + Math.round(x) + ',' + Math.round(y) + '\x26imagewidth\x3d' + Math.floor(width) + '\x26imageheight\x3d' + Math.floor(height), params:{WebcamUID:stream.WebcamUID, ProjectUID:stream.ProjectUID}, successCallback:this.onPTZRequestSuccess}, this);
}, ptzMaskZoom:function(x, y, zoom) {
  analytics.Ctrl.setOptionalDefaultEventProperties({'Method':'Stream Interaction', 'Sub Method':'Box Zoom'});
  var width = this.getView().getWidth(), height = this.getView().getHeight(), stream = this.getStream();
  Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daClientWebcam.move\x26areazoom\x3d' + Math.round(x) + ',' + Math.round(y) + ',' + zoom + '\x26imagewidth\x3d' + Math.floor(width) + '\x26imageheight\x3d' + Math.floor(height), params:{WebcamUID:stream.WebcamUID, ProjectUID:stream.ProjectUID}, successCallback:this.onPTZRequestSuccess}, this);
}, onPTZRequestSuccess:function() {
  setTimeout(function() {
    app.fireEvent('forceupdateptzposition');
  }, 2500);
}}, 0, 0, 0, 0, ['controller.ptzstreammask'], 0, [webcamShared.view.PTZ, 'PTZStreamMaskController'], 0);
Ext.cmd.derive('webcamShared.view.Stream', Ext.container.Container, {config:{showFullscreenButton:true}, layout:{type:'absolute'}, items:[{xtype:'button', ui:'plain', itemId:'webcamFullscreenBtn', cls:'webcam-fullscreen-btn', hidden:true, handler:function(button) {
  button.up('webcamlivestream').requestFullScreen();
}}, {xtype:'container', itemId:'wcLiveStreamContainer', items:[{xtype:'component', itemId:'wcLiveStream', cls:'webcam-stream no-volume no-mute', width:'100%', height:'100%', listeners:{resize:function() {
  var me = this.up('webcamlivestream');
  if (me.down('#ptzMask').isVisible()) {
    me.down('#ptzMask').alignTo(this.getEl(), 'tl?');
    me.down('#ptzMask').setSize(this.getSize());
  }
}}}, {xtype:'ptzstreammask', itemId:'ptzMask', hidden:true}]}], Webcam:null, Image:null, params:null, localScale:100, loadAttempts:0, httpImageTimeout:null, load:function(webcam, params, viewport, supressResize) {
  var me = Ext.getCmp(this.getId());
  me.Webcam = webcam;
  me.HTTPStreamParams = Ext.clone(params);
  me.viewport = viewport;
  if (!supressResize) {
    me.resize();
  }
  var pageQueryObject = Ext.Object.fromQueryString(document.location.search), circuit = pageQueryObject.fuseaction ? pageQueryObject.fuseaction.split('.')[0] : document.location.pathname.match('clientWebcam') ? 'aClientWebcam' : document.location.pathname.match('publicWebcam') ? 'aPublicWebcam' : '';
  me.HTTPStreamParams.fuseaction = circuit + '.getHTTPStream';
  if (webcam.WebcamStreamType == 'RTSP') {
    this.clearImage();
    if (webcam.ForceFlashStream) {
      this.loadFlowplayer();
    } else {
      this.loadH5Live();
    }
  } else {
    var imageCmp = Ext.create('Ext.Img', {renderTo:me.down('#wcLiveStream').el, src:me.Webcam.ImageURL, centered:true, listeners:{afterrender:function(img) {
      Ext.getCmp(this.getId()).mask('Loading ...');
    }}});
    webcam.isPlaying = true;
    me.Image = imageCmp.el.dom;
    me.Image.onload = function() {
      me.fireEvent('imageload');
    };
    me.loadImage();
    var fullscreenBtn = Ext.getCmp('fullscreenBtn');
    if (fullscreenBtn && this.canRequestFullscreen() && this.getShowFullscreenButton()) {
      fullscreenBtn.show();
    }
  }
}, loadH5Live:function() {
  var me = this;
  var id = me.down('#wcLiveStream').getId();
  var webcam = this.Webcam;
  var streamSource = {h5live:{server:{websocket:'wss://bintu-play.nanocosmos.de:443/h5live/stream', hls:'https://bintu-play.nanocosmos.de:443/h5live/http/playlist.m3u8', progressive:'https://bintu-play.nanocosmos.de:443/h5live/http/stream.mp4'}, token:'{"type":"token1","key":"mvis9174hf-ltohd"}', rtmp:{url:webcam.RTMPURL, streamname:webcam.StreamName}}};
  if (this.h5livePlayer) {
    this.h5livePlayer.updateSource(streamSource);
  } else {
    var config = {source:streamSource, playback:{autoplay:true, muted:true}, style:{controls:false}, events:{onReady:function() {
      me.setH5LivePoster();
    }, onPlay:function() {
      me.Webcam.isPlaying = true;
      me.setPTZMaskVisibility(true);
      var player = me.h5livePlayer._view._mediaElement;
      player.style.removeProperty('background-image');
      app.fireEvent('flowplayerReady');
      me.setupTimeout(me.h5livePlayer);
      var fullscreenBtn = me.down('#webcamFullscreenBtn');
      if (fullscreenBtn && me.getShowFullscreenButton() && me.canRequestFullscreen()) {
        fullscreenBtn.show();
      }
    }, onPause:function() {
    }, onLoading:function() {
      me.setH5LivePoster();
    }}};
    this.h5livePlayer = new NanoPlayer(id);
    this.h5livePlayer.setup(config).then(function(config) {
    }, function(error) {
      alert(error.message);
    });
  }
}, setH5LivePoster:function() {
  var webcam = this.Webcam;
  var player = this.h5livePlayer;
  var video = player._view._mediaElement;
  video.poster = webcam.ImageURL;
}, loadFlowplayer:function() {
  var container = document.getElementById(this.getId()), webcam = this.Webcam, controller = this, key = '$131119724416338';
  if (location.href.indexOf('localhost') != -1) {
    key = '$863732616083910';
  }
  var api = flowplayer(container, {key:key, autoplay:true, clip:{live:true, sources:[{type:'video/flash', src:webcam.RTMPURL + '/' + webcam.StreamName}]}, wmode:'transparent', fullscreen:true, embed:false, poster:webcam.ImageURL}).on('ready', function(e, api, video) {
    controller.loadAttempts = 0;
    controller.setupTimeout(api);
    webcam.isPlaying = true;
    controller.setPTZMaskVisibility(true);
    app.fireEvent('flowplayerReady');
    var fullscreenBtn = controller.down('#webcamFullscreenBtn');
    if (fullscreenBtn && controller.canRequestFullscreen() && controller.getShowFullscreenButton()) {
      fullscreenBtn.show();
    }
  }).on('pause', function(e, api) {
    if (webcam.isPlaying) {
      api.play();
    } else {
      Ext.select('.fp-ui').elements[0].style = '';
    }
  }).on('resume', function(e, api) {
    if (!webcam.isPlaying) {
      controller.setupTimeout(api);
      Ext.select('.fp-ui').elements[0].style = 'background: none;';
      webcam.isPlaying = true;
      controller.setPTZMaskVisibility(true);
    }
  }).on('error', function(e, api, err) {
    console.log('Error loading video');
    console.log(err);
    controller.loadAttempts++;
    if (controller.loadAttempts < 5) {
      api.error = api.loading = false;
      container.className = container.className.replace(/\bis-offline\b/, '');
      container.className = container.className.replace(/\bis-error\b/, '');
      api.load(api.conf.clip);
    } else {
      console.log('Error - Attempts to connect exceeded 5');
    }
  });
  controller.flowplayerApi = api;
  setTimeout(function() {
    if (!api.ready) {
      api.loading = false;
    }
  }, 5000);
}, setupTimeout:function(api) {
  var controller = this, webcam = this.Webcam, timeout = webcam.DefaultStreamTimeout * 60 * 1000, overrides = webcam.StreamTimeouts, now = new Date;
  if (overrides) {
    var nextClosest = Ext.Date.add(now, Ext.Date.DAY, 1);
    for (var i = overrides.length - 1; i >= 0; i--) {
      var start = new Date, end = new Date;
      start.setHours(Math.floor(overrides[i].StartTimeMinutes / 60), overrides[i].StartTimeMinutes % 60);
      end.setHours(Math.floor(overrides[i].EndTimeMinutes / 60), overrides[i].EndTimeMinutes % 60);
      if (end < start) {
        end = Ext.Date.add(end, Ext.Date.DAY, 1);
      }
      if (end < now) {
        end = Ext.Date.add(end, Ext.Date.DAY, 1);
        start = Ext.Date.add(start, Ext.Date.DAY, 1);
      }
      if (now >= start && now < end) {
        timeout = overrides[i].TimeoutLength === 0 ? end - now : Math.min(overrides[i].TimeoutLength * 60 * 1000, end - now);
      }
      if (now < start && start < nextClosest) {
        nextClosest = start;
      }
      timeout = Math.min(timeout, nextClosest - now);
    }
  }
  if (timeout) {
    Ext.defer(function() {
      var element = document.getElementById('ptzMask');
      if (element) {
        element.parentNode.removeChild(element);
      }
      webcam.isPlaying = false;
      controller.setPTZMaskVisibility(true);
      api.pause();
    }, timeout);
  }
}, resize:function() {
  var me = this;
  var isPhotoViewer = !!me.up('photoviewer');
  if (!me.Webcam) {
    return;
  }
  me.staticHSpace = me.viewport.getStaticHSpace();
  me.staticVSpace = me.viewport.getStaticVSpace();
  var maxHSpace = (me.viewport.body ? me.viewport.body.getWidth() : me.viewport.getWidth()) - me.staticHSpace;
  var maxVSpace = (me.viewport.body ? me.viewport.body.getHeight() : me.viewport.getHeight()) - me.staticVSpace;
  var height = Math.min(maxVSpace, me.Webcam.StreamHeight);
  var width = height / this.Webcam.StreamHeight * this.Webcam.StreamWidth;
  if (width > maxHSpace) {
    width = maxHSpace;
    height = width / me.Webcam.StreamWidth * me.Webcam.StreamHeight;
  }
  if (height > maxVSpace) {
    height = maxVSpace;
    width = height / me.Webcam.StreamHeight * me.Webcam.StreamWidth;
  }
  if (isPhotoViewer && width < maxHSpace && height < maxVSpace) {
    var fitToHeight = width / height < maxHSpace / maxVSpace;
    if (fitToHeight) {
      height = maxVSpace;
      width = height / me.Webcam.StreamHeight * me.Webcam.StreamWidth;
    } else {
      width = maxHSpace;
      height = width / me.Webcam.StreamWidth * me.Webcam.StreamHeight;
    }
  }
  var wrapper = Ext.getCmp('streamWrapper');
  if (wrapper) {
    wrapper.el.dom.style.overflow = me.localScale == 100 ? 'hidden' : 'scroll';
    wrapper.setSize(width, height);
  }
  me.down('#wcLiveStream').setSize(width * (me.localScale / 100), height * (me.localScale / 100));
  me.down('#wcLiveStreamContainer').setSize(width * (me.localScale / 100), height * (me.localScale / 100));
  if (isPhotoViewer) {
    height = Math.max(maxVSpace, height * (me.localScale / 100));
    width = width * (me.localScale / 100);
    me.setSize(width, height);
  } else {
    me.setSize(width, height);
  }
}, clearImage:function() {
  var me = Ext.getCmp(this.getId());
  if (me.Image) {
    me.Image.src = '';
  }
}, loadImage:function() {
  var me = Ext.getCmp(this.getId());
  me.Image.src = mdslink.server + '/index.cfm?' + Ext.Object.toQueryString(me.HTTPStreamParams) + '\x26dc\x3d' + (new Date).getTime();
}, zoom:function(increment) {
  var zoomValue = this.localScale;
  if (increment > 0) {
    zoomValue *= 1.25;
  } else {
    zoomValue /= 1.25;
  }
  zoomValue = Math.max(100, zoomValue);
  this.localZoom(zoomValue);
}, localZoom:function(zoomValue) {
  this.localScale = zoomValue;
  this.resize();
}, requestFullScreen:function() {
  if (this.flowplayerApi) {
    this.flowplayerApi.fullscreen();
    return;
  }
  var element = this.down('#wcLiveStream').el.dom;
  var requestMethod = element.requestFullScreen || element.webkitRequestFullScreen || element.mozRequestFullScreen || element.msRequestFullScreen;
  if (requestMethod) {
    requestMethod.call(element);
  } else {
    if (typeof window.ActiveXObject !== 'undefined') {
      var wscript = new ActiveXObject('WScript.Shell');
      if (wscript !== null) {
        wscript.SendKeys('{F11}');
      }
    }
  }
}, canRequestFullscreen:function() {
  var element = this.el.dom;
  return (element.requestFullScreen || element.webkitRequestFullScreen || element.mozRequestFullScreen || element.msRequestFullScreen) && !Ext.isIE ? true : false;
}, cleanup:function() {
  if (this.h5livePlayer) {
    this.h5livePlayer.destroy();
  }
  clearTimeout(this.httpImageTimeout);
}, listeners:{imageload:function() {
  clearTimeout(this.httpImageTimeout);
  this.httpImageTimeout = Ext.defer(this.loadImage, this.Webcam.StreamRefreshRate * 1000, this);
}, beforedestroy:function() {
  this.cleanup();
}, hide:function() {
  this.cleanup();
}}, requestFullscreenRTSP:function() {
  var me = document.getElementById(this.getId());
  var video = me.querySelector('video');
  if (video) {
    this.requestFullScreen();
  }
  var element = document.getElementById('ptzMask');
  if (element) {
    element.parentNode.removeChild(element);
  }
}, setPTZMaskVisibility:function(visible) {
  var isPhotoViewer = !!this.up('photoviewer'), ptzEnabled = this.lookupViewModel().get('PTZPosition');
  if (isPhotoViewer && ptzEnabled && visible) {
    this.down('#ptzMask').show();
    this.down('#wcLiveStream').fireEvent('resize');
  } else {
    this.down('#ptzMask').hide();
  }
}}, 0, ['webcamlivestream'], ['component', 'box', 'container', 'webcamlivestream'], {'component':true, 'box':true, 'container':true, 'webcamlivestream':true}, ['widget.webcamlivestream'], 0, [webcamShared.view, 'Stream'], 0);
Ext.cmd.derive('Ext.draw.ContainerBase', Ext.panel.Panel, {previewTitleText:'Chart Preview', previewAltText:'Chart preview', layout:'container', addElementListener:function() {
  var me = this, args = arguments;
  if (me.rendered) {
    me.el.on.apply(me.el, args);
  } else {
    me.on('render', function() {
      me.el.on.apply(me.el, args);
    });
  }
}, removeElementListener:function() {
  var me = this, args = arguments;
  if (me.rendered) {
    me.el.un.apply(me.el, args);
  }
}, afterRender:function() {
  Ext.panel.Panel.prototype.afterRender.apply(this, arguments);
  this.initAnimator();
}, getItems:function() {
  var me = this, items = me.items;
  if (!items || !items.isMixedCollection) {
    me.initItems();
  }
  return me.items;
}, onRender:function() {
  Ext.panel.Panel.prototype.onRender.apply(this, arguments);
  this.element = this.el;
  this.innerElement = this.body;
}, setItems:function(items) {
  this.items = items;
  return items;
}, setSurfaceSize:function(width, height) {
  this.resizeHandler({width:width, height:height});
  this.renderFrame();
}, onResize:function(width, height, oldWidth, oldHeight) {
  var me = this;
  Ext.panel.Panel.prototype.onResize.call(this, width, height, oldWidth, oldHeight);
  me.handleResize({width:width, height:height}, !me.size);
}, preview:function() {
  var image = this.getImage(), items;
  if (Ext.isIE8) {
    return false;
  }
  if (image.type === 'svg-markup') {
    items = {xtype:'container', html:image.data};
  } else {
    items = {xtype:'image', mode:'img', cls:'x-chart-image', alt:this.previewAltText, src:image.data, listeners:{afterrender:function() {
      var me = this, img = me.imgEl.dom, ratio = image.type === 'svg' ? 1 : window['devicePixelRatio'] || 1, size;
      if (!img.naturalWidth || !img.naturalHeight) {
        img.onload = function() {
          var width = img.naturalWidth, height = img.naturalHeight;
          me.setWidth(Math.floor(width / ratio));
          me.setHeight(Math.floor(height / ratio));
        };
      } else {
        size = me.getSize();
        me.setWidth(Math.floor(size.width / ratio));
        me.setHeight(Math.floor(size.height / ratio));
      }
    }}};
  }
  new Ext.window.Window({title:this.previewTitleText, closeable:true, renderTo:Ext.getBody(), autoShow:true, maximizeable:true, maximized:true, border:true, layout:{type:'hbox', pack:'center', align:'middle'}, items:{xtype:'container', items:items}});
}, privates:{getTargetEl:function() {
  return this.innerElement;
}, reattachToBody:function() {
  var me = this;
  if (me.pendingDetachSize) {
    me.handleResize();
  }
  me.pendingDetachSize = false;
  Ext.panel.Panel.prototype.reattachToBody.call(this);
}}}, 0, 0, ['component', 'box', 'container', 'panel'], {'component':true, 'box':true, 'container':true, 'panel':true}, 0, 0, [Ext.draw, 'ContainerBase'], 0);
Ext.cmd.derive('Ext.draw.SurfaceBase', Ext.Widget, {getOwnerBody:function() {
  return this.ownerCt.body;
}}, 0, 0, ['widget'], {'widget':true}, 0, 0, [Ext.draw, 'SurfaceBase'], 0);
Ext.cmd.derive('Ext.draw.sprite.AnimationParser', Ext.Base, function() {
  function compute(from, to, delta) {
    return from + (to - from) * delta;
  }
  return {singleton:true, attributeRe:/^url\(#([a-zA-Z\-]+)\)$/, color:{parseInitial:function(color1, color2) {
    if (Ext.isString(color1)) {
      color1 = Ext.util.Color.create(color1);
    }
    if (Ext.isString(color2)) {
      color2 = Ext.util.Color.create(color2);
    }
    if (color1 && color1.isColor && (color2 && color2.isColor)) {
      return [[color1.r, color1.g, color1.b, color1.a], [color2.r, color2.g, color2.b, color2.a]];
    } else {
      return [color1 || color2, color2 || color1];
    }
  }, compute:function(from, to, delta) {
    if (!Ext.isArray(from) || !Ext.isArray(to)) {
      return to || from;
    } else {
      return [compute(from[0], to[0], delta), compute(from[1], to[1], delta), compute(from[2], to[2], delta), compute(from[3], to[3], delta)];
    }
  }, serve:function(array) {
    var color = Ext.util.Color.fly(array[0], array[1], array[2], array[3]);
    return color.toString();
  }}, number:{parse:function(n) {
    return n === null ? null : +n;
  }, compute:function(from, to, delta) {
    if (!Ext.isNumber(from) || !Ext.isNumber(to)) {
      return to || from;
    } else {
      return compute(from, to, delta);
    }
  }}, angle:{parseInitial:function(from, to) {
    if (to - from > Math.PI) {
      to -= Math.PI * 2;
    } else {
      if (to - from < -Math.PI) {
        to += Math.PI * 2;
      }
    }
    return [from, to];
  }, compute:function(from, to, delta) {
    if (!Ext.isNumber(from) || !Ext.isNumber(to)) {
      return to || from;
    } else {
      return compute(from, to, delta);
    }
  }}, path:{parseInitial:function(from, to) {
    var fromStripes = from.toStripes(), toStripes = to.toStripes(), i, j, fromLength = fromStripes.length, toLength = toStripes.length, fromStripe, toStripe, length, lastStripe = toStripes[toLength - 1], endPoint = [lastStripe[lastStripe.length - 2], lastStripe[lastStripe.length - 1]];
    for (i = fromLength; i < toLength; i++) {
      fromStripes.push(fromStripes[fromLength - 1].slice(0));
    }
    for (i = toLength; i < fromLength; i++) {
      toStripes.push(endPoint.slice(0));
    }
    length = fromStripes.length;
    toStripes.path = to;
    toStripes.temp = new Ext.draw.Path;
    for (i = 0; i < length; i++) {
      fromStripe = fromStripes[i];
      toStripe = toStripes[i];
      fromLength = fromStripe.length;
      toLength = toStripe.length;
      toStripes.temp.commands.push('M');
      for (j = toLength; j < fromLength; j += 6) {
        toStripe.push(endPoint[0], endPoint[1], endPoint[0], endPoint[1], endPoint[0], endPoint[1]);
      }
      lastStripe = toStripes[toStripes.length - 1];
      endPoint = [lastStripe[lastStripe.length - 2], lastStripe[lastStripe.length - 1]];
      for (j = fromLength; j < toLength; j += 6) {
        fromStripe.push(endPoint[0], endPoint[1], endPoint[0], endPoint[1], endPoint[0], endPoint[1]);
      }
      for (i = 0; i < toStripe.length; i++) {
        toStripe[i] -= fromStripe[i];
      }
      for (i = 2; i < toStripe.length; i += 6) {
        toStripes.temp.commands.push('C');
      }
    }
    return [fromStripes, toStripes];
  }, compute:function(fromStripes, toStripes, delta) {
    if (delta >= 1) {
      return toStripes.path;
    }
    var i = 0, ln = fromStripes.length, j = 0, ln2, from, to, temp = toStripes.temp.params, pos = 0;
    for (; i < ln; i++) {
      from = fromStripes[i];
      to = toStripes[i];
      ln2 = from.length;
      for (j = 0; j < ln2; j++) {
        temp[pos++] = to[j] * delta + from[j];
      }
    }
    return toStripes.temp;
  }}, data:{compute:function(from, to, delta, target) {
    var lf = from.length - 1, lt = to.length - 1, len = Math.max(lf, lt), f, t, i;
    if (!target || target === from) {
      target = [];
    }
    target.length = len + 1;
    for (i = 0; i <= len; i++) {
      f = from[Math.min(i, lf)];
      t = to[Math.min(i, lt)];
      if (Ext.isNumber(f)) {
        if (!Ext.isNumber(t)) {
          t = 0;
        }
        target[i] = (t - f) * delta + f;
      } else {
        target[i] = t;
      }
    }
    return target;
  }}, text:{compute:function(from, to, delta) {
    return from.substr(0, Math.round(from.length * (1 - delta))) + to.substr(Math.round(to.length * (1 - delta)));
  }}, limited:'number', limited01:'number'};
}, 0, 0, 0, 0, 0, 0, [Ext.draw.sprite, 'AnimationParser'], 0);
(function() {
  if (!Ext.global.Float32Array) {
    var Float32Array = function(array) {
      if (typeof array === 'number') {
        this.length = array;
      } else {
        if ('length' in array) {
          this.length = array.length;
          for (var i = 0, len = array.length; i < len; i++) {
            this[i] = +array[i];
          }
        }
      }
    };
    Float32Array.prototype = [];
    Ext.global.Float32Array = Float32Array;
  }
})();
Ext.cmd.derive('Ext.draw.Draw', Ext.Base, {singleton:true, radian:Math.PI / 180, pi2:Math.PI * 2, reflectFn:function(a) {
  return a;
}, rad:function(degrees) {
  return degrees % 360 * this.radian;
}, degrees:function(radian) {
  return radian / this.radian % 360;
}, isBBoxIntersect:function(bbox1, bbox2, padding) {
  padding = padding || 0;
  return Math.max(bbox1.x, bbox2.x) - padding > Math.min(bbox1.x + bbox1.width, bbox2.x + bbox2.width) || Math.max(bbox1.y, bbox2.y) - padding > Math.min(bbox1.y + bbox1.height, bbox2.y + bbox2.height);
}, isPointInBBox:function(x, y, bbox) {
  return !!bbox && x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;
}, spline:function(points) {
  var i, j, ln = points.length, nd, d, y, ny, r = 0, zs = new Float32Array(points.length), result = new Float32Array(points.length * 3 - 2);
  zs[0] = 0;
  zs[ln - 1] = 0;
  for (i = 1; i < ln - 1; i++) {
    zs[i] = points[i + 1] + points[i - 1] - 2 * points[i] - zs[i - 1];
    r = 1 / (4 - r);
    zs[i] *= r;
  }
  for (i = ln - 2; i > 0; i--) {
    r = 3.732050807568877 + 48.248711305964385 / (-13.928203230275537 + Math.pow(0.07179676972449123, i));
    zs[i] -= zs[i + 1] * r;
  }
  ny = points[0];
  nd = ny - zs[0];
  for (i = 0, j = 0; i < ln - 1; j += 3) {
    y = ny;
    d = nd;
    i++;
    ny = points[i];
    nd = ny - zs[i];
    result[j] = y;
    result[j + 1] = (nd + 2 * d) / 3;
    result[j + 2] = (nd * 2 + d) / 3;
  }
  result[j] = ny;
  return result;
}, getAnchors:function(prevX, prevY, curX, curY, nextX, nextY, value) {
  value = value || 4;
  var PI = Math.PI, halfPI = PI / 2, abs = Math.abs, sin = Math.sin, cos = Math.cos, atan = Math.atan, control1Length, control2Length, control1Angle, control2Angle, control1X, control1Y, control2X, control2Y, alpha;
  control1Length = (curX - prevX) / value;
  control2Length = (nextX - curX) / value;
  if (curY >= prevY && curY >= nextY || curY <= prevY && curY <= nextY) {
    control1Angle = control2Angle = halfPI;
  } else {
    control1Angle = atan((curX - prevX) / abs(curY - prevY));
    if (prevY < curY) {
      control1Angle = PI - control1Angle;
    }
    control2Angle = atan((nextX - curX) / abs(curY - nextY));
    if (nextY < curY) {
      control2Angle = PI - control2Angle;
    }
  }
  alpha = halfPI - (control1Angle + control2Angle) % (PI * 2) / 2;
  if (alpha > halfPI) {
    alpha -= PI;
  }
  control1Angle += alpha;
  control2Angle += alpha;
  control1X = curX - control1Length * sin(control1Angle);
  control1Y = curY + control1Length * cos(control1Angle);
  control2X = curX + control2Length * sin(control2Angle);
  control2Y = curY + control2Length * cos(control2Angle);
  if (curY > prevY && control1Y < prevY || curY < prevY && control1Y > prevY) {
    control1X += abs(prevY - control1Y) * (control1X - curX) / (control1Y - curY);
    control1Y = prevY;
  }
  if (curY > nextY && control2Y < nextY || curY < nextY && control2Y > nextY) {
    control2X -= abs(nextY - control2Y) * (control2X - curX) / (control2Y - curY);
    control2Y = nextY;
  }
  return {x1:control1X, y1:control1Y, x2:control2X, y2:control2Y};
}, smooth:function(dataX, dataY, value) {
  var ln = dataX.length, prevX, prevY, curX, curY, nextX, nextY, x, y, smoothX = [], smoothY = [], i, anchors;
  for (i = 0; i < ln - 1; i++) {
    prevX = dataX[i];
    prevY = dataY[i];
    if (i === 0) {
      x = prevX;
      y = prevY;
      smoothX.push(x);
      smoothY.push(y);
      if (ln === 1) {
        break;
      }
    }
    curX = dataX[i + 1];
    curY = dataY[i + 1];
    nextX = dataX[i + 2];
    nextY = dataY[i + 2];
    if (!(Ext.isNumber(nextX) && Ext.isNumber(nextY))) {
      smoothX.push(x, curX, curX);
      smoothY.push(y, curY, curY);
      break;
    }
    anchors = this.getAnchors(prevX, prevY, curX, curY, nextX, nextY, value);
    smoothX.push(x, anchors.x1, curX);
    smoothY.push(y, anchors.y1, curY);
    x = anchors.x2;
    y = anchors.y2;
  }
  return {smoothX:smoothX, smoothY:smoothY};
}, beginUpdateIOS:Ext.os.is.iOS ? function() {
  this.iosUpdateEl = Ext.getBody().createChild({style:'position: absolute; top: 0px; bottom: 0px; left: 0px; right: 0px; background: rgba(0,0,0,0.001); z-index: 100000'});
} : Ext.emptyFn, endUpdateIOS:function() {
  this.iosUpdateEl = Ext.destroy(this.iosUpdateEl);
}}, 0, 0, 0, 0, 0, 0, [Ext.draw, 'Draw'], 0);
Ext.cmd.derive('Ext.draw.gradient.Gradient', Ext.Base, {isGradient:true, config:{stops:[]}, applyStops:function(newStops) {
  var stops = [], ln = newStops.length, i, stop, color;
  for (i = 0; i < ln; i++) {
    stop = newStops[i];
    color = stop.color;
    if (!(color && color.isColor)) {
      color = Ext.util.Color.fly(color || Ext.util.Color.NONE);
    }
    stops.push({offset:Math.min(1, Math.max(0, 'offset' in stop ? stop.offset : stop.position || 0)), color:color.toString()});
  }
  stops.sort(function(a, b) {
    return a.offset - b.offset;
  });
  return stops;
}, onClassExtended:function(subClass, member) {
  if (!member.alias && member.type) {
    member.alias = 'gradient.' + member.type;
  }
}, constructor:function(config) {
  this.initConfig(config);
}, generateGradient:Ext.emptyFn}, 1, 0, 0, 0, 0, 0, [Ext.draw.gradient, 'Gradient'], 0);
Ext.cmd.derive('Ext.draw.gradient.GradientDefinition', Ext.Base, {singleton:true, urlStringRe:/^url\(#([\w\-]+)\)$/, gradients:{}, add:function(gradients) {
  var store = this.gradients, i, n, gradient;
  for (i = 0, n = gradients.length; i < n; i++) {
    gradient = gradients[i];
    if (Ext.isString(gradient.id)) {
      store[gradient.id] = gradient;
    }
  }
}, get:function(str) {
  var store = this.gradients, match = str.match(this.urlStringRe), gradient;
  if (match && match[1] && (gradient = store[match[1]])) {
    return gradient || str;
  }
  return str;
}}, 0, 0, 0, 0, 0, 0, [Ext.draw.gradient, 'GradientDefinition'], 0);
Ext.cmd.derive('Ext.draw.sprite.AttributeParser', Ext.Base, {singleton:true, attributeRe:/^url\(#([a-zA-Z\-]+)\)$/, 'default':Ext.identityFn, string:function(n) {
  return String(n);
}, number:function(n) {
  if (Ext.isNumber(+n)) {
    return n;
  }
}, angle:function(n) {
  if (Ext.isNumber(n)) {
    n %= Math.PI * 2;
    if (n < -Math.PI) {
      n += Math.PI * 2;
    } else {
      if (n >= Math.PI) {
        n -= Math.PI * 2;
      }
    }
    return n;
  }
}, data:function(n) {
  if (Ext.isArray(n)) {
    return n.slice();
  } else {
    if (n instanceof Float32Array) {
      return new Float32Array(n);
    }
  }
}, bool:function(n) {
  return !!n;
}, color:function(n) {
  if (n && n.isColor) {
    return n.toString();
  } else {
    if (n && n.isGradient) {
      return n;
    } else {
      if (!n) {
        return Ext.util.Color.NONE;
      } else {
        if (Ext.isString(n)) {
          if (n.substr(0, 3) === 'url') {
            n = Ext.draw.gradient.GradientDefinition.get(n);
            if (Ext.isString(n)) {
              return n;
            }
          } else {
            return Ext.util.Color.fly(n).toString();
          }
        }
      }
    }
  }
  if (n.type === 'linear') {
    return Ext.create('Ext.draw.gradient.Linear', n);
  } else {
    if (n.type === 'radial') {
      return Ext.create('Ext.draw.gradient.Radial', n);
    } else {
      if (n.type === 'pattern') {
        return Ext.create('Ext.draw.gradient.Pattern', n);
      } else {
        return Ext.util.Color.NONE;
      }
    }
  }
}, limited:function(low, hi) {
  return function(n) {
    n = +n;
    return Ext.isNumber(n) ? Math.min(Math.max(n, low), hi) : undefined;
  };
}, limited01:function(n) {
  n = +n;
  return Ext.isNumber(n) ? Math.min(Math.max(n, 0), 1) : undefined;
}, enums:function() {
  var enums = {}, args = Array.prototype.slice.call(arguments, 0), i, ln;
  for (i = 0, ln = args.length; i < ln; i++) {
    enums[args[i]] = true;
  }
  return function(n) {
    return n in enums ? n : undefined;
  };
}}, 0, 0, 0, 0, 0, 0, [Ext.draw.sprite, 'AttributeParser'], 0);
Ext.cmd.derive('Ext.draw.sprite.AttributeDefinition', Ext.Base, {config:{defaults:{$value:{}, lazy:true}, aliases:{}, animationProcessors:{}, processors:{$value:{}, lazy:true}, dirtyTriggers:{}, triggers:{}, updaters:{}}, inheritableStatics:{processorFactoryRe:/^(\w+)\(([\w\-,]*)\)$/}, spriteClass:null, constructor:function(config) {
  var me = this;
  me.initConfig(config);
}, applyDefaults:function(defaults, oldDefaults) {
  oldDefaults = Ext.apply(oldDefaults || {}, this.normalize(defaults));
  return oldDefaults;
}, applyAliases:function(aliases, oldAliases) {
  return Ext.apply(oldAliases || {}, aliases);
}, applyProcessors:function(processors, oldProcessors) {
  this.getAnimationProcessors();
  var result = oldProcessors || {}, defaultProcessor = Ext.draw.sprite.AttributeParser, processorFactoryRe = this.self.processorFactoryRe, animationProcessors = {}, anyAnimationProcessors, name, match, fn;
  for (name in processors) {
    fn = processors[name];
    if (typeof fn === 'string') {
      match = fn.match(processorFactoryRe);
      if (match) {
        fn = defaultProcessor[match[1]].apply(defaultProcessor, match[2].split(','));
      } else {
        if (defaultProcessor[fn]) {
          animationProcessors[name] = fn;
          anyAnimationProcessors = true;
          fn = defaultProcessor[fn];
        }
      }
    }
    result[name] = fn;
  }
  if (anyAnimationProcessors) {
    this.setAnimationProcessors(animationProcessors);
  }
  return result;
}, applyAnimationProcessors:function(animationProcessors, oldAnimationProcessors) {
  var parser = Ext.draw.sprite.AnimationParser, name, item;
  if (!oldAnimationProcessors) {
    oldAnimationProcessors = {};
  }
  for (name in animationProcessors) {
    item = animationProcessors[name];
    if (item === 'none') {
      oldAnimationProcessors[name] = null;
    } else {
      if (Ext.isString(item) && !(name in oldAnimationProcessors)) {
        if (item in parser) {
          while (Ext.isString(parser[item])) {
            item = parser[item];
          }
          oldAnimationProcessors[name] = parser[item];
        }
      } else {
        if (Ext.isObject(item)) {
          oldAnimationProcessors[name] = item;
        }
      }
    }
  }
  return oldAnimationProcessors;
}, updateDirtyTriggers:function(dirtyTriggers) {
  this.setTriggers(dirtyTriggers);
}, applyTriggers:function(triggers, oldTriggers) {
  if (!oldTriggers) {
    oldTriggers = {};
  }
  for (var name in triggers) {
    oldTriggers[name] = triggers[name].split(',');
  }
  return oldTriggers;
}, applyUpdaters:function(updaters, oldUpdaters) {
  return Ext.apply(oldUpdaters || {}, updaters);
}, batchedNormalize:function(batchedChanges, keepUnrecognized) {
  if (!batchedChanges) {
    return {};
  }
  var processors = this.getProcessors(), aliases = this.getAliases(), translation = batchedChanges.translation || batchedChanges.translate, normalized = {}, i, ln, name, val, rotation, scaling, matrix, subVal, split;
  if ('rotation' in batchedChanges) {
    rotation = batchedChanges.rotation;
  } else {
    rotation = 'rotate' in batchedChanges ? batchedChanges.rotate : undefined;
  }
  if ('scaling' in batchedChanges) {
    scaling = batchedChanges.scaling;
  } else {
    scaling = 'scale' in batchedChanges ? batchedChanges.scale : undefined;
  }
  if (typeof scaling !== 'undefined') {
    if (Ext.isNumber(scaling)) {
      normalized.scalingX = scaling;
      normalized.scalingY = scaling;
    } else {
      if ('x' in scaling) {
        normalized.scalingX = scaling.x;
      }
      if ('y' in scaling) {
        normalized.scalingY = scaling.y;
      }
      if ('centerX' in scaling) {
        normalized.scalingCenterX = scaling.centerX;
      }
      if ('centerY' in scaling) {
        normalized.scalingCenterY = scaling.centerY;
      }
    }
  }
  if (typeof rotation !== 'undefined') {
    if (Ext.isNumber(rotation)) {
      rotation = Ext.draw.Draw.rad(rotation);
      normalized.rotationRads = rotation;
    } else {
      if ('rads' in rotation) {
        normalized.rotationRads = rotation.rads;
      } else {
        if ('degrees' in rotation) {
          if (Ext.isArray(rotation.degrees)) {
            normalized.rotationRads = Ext.Array.map(rotation.degrees, function(deg) {
              return Ext.draw.Draw.rad(deg);
            });
          } else {
            normalized.rotationRads = Ext.draw.Draw.rad(rotation.degrees);
          }
        }
      }
      if ('centerX' in rotation) {
        normalized.rotationCenterX = rotation.centerX;
      }
      if ('centerY' in rotation) {
        normalized.rotationCenterY = rotation.centerY;
      }
    }
  }
  if (typeof translation !== 'undefined') {
    if ('x' in translation) {
      normalized.translationX = translation.x;
    }
    if ('y' in translation) {
      normalized.translationY = translation.y;
    }
  }
  if ('matrix' in batchedChanges) {
    matrix = Ext.draw.Matrix.create(batchedChanges.matrix);
    split = matrix.split();
    normalized.matrix = matrix;
    normalized.rotationRads = split.rotation;
    normalized.rotationCenterX = 0;
    normalized.rotationCenterY = 0;
    normalized.scalingX = split.scaleX;
    normalized.scalingY = split.scaleY;
    normalized.scalingCenterX = 0;
    normalized.scalingCenterY = 0;
    normalized.translationX = split.translateX;
    normalized.translationY = split.translateY;
  }
  for (name in batchedChanges) {
    val = batchedChanges[name];
    if (typeof val === 'undefined') {
      continue;
    } else {
      if (Ext.isArray(val)) {
        if (name in aliases) {
          name = aliases[name];
        }
        if (name in processors) {
          normalized[name] = [];
          for (i = 0, ln = val.length; i < ln; i++) {
            subVal = processors[name].call(this, val[i]);
            if (typeof subVal !== 'undefined') {
              normalized[name][i] = subVal;
            }
          }
        } else {
          if (keepUnrecognized) {
            normalized[name] = val;
          }
        }
      } else {
        if (name in aliases) {
          name = aliases[name];
        }
        if (name in processors) {
          val = processors[name].call(this, val);
          if (typeof val !== 'undefined') {
            normalized[name] = val;
          }
        } else {
          if (keepUnrecognized) {
            normalized[name] = val;
          }
        }
      }
    }
  }
  return normalized;
}, normalize:function(changes, keepUnrecognized) {
  if (!changes) {
    return {};
  }
  var processors = this.getProcessors(), aliases = this.getAliases(), translation = changes.translation || changes.translate, normalized = {}, name, val, rotation, scaling, matrix, split;
  if ('rotation' in changes) {
    rotation = changes.rotation;
  } else {
    rotation = 'rotate' in changes ? changes.rotate : undefined;
  }
  if ('scaling' in changes) {
    scaling = changes.scaling;
  } else {
    scaling = 'scale' in changes ? changes.scale : undefined;
  }
  if (translation) {
    if ('x' in translation) {
      normalized.translationX = translation.x;
    }
    if ('y' in translation) {
      normalized.translationY = translation.y;
    }
  }
  if (typeof scaling !== 'undefined') {
    if (Ext.isNumber(scaling)) {
      normalized.scalingX = scaling;
      normalized.scalingY = scaling;
    } else {
      if ('x' in scaling) {
        normalized.scalingX = scaling.x;
      }
      if ('y' in scaling) {
        normalized.scalingY = scaling.y;
      }
      if ('centerX' in scaling) {
        normalized.scalingCenterX = scaling.centerX;
      }
      if ('centerY' in scaling) {
        normalized.scalingCenterY = scaling.centerY;
      }
    }
  }
  if (typeof rotation !== 'undefined') {
    if (Ext.isNumber(rotation)) {
      rotation = Ext.draw.Draw.rad(rotation);
      normalized.rotationRads = rotation;
    } else {
      if ('rads' in rotation) {
        normalized.rotationRads = rotation.rads;
      } else {
        if ('degrees' in rotation) {
          normalized.rotationRads = Ext.draw.Draw.rad(rotation.degrees);
        }
      }
      if ('centerX' in rotation) {
        normalized.rotationCenterX = rotation.centerX;
      }
      if ('centerY' in rotation) {
        normalized.rotationCenterY = rotation.centerY;
      }
    }
  }
  if ('matrix' in changes) {
    matrix = Ext.draw.Matrix.create(changes.matrix);
    split = matrix.split();
    normalized.matrix = matrix;
    normalized.rotationRads = split.rotation;
    normalized.rotationCenterX = 0;
    normalized.rotationCenterY = 0;
    normalized.scalingX = split.scaleX;
    normalized.scalingY = split.scaleY;
    normalized.scalingCenterX = 0;
    normalized.scalingCenterY = 0;
    normalized.translationX = split.translateX;
    normalized.translationY = split.translateY;
  }
  for (name in changes) {
    val = changes[name];
    if (typeof val === 'undefined') {
      continue;
    }
    if (name in aliases) {
      name = aliases[name];
    }
    if (name in processors) {
      val = processors[name].call(this, val);
      if (typeof val !== 'undefined') {
        normalized[name] = val;
      }
    } else {
      if (keepUnrecognized) {
        normalized[name] = val;
      }
    }
  }
  return normalized;
}, setBypassingNormalization:function(attr, modifierStack, changes) {
  return modifierStack.pushDown(attr, changes);
}, set:function(attr, modifierStack, changes) {
  changes = this.normalize(changes);
  return this.setBypassingNormalization(attr, modifierStack, changes);
}}, 1, 0, 0, 0, 0, 0, [Ext.draw.sprite, 'AttributeDefinition'], 0);
Ext.cmd.derive('Ext.draw.Matrix', Ext.Base, {isMatrix:true, statics:{createAffineMatrixFromTwoPair:function(x0, y0, x1, y1, x0p, y0p, x1p, y1p) {
  var dx = x1 - x0, dy = y1 - y0, dxp = x1p - x0p, dyp = y1p - y0p, r = 1 / (dx * dx + dy * dy), a = dx * dxp + dy * dyp, b = dxp * dy - dx * dyp, c = -a * x0 - b * y0, f = b * x0 - a * y0;
  return new this(a * r, -b * r, b * r, a * r, c * r + x0p, f * r + y0p);
}, createPanZoomFromTwoPair:function(x0, y0, x1, y1, x0p, y0p, x1p, y1p) {
  if (arguments.length === 2) {
    return this.createPanZoomFromTwoPair.apply(this, x0.concat(y0));
  }
  var dx = x1 - x0, dy = y1 - y0, cx = (x0 + x1) * 0.5, cy = (y0 + y1) * 0.5, dxp = x1p - x0p, dyp = y1p - y0p, cxp = (x0p + x1p) * 0.5, cyp = (y0p + y1p) * 0.5, r = dx * dx + dy * dy, rp = dxp * dxp + dyp * dyp, scale = Math.sqrt(rp / r);
  return new this(scale, 0, 0, scale, cxp - scale * cx, cyp - scale * cy);
}, fly:function() {
  var flyMatrix = null, simplefly = function(elements) {
    flyMatrix.elements = elements;
    return flyMatrix;
  };
  return function(elements) {
    if (!flyMatrix) {
      flyMatrix = new Ext.draw.Matrix;
    }
    flyMatrix.elements = elements;
    Ext.draw.Matrix.fly = simplefly;
    return flyMatrix;
  };
}(), create:function(mat) {
  if (mat instanceof this) {
    return mat;
  }
  return new this(mat);
}}, constructor:function(xx, xy, yx, yy, dx, dy) {
  if (xx && xx.length === 6) {
    this.elements = xx.slice();
  } else {
    if (xx !== undefined) {
      this.elements = [xx, xy, yx, yy, dx, dy];
    } else {
      this.elements = [1, 0, 0, 1, 0, 0];
    }
  }
}, prepend:function(xx, xy, yx, yy, dx, dy) {
  var elements = this.elements, xx0 = elements[0], xy0 = elements[1], yx0 = elements[2], yy0 = elements[3], dx0 = elements[4], dy0 = elements[5];
  elements[0] = xx * xx0 + yx * xy0;
  elements[1] = xy * xx0 + yy * xy0;
  elements[2] = xx * yx0 + yx * yy0;
  elements[3] = xy * yx0 + yy * yy0;
  elements[4] = xx * dx0 + yx * dy0 + dx;
  elements[5] = xy * dx0 + yy * dy0 + dy;
  return this;
}, prependMatrix:function(matrix) {
  return this.prepend.apply(this, matrix.elements);
}, append:function(xx, xy, yx, yy, dx, dy) {
  var elements = this.elements, xx0 = elements[0], xy0 = elements[1], yx0 = elements[2], yy0 = elements[3], dx0 = elements[4], dy0 = elements[5];
  elements[0] = xx * xx0 + xy * yx0;
  elements[1] = xx * xy0 + xy * yy0;
  elements[2] = yx * xx0 + yy * yx0;
  elements[3] = yx * xy0 + yy * yy0;
  elements[4] = dx * xx0 + dy * yx0 + dx0;
  elements[5] = dx * xy0 + dy * yy0 + dy0;
  return this;
}, appendMatrix:function(matrix) {
  return this.append.apply(this, matrix.elements);
}, set:function(xx, xy, yx, yy, dx, dy) {
  var elements = this.elements;
  elements[0] = xx;
  elements[1] = xy;
  elements[2] = yx;
  elements[3] = yy;
  elements[4] = dx;
  elements[5] = dy;
  return this;
}, inverse:function(target) {
  var elements = this.elements, a = elements[0], b = elements[1], c = elements[2], d = elements[3], e = elements[4], f = elements[5], rDim = 1 / (a * d - b * c);
  a *= rDim;
  b *= rDim;
  c *= rDim;
  d *= rDim;
  if (target) {
    target.set(d, -b, -c, a, c * f - d * e, b * e - a * f);
    return target;
  } else {
    return new Ext.draw.Matrix(d, -b, -c, a, c * f - d * e, b * e - a * f);
  }
}, translate:function(x, y, prepend) {
  if (prepend) {
    return this.prepend(1, 0, 0, 1, x, y);
  } else {
    return this.append(1, 0, 0, 1, x, y);
  }
}, scale:function(sx, sy, scx, scy, prepend) {
  var me = this;
  if (sy == null) {
    sy = sx;
  }
  if (scx === undefined) {
    scx = 0;
  }
  if (scy === undefined) {
    scy = 0;
  }
  if (prepend) {
    return me.prepend(sx, 0, 0, sy, scx - scx * sx, scy - scy * sy);
  } else {
    return me.append(sx, 0, 0, sy, scx - scx * sx, scy - scy * sy);
  }
}, rotate:function(angle, rcx, rcy, prepend) {
  var me = this, cos = Math.cos(angle), sin = Math.sin(angle);
  rcx = rcx || 0;
  rcy = rcy || 0;
  if (prepend) {
    return me.prepend(cos, sin, -sin, cos, rcx - cos * rcx + rcy * sin, rcy - cos * rcy - rcx * sin);
  } else {
    return me.append(cos, sin, -sin, cos, rcx - cos * rcx + rcy * sin, rcy - cos * rcy - rcx * sin);
  }
}, rotateFromVector:function(x, y, prepend) {
  var me = this, d = Math.sqrt(x * x + y * y), cos = x / d, sin = y / d;
  if (prepend) {
    return me.prepend(cos, sin, -sin, cos, 0, 0);
  } else {
    return me.append(cos, sin, -sin, cos, 0, 0);
  }
}, clone:function() {
  return new Ext.draw.Matrix(this.elements);
}, flipX:function() {
  return this.append(-1, 0, 0, 1, 0, 0);
}, flipY:function() {
  return this.append(1, 0, 0, -1, 0, 0);
}, skewX:function(angle) {
  return this.append(1, 0, Math.tan(angle), 1, 0, 0);
}, skewY:function(angle) {
  return this.append(1, Math.tan(angle), 0, 1, 0, 0);
}, shearX:function(factor) {
  return this.append(1, 0, factor, 1, 0, 0);
}, shearY:function(factor) {
  return this.append(1, factor, 0, 1, 0, 0);
}, reset:function() {
  return this.set(1, 0, 0, 1, 0, 0);
}, precisionCompensate:function(devicePixelRatio, comp) {
  var elements = this.elements, x2x = elements[0], x2y = elements[1], y2x = elements[2], y2y = elements[3], newDx = elements[4], newDy = elements[5], r = x2y * y2x - x2x * y2y;
  comp.b = devicePixelRatio * x2y / x2x;
  comp.c = devicePixelRatio * y2x / y2y;
  comp.d = devicePixelRatio;
  comp.xx = x2x / devicePixelRatio;
  comp.yy = y2y / devicePixelRatio;
  comp.dx = (newDy * x2x * y2x - newDx * x2x * y2y) / r / devicePixelRatio;
  comp.dy = (newDx * x2y * y2y - newDy * x2x * y2y) / r / devicePixelRatio;
}, precisionCompensateRect:function(devicePixelRatio, comp) {
  var elements = this.elements, x2x = elements[0], x2y = elements[1], y2x = elements[2], y2y = elements[3], newDx = elements[4], newDy = elements[5], yxOnXx = y2x / x2x;
  comp.b = devicePixelRatio * x2y / x2x;
  comp.c = devicePixelRatio * yxOnXx;
  comp.d = devicePixelRatio * y2y / x2x;
  comp.xx = x2x / devicePixelRatio;
  comp.yy = x2x / devicePixelRatio;
  comp.dx = (newDy * y2x - newDx * y2y) / (x2y * yxOnXx - y2y) / devicePixelRatio;
  comp.dy = -(newDy * x2x - newDx * x2y) / (x2y * yxOnXx - y2y) / devicePixelRatio;
}, x:function(x, y) {
  var elements = this.elements;
  return x * elements[0] + y * elements[2] + elements[4];
}, y:function(x, y) {
  var elements = this.elements;
  return x * elements[1] + y * elements[3] + elements[5];
}, get:function(i, j) {
  return +this.elements[i + j * 2].toFixed(4);
}, transformPoint:function(point) {
  var elements = this.elements, x, y;
  if (point.isPoint) {
    x = point.x;
    y = point.y;
  } else {
    x = point[0];
    y = point[1];
  }
  return [x * elements[0] + y * elements[2] + elements[4], x * elements[1] + y * elements[3] + elements[5]];
}, transformBBox:function(bbox, radius, target) {
  var elements = this.elements, l = bbox.x, t = bbox.y, w0 = bbox.width * 0.5, h0 = bbox.height * 0.5, xx = elements[0], xy = elements[1], yx = elements[2], yy = elements[3], cx = l + w0, cy = t + h0, w, h, scales;
  if (radius) {
    w0 -= radius;
    h0 -= radius;
    scales = [Math.sqrt(elements[0] * elements[0] + elements[2] * elements[2]), Math.sqrt(elements[1] * elements[1] + elements[3] * elements[3])];
    w = Math.abs(w0 * xx) + Math.abs(h0 * yx) + Math.abs(scales[0] * radius);
    h = Math.abs(w0 * xy) + Math.abs(h0 * yy) + Math.abs(scales[1] * radius);
  } else {
    w = Math.abs(w0 * xx) + Math.abs(h0 * yx);
    h = Math.abs(w0 * xy) + Math.abs(h0 * yy);
  }
  if (!target) {
    target = {};
  }
  target.x = cx * xx + cy * yx + elements[4] - w;
  target.y = cx * xy + cy * yy + elements[5] - h;
  target.width = w + w;
  target.height = h + h;
  return target;
}, transformList:function(list) {
  var elements = this.elements, xx = elements[0], yx = elements[2], dx = elements[4], xy = elements[1], yy = elements[3], dy = elements[5], ln = list.length, p, i;
  for (i = 0; i < ln; i++) {
    p = list[i];
    list[i] = [p[0] * xx + p[1] * yx + dx, p[0] * xy + p[1] * yy + dy];
  }
  return list;
}, isIdentity:function() {
  var elements = this.elements;
  return elements[0] === 1 && elements[1] === 0 && elements[2] === 0 && elements[3] === 1 && elements[4] === 0 && elements[5] === 0;
}, isEqual:function(matrix) {
  var elements = matrix && matrix.isMatrix ? matrix.elements : matrix, myElements = this.elements;
  return myElements[0] === elements[0] && myElements[1] === elements[1] && myElements[2] === elements[2] && myElements[3] === elements[3] && myElements[4] === elements[4] && myElements[5] === elements[5];
}, equals:function(matrix) {
  return this.isEqual(matrix);
}, toArray:function() {
  var elements = this.elements;
  return [elements[0], elements[2], elements[4], elements[1], elements[3], elements[5]];
}, toVerticalArray:function() {
  return this.elements.slice();
}, toString:function() {
  var me = this;
  return [me.get(0, 0), me.get(0, 1), me.get(1, 0), me.get(1, 1), me.get(2, 0), me.get(2, 1)].join(',');
}, toContext:function(ctx) {
  ctx.transform.apply(ctx, this.elements);
  return this;
}, toSvg:function() {
  var elements = this.elements;
  return 'matrix(' + elements[0].toFixed(9) + ',' + elements[1].toFixed(9) + ',' + elements[2].toFixed(9) + ',' + elements[3].toFixed(9) + ',' + elements[4].toFixed(9) + ',' + elements[5].toFixed(9) + ')';
}, getScaleX:function() {
  var elements = this.elements;
  return Math.sqrt(elements[0] * elements[0] + elements[2] * elements[2]);
}, getScaleY:function() {
  var elements = this.elements;
  return Math.sqrt(elements[1] * elements[1] + elements[3] * elements[3]);
}, getXX:function() {
  return this.elements[0];
}, getXY:function() {
  return this.elements[1];
}, getYX:function() {
  return this.elements[2];
}, getYY:function() {
  return this.elements[3];
}, getDX:function() {
  return this.elements[4];
}, getDY:function() {
  return this.elements[5];
}, split:function() {
  var el = this.elements, xx = el[0], xy = el[1], yy = el[3], out = {translateX:el[4], translateY:el[5]};
  out.rotate = out.rotation = Math.atan2(xy, xx);
  out.scaleX = xx / Math.cos(out.rotate);
  out.scaleY = yy / xx * out.scaleX;
  return out;
}}, 3, 0, 0, 0, 0, 0, [Ext.draw, 'Matrix'], function() {
  function registerName(properties, name, i) {
    properties[name] = {get:function() {
      return this.elements[i];
    }, set:function(val) {
      this.elements[i] = val;
    }};
  }
  if (Object.defineProperties) {
    var properties = {};
    registerName(properties, 'a', 0);
    registerName(properties, 'b', 1);
    registerName(properties, 'c', 2);
    registerName(properties, 'd', 3);
    registerName(properties, 'e', 4);
    registerName(properties, 'f', 5);
    Object.defineProperties(this.prototype, properties);
  }
  this.prototype.multiply = this.prototype.appendMatrix;
});
Ext.cmd.derive('Ext.draw.modifier.Modifier', Ext.Base, {config:{lower:null, upper:null, sprite:null}, constructor:function(config) {
  this.mixins.observable.constructor.call(this, config);
}, updateUpper:function(upper) {
  if (upper) {
    upper.setLower(this);
  }
}, updateLower:function(lower) {
  if (lower) {
    lower.setUpper(this);
  }
}, prepareAttributes:function(attr) {
  if (this._lower) {
    this._lower.prepareAttributes(attr);
  }
}, popUp:function(attributes, changes) {
  if (this._upper) {
    this._upper.popUp(attributes, changes);
  } else {
    Ext.apply(attributes, changes);
  }
}, pushDown:function(attr, changes) {
  if (this._lower) {
    return this._lower.pushDown(attr, changes);
  } else {
    for (var name in changes) {
      if (changes[name] === attr[name]) {
        delete changes[name];
      }
    }
    return changes;
  }
}}, 1, 0, 0, 0, 0, [['observable', Ext.mixin.Observable]], [Ext.draw.modifier, 'Modifier'], 0);
Ext.cmd.derive('Ext.draw.modifier.Target', Ext.draw.modifier.Modifier, {statics:{uniqueId:0}, prepareAttributes:function(attr) {
  if (this._lower) {
    this._lower.prepareAttributes(attr);
  }
  attr.attributeId = 'attribute-' + Ext.draw.modifier.Target.uniqueId++;
  if (!attr.hasOwnProperty('canvasAttributes')) {
    attr.bbox = {plain:{dirty:true}, transform:{dirty:true}};
    attr.dirty = true;
    attr.pendingUpdaters = {};
    attr.canvasAttributes = {};
    attr.matrix = new Ext.draw.Matrix;
    attr.inverseMatrix = new Ext.draw.Matrix;
  }
}, applyChanges:function(attr, changes) {
  Ext.apply(attr, changes);
  var sprite = this.getSprite(), pendingUpdaters = attr.pendingUpdaters, triggers = sprite.self.def.getTriggers(), updaters, instances, instance, name, hasChanges, canvasAttributes, i, j, ln;
  for (name in changes) {
    hasChanges = true;
    if (updaters = triggers[name]) {
      sprite.scheduleUpdaters(attr, updaters, [name]);
    }
    if (attr.template && changes.removeFromInstance && changes.removeFromInstance[name]) {
      delete attr[name];
    }
  }
  if (!hasChanges) {
    return;
  }
  if (pendingUpdaters.canvas) {
    canvasAttributes = pendingUpdaters.canvas;
    delete pendingUpdaters.canvas;
    for (i = 0, ln = canvasAttributes.length; i < ln; i++) {
      name = canvasAttributes[i];
      attr.canvasAttributes[name] = attr[name];
    }
  }
  if (attr.hasOwnProperty('children')) {
    instances = attr.children;
    for (i = 0, ln = instances.length; i < ln; i++) {
      instance = instances[i];
      Ext.apply(instance.pendingUpdaters, pendingUpdaters);
      if (canvasAttributes) {
        for (j = 0; j < canvasAttributes.length; j++) {
          name = canvasAttributes[j];
          instance.canvasAttributes[name] = instance[name];
        }
      }
      sprite.callUpdaters(instance);
    }
  }
  sprite.setDirty(true);
  sprite.callUpdaters(attr);
}, popUp:function(attr, changes) {
  this.applyChanges(attr, changes);
}, pushDown:function(attr, changes) {
  if (this._lower) {
    changes = this._lower.pushDown(attr, changes);
  }
  this.applyChanges(attr, changes);
  return changes;
}}, 0, 0, 0, 0, ['modifier.target'], 0, [Ext.draw.modifier, 'Target'], 0);
Ext.cmd.derive('Ext.draw.TimingFunctions', Ext.Base, function() {
  var pow = Math.pow, sin = Math.sin, cos = Math.cos, sqrt = Math.sqrt, pi = Math.PI, poly = ['quad', 'cube', 'quart', 'quint'], easings = {pow:function(p, x) {
    return pow(p, x || 6);
  }, expo:function(p) {
    return pow(2, 8 * (p - 1));
  }, circ:function(p) {
    return 1 - sqrt(1 - p * p);
  }, sine:function(p) {
    return 1 - sin((1 - p) * pi / 2);
  }, back:function(p, n) {
    n = n || 1.616;
    return p * p * ((n + 1) * p - n);
  }, bounce:function(p) {
    for (var a = 0, b = 1; 1; a += b, b /= 2) {
      if (p >= (7 - 4 * a) / 11) {
        return b * b - pow((11 - 6 * a - 11 * p) / 4, 2);
      }
    }
  }, elastic:function(p, x) {
    return pow(2, 10 * --p) * cos(20 * p * pi * (x || 1) / 3);
  }}, easingsMap = {}, name, len, i;
  function createPoly(times) {
    return function(p) {
      return pow(p, times);
    };
  }
  function addEasing(name, easing) {
    easingsMap[name + 'In'] = function(pos) {
      return easing(pos);
    };
    easingsMap[name + 'Out'] = function(pos) {
      return 1 - easing(1 - pos);
    };
    easingsMap[name + 'InOut'] = function(pos) {
      return pos <= 0.5 ? easing(2 * pos) / 2 : (2 - easing(2 * (1 - pos))) / 2;
    };
  }
  for (i = 0, len = poly.length; i < len; ++i) {
    easings[poly[i]] = createPoly(i + 2);
  }
  for (name in easings) {
    addEasing(name, easings[name]);
  }
  easingsMap.linear = Ext.identityFn;
  easingsMap.easeIn = easingsMap.quadIn;
  easingsMap.easeOut = easingsMap.quadOut;
  easingsMap.easeInOut = easingsMap.quadInOut;
  return {singleton:true, easingMap:easingsMap};
}, 0, 0, 0, 0, 0, 0, [Ext.draw, 'TimingFunctions'], function(Cls) {
  Ext.apply(Cls, Cls.easingMap);
});
Ext.cmd.derive('Ext.draw.Animator', Ext.Base, {singleton:true, frameCallbacks:{}, frameCallbackId:0, scheduled:0, frameStartTimeOffset:Ext.now(), animations:[], running:false, animationTime:function() {
  return Ext.AnimationQueue.frameStartTime - this.frameStartTimeOffset;
}, add:function(animation) {
  var me = this;
  if (!me.contains(animation)) {
    me.animations.push(animation);
    me.ignite();
    if ('fireEvent' in animation) {
      animation.fireEvent('animationstart', animation);
    }
  }
}, remove:function(animation) {
  var me = this, animations = me.animations, i = 0, l = animations.length;
  for (; i < l; ++i) {
    if (animations[i] === animation) {
      animations.splice(i, 1);
      if ('fireEvent' in animation) {
        animation.fireEvent('animationend', animation);
      }
      return;
    }
  }
}, contains:function(animation) {
  return Ext.Array.indexOf(this.animations, animation) > -1;
}, empty:function() {
  return this.animations.length === 0;
}, step:function(frameTime) {
  var me = this, animations = me.animations, animation, i = 0, ln = animations.length;
  for (; i < ln; i++) {
    animation = animations[i];
    animation.step(frameTime);
    if (!animation.animating) {
      animations.splice(i, 1);
      i--;
      ln--;
      if (animation.fireEvent) {
        animation.fireEvent('animationend', animation);
      }
    }
  }
}, schedule:function(callback, scope) {
  scope = scope || this;
  var id = 'frameCallback' + this.frameCallbackId++;
  if (Ext.isString(callback)) {
    callback = scope[callback];
  }
  Ext.draw.Animator.frameCallbacks[id] = {fn:callback, scope:scope, once:true};
  this.scheduled++;
  Ext.draw.Animator.ignite();
  return id;
}, scheduleIf:function(callback, scope) {
  scope = scope || this;
  var frameCallbacks = Ext.draw.Animator.frameCallbacks, cb, id;
  if (Ext.isString(callback)) {
    callback = scope[callback];
  }
  for (id in frameCallbacks) {
    cb = frameCallbacks[id];
    if (cb.once && cb.fn === callback && cb.scope === scope) {
      return null;
    }
  }
  return this.schedule(callback, scope);
}, cancel:function(id) {
  if (Ext.draw.Animator.frameCallbacks[id] && Ext.draw.Animator.frameCallbacks[id].once) {
    this.scheduled--;
    delete Ext.draw.Animator.frameCallbacks[id];
    Ext.draw.Draw.endUpdateIOS();
  }
}, clear:function() {
  this.animations.length = 0;
  this.running = false;
  Ext.draw.Animator.frameCallbacks = {};
  Ext.draw.Draw.endUpdateIOS();
}, addFrameCallback:function(callback, scope) {
  scope = scope || this;
  if (Ext.isString(callback)) {
    callback = scope[callback];
  }
  var id = 'frameCallback' + this.frameCallbackId++;
  Ext.draw.Animator.frameCallbacks[id] = {fn:callback, scope:scope};
  return id;
}, removeFrameCallback:function(id) {
  delete Ext.draw.Animator.frameCallbacks[id];
}, fireFrameCallbacks:function() {
  var callbacks = this.frameCallbacks, id, fn, cb;
  for (id in callbacks) {
    cb = callbacks[id];
    fn = cb.fn;
    if (Ext.isString(fn)) {
      fn = cb.scope[fn];
    }
    fn.call(cb.scope);
    if (callbacks[id] && cb.once) {
      this.scheduled--;
      delete callbacks[id];
    }
  }
}, handleFrame:function() {
  var me = this;
  me.step(me.animationTime());
  me.fireFrameCallbacks();
  if (!me.scheduled && me.empty()) {
    Ext.AnimationQueue.stop(me.handleFrame, me);
    me.running = false;
    Ext.draw.Draw.endUpdateIOS();
  }
}, ignite:function() {
  if (!this.running) {
    this.running = true;
    Ext.AnimationQueue.start(this.handleFrame, this);
    Ext.draw.Draw.beginUpdateIOS();
  }
}}, 0, 0, 0, 0, 0, 0, [Ext.draw, 'Animator'], 0);
Ext.cmd.derive('Ext.draw.modifier.Animation', Ext.draw.modifier.Modifier, {config:{easing:Ext.identityFn, duration:0, customEasings:{}, customDurations:{}}, constructor:function(config) {
  var me = this;
  me.anyAnimation = me.anySpecialAnimations = false;
  me.animating = 0;
  me.animatingPool = [];
  Ext.draw.modifier.Modifier.prototype.constructor.call(this, config);
}, prepareAttributes:function(attr) {
  if (!attr.hasOwnProperty('timers')) {
    attr.animating = false;
    attr.timers = {};
    attr.animationOriginal = Ext.Object.chain(attr);
    attr.animationOriginal.prototype = attr;
  }
  if (this._lower) {
    this._lower.prepareAttributes(attr.animationOriginal);
  }
}, updateSprite:function(sprite) {
  this.setConfig(sprite.config.fx);
}, updateDuration:function(duration) {
  this.anyAnimation = duration > 0;
}, applyEasing:function(easing) {
  if (typeof easing === 'string') {
    easing = Ext.draw.TimingFunctions.easingMap[easing];
  }
  return easing;
}, applyCustomEasings:function(newEasings, oldEasings) {
  oldEasings = oldEasings || {};
  var any, key, attrs, easing, i, ln;
  for (key in newEasings) {
    any = true;
    easing = newEasings[key];
    attrs = key.split(',');
    if (typeof easing === 'string') {
      easing = Ext.draw.TimingFunctions.easingMap[easing];
    }
    for (i = 0, ln = attrs.length; i < ln; i++) {
      oldEasings[attrs[i]] = easing;
    }
  }
  if (any) {
    this.anySpecialAnimations = any;
  }
  return oldEasings;
}, setEasingOn:function(attrs, easing) {
  attrs = Ext.Array.from(attrs).slice();
  var customEasings = {}, ln = attrs.length, i = 0;
  for (; i < ln; i++) {
    customEasings[attrs[i]] = easing;
  }
  this.setCustomEasings(customEasings);
}, clearEasingOn:function(attrs) {
  attrs = Ext.Array.from(attrs, true);
  var i = 0, ln = attrs.length;
  for (; i < ln; i++) {
    delete this._customEasings[attrs[i]];
  }
}, applyCustomDurations:function(newDurations, oldDurations) {
  oldDurations = oldDurations || {};
  var any, key, duration, attrs, i, ln;
  for (key in newDurations) {
    any = true;
    duration = newDurations[key];
    attrs = key.split(',');
    for (i = 0, ln = attrs.length; i < ln; i++) {
      oldDurations[attrs[i]] = duration;
    }
  }
  if (any) {
    this.anySpecialAnimations = any;
  }
  return oldDurations;
}, setDurationOn:function(attrs, duration) {
  attrs = Ext.Array.from(attrs).slice();
  var customDurations = {}, i = 0, ln = attrs.length;
  for (; i < ln; i++) {
    customDurations[attrs[i]] = duration;
  }
  this.setCustomDurations(customDurations);
}, clearDurationOn:function(attrs) {
  attrs = Ext.Array.from(attrs, true);
  var i = 0, ln = attrs.length;
  for (; i < ln; i++) {
    delete this._customDurations[attrs[i]];
  }
}, setAnimating:function(attr, animating) {
  var me = this, pool = me.animatingPool;
  if (attr.animating !== animating) {
    attr.animating = animating;
    if (animating) {
      pool.push(attr);
      if (me.animating === 0) {
        Ext.draw.Animator.add(me);
      }
      me.animating++;
    } else {
      for (var i = pool.length; i--;) {
        if (pool[i] === attr) {
          pool.splice(i, 1);
        }
      }
      me.animating = pool.length;
    }
  }
}, setAttrs:function(attr, changes) {
  var me = this, timers = attr.timers, parsers = me._sprite.self.def._animationProcessors, defaultEasing = me._easing, defaultDuration = me._duration, customDurations = me._customDurations, customEasings = me._customEasings, anySpecial = me.anySpecialAnimations, any = me.anyAnimation || anySpecial, animationOriginal = attr.animationOriginal, ignite = false, timer, name, newValue, startValue, parser, easing, duration;
  if (!any) {
    for (name in changes) {
      if (attr[name] === changes[name]) {
        delete changes[name];
      } else {
        attr[name] = changes[name];
      }
      delete animationOriginal[name];
      delete timers[name];
    }
    return changes;
  } else {
    for (name in changes) {
      newValue = changes[name];
      startValue = attr[name];
      if (newValue !== startValue && startValue !== undefined && startValue !== null && (parser = parsers[name])) {
        easing = defaultEasing;
        duration = defaultDuration;
        if (anySpecial) {
          if (name in customEasings) {
            easing = customEasings[name];
          }
          if (name in customDurations) {
            duration = customDurations[name];
          }
        }
        if (startValue && startValue.isGradient || newValue && newValue.isGradient) {
          duration = 0;
        }
        if (duration) {
          if (!timers[name]) {
            timers[name] = {};
          }
          timer = timers[name];
          timer.start = 0;
          timer.easing = easing;
          timer.duration = duration;
          timer.compute = parser.compute;
          timer.serve = parser.serve || Ext.identityFn;
          timer.remove = changes.removeFromInstance && changes.removeFromInstance[name];
          if (parser.parseInitial) {
            var initial = parser.parseInitial(startValue, newValue);
            timer.source = initial[0];
            timer.target = initial[1];
          } else {
            if (parser.parse) {
              timer.source = parser.parse(startValue);
              timer.target = parser.parse(newValue);
            } else {
              timer.source = startValue;
              timer.target = newValue;
            }
          }
          animationOriginal[name] = newValue;
          delete changes[name];
          ignite = true;
          continue;
        } else {
          delete animationOriginal[name];
        }
      } else {
        delete animationOriginal[name];
      }
      delete timers[name];
    }
  }
  if (ignite && !attr.animating) {
    me.setAnimating(attr, true);
  }
  return changes;
}, updateAttributes:function(attr) {
  if (!attr.animating) {
    return {};
  }
  var changes = {}, any = false, timers = attr.timers, animationOriginal = attr.animationOriginal, now = Ext.draw.Animator.animationTime(), name, timer, delta;
  if (attr.lastUpdate === now) {
    return null;
  }
  for (name in timers) {
    timer = timers[name];
    if (!timer.start) {
      timer.start = now;
      delta = 0;
    } else {
      delta = (now - timer.start) / timer.duration;
    }
    if (delta >= 1) {
      changes[name] = animationOriginal[name];
      delete animationOriginal[name];
      if (timers[name].remove) {
        changes.removeFromInstance = changes.removeFromInstance || {};
        changes.removeFromInstance[name] = true;
      }
      delete timers[name];
    } else {
      changes[name] = timer.serve(timer.compute(timer.source, timer.target, timer.easing(delta), attr[name]));
      any = true;
    }
  }
  attr.lastUpdate = now;
  this.setAnimating(attr, any);
  return changes;
}, pushDown:function(attr, changes) {
  changes = Ext.draw.modifier.Modifier.prototype.pushDown.call(this, attr.animationOriginal, changes);
  return this.setAttrs(attr, changes);
}, popUp:function(attr, changes) {
  attr = attr.prototype;
  changes = this.setAttrs(attr, changes);
  if (this._upper) {
    return this._upper.popUp(attr, changes);
  } else {
    return Ext.apply(attr, changes);
  }
}, step:function(frameTime) {
  var me = this, pool = me.animatingPool.slice(), ln = pool.length, i = 0, attr, changes;
  for (; i < ln; i++) {
    attr = pool[i];
    changes = me.updateAttributes(attr);
    if (changes && me._upper) {
      me._upper.popUp(attr, changes);
    }
  }
}, stop:function() {
  this.step();
  var me = this, pool = me.animatingPool, i, ln;
  for (i = 0, ln = pool.length; i < ln; i++) {
    pool[i].animating = false;
  }
  me.animatingPool.length = 0;
  me.animating = 0;
  Ext.draw.Animator.remove(me);
}, destroy:function() {
  Ext.draw.Animator.remove(this);
  Ext.draw.modifier.Modifier.prototype.destroy.call(this);
}}, 1, 0, 0, 0, ['modifier.animation'], 0, [Ext.draw.modifier, 'Animation'], 0);
Ext.cmd.derive('Ext.draw.modifier.Highlight', Ext.draw.modifier.Modifier, {config:{enabled:false, highlightStyle:null}, preFx:true, applyHighlightStyle:function(style, oldStyle) {
  oldStyle = oldStyle || {};
  if (this.getSprite()) {
    Ext.apply(oldStyle, this.getSprite().self.def.normalize(style));
  } else {
    Ext.apply(oldStyle, style);
  }
  return oldStyle;
}, prepareAttributes:function(attr) {
  if (!attr.hasOwnProperty('highlightOriginal')) {
    attr.highlighted = false;
    attr.highlightOriginal = Ext.Object.chain(attr);
    attr.highlightOriginal.prototype = attr;
    attr.highlightOriginal.removeFromInstance = {};
  }
  if (this._lower) {
    this._lower.prepareAttributes(attr.highlightOriginal);
  }
}, updateSprite:function(sprite, oldSprite) {
  if (sprite) {
    if (this.getHighlightStyle()) {
      this._highlightStyle = sprite.self.def.normalize(this.getHighlightStyle());
    }
    this.setHighlightStyle(sprite.config.highlight);
  }
  sprite.self.def.setConfig({defaults:{highlighted:false}, processors:{highlighted:'bool'}});
  this.setSprite(sprite);
}, filterChanges:function(attr, changes) {
  var me = this, highlightOriginal = attr.highlightOriginal, style = me.getHighlightStyle(), name;
  if (attr.highlighted) {
    for (name in changes) {
      if (style.hasOwnProperty(name)) {
        highlightOriginal[name] = changes[name];
        delete changes[name];
      }
    }
  }
  return changes;
}, pushDown:function(attr, changes) {
  var highlightStyle = this.getHighlightStyle(), highlightOriginal = attr.highlightOriginal, removeFromInstance = highlightOriginal.removeFromInstance, highlighted, name, tplAttr, timer;
  if (changes.hasOwnProperty('highlighted')) {
    highlighted = changes.highlighted;
    delete changes.highlighted;
    if (this._lower) {
      changes = this._lower.pushDown(highlightOriginal, changes);
    }
    changes = this.filterChanges(attr, changes);
    if (highlighted !== attr.highlighted) {
      if (highlighted) {
        for (name in highlightStyle) {
          if (name in changes) {
            highlightOriginal[name] = changes[name];
          } else {
            tplAttr = attr.template && attr.template.ownAttr;
            if (tplAttr && !attr.prototype.hasOwnProperty(name)) {
              removeFromInstance[name] = true;
              highlightOriginal[name] = tplAttr.animationOriginal[name];
            } else {
              timer = highlightOriginal.timers[name];
              if (timer && timer.remove) {
                removeFromInstance[name] = true;
              }
              highlightOriginal[name] = attr[name];
            }
          }
          if (highlightOriginal[name] !== highlightStyle[name]) {
            changes[name] = highlightStyle[name];
          }
        }
      } else {
        for (name in highlightStyle) {
          if (!(name in changes)) {
            changes[name] = highlightOriginal[name];
          }
          delete highlightOriginal[name];
        }
        changes.removeFromInstance = changes.removeFromInstance || {};
        Ext.apply(changes.removeFromInstance, removeFromInstance);
        highlightOriginal.removeFromInstance = {};
      }
      changes.highlighted = highlighted;
    }
  } else {
    if (this._lower) {
      changes = this._lower.pushDown(highlightOriginal, changes);
    }
    changes = this.filterChanges(attr, changes);
  }
  return changes;
}, popUp:function(attr, changes) {
  changes = this.filterChanges(attr, changes);
  Ext.draw.modifier.Modifier.prototype.popUp.call(this, attr, changes);
}}, 0, 0, 0, 0, ['modifier.highlight'], 0, [Ext.draw.modifier, 'Highlight'], 0);
Ext.cmd.derive('Ext.draw.sprite.Sprite', Ext.Base, {isSprite:true, statics:{defaultHitTestOptions:{fill:true, stroke:true}}, inheritableStatics:{def:{processors:{strokeStyle:'color', fillStyle:'color', strokeOpacity:'limited01', fillOpacity:'limited01', lineWidth:'number', lineCap:'enums(butt,round,square)', lineJoin:'enums(round,bevel,miter)', lineDash:'data', lineDashOffset:'number', miterLimit:'number', shadowColor:'color', shadowOffsetX:'number', shadowOffsetY:'number', shadowBlur:'number', globalAlpha:'limited01', 
globalCompositeOperation:'enums(source-over,destination-over,source-in,destination-in,source-out,destination-out,source-atop,destination-atop,lighter,xor,copy)', hidden:'bool', transformFillStroke:'bool', zIndex:'number', translationX:'number', translationY:'number', rotationRads:'number', rotationCenterX:'number', rotationCenterY:'number', scalingX:'number', scalingY:'number', scalingCenterX:'number', scalingCenterY:'number', constrainGradients:'bool'}, aliases:{'stroke':'strokeStyle', 'fill':'fillStyle', 
'color':'fillStyle', 'stroke-width':'lineWidth', 'stroke-linecap':'lineCap', 'stroke-linejoin':'lineJoin', 'stroke-miterlimit':'miterLimit', 'text-anchor':'textAlign', 'opacity':'globalAlpha', translateX:'translationX', translateY:'translationY', rotateRads:'rotationRads', rotateCenterX:'rotationCenterX', rotateCenterY:'rotationCenterY', scaleX:'scalingX', scaleY:'scalingY', scaleCenterX:'scalingCenterX', scaleCenterY:'scalingCenterY'}, defaults:{hidden:false, zIndex:0, strokeStyle:'none', fillStyle:'none', 
lineWidth:1, lineDash:[], lineDashOffset:0, lineCap:'butt', lineJoin:'miter', miterLimit:10, shadowColor:'none', shadowOffsetX:0, shadowOffsetY:0, shadowBlur:0, globalAlpha:1, strokeOpacity:1, fillOpacity:1, transformFillStroke:false, translationX:0, translationY:0, rotationRads:0, rotationCenterX:null, rotationCenterY:null, scalingX:1, scalingY:1, scalingCenterX:null, scalingCenterY:null, constrainGradients:false}, triggers:{zIndex:'zIndex', globalAlpha:'canvas', globalCompositeOperation:'canvas', 
transformFillStroke:'canvas', strokeStyle:'canvas', fillStyle:'canvas', strokeOpacity:'canvas', fillOpacity:'canvas', lineWidth:'canvas', lineCap:'canvas', lineJoin:'canvas', lineDash:'canvas', lineDashOffset:'canvas', miterLimit:'canvas', shadowColor:'canvas', shadowOffsetX:'canvas', shadowOffsetY:'canvas', shadowBlur:'canvas', translationX:'transform', translationY:'transform', rotationRads:'transform', rotationCenterX:'transform', rotationCenterY:'transform', scalingX:'transform', scalingY:'transform', 
scalingCenterX:'transform', scalingCenterY:'transform', constrainGradients:'canvas'}, updaters:{bbox:'bboxUpdater', zIndex:function(attr) {
  attr.dirtyZIndex = true;
}, transform:function(attr) {
  attr.dirtyTransform = true;
  attr.bbox.transform.dirty = true;
}}}}, config:{parent:null, surface:null}, onClassExtended:function(subClass, data) {
  var superclassCfg = subClass.superclass.self.def.initialConfig, ownCfg = data.inheritableStatics && data.inheritableStatics.def, cfg;
  if (ownCfg) {
    cfg = Ext.Object.merge({}, superclassCfg, ownCfg);
    subClass.def = new Ext.draw.sprite.AttributeDefinition(cfg);
    delete data.inheritableStatics.def;
  } else {
    subClass.def = new Ext.draw.sprite.AttributeDefinition(superclassCfg);
  }
  subClass.def.spriteClass = subClass;
}, constructor:function(config) {
  var me = this, attributeDefinition = me.self.def, defaults = attributeDefinition.getDefaults(), modifiers;
  config = Ext.isObject(config) ? config : {};
  me.id = config.id || Ext.id(null, 'ext-sprite-');
  me.attr = {};
  me.mixins.observable.constructor.apply(me, arguments);
  modifiers = Ext.Array.from(config.modifiers, true);
  me.prepareModifiers(modifiers);
  me.initializeAttributes();
  me.setAttributes(defaults, true);
  me.setAttributes(config);
}, updateSurface:function(surface, oldSurface) {
  if (oldSurface) {
    oldSurface.remove(this);
  }
}, getDirty:function() {
  return this.attr.dirty;
}, setDirty:function(dirty) {
  this.attr.dirty = dirty;
  if (dirty) {
    var parent = this.getParent();
    if (parent) {
      parent.setDirty(true);
    }
  }
}, addModifier:function(modifier, reinitializeAttributes) {
  var me = this;
  if (!(modifier instanceof Ext.draw.modifier.Modifier)) {
    modifier = Ext.factory(modifier, null, null, 'modifier');
  }
  modifier.setSprite(me);
  if (modifier.preFx || modifier.config && modifier.config.preFx) {
    if (me.fx._lower) {
      me.fx._lower.setUpper(modifier);
    }
    modifier.setUpper(me.fx);
  } else {
    me.topModifier._lower.setUpper(modifier);
    modifier.setUpper(me.topModifier);
  }
  if (reinitializeAttributes) {
    me.initializeAttributes();
  }
  return modifier;
}, prepareModifiers:function(additionalModifiers) {
  var me = this, i, ln;
  me.topModifier = new Ext.draw.modifier.Target({sprite:me});
  me.fx = new Ext.draw.modifier.Animation({sprite:me});
  me.fx.setUpper(me.topModifier);
  for (i = 0, ln = additionalModifiers.length; i < ln; i++) {
    me.addModifier(additionalModifiers[i], false);
  }
}, getAnimation:function() {
  return this.fx;
}, setAnimation:function(config) {
  this.fx.setConfig(config);
}, initializeAttributes:function() {
  this.topModifier.prepareAttributes(this.attr);
}, callUpdaters:function(attr) {
  attr = attr || this.attr;
  var me = this, pendingUpdaters = attr.pendingUpdaters, updaters = me.self.def.getUpdaters(), any = false, dirty = false, flags, updater, fn;
  me.callUpdaters = Ext.emptyFn;
  do {
    any = false;
    for (updater in pendingUpdaters) {
      any = true;
      flags = pendingUpdaters[updater];
      delete pendingUpdaters[updater];
      fn = updaters[updater];
      if (typeof fn === 'string') {
        fn = me[fn];
      }
      if (fn) {
        fn.call(me, attr, flags);
      }
    }
    dirty = dirty || any;
  } while (any);
  delete me.callUpdaters;
  if (dirty) {
    me.setDirty(true);
  }
}, callUpdater:function(attr, updater, triggers) {
  this.scheduleUpdater(attr, updater, triggers);
  this.callUpdaters(attr);
}, scheduleUpdaters:function(attr, updaters, triggers) {
  var updater;
  attr = attr || this.attr;
  if (triggers) {
    for (var i = 0, ln = updaters.length; i < ln; i++) {
      updater = updaters[i];
      this.scheduleUpdater(attr, updater, triggers);
    }
  } else {
    for (updater in updaters) {
      triggers = updaters[updater];
      this.scheduleUpdater(attr, updater, triggers);
    }
  }
}, scheduleUpdater:function(attr, updater, triggers) {
  triggers = triggers || [];
  attr = attr || this.attr;
  var pendingUpdaters = attr.pendingUpdaters;
  if (updater in pendingUpdaters) {
    if (triggers.length) {
      pendingUpdaters[updater] = Ext.Array.merge(pendingUpdaters[updater], triggers);
    }
  } else {
    pendingUpdaters[updater] = triggers;
  }
}, setAttributes:function(changes, bypassNormalization, avoidCopy) {
  var me = this, changesToPush;
  if (bypassNormalization) {
    if (avoidCopy) {
      changesToPush = changes;
    } else {
      changesToPush = Ext.apply({}, changes);
    }
  } else {
    changesToPush = me.self.def.normalize(changes);
  }
  me.topModifier.pushDown(me.attr, changesToPush);
}, setAttributesBypassingNormalization:function(changes, avoidCopy) {
  return this.setAttributes(changes, true, avoidCopy);
}, bboxUpdater:function(attr) {
  var hasRotation = attr.rotationRads !== 0, hasScaling = attr.scalingX !== 1 || attr.scalingY !== 1, noRotationCenter = attr.rotationCenterX === null || attr.rotationCenterY === null, noScalingCenter = attr.scalingCenterX === null || attr.scalingCenterY === null;
  attr.bbox.plain.dirty = true;
  attr.bbox.transform.dirty = true;
  if (hasRotation && noRotationCenter || hasScaling && noScalingCenter) {
    this.scheduleUpdater(attr, 'transform');
  }
}, getBBox:function(isWithoutTransform) {
  var me = this, attr = me.attr, bbox = attr.bbox, plain = bbox.plain, transform = bbox.transform;
  if (plain.dirty) {
    me.updatePlainBBox(plain);
    plain.dirty = false;
  }
  if (!isWithoutTransform) {
    me.applyTransformations();
    if (transform.dirty) {
      me.updateTransformedBBox(transform, plain);
      transform.dirty = false;
    }
    return transform;
  }
  return plain;
}, updatePlainBBox:Ext.emptyFn, updateTransformedBBox:function(transform, plain) {
  this.attr.matrix.transformBBox(plain, 0, transform);
}, getBBoxCenter:function(isWithoutTransform) {
  var bbox = this.getBBox(isWithoutTransform);
  if (bbox) {
    return [bbox.x + bbox.width * 0.5, bbox.y + bbox.height * 0.5];
  } else {
    return [0, 0];
  }
}, hide:function() {
  this.attr.hidden = true;
  this.setDirty(true);
  return this;
}, show:function() {
  this.attr.hidden = false;
  this.setDirty(true);
  return this;
}, useAttributes:function(ctx, rect) {
  this.applyTransformations(this.isSpriteInstance);
  var attr = this.attr, canvasAttributes = attr.canvasAttributes, strokeStyle = canvasAttributes.strokeStyle, fillStyle = canvasAttributes.fillStyle, lineDash = canvasAttributes.lineDash, lineDashOffset = canvasAttributes.lineDashOffset, id;
  if (strokeStyle) {
    if (strokeStyle.isGradient) {
      ctx.strokeStyle = 'black';
      ctx.strokeGradient = strokeStyle;
    } else {
      ctx.strokeGradient = false;
    }
  }
  if (fillStyle) {
    if (fillStyle.isGradient) {
      ctx.fillStyle = 'black';
      ctx.fillGradient = fillStyle;
    } else {
      ctx.fillGradient = false;
    }
  }
  if (lineDash) {
    ctx.setLineDash(lineDash);
  }
  if (Ext.isNumber(lineDashOffset) && Ext.isNumber(ctx.lineDashOffset)) {
    ctx.lineDashOffset = lineDashOffset;
  }
  for (id in canvasAttributes) {
    if (canvasAttributes[id] !== undefined && canvasAttributes[id] !== ctx[id]) {
      ctx[id] = canvasAttributes[id];
    }
  }
  this.setGradientBBox(ctx, rect);
}, setGradientBBox:function(ctx, rect) {
  var attr = this.attr;
  if (attr.constrainGradients) {
    ctx.setGradientBBox({x:rect[0], y:rect[1], width:rect[2], height:rect[3]});
  } else {
    ctx.setGradientBBox(this.getBBox(attr.transformFillStroke));
  }
}, applyTransformations:function(force) {
  if (!force && !this.attr.dirtyTransform) {
    return;
  }
  var me = this, attr = me.attr, center = me.getBBoxCenter(true), centerX = center[0], centerY = center[1], tx = attr.translationX, ty = attr.translationY, sx = attr.scalingX, sy = attr.scalingY === null ? attr.scalingX : attr.scalingY, scx = attr.scalingCenterX === null ? centerX : attr.scalingCenterX, scy = attr.scalingCenterY === null ? centerY : attr.scalingCenterY, rad = attr.rotationRads, rcx = attr.rotationCenterX === null ? centerX : attr.rotationCenterX, rcy = attr.rotationCenterY === null ? 
  centerY : attr.rotationCenterY, cos = Math.cos(rad), sin = Math.sin(rad), tx_4, ty_4;
  if (sx === 1 && sy === 1) {
    scx = 0;
    scy = 0;
  }
  if (rad === 0) {
    rcx = 0;
    rcy = 0;
  }
  tx_4 = scx * (1 - sx) - rcx;
  ty_4 = scy * (1 - sy) - rcy;
  attr.matrix.elements = [cos * sx, sin * sx, -sin * sy, cos * sy, cos * tx_4 - sin * ty_4 + rcx + tx, sin * tx_4 + cos * ty_4 + rcy + ty];
  attr.matrix.inverse(attr.inverseMatrix);
  attr.dirtyTransform = false;
  attr.bbox.transform.dirty = true;
}, transform:function(matrix, isSplit) {
  var attr = this.attr, spriteMatrix = attr.matrix, elements;
  if (matrix && matrix.isMatrix) {
    elements = matrix.elements;
  } else {
    elements = matrix;
  }
  spriteMatrix.prepend.apply(spriteMatrix, elements.slice());
  spriteMatrix.inverse(attr.inverseMatrix);
  if (isSplit) {
    this.updateTransformAttributes();
  }
  attr.dirtyTransform = false;
  attr.bbox.transform.dirty = true;
  this.setDirty(true);
  return this;
}, updateTransformAttributes:function() {
  var attr = this.attr, split = attr.matrix.split();
  attr.rotationRads = split.rotate;
  attr.rotationCenterX = 0;
  attr.rotationCenterY = 0;
  attr.scalingX = split.scaleX;
  attr.scalingY = split.scaleY;
  attr.scalingCenterX = 0;
  attr.scalingCenterY = 0;
  attr.translationX = split.translateX;
  attr.translationY = split.translateY;
}, resetTransform:function(isSplit) {
  var attr = this.attr;
  attr.matrix.reset();
  attr.inverseMatrix.reset();
  if (!isSplit) {
    this.updateTransformAttributes();
  }
  attr.dirtyTransform = false;
  attr.bbox.transform.dirty = true;
  this.setDirty(true);
  return this;
}, setTransform:function(matrix, isSplit) {
  this.resetTransform(true);
  this.transform.call(this, matrix, isSplit);
  return this;
}, preRender:Ext.emptyFn, render:Ext.emptyFn, hitTest:function(point, options) {
  if (this.isVisible()) {
    var x = point[0], y = point[1], bbox = this.getBBox(), isBBoxHit = bbox && x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;
    if (isBBoxHit) {
      return {sprite:this};
    }
  }
  return null;
}, isVisible:function() {
  var attr = this.attr, parent = this.getParent(), hasParent = parent && (parent.isSurface || parent.isVisible()), isSeen = hasParent && !attr.hidden && attr.globalAlpha, none1 = Ext.util.Color.NONE, none2 = Ext.util.Color.RGBA_NONE, hasFill = attr.fillOpacity && attr.fillStyle !== none1 && attr.fillStyle !== none2, hasStroke = attr.strokeOpacity && attr.strokeStyle !== none1 && attr.strokeStyle !== none2, result = isSeen && (hasFill || hasStroke);
  return !!result;
}, repaint:function() {
  var surface = this.getSurface();
  if (surface) {
    surface.renderFrame();
  }
}, remove:function() {
  var surface = this.getSurface();
  if (surface && surface.isSurface) {
    return surface.remove(this);
  }
  return null;
}, destroy:function() {
  var me = this, modifier = me.topModifier, currentModifier;
  while (modifier) {
    currentModifier = modifier;
    modifier = modifier._lower;
    currentModifier.destroy();
  }
  delete me.attr;
  me.remove();
  if (me.fireEvent('beforedestroy', me) !== false) {
    me.fireEvent('destroy', me);
  }
  me.callParent();
}}, 1, 0, 0, 0, ['sprite.sprite'], [['observable', Ext.mixin.Observable]], [Ext.draw.sprite, 'Sprite'], function() {
  this.def = new Ext.draw.sprite.AttributeDefinition(this.def);
  this.def.spriteClass = this;
});
Ext.cmd.derive('Ext.draw.Path', Ext.Base, {statics:{pathRe:/,?([achlmqrstvxz]),?/gi, pathRe2:/-/gi, pathSplitRe:/\s|,/g}, svgString:'', constructor:function(pathString) {
  var me = this;
  me.commands = [];
  me.params = [];
  me.cursor = null;
  me.startX = 0;
  me.startY = 0;
  if (pathString) {
    me.fromSvgString(pathString);
  }
}, clear:function() {
  var me = this;
  me.params.length = 0;
  me.commands.length = 0;
  me.cursor = null;
  me.startX = 0;
  me.startY = 0;
  me.dirt();
}, dirt:function() {
  this.svgString = '';
}, moveTo:function(x, y) {
  var me = this;
  if (!me.cursor) {
    me.cursor = [x, y];
  }
  me.params.push(x, y);
  me.commands.push('M');
  me.startX = x;
  me.startY = y;
  me.cursor[0] = x;
  me.cursor[1] = y;
  me.dirt();
}, lineTo:function(x, y) {
  var me = this;
  if (!me.cursor) {
    me.cursor = [x, y];
    me.params.push(x, y);
    me.commands.push('M');
  } else {
    me.params.push(x, y);
    me.commands.push('L');
  }
  me.cursor[0] = x;
  me.cursor[1] = y;
  me.dirt();
}, bezierCurveTo:function(cx1, cy1, cx2, cy2, x, y) {
  var me = this;
  if (!me.cursor) {
    me.moveTo(cx1, cy1);
  }
  me.params.push(cx1, cy1, cx2, cy2, x, y);
  me.commands.push('C');
  me.cursor[0] = x;
  me.cursor[1] = y;
  me.dirt();
}, quadraticCurveTo:function(cx, cy, x, y) {
  var me = this;
  if (!me.cursor) {
    me.moveTo(cx, cy);
  }
  me.bezierCurveTo((2 * cx + me.cursor[0]) / 3, (2 * cy + me.cursor[1]) / 3, (2 * cx + x) / 3, (2 * cy + y) / 3, x, y);
}, closePath:function() {
  var me = this;
  if (me.cursor) {
    me.cursor = null;
    me.commands.push('Z');
    me.dirt();
  }
}, arcTo:function(x1, y1, x2, y2, rx, ry, rotation) {
  var me = this;
  if (ry === undefined) {
    ry = rx;
  }
  if (rotation === undefined) {
    rotation = 0;
  }
  if (!me.cursor) {
    me.moveTo(x1, y1);
    return;
  }
  if (rx === 0 || ry === 0) {
    me.lineTo(x1, y1);
    return;
  }
  x2 -= x1;
  y2 -= y1;
  var x0 = me.cursor[0] - x1, y0 = me.cursor[1] - y1, area = x2 * y0 - y2 * x0, cos, sin, xx, yx, xy, yy, l0 = Math.sqrt(x0 * x0 + y0 * y0), l2 = Math.sqrt(x2 * x2 + y2 * y2), dist, cx, cy;
  if (area === 0) {
    me.lineTo(x1, y1);
    return;
  }
  if (ry !== rx) {
    cos = Math.cos(rotation);
    sin = Math.sin(rotation);
    xx = cos / rx;
    yx = sin / ry;
    xy = -sin / rx;
    yy = cos / ry;
    var temp = xx * x0 + yx * y0;
    y0 = xy * x0 + yy * y0;
    x0 = temp;
    temp = xx * x2 + yx * y2;
    y2 = xy * x2 + yy * y2;
    x2 = temp;
  } else {
    x0 /= rx;
    y0 /= ry;
    x2 /= rx;
    y2 /= ry;
  }
  cx = x0 * l2 + x2 * l0;
  cy = y0 * l2 + y2 * l0;
  dist = 1 / (Math.sin(Math.asin(Math.abs(area) / (l0 * l2)) * 0.5) * Math.sqrt(cx * cx + cy * cy));
  cx *= dist;
  cy *= dist;
  var k0 = (cx * x0 + cy * y0) / (x0 * x0 + y0 * y0), k2 = (cx * x2 + cy * y2) / (x2 * x2 + y2 * y2);
  var cosStart = x0 * k0 - cx, sinStart = y0 * k0 - cy, cosEnd = x2 * k2 - cx, sinEnd = y2 * k2 - cy, startAngle = Math.atan2(sinStart, cosStart), endAngle = Math.atan2(sinEnd, cosEnd);
  if (area > 0) {
    if (endAngle < startAngle) {
      endAngle += Math.PI * 2;
    }
  } else {
    if (startAngle < endAngle) {
      startAngle += Math.PI * 2;
    }
  }
  if (ry !== rx) {
    cx = cos * cx * rx - sin * cy * ry + x1;
    cy = sin * cy * ry + cos * cy * ry + y1;
    me.lineTo(cos * rx * cosStart - sin * ry * sinStart + cx, sin * rx * cosStart + cos * ry * sinStart + cy);
    me.ellipse(cx, cy, rx, ry, rotation, startAngle, endAngle, area < 0);
  } else {
    cx = cx * rx + x1;
    cy = cy * ry + y1;
    me.lineTo(rx * cosStart + cx, ry * sinStart + cy);
    me.ellipse(cx, cy, rx, ry, rotation, startAngle, endAngle, area < 0);
  }
}, ellipse:function(cx, cy, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
  var me = this, params = me.params, start = params.length, count, i, j;
  if (endAngle - startAngle >= Math.PI * 2) {
    me.ellipse(cx, cy, radiusX, radiusY, rotation, startAngle, startAngle + Math.PI, anticlockwise);
    me.ellipse(cx, cy, radiusX, radiusY, rotation, startAngle + Math.PI, endAngle, anticlockwise);
    return;
  }
  if (!anticlockwise) {
    if (endAngle < startAngle) {
      endAngle += Math.PI * 2;
    }
    count = me.approximateArc(params, cx, cy, radiusX, radiusY, rotation, startAngle, endAngle);
  } else {
    if (startAngle < endAngle) {
      startAngle += Math.PI * 2;
    }
    count = me.approximateArc(params, cx, cy, radiusX, radiusY, rotation, endAngle, startAngle);
    for (i = start, j = params.length - 2; i < j; i += 2, j -= 2) {
      var temp = params[i];
      params[i] = params[j];
      params[j] = temp;
      temp = params[i + 1];
      params[i + 1] = params[j + 1];
      params[j + 1] = temp;
    }
  }
  if (!me.cursor) {
    me.cursor = [params[params.length - 2], params[params.length - 1]];
    me.commands.push('M');
  } else {
    me.cursor[0] = params[params.length - 2];
    me.cursor[1] = params[params.length - 1];
    me.commands.push('L');
  }
  for (i = 2; i < count; i += 6) {
    me.commands.push('C');
  }
  me.dirt();
}, arc:function(x, y, radius, startAngle, endAngle, anticlockwise) {
  this.ellipse(x, y, radius, radius, 0, startAngle, endAngle, anticlockwise);
}, rect:function(x, y, width, height) {
  if (width == 0 || height == 0) {
    return;
  }
  var me = this;
  me.moveTo(x, y);
  me.lineTo(x + width, y);
  me.lineTo(x + width, y + height);
  me.lineTo(x, y + height);
  me.closePath();
}, approximateArc:function(result, cx, cy, rx, ry, phi, theta1, theta2) {
  var cosPhi = Math.cos(phi), sinPhi = Math.sin(phi), cosTheta1 = Math.cos(theta1), sinTheta1 = Math.sin(theta1), xx = cosPhi * cosTheta1 * rx - sinPhi * sinTheta1 * ry, yx = -cosPhi * sinTheta1 * rx - sinPhi * cosTheta1 * ry, xy = sinPhi * cosTheta1 * rx + cosPhi * sinTheta1 * ry, yy = -sinPhi * sinTheta1 * rx + cosPhi * cosTheta1 * ry, rightAngle = Math.PI / 2, count = 2, exx = xx, eyx = yx, exy = xy, eyy = yy, rho = 0.547443256150549, temp, y1, x3, y3, x2, y2;
  theta2 -= theta1;
  if (theta2 < 0) {
    theta2 += Math.PI * 2;
  }
  result.push(xx + cx, xy + cy);
  while (theta2 >= rightAngle) {
    result.push(exx + eyx * rho + cx, exy + eyy * rho + cy, exx * rho + eyx + cx, exy * rho + eyy + cy, eyx + cx, eyy + cy);
    count += 6;
    theta2 -= rightAngle;
    temp = exx;
    exx = eyx;
    eyx = -temp;
    temp = exy;
    exy = eyy;
    eyy = -temp;
  }
  if (theta2) {
    y1 = (0.3294738052815987 + 0.012120855841304373 * theta2) * theta2;
    x3 = Math.cos(theta2);
    y3 = Math.sin(theta2);
    x2 = x3 + y1 * y3;
    y2 = y3 - y1 * x3;
    result.push(exx + eyx * y1 + cx, exy + eyy * y1 + cy, exx * x2 + eyx * y2 + cx, exy * x2 + eyy * y2 + cy, exx * x3 + eyx * y3 + cx, exy * x3 + eyy * y3 + cy);
    count += 6;
  }
  return count;
}, arcSvg:function(rx, ry, rotation, fA, fS, x2, y2) {
  if (rx < 0) {
    rx = -rx;
  }
  if (ry < 0) {
    ry = -ry;
  }
  var me = this, x1 = me.cursor[0], y1 = me.cursor[1], hdx = (x1 - x2) / 2, hdy = (y1 - y2) / 2, cosPhi = Math.cos(rotation), sinPhi = Math.sin(rotation), xp = hdx * cosPhi + hdy * sinPhi, yp = -hdx * sinPhi + hdy * cosPhi, ratX = xp / rx, ratY = yp / ry, lambda = ratX * ratX + ratY * ratY, cx = (x1 + x2) * 0.5, cy = (y1 + y2) * 0.5, cpx = 0, cpy = 0;
  if (lambda >= 1) {
    lambda = Math.sqrt(lambda);
    rx *= lambda;
    ry *= lambda;
  } else {
    lambda = Math.sqrt(1 / lambda - 1);
    if (fA === fS) {
      lambda = -lambda;
    }
    cpx = lambda * rx * ratY;
    cpy = -lambda * ry * ratX;
    cx += cosPhi * cpx - sinPhi * cpy;
    cy += sinPhi * cpx + cosPhi * cpy;
  }
  var theta1 = Math.atan2((yp - cpy) / ry, (xp - cpx) / rx), deltaTheta = Math.atan2((-yp - cpy) / ry, (-xp - cpx) / rx) - theta1;
  if (fS) {
    if (deltaTheta <= 0) {
      deltaTheta += Math.PI * 2;
    }
  } else {
    if (deltaTheta >= 0) {
      deltaTheta -= Math.PI * 2;
    }
  }
  me.ellipse(cx, cy, rx, ry, rotation, theta1, theta1 + deltaTheta, 1 - fS);
}, fromSvgString:function(pathString) {
  if (!pathString) {
    return;
  }
  var me = this, parts, paramCounts = {a:7, c:6, h:1, l:2, m:2, q:4, s:4, t:2, v:1, z:0, A:7, C:6, H:1, L:2, M:2, Q:4, S:4, T:2, V:1, Z:0}, lastCommand = '', lastControlX, lastControlY, lastX = 0, lastY = 0, part = false, i, partLength, relative;
  if (Ext.isString(pathString)) {
    parts = pathString.replace(Ext.draw.Path.pathRe, ' $1 ').replace(Ext.draw.Path.pathRe2, ' -').split(Ext.draw.Path.pathSplitRe);
  } else {
    if (Ext.isArray(pathString)) {
      parts = pathString.join(',').split(Ext.draw.Path.pathSplitRe);
    }
  }
  for (i = 0, partLength = 0; i < parts.length; i++) {
    if (parts[i] !== '') {
      parts[partLength++] = parts[i];
    }
  }
  parts.length = partLength;
  me.clear();
  for (i = 0; i < parts.length;) {
    lastCommand = part;
    part = parts[i];
    relative = part.toUpperCase() !== part;
    i++;
    switch(part) {
      case 'M':
        me.moveTo(lastX = +parts[i], lastY = +parts[i + 1]);
        i += 2;
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.lineTo(lastX = +parts[i], lastY = +parts[i + 1]);
          i += 2;
        }
        break;
      case 'L':
        me.lineTo(lastX = +parts[i], lastY = +parts[i + 1]);
        i += 2;
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.lineTo(lastX = +parts[i], lastY = +parts[i + 1]);
          i += 2;
        }
        break;
      case 'A':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.arcSvg(+parts[i], +parts[i + 1], +parts[i + 2] * Math.PI / 180, +parts[i + 3], +parts[i + 4], lastX = +parts[i + 5], lastY = +parts[i + 6]);
          i += 7;
        }
        break;
      case 'C':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.bezierCurveTo(+parts[i], +parts[i + 1], lastControlX = +parts[i + 2], lastControlY = +parts[i + 3], lastX = +parts[i + 4], lastY = +parts[i + 5]);
          i += 6;
        }
        break;
      case 'Z':
        me.closePath();
        break;
      case 'm':
        me.moveTo(lastX += +parts[i], lastY += +parts[i + 1]);
        i += 2;
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.lineTo(lastX += +parts[i], lastY += +parts[i + 1]);
          i += 2;
        }
        break;
      case 'l':
        me.lineTo(lastX += +parts[i], lastY += +parts[i + 1]);
        i += 2;
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.lineTo(lastX += +parts[i], lastY += +parts[i + 1]);
          i += 2;
        }
        break;
      case 'a':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.arcSvg(+parts[i], +parts[i + 1], +parts[i + 2] * Math.PI / 180, +parts[i + 3], +parts[i + 4], lastX += +parts[i + 5], lastY += +parts[i + 6]);
          i += 7;
        }
        break;
      case 'c':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.bezierCurveTo(lastX + +parts[i], lastY + +parts[i + 1], lastControlX = lastX + +parts[i + 2], lastControlY = lastY + +parts[i + 3], lastX += +parts[i + 4], lastY += +parts[i + 5]);
          i += 6;
        }
        break;
      case 'z':
        me.closePath();
        break;
      case 's':
        if (!(lastCommand === 'c' || lastCommand === 'C' || lastCommand === 's' || lastCommand === 'S')) {
          lastControlX = lastX;
          lastControlY = lastY;
        }
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.bezierCurveTo(lastX + lastX - lastControlX, lastY + lastY - lastControlY, lastControlX = lastX + +parts[i], lastControlY = lastY + +parts[i + 1], lastX += +parts[i + 2], lastY += +parts[i + 3]);
          i += 4;
        }
        break;
      case 'S':
        if (!(lastCommand === 'c' || lastCommand === 'C' || lastCommand === 's' || lastCommand === 'S')) {
          lastControlX = lastX;
          lastControlY = lastY;
        }
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.bezierCurveTo(lastX + lastX - lastControlX, lastY + lastY - lastControlY, lastControlX = +parts[i], lastControlY = +parts[i + 1], lastX = +parts[i + 2], lastY = +parts[i + 3]);
          i += 4;
        }
        break;
      case 'q':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.quadraticCurveTo(lastControlX = lastX + +parts[i], lastControlY = lastY + +parts[i + 1], lastX += +parts[i + 2], lastY += +parts[i + 3]);
          i += 4;
        }
        break;
      case 'Q':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.quadraticCurveTo(lastControlX = +parts[i], lastControlY = +parts[i + 1], lastX = +parts[i + 2], lastY = +parts[i + 3]);
          i += 4;
        }
        break;
      case 't':
        if (!(lastCommand === 'q' || lastCommand === 'Q' || lastCommand === 't' || lastCommand === 'T')) {
          lastControlX = lastX;
          lastControlY = lastY;
        }
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.quadraticCurveTo(lastControlX = lastX + lastX - lastControlX, lastControlY = lastY + lastY - lastControlY, lastX += +parts[i + 1], lastY += +parts[i + 2]);
          i += 2;
        }
        break;
      case 'T':
        if (!(lastCommand === 'q' || lastCommand === 'Q' || lastCommand === 't' || lastCommand === 'T')) {
          lastControlX = lastX;
          lastControlY = lastY;
        }
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.quadraticCurveTo(lastControlX = lastX + lastX - lastControlX, lastControlY = lastY + lastY - lastControlY, lastX = +parts[i + 1], lastY = +parts[i + 2]);
          i += 2;
        }
        break;
      case 'h':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.lineTo(lastX += +parts[i], lastY);
          i++;
        }
        break;
      case 'H':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.lineTo(lastX = +parts[i], lastY);
          i++;
        }
        break;
      case 'v':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.lineTo(lastX, lastY += +parts[i]);
          i++;
        }
        break;
      case 'V':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.lineTo(lastX, lastY = +parts[i]);
          i++;
        }
        break;
    }
  }
}, clone:function() {
  var me = this, path = new Ext.draw.Path;
  path.params = me.params.slice(0);
  path.commands = me.commands.slice(0);
  path.cursor = me.cursor ? me.cursor.slice(0) : null;
  path.startX = me.startX;
  path.startY = me.startY;
  path.svgString = me.svgString;
  return path;
}, transform:function(matrix) {
  if (matrix.isIdentity()) {
    return;
  }
  var xx = matrix.getXX(), yx = matrix.getYX(), dx = matrix.getDX(), xy = matrix.getXY(), yy = matrix.getYY(), dy = matrix.getDY(), params = this.params, i = 0, ln = params.length, x, y;
  for (; i < ln; i += 2) {
    x = params[i];
    y = params[i + 1];
    params[i] = x * xx + y * yx + dx;
    params[i + 1] = x * xy + y * yy + dy;
  }
  this.dirt();
}, getDimension:function(target) {
  if (!target) {
    target = {};
  }
  if (!this.commands || !this.commands.length) {
    target.x = 0;
    target.y = 0;
    target.width = 0;
    target.height = 0;
    return target;
  }
  target.left = Infinity;
  target.top = Infinity;
  target.right = -Infinity;
  target.bottom = -Infinity;
  var i = 0, j = 0, commands = this.commands, params = this.params, ln = commands.length, x, y;
  for (; i < ln; i++) {
    switch(commands[i]) {
      case 'M':
      case 'L':
        x = params[j];
        y = params[j + 1];
        target.left = Math.min(x, target.left);
        target.top = Math.min(y, target.top);
        target.right = Math.max(x, target.right);
        target.bottom = Math.max(y, target.bottom);
        j += 2;
        break;
      case 'C':
        this.expandDimension(target, x, y, params[j], params[j + 1], params[j + 2], params[j + 3], x = params[j + 4], y = params[j + 5]);
        j += 6;
        break;
    }
  }
  target.x = target.left;
  target.y = target.top;
  target.width = target.right - target.left;
  target.height = target.bottom - target.top;
  return target;
}, getDimensionWithTransform:function(matrix, target) {
  if (!this.commands || !this.commands.length) {
    if (!target) {
      target = {};
    }
    target.x = 0;
    target.y = 0;
    target.width = 0;
    target.height = 0;
    return target;
  }
  target.left = Infinity;
  target.top = Infinity;
  target.right = -Infinity;
  target.bottom = -Infinity;
  var xx = matrix.getXX(), yx = matrix.getYX(), dx = matrix.getDX(), xy = matrix.getXY(), yy = matrix.getYY(), dy = matrix.getDY(), i = 0, j = 0, commands = this.commands, params = this.params, ln = commands.length, x, y;
  for (; i < ln; i++) {
    switch(commands[i]) {
      case 'M':
      case 'L':
        x = params[j] * xx + params[j + 1] * yx + dx;
        y = params[j] * xy + params[j + 1] * yy + dy;
        target.left = Math.min(x, target.left);
        target.top = Math.min(y, target.top);
        target.right = Math.max(x, target.right);
        target.bottom = Math.max(y, target.bottom);
        j += 2;
        break;
      case 'C':
        this.expandDimension(target, x, y, params[j] * xx + params[j + 1] * yx + dx, params[j] * xy + params[j + 1] * yy + dy, params[j + 2] * xx + params[j + 3] * yx + dx, params[j + 2] * xy + params[j + 3] * yy + dy, x = params[j + 4] * xx + params[j + 5] * yx + dx, y = params[j + 4] * xy + params[j + 5] * yy + dy);
        j += 6;
        break;
    }
  }
  if (!target) {
    target = {};
  }
  target.x = target.left;
  target.y = target.top;
  target.width = target.right - target.left;
  target.height = target.bottom - target.top;
  return target;
}, expandDimension:function(target, x1, y1, cx1, cy1, cx2, cy2, x2, y2) {
  var me = this, l = target.left, r = target.right, t = target.top, b = target.bottom, dim = me.dim || (me.dim = []);
  me.curveDimension(x1, cx1, cx2, x2, dim);
  l = Math.min(l, dim[0]);
  r = Math.max(r, dim[1]);
  me.curveDimension(y1, cy1, cy2, y2, dim);
  t = Math.min(t, dim[0]);
  b = Math.max(b, dim[1]);
  target.left = l;
  target.right = r;
  target.top = t;
  target.bottom = b;
}, curveDimension:function(a, b, c, d, dim) {
  var qa = 3 * (-a + 3 * (b - c) + d), qb = 6 * (a - 2 * b + c), qc = -3 * (a - b), x, y, min = Math.min(a, d), max = Math.max(a, d), delta;
  if (qa === 0) {
    if (qb === 0) {
      dim[0] = min;
      dim[1] = max;
      return;
    } else {
      x = -qc / qb;
      if (0 < x && x < 1) {
        y = this.interpolate(a, b, c, d, x);
        min = Math.min(min, y);
        max = Math.max(max, y);
      }
    }
  } else {
    delta = qb * qb - 4 * qa * qc;
    if (delta >= 0) {
      delta = Math.sqrt(delta);
      x = (delta - qb) / 2 / qa;
      if (0 < x && x < 1) {
        y = this.interpolate(a, b, c, d, x);
        min = Math.min(min, y);
        max = Math.max(max, y);
      }
      if (delta > 0) {
        x -= delta / qa;
        if (0 < x && x < 1) {
          y = this.interpolate(a, b, c, d, x);
          min = Math.min(min, y);
          max = Math.max(max, y);
        }
      }
    }
  }
  dim[0] = min;
  dim[1] = max;
}, interpolate:function(a, b, c, d, t) {
  if (t === 0) {
    return a;
  }
  if (t === 1) {
    return d;
  }
  var rate = (1 - t) / t;
  return t * t * t * (d + rate * (3 * c + rate * (3 * b + rate * a)));
}, fromStripes:function(stripes) {
  var me = this, i = 0, ln = stripes.length, j, ln2, stripe;
  me.clear();
  for (; i < ln; i++) {
    stripe = stripes[i];
    me.params.push.apply(me.params, stripe);
    me.commands.push('M');
    for (j = 2, ln2 = stripe.length; j < ln2; j += 6) {
      me.commands.push('C');
    }
  }
  if (!me.cursor) {
    me.cursor = [];
  }
  me.cursor[0] = me.params[me.params.length - 2];
  me.cursor[1] = me.params[me.params.length - 1];
  me.dirt();
}, toStripes:function(target) {
  var stripes = target || [], curr, x, y, lastX, lastY, startX, startY, i, j, commands = this.commands, params = this.params, ln = commands.length;
  for (i = 0, j = 0; i < ln; i++) {
    switch(commands[i]) {
      case 'M':
        curr = [startX = lastX = params[j++], startY = lastY = params[j++]];
        stripes.push(curr);
        break;
      case 'L':
        x = params[j++];
        y = params[j++];
        curr.push((lastX + lastX + x) / 3, (lastY + lastY + y) / 3, (lastX + x + x) / 3, (lastY + y + y) / 3, lastX = x, lastY = y);
        break;
      case 'C':
        curr.push(params[j++], params[j++], params[j++], params[j++], lastX = params[j++], lastY = params[j++]);
        break;
      case 'Z':
        x = startX;
        y = startY;
        curr.push((lastX + lastX + x) / 3, (lastY + lastY + y) / 3, (lastX + x + x) / 3, (lastY + y + y) / 3, lastX = x, lastY = y);
        break;
    }
  }
  return stripes;
}, updateSvgString:function() {
  var result = [], commands = this.commands, params = this.params, ln = commands.length, i = 0, j = 0;
  for (; i < ln; i++) {
    switch(commands[i]) {
      case 'M':
        result.push('M' + params[j] + ',' + params[j + 1]);
        j += 2;
        break;
      case 'L':
        result.push('L' + params[j] + ',' + params[j + 1]);
        j += 2;
        break;
      case 'C':
        result.push('C' + params[j] + ',' + params[j + 1] + ' ' + params[j + 2] + ',' + params[j + 3] + ' ' + params[j + 4] + ',' + params[j + 5]);
        j += 6;
        break;
      case 'Z':
        result.push('Z');
        break;
    }
  }
  this.svgString = result.join('');
}, toString:function() {
  if (!this.svgString) {
    this.updateSvgString();
  }
  return this.svgString;
}}, 3, 0, 0, 0, 0, 0, [Ext.draw, 'Path'], 0);
Ext.define('Ext.draw.overrides.hittest.Path', {override:'Ext.draw.Path', rayOrigin:{x:-10000, y:-10000}, isPointInPath:function(x, y) {
  var me = this, commands = me.commands, solver = Ext.draw.PathUtil, origin = me.rayOrigin, params = me.params, ln = commands.length, firstX = null, firstY = null, lastX = 0, lastY = 0, count = 0, i, j;
  for (i = 0, j = 0; i < ln; i++) {
    switch(commands[i]) {
      case 'M':
        if (firstX !== null) {
          if (solver.linesIntersection(firstX, firstY, lastX, lastY, origin.x, origin.y, x, y)) {
            count += 1;
          }
        }
        firstX = lastX = params[j];
        firstY = lastY = params[j + 1];
        j += 2;
        break;
      case 'L':
        if (solver.linesIntersection(lastX, lastY, params[j], params[j + 1], origin.x, origin.y, x, y)) {
          count += 1;
        }
        lastX = params[j];
        lastY = params[j + 1];
        j += 2;
        break;
      case 'C':
        count += solver.cubicLineIntersections(lastX, params[j], params[j + 2], params[j + 4], lastY, params[j + 1], params[j + 3], params[j + 5], origin.x, origin.y, x, y).length;
        lastX = params[j + 4];
        lastY = params[j + 5];
        j += 6;
        break;
      case 'Z':
        if (firstX !== null) {
          if (solver.linesIntersection(firstX, firstY, lastX, lastY, origin.x, origin.y, x, y)) {
            count += 1;
          }
        }
        break;
    }
  }
  return count % 2 === 1;
}, isPointOnPath:function(x, y) {
  var me = this, commands = me.commands, solver = Ext.draw.PathUtil, params = me.params, ln = commands.length, firstX = null, firstY = null, lastX = 0, lastY = 0, i, j;
  for (i = 0, j = 0; i < ln; i++) {
    switch(commands[i]) {
      case 'M':
        if (firstX !== null) {
          if (solver.pointOnLine(firstX, firstY, lastX, lastY, x, y)) {
            return true;
          }
        }
        firstX = lastX = params[j];
        firstY = lastY = params[j + 1];
        j += 2;
        break;
      case 'L':
        if (solver.pointOnLine(lastX, lastY, params[j], params[j + 1], x, y)) {
          return true;
        }
        lastX = params[j];
        lastY = params[j + 1];
        j += 2;
        break;
      case 'C':
        if (solver.pointOnCubic(lastX, params[j], params[j + 2], params[j + 4], lastY, params[j + 1], params[j + 3], params[j + 5], x, y)) {
          return true;
        }
        lastX = params[j + 4];
        lastY = params[j + 5];
        j += 6;
        break;
      case 'Z':
        if (firstX !== null) {
          if (solver.pointOnLine(firstX, firstY, lastX, lastY, x, y)) {
            return true;
          }
        }
        break;
    }
  }
  return false;
}, getSegmentIntersections:function(x1, y1, x2, y2, x3, y3, x4, y4) {
  var me = this, count = arguments.length, solver = Ext.draw.PathUtil, commands = me.commands, params = me.params, ln = commands.length, firstX = null, firstY = null, lastX = 0, lastY = 0, intersections = [], i, j, points;
  for (i = 0, j = 0; i < ln; i++) {
    switch(commands[i]) {
      case 'M':
        if (firstX !== null) {
          switch(count) {
            case 4:
              points = solver.linesIntersection(firstX, firstY, lastX, lastY, x1, y1, x2, y2);
              if (points) {
                intersections.push(points);
              }
              break;
            case 8:
              points = solver.cubicLineIntersections(x1, x2, x3, x4, y1, y2, y3, y4, firstX, firstY, lastX, lastY);
              intersections.push.apply(intersections, points);
              break;
          }
        }
        firstX = lastX = params[j];
        firstY = lastY = params[j + 1];
        j += 2;
        break;
      case 'L':
        switch(count) {
          case 4:
            points = solver.linesIntersection(lastX, lastY, params[j], params[j + 1], x1, y1, x2, y2);
            if (points) {
              intersections.push(points);
            }
            break;
          case 8:
            points = solver.cubicLineIntersections(x1, x2, x3, x4, y1, y2, y3, y4, lastX, lastY, params[j], params[j + 1]);
            intersections.push.apply(intersections, points);
            break;
        }lastX = params[j];
        lastY = params[j + 1];
        j += 2;
        break;
      case 'C':
        switch(count) {
          case 4:
            points = solver.cubicLineIntersections(lastX, params[j], params[j + 2], params[j + 4], lastY, params[j + 1], params[j + 3], params[j + 5], x1, y1, x2, y2);
            intersections.push.apply(intersections, points);
            break;
          case 8:
            points = solver.cubicsIntersections(lastX, params[j], params[j + 2], params[j + 4], lastY, params[j + 1], params[j + 3], params[j + 5], x1, x2, x3, x4, y1, y2, y3, y4);
            intersections.push.apply(intersections, points);
            break;
        }lastX = params[j + 4];
        lastY = params[j + 5];
        j += 6;
        break;
      case 'Z':
        if (firstX !== null) {
          switch(count) {
            case 4:
              points = solver.linesIntersection(firstX, firstY, lastX, lastY, x1, y1, x2, y2);
              if (points) {
                intersections.push(points);
              }
              break;
            case 8:
              points = solver.cubicLineIntersections(x1, x2, x3, x4, y1, y2, y3, y4, firstX, firstY, lastX, lastY);
              intersections.push.apply(intersections, points);
              break;
          }
        }
        break;
    }
  }
  return intersections;
}, getIntersections:function(path) {
  var me = this, commands = me.commands, params = me.params, ln = commands.length, firstX = null, firstY = null, lastX = 0, lastY = 0, intersections = [], i, j, points;
  for (i = 0, j = 0; i < ln; i++) {
    switch(commands[i]) {
      case 'M':
        if (firstX !== null) {
          points = path.getSegmentIntersections.call(path, firstX, firstY, lastX, lastY);
          intersections.push.apply(intersections, points);
        }
        firstX = lastX = params[j];
        firstY = lastY = params[j + 1];
        j += 2;
        break;
      case 'L':
        points = path.getSegmentIntersections.call(path, lastX, lastY, params[j], params[j + 1]);
        intersections.push.apply(intersections, points);
        lastX = params[j];
        lastY = params[j + 1];
        j += 2;
        break;
      case 'C':
        points = path.getSegmentIntersections.call(path, lastX, lastY, params[j], params[j + 1], params[j + 2], params[j + 3], params[j + 4], params[j + 5]);
        intersections.push.apply(intersections, points);
        lastX = params[j + 4];
        lastY = params[j + 5];
        j += 6;
        break;
      case 'Z':
        if (firstX !== null) {
          points = path.getSegmentIntersections.call(path, firstX, firstY, lastX, lastY);
          intersections.push.apply(intersections, points);
        }
        break;
    }
  }
  return intersections;
}});
Ext.cmd.derive('Ext.draw.sprite.Path', Ext.draw.sprite.Sprite, {type:'path', isPath:true, inheritableStatics:{def:{processors:{path:function(n, o) {
  if (!(n instanceof Ext.draw.Path)) {
    n = new Ext.draw.Path(n);
  }
  return n;
}}, aliases:{d:'path'}, triggers:{path:'bbox'}, updaters:{path:function(attr) {
  var path = attr.path;
  if (!path || path.bindAttr !== attr) {
    path = new Ext.draw.Path;
    path.bindAttr = attr;
    attr.path = path;
  }
  path.clear();
  this.updatePath(path, attr);
  this.scheduleUpdater(attr, 'bbox', ['path']);
}}}}, updatePlainBBox:function(plain) {
  if (this.attr.path) {
    this.attr.path.getDimension(plain);
  }
}, updateTransformedBBox:function(transform) {
  if (this.attr.path) {
    this.attr.path.getDimensionWithTransform(this.attr.matrix, transform);
  }
}, render:function(surface, ctx) {
  var mat = this.attr.matrix, attr = this.attr;
  if (!attr.path || attr.path.params.length === 0) {
    return;
  }
  mat.toContext(ctx);
  ctx.appendPath(attr.path);
  ctx.fillStroke(attr);
}, updatePath:function(path, attr) {
}}, 0, 0, 0, 0, ['Ext.draw.Sprite', 'sprite.path'], 0, [Ext.draw.sprite, 'Path'], 0);
Ext.define('Ext.draw.overrides.hittest.sprite.Path', {override:'Ext.draw.sprite.Path', isPointInPath:function(x, y) {
  var attr = this.attr;
  if (attr.fillStyle === Ext.util.Color.RGBA_NONE) {
    return this.isPointOnPath(x, y);
  }
  var path = attr.path, matrix = attr.matrix, params, result;
  if (!matrix.isIdentity()) {
    params = path.params.slice(0);
    path.transform(attr.matrix);
  }
  result = path.isPointInPath(x, y);
  if (params) {
    path.params = params;
  }
  return result;
}, isPointOnPath:function(x, y) {
  var attr = this.attr, path = attr.path, matrix = attr.matrix, params, result;
  if (!matrix.isIdentity()) {
    params = path.params.slice(0);
    path.transform(attr.matrix);
  }
  result = path.isPointOnPath(x, y);
  if (params) {
    path.params = params;
  }
  return result;
}, hitTest:function(point, options) {
  var me = this, attr = me.attr, path = attr.path, matrix = attr.matrix, x = point[0], y = point[1], parentResult = (arguments.callee.$previous || Ext.draw.sprite.Sprite.prototype.hitTest).call(this, point, options), result = null, params, isFilled;
  if (!parentResult) {
    return result;
  }
  options = options || Ext.draw.sprite.Sprite.defaultHitTestOptions;
  if (!matrix.isIdentity()) {
    params = path.params.slice(0);
    path.transform(attr.matrix);
  }
  if (options.fill && options.stroke) {
    isFilled = attr.fillStyle !== Ext.util.Color.NONE && attr.fillStyle !== Ext.util.Color.RGBA_NONE;
    if (isFilled) {
      if (path.isPointInPath(x, y)) {
        result = {sprite:me};
      }
    } else {
      if (path.isPointInPath(x, y) || path.isPointOnPath(x, y)) {
        result = {sprite:me};
      }
    }
  } else {
    if (options.stroke && !options.fill) {
      if (path.isPointOnPath(x, y)) {
        result = {sprite:me};
      }
    } else {
      if (options.fill && !options.stroke) {
        if (path.isPointInPath(x, y)) {
          result = {sprite:me};
        }
      }
    }
  }
  if (params) {
    path.params = params;
  }
  return result;
}, getIntersections:function(path) {
  if (!(path.isSprite && path.isPath)) {
    return [];
  }
  var aAttr = this.attr, bAttr = path.attr, aPath = aAttr.path, bPath = bAttr.path, aMatrix = aAttr.matrix, bMatrix = bAttr.matrix, aParams, bParams, intersections;
  if (!aMatrix.isIdentity()) {
    aParams = aPath.params.slice(0);
    aPath.transform(aAttr.matrix);
  }
  if (!bMatrix.isIdentity()) {
    bParams = bPath.params.slice(0);
    bPath.transform(bAttr.matrix);
  }
  intersections = aPath.getIntersections(bPath);
  if (aParams) {
    aPath.params = aParams;
  }
  if (bParams) {
    bPath.params = bParams;
  }
  return intersections;
}});
Ext.cmd.derive('Ext.draw.sprite.Circle', Ext.draw.sprite.Path, {type:'circle', inheritableStatics:{def:{processors:{cx:'number', cy:'number', r:'number'}, aliases:{radius:'r', x:'cx', y:'cy', centerX:'cx', centerY:'cy'}, defaults:{cx:0, cy:0, r:4}, triggers:{cx:'path', cy:'path', r:'path'}}}, updatePlainBBox:function(plain) {
  var attr = this.attr, cx = attr.cx, cy = attr.cy, r = attr.r;
  plain.x = cx - r;
  plain.y = cy - r;
  plain.width = r + r;
  plain.height = r + r;
}, updateTransformedBBox:function(transform) {
  var attr = this.attr, cx = attr.cx, cy = attr.cy, r = attr.r, matrix = attr.matrix, scaleX = matrix.getScaleX(), scaleY = matrix.getScaleY(), rx, ry;
  rx = scaleX * r;
  ry = scaleY * r;
  transform.x = matrix.x(cx, cy) - rx;
  transform.y = matrix.y(cx, cy) - ry;
  transform.width = rx + rx;
  transform.height = ry + ry;
}, updatePath:function(path, attr) {
  path.arc(attr.cx, attr.cy, attr.r, 0, Math.PI * 2, false);
}}, 0, 0, 0, 0, ['sprite.circle'], 0, [Ext.draw.sprite, 'Circle'], 0);
Ext.cmd.derive('Ext.draw.sprite.Arc', Ext.draw.sprite.Circle, {type:'arc', inheritableStatics:{def:{processors:{startAngle:'number', endAngle:'number', anticlockwise:'bool'}, aliases:{from:'startAngle', to:'endAngle', start:'startAngle', end:'endAngle'}, defaults:{startAngle:0, endAngle:Math.PI * 2, anticlockwise:false}, triggers:{startAngle:'path', endAngle:'path', anticlockwise:'path'}}}, updatePath:function(path, attr) {
  path.arc(attr.cx, attr.cy, attr.r, attr.startAngle, attr.endAngle, attr.anticlockwise);
}}, 0, 0, 0, 0, ['sprite.arc'], 0, [Ext.draw.sprite, 'Arc'], 0);
Ext.cmd.derive('Ext.draw.sprite.Arrow', Ext.draw.sprite.Path, {inheritableStatics:{def:{processors:{x:'number', y:'number', size:'number'}, defaults:{x:0, y:0, size:4}, triggers:{x:'path', y:'path', size:'path'}}}, updatePath:function(path, attr) {
  var s = attr.size * 1.5, x = attr.x - attr.lineWidth / 2, y = attr.y;
  path.fromSvgString('M'.concat(x - s * 0.7, ',', y - s * 0.4, 'l', [s * 0.6, 0, 0, -s * 0.4, s, s * 0.8, -s, s * 0.8, 0, -s * 0.4, -s * 0.6, 0], 'z'));
}}, 0, 0, 0, 0, ['sprite.arrow'], 0, [Ext.draw.sprite, 'Arrow'], 0);
Ext.cmd.derive('Ext.draw.sprite.Composite', Ext.draw.sprite.Sprite, {type:'composite', isComposite:true, config:{sprites:[]}, constructor:function(config) {
  this.sprites = [];
  this.map = {};
  Ext.draw.sprite.Sprite.prototype.constructor.call(this, config);
}, addSprite:function(sprite) {
  var i = 0, results;
  if (Ext.isArray(sprite)) {
    results = [];
    while (i < sprite.length) {
      results.push(this.addSprite(sprite[i++]));
    }
    return results;
  }
  if (sprite && sprite.type && !sprite.isSprite) {
    sprite = Ext.create('sprite.' + sprite.type, sprite);
  }
  if (!sprite || !sprite.isSprite || sprite.isComposite) {
    return null;
  }
  sprite.setSurface(null);
  sprite.setParent(this);
  var attr = this.attr, oldTransformations = sprite.applyTransformations;
  sprite.applyTransformations = function(force) {
    if (sprite.attr.dirtyTransform) {
      attr.dirtyTransform = true;
      attr.bbox.plain.dirty = true;
      attr.bbox.transform.dirty = true;
    }
    oldTransformations.call(sprite, force);
  };
  this.sprites.push(sprite);
  this.map[sprite.id] = sprite.getId();
  attr.bbox.plain.dirty = true;
  attr.bbox.transform.dirty = true;
  return sprite;
}, add:function(sprite) {
  return this.addSprite(sprite);
}, removeSprite:function(sprite, isDestroy) {
  var me = this, id, isOwnSprite;
  if (sprite) {
    if (sprite.charAt) {
      sprite = me.map[sprite];
    }
    if (!sprite || !sprite.isSprite) {
      return null;
    }
    if (sprite.destroyed || sprite.destroying) {
      return sprite;
    }
    id = sprite.getId();
    isOwnSprite = me.map[id];
    delete me.map[id];
    if (isDestroy) {
      sprite.destroy();
    }
    if (!isOwnSprite) {
      return sprite;
    }
    sprite.setParent(null);
    Ext.Array.remove(me.sprites, sprite);
    me.dirtyZIndex = true;
    me.setDirty(true);
  }
  return sprite || null;
}, addAll:function(sprites) {
  if (sprites.isSprite || sprites.type) {
    this.add(sprites);
  } else {
    if (Ext.isArray(sprites)) {
      var i = 0;
      while (i < sprites.length) {
        this.add(sprites[i++]);
      }
    }
  }
}, updatePlainBBox:function(plain) {
  var me = this, left = Infinity, right = -Infinity, top = Infinity, bottom = -Infinity, sprite, bbox, i, ln;
  for (i = 0, ln = me.sprites.length; i < ln; i++) {
    sprite = me.sprites[i];
    sprite.applyTransformations();
    bbox = sprite.getBBox();
    if (left > bbox.x) {
      left = bbox.x;
    }
    if (right < bbox.x + bbox.width) {
      right = bbox.x + bbox.width;
    }
    if (top > bbox.y) {
      top = bbox.y;
    }
    if (bottom < bbox.y + bbox.height) {
      bottom = bbox.y + bbox.height;
    }
  }
  plain.x = left;
  plain.y = top;
  plain.width = right - left;
  plain.height = bottom - top;
}, isVisible:function() {
  var attr = this.attr, parent = this.getParent(), hasParent = parent && (parent.isSurface || parent.isVisible()), isSeen = hasParent && !attr.hidden && attr.globalAlpha;
  return !!isSeen;
}, render:function(surface, ctx, rect) {
  var me = this, attr = me.attr, mat = me.attr.matrix, sprites = me.sprites, ln = sprites.length, i = 0;
  mat.toContext(ctx);
  for (; i < ln; i++) {
    surface.renderSprite(sprites[i], rect);
  }
}, destroy:function() {
  var me = this, sprites = me.sprites, ln = sprites.length, i;
  for (i = 0; i < ln; i++) {
    sprites[i].destroy();
  }
  sprites.length = 0;
  Ext.draw.sprite.Sprite.prototype.destroy.call(this);
}}, 1, 0, 0, 0, ['sprite.composite'], 0, [Ext.draw.sprite, 'Composite'], 0);
Ext.cmd.derive('Ext.draw.sprite.Cross', Ext.draw.sprite.Path, {inheritableStatics:{def:{processors:{x:'number', y:'number', size:'number'}, defaults:{x:0, y:0, size:4}, triggers:{x:'path', y:'path', size:'path'}}}, updatePath:function(path, attr) {
  var s = attr.size / 1.7, x = attr.x - attr.lineWidth / 2, y = attr.y;
  path.fromSvgString('M'.concat(x - s, ',', y, 'l', [-s, -s, s, -s, s, s, s, -s, s, s, -s, s, s, s, -s, s, -s, -s, -s, s, -s, -s, 'z']));
}}, 0, 0, 0, 0, ['sprite.cross'], 0, [Ext.draw.sprite, 'Cross'], 0);
Ext.cmd.derive('Ext.draw.sprite.Diamond', Ext.draw.sprite.Path, {inheritableStatics:{def:{processors:{x:'number', y:'number', size:'number'}, defaults:{x:0, y:0, size:4}, triggers:{x:'path', y:'path', size:'path'}}}, updatePath:function(path, attr) {
  var s = attr.size * 1.25, x = attr.x - attr.lineWidth / 2, y = attr.y;
  path.fromSvgString(['M', x, y - s, 'l', s, s, -s, s, -s, -s, s, -s, 'z']);
}}, 0, 0, 0, 0, ['sprite.diamond'], 0, [Ext.draw.sprite, 'Diamond'], 0);
Ext.cmd.derive('Ext.draw.sprite.Ellipse', Ext.draw.sprite.Path, {type:'ellipse', inheritableStatics:{def:{processors:{cx:'number', cy:'number', rx:'number', ry:'number', axisRotation:'number'}, aliases:{radius:'r', x:'cx', y:'cy', centerX:'cx', centerY:'cy', radiusX:'rx', radiusY:'ry'}, defaults:{cx:0, cy:0, rx:1, ry:1, axisRotation:0}, triggers:{cx:'path', cy:'path', rx:'path', ry:'path', axisRotation:'path'}}}, updatePlainBBox:function(plain) {
  var attr = this.attr, cx = attr.cx, cy = attr.cy, rx = attr.rx, ry = attr.ry;
  plain.x = cx - rx;
  plain.y = cy - ry;
  plain.width = rx + rx;
  plain.height = ry + ry;
}, updateTransformedBBox:function(transform) {
  var attr = this.attr, cx = attr.cx, cy = attr.cy, rx = attr.rx, ry = attr.ry, rxy = ry / rx, matrix = attr.matrix.clone(), xx, xy, yx, yy, dx, dy, w, h;
  matrix.append(1, 0, 0, rxy, 0, cy * (1 - rxy));
  xx = matrix.getXX();
  yx = matrix.getYX();
  dx = matrix.getDX();
  xy = matrix.getXY();
  yy = matrix.getYY();
  dy = matrix.getDY();
  w = Math.sqrt(xx * xx + yx * yx) * rx;
  h = Math.sqrt(xy * xy + yy * yy) * rx;
  transform.x = cx * xx + cy * yx + dx - w;
  transform.y = cx * xy + cy * yy + dy - h;
  transform.width = w + w;
  transform.height = h + h;
}, updatePath:function(path, attr) {
  path.ellipse(attr.cx, attr.cy, attr.rx, attr.ry, attr.axisRotation, 0, Math.PI * 2, false);
}}, 0, 0, 0, 0, ['sprite.ellipse'], 0, [Ext.draw.sprite, 'Ellipse'], 0);
Ext.cmd.derive('Ext.draw.sprite.EllipticalArc', Ext.draw.sprite.Ellipse, {type:'ellipticalArc', inheritableStatics:{def:{processors:{startAngle:'number', endAngle:'number', anticlockwise:'bool'}, aliases:{from:'startAngle', to:'endAngle', start:'startAngle', end:'endAngle'}, defaults:{startAngle:0, endAngle:Math.PI * 2, anticlockwise:false}, triggers:{startAngle:'path', endAngle:'path', anticlockwise:'path'}}}, updatePath:function(path, attr) {
  path.ellipse(attr.cx, attr.cy, attr.rx, attr.ry, attr.axisRotation, attr.startAngle, attr.endAngle, attr.anticlockwise);
}}, 0, 0, 0, 0, ['sprite.ellipticalArc'], 0, [Ext.draw.sprite, 'EllipticalArc'], 0);
Ext.cmd.derive('Ext.draw.sprite.Rect', Ext.draw.sprite.Path, {type:'rect', inheritableStatics:{def:{processors:{x:'number', y:'number', width:'number', height:'number', radius:'number'}, aliases:{}, triggers:{x:'path', y:'path', width:'path', height:'path', radius:'path'}, defaults:{x:0, y:0, width:8, height:8, radius:0}}}, updatePlainBBox:function(plain) {
  var attr = this.attr;
  plain.x = attr.x;
  plain.y = attr.y;
  plain.width = attr.width;
  plain.height = attr.height;
}, updateTransformedBBox:function(transform, plain) {
  this.attr.matrix.transformBBox(plain, this.attr.radius, transform);
}, updatePath:function(path, attr) {
  var x = attr.x, y = attr.y, width = attr.width, height = attr.height, radius = Math.min(attr.radius, Math.abs(height) * 0.5, Math.abs(width) * 0.5);
  if (radius === 0) {
    path.rect(x, y, width, height);
  } else {
    path.moveTo(x + radius, y);
    path.arcTo(x + width, y, x + width, y + height, radius);
    path.arcTo(x + width, y + height, x, y + height, radius);
    path.arcTo(x, y + height, x, y, radius);
    path.arcTo(x, y, x + radius, y, radius);
  }
}}, 0, 0, 0, 0, ['sprite.rect'], 0, [Ext.draw.sprite, 'Rect'], 0);
Ext.cmd.derive('Ext.draw.sprite.Image', Ext.draw.sprite.Rect, {type:'image', statics:{imageLoaders:{}}, inheritableStatics:{def:{processors:{src:'string'}, triggers:{src:'src'}, updaters:{src:'updateSource'}, defaults:{src:'', width:null, height:null}}}, updateSurface:function(surface) {
  if (surface) {
    this.updateSource(this.attr);
  }
}, updateSource:function(attr) {
  var me = this, src = attr.src, surface = me.getSurface(), loadingStub = Ext.draw.sprite.Image.imageLoaders[src], width = attr.width, height = attr.height, imageLoader, i;
  if (!surface) {
    return;
  }
  if (!loadingStub) {
    imageLoader = new Image;
    loadingStub = Ext.draw.sprite.Image.imageLoaders[src] = {image:imageLoader, done:false, pendingSprites:[me], pendingSurfaces:[surface]};
    imageLoader.width = width;
    imageLoader.height = height;
    imageLoader.onload = function() {
      var item;
      if (!loadingStub.done) {
        loadingStub.done = true;
        for (i = 0; i < loadingStub.pendingSprites.length; i++) {
          item = loadingStub.pendingSprites[i];
          if (!item.destroyed) {
            item.setDirty(true);
          }
        }
        for (i = 0; i < loadingStub.pendingSurfaces.length; i++) {
          item = loadingStub.pendingSurfaces[i];
          if (!item.destroyed) {
            item.renderFrame();
          }
        }
      }
    };
    imageLoader.src = src;
  } else {
    Ext.Array.include(loadingStub.pendingSprites, me);
    Ext.Array.include(loadingStub.pendingSurfaces, surface);
  }
}, render:function(surface, ctx) {
  var me = this, attr = me.attr, mat = attr.matrix, src = attr.src, x = attr.x, y = attr.y, width = attr.width, height = attr.height, loadingStub = Ext.draw.sprite.Image.imageLoaders[src], image;
  if (loadingStub && loadingStub.done) {
    mat.toContext(ctx);
    image = loadingStub.image;
    ctx.drawImage(image, x, y, width || (image.naturalWidth || image.width) / surface.devicePixelRatio, height || (image.naturalHeight || image.height) / surface.devicePixelRatio);
  }
}, isVisible:function() {
  var attr = this.attr, parent = this.getParent(), hasParent = parent && (parent.isSurface || parent.isVisible()), isSeen = hasParent && !attr.hidden && attr.globalAlpha;
  return !!isSeen;
}}, 0, 0, 0, 0, ['sprite.image'], 0, [Ext.draw.sprite, 'Image'], 0);
Ext.cmd.derive('Ext.draw.sprite.Instancing', Ext.draw.sprite.Sprite, {type:'instancing', isInstancing:true, config:{template:null, instances:null}, instances:null, applyTemplate:function(template) {
  if (!template.isSprite) {
    if (!template.xclass && !template.type) {
      template.type = 'circle';
    }
    template = Ext.create(template.xclass || 'sprite.' + template.type, template);
  }
  var surface = template.getSurface();
  if (surface) {
    surface.remove(template);
  }
  template.setParent(this);
  return template;
}, updateTemplate:function(template, oldTemplate) {
  if (oldTemplate) {
    delete oldTemplate.ownAttr;
  }
  template.setSurface(this.getSurface());
  template.ownAttr = template.attr;
  this.clearAll();
}, updateInstances:function(instances) {
  this.clearAll();
  if (Ext.isArray(instances)) {
    for (var i = 0, ln = instances.length; i < ln; i++) {
      this.add(instances[i]);
    }
  }
}, updateSurface:function(surface) {
  var template = this.getTemplate();
  if (template && !template.destroyed) {
    template.setSurface(surface);
  }
}, get:function(index) {
  return this.instances[index];
}, getCount:function() {
  return this.instances.length;
}, clearAll:function() {
  var template = this.getTemplate();
  template.attr.children = this.instances = [];
  this.position = 0;
}, createInstance:function(config, bypassNormalization, avoidCopy) {
  return this.add(config, bypassNormalization, avoidCopy);
}, add:function(config, bypassNormalization, avoidCopy) {
  var template = this.getTemplate(), originalAttr = template.attr, attr = Ext.Object.chain(originalAttr);
  template.topModifier.prepareAttributes(attr);
  template.attr = attr;
  template.setAttributes(config, bypassNormalization, avoidCopy);
  attr.template = template;
  this.instances.push(attr);
  template.attr = originalAttr;
  this.position++;
  return attr;
}, getBBox:function() {
  return null;
}, getBBoxFor:function(index, isWithoutTransform) {
  var template = this.getTemplate(), originalAttr = template.attr, bbox;
  template.attr = this.instances[index];
  bbox = template.getBBox(isWithoutTransform);
  template.attr = originalAttr;
  return bbox;
}, isVisible:function() {
  var attr = this.attr, parent = this.getParent(), result;
  result = parent && parent.isSurface && !attr.hidden && attr.globalAlpha;
  return !!result;
}, isInstanceVisible:function(index) {
  var me = this, template = me.getTemplate(), originalAttr = template.attr, instances = me.instances, result = false;
  if (!Ext.isNumber(index) || index < 0 || index >= instances.length || !me.isVisible()) {
    return result;
  }
  template.attr = instances[index];
  result = template.isVisible(point, options);
  template.attr = originalAttr;
  return result;
}, render:function(surface, ctx, rect) {
  var me = this, template = me.getTemplate(), surfaceRect = surface.getRect(), mat = me.attr.matrix, originalAttr = template.attr, instances = me.instances, ln = me.position, i;
  mat.toContext(ctx);
  template.preRender(surface, ctx, rect);
  template.useAttributes(ctx, surfaceRect);
  template.isSpriteInstance = true;
  for (i = 0; i < ln; i++) {
    if (instances[i].hidden) {
      continue;
    }
    ctx.save();
    template.attr = instances[i];
    template.useAttributes(ctx, surfaceRect);
    template.render(surface, ctx, rect);
    ctx.restore();
  }
  template.isSpriteInstance = false;
  template.attr = originalAttr;
}, setAttributesFor:function(index, changes, bypassNormalization) {
  var template = this.getTemplate(), originalAttr = template.attr, attr = this.instances[index];
  if (!attr) {
    return;
  }
  template.attr = attr;
  if (bypassNormalization) {
    changes = Ext.apply({}, changes);
  } else {
    changes = template.self.def.normalize(changes);
  }
  template.topModifier.pushDown(attr, changes);
  template.attr = originalAttr;
}, destroy:function() {
  var me = this, template = me.getTemplate();
  me.instances = null;
  if (template) {
    template.destroy();
  }
  Ext.draw.sprite.Sprite.prototype.destroy.call(this);
}}, 0, 0, 0, 0, ['sprite.instancing'], 0, [Ext.draw.sprite, 'Instancing'], 0);
Ext.define('Ext.draw.overrides.hittest.sprite.Instancing', {override:'Ext.draw.sprite.Instancing', hitTest:function(point, options) {
  var me = this, template = me.getTemplate(), originalAttr = template.attr, instances = me.instances, ln = instances.length, i = 0, result = null;
  if (!me.isVisible()) {
    return result;
  }
  for (; i < ln; i++) {
    template.attr = instances[i];
    result = template.hitTest(point, options);
    if (result) {
      result.isInstance = true;
      result.template = result.sprite;
      result.sprite = this;
      result.instance = instances[i];
      result.index = i;
      return result;
    }
  }
  template.attr = originalAttr;
  return result;
}});
Ext.cmd.derive('Ext.draw.sprite.Line', Ext.draw.sprite.Sprite, {type:'line', inheritableStatics:{def:{processors:{fromX:'number', fromY:'number', toX:'number', toY:'number'}, defaults:{fromX:0, fromY:0, toX:1, toY:1, strokeStyle:'black'}, aliases:{x1:'fromX', y1:'fromY', x2:'toX', y2:'toY'}}}, updateLineBBox:function(bbox, isTransform, x1, y1, x2, y2) {
  var attr = this.attr, matrix = attr.matrix, halfLineWidth = attr.lineWidth / 2, fromX, fromY, toX, toY, dx, dy, p;
  if (isTransform) {
    p = matrix.transformPoint([x1, y1]);
    x1 = p[0];
    y1 = p[1];
    p = matrix.transformPoint([x2, y2]);
    x2 = p[0];
    y2 = p[1];
  }
  fromX = Math.min(x1, x2);
  toX = Math.max(x1, x2);
  fromY = Math.min(y1, y2);
  toY = Math.max(y1, y2);
  var angle = Math.atan2(toX - fromX, toY - fromY), sin = Math.sin(angle), cos = Math.cos(angle), dx = halfLineWidth * cos, dy = halfLineWidth * sin;
  fromX -= dx;
  fromY -= dy;
  toX += dx;
  toY += dy;
  bbox.x = fromX;
  bbox.y = fromY;
  bbox.width = toX - fromX;
  bbox.height = toY - fromY;
}, updatePlainBBox:function(plain) {
  var attr = this.attr;
  this.updateLineBBox(plain, false, attr.fromX, attr.fromY, attr.toX, attr.toY);
}, updateTransformedBBox:function(transform, plain) {
  var attr = this.attr;
  this.updateLineBBox(transform, true, attr.fromX, attr.fromY, attr.toX, attr.toY);
}, render:function(surface, ctx) {
  var attr = this.attr, matrix = this.attr.matrix;
  matrix.toContext(ctx);
  ctx.beginPath();
  ctx.moveTo(attr.fromX, attr.fromY);
  ctx.lineTo(attr.toX, attr.toY);
  ctx.stroke();
}}, 0, 0, 0, 0, ['sprite.line'], 0, [Ext.draw.sprite, 'Line'], 0);
Ext.cmd.derive('Ext.draw.sprite.Plus', Ext.draw.sprite.Path, {inheritableStatics:{def:{processors:{x:'number', y:'number', size:'number'}, defaults:{x:0, y:0, size:4}, triggers:{x:'path', y:'path', size:'path'}}}, updatePath:function(path, attr) {
  var s = attr.size / 1.3, x = attr.x - attr.lineWidth / 2, y = attr.y;
  path.fromSvgString('M'.concat(x - s / 2, ',', y - s / 2, 'l', [0, -s, s, 0, 0, s, s, 0, 0, s, -s, 0, 0, s, -s, 0, 0, -s, -s, 0, 0, -s, 'z']));
}}, 0, 0, 0, 0, ['sprite.plus'], 0, [Ext.draw.sprite, 'Plus'], 0);
Ext.cmd.derive('Ext.draw.sprite.Sector', Ext.draw.sprite.Path, {type:'sector', inheritableStatics:{def:{processors:{centerX:'number', centerY:'number', startAngle:'number', endAngle:'number', startRho:'number', endRho:'number', margin:'number'}, aliases:{rho:'endRho'}, triggers:{centerX:'path,bbox', centerY:'path,bbox', startAngle:'path,bbox', endAngle:'path,bbox', startRho:'path,bbox', endRho:'path,bbox', margin:'path,bbox'}, defaults:{centerX:0, centerY:0, startAngle:0, endAngle:0, startRho:0, 
endRho:150, margin:0, path:'M 0,0'}}}, getMidAngle:function() {
  return this.midAngle || 0;
}, updatePath:function(path, attr) {
  var startAngle = Math.min(attr.startAngle, attr.endAngle), endAngle = Math.max(attr.startAngle, attr.endAngle), midAngle = this.midAngle = (startAngle + endAngle) * 0.5, margin = attr.margin, centerX = attr.centerX, centerY = attr.centerY, startRho = Math.min(attr.startRho, attr.endRho), endRho = Math.max(attr.startRho, attr.endRho);
  if (margin) {
    centerX += margin * Math.cos(midAngle);
    centerY += margin * Math.sin(midAngle);
  }
  path.moveTo(centerX + startRho * Math.cos(startAngle), centerY + startRho * Math.sin(startAngle));
  path.lineTo(centerX + endRho * Math.cos(startAngle), centerY + endRho * Math.sin(startAngle));
  path.arc(centerX, centerY, endRho, startAngle, endAngle, false);
  path.lineTo(centerX + startRho * Math.cos(endAngle), centerY + startRho * Math.sin(endAngle));
  path.arc(centerX, centerY, startRho, endAngle, startAngle, true);
}}, 0, 0, 0, 0, ['sprite.sector'], 0, [Ext.draw.sprite, 'Sector'], 0);
Ext.cmd.derive('Ext.draw.sprite.Square', Ext.draw.sprite.Path, {inheritableStatics:{def:{processors:{x:'number', y:'number', size:'number'}, defaults:{x:0, y:0, size:4}, triggers:{x:'path', y:'path', size:'size'}}}, updatePath:function(path, attr) {
  var size = attr.size * 1.2, s = size * 2, x = attr.x - attr.lineWidth / 2, y = attr.y;
  path.fromSvgString('M'.concat(x - size, ',', y - size, 'l', [s, 0, 0, s, -s, 0, 0, -s, 'z']));
}}, 0, 0, 0, 0, ['sprite.square'], 0, [Ext.draw.sprite, 'Square'], 0);
Ext.cmd.derive('Ext.draw.TextMeasurer', Ext.Base, {singleton:true, measureDiv:null, measureCache:{}, precise:Ext.isIE8, measureDivTpl:{id:'ext-draw-text-measurer', tag:'div', style:{overflow:'hidden', position:'relative', 'float':'left', width:0, height:0}, children:{tag:'div', style:{display:'block', position:'absolute', x:-100000, y:-100000, padding:0, margin:0, 'z-index':-100000, 'white-space':'nowrap'}}}, actualMeasureText:function(text, font) {
  var me = Ext.draw.TextMeasurer, measureDiv = me.measureDiv, FARAWAY = 100000, size;
  if (!measureDiv) {
    var parent = Ext.Element.create({style:{'overflow':'hidden', 'position':'relative', 'float':'left', 'width':0, 'height':0}});
    me.measureDiv = measureDiv = Ext.Element.create({style:{'position':'absolute', 'x':FARAWAY, 'y':FARAWAY, 'z-index':-FARAWAY, 'white-space':'nowrap', 'display':'block', 'padding':0, 'margin':0}});
    Ext.getBody().appendChild(parent);
    parent.appendChild(measureDiv);
  }
  if (font) {
    measureDiv.setStyle({font:font, lineHeight:'normal'});
  }
  measureDiv.setText('(' + text + ')');
  size = measureDiv.getSize();
  measureDiv.setText('()');
  size.width -= measureDiv.getSize().width;
  return size;
}, measureTextSingleLine:function(text, font) {
  if (this.precise) {
    return this.preciseMeasureTextSingleLine(text, font);
  }
  text = text.toString();
  var cache = this.measureCache, chars = text.split(''), width = 0, height = 0, cachedItem, charactor, i, ln, size;
  if (!cache[font]) {
    cache[font] = {};
  }
  cache = cache[font];
  if (cache[text]) {
    return cache[text];
  }
  for (i = 0, ln = chars.length; i < ln; i++) {
    charactor = chars[i];
    if (!(cachedItem = cache[charactor])) {
      size = this.actualMeasureText(charactor, font);
      cachedItem = cache[charactor] = size;
    }
    width += cachedItem.width;
    height = Math.max(height, cachedItem.height);
  }
  return cache[text] = {width:width, height:height};
}, preciseMeasureTextSingleLine:function(text, font) {
  text = text.toString();
  var measureDiv = this.measureDiv || (this.measureDiv = Ext.getBody().createChild(this.measureDivTpl).down('div'));
  measureDiv.setStyle({font:font || ''});
  return Ext.util.TextMetrics.measure(measureDiv, text);
}, measureText:function(text, font) {
  var lines = text.split('\n'), ln = lines.length, height = 0, width = 0, line, i, sizes;
  if (ln === 1) {
    return this.measureTextSingleLine(text, font);
  }
  sizes = [];
  for (i = 0; i < ln; i++) {
    line = this.measureTextSingleLine(lines[i], font);
    sizes.push(line);
    height += line.height;
    width = Math.max(width, line.width);
  }
  return {width:width, height:height, sizes:sizes};
}}, 0, 0, 0, 0, 0, 0, [Ext.draw, 'TextMeasurer'], 0);
Ext.cmd.derive('Ext.draw.sprite.Text', Ext.draw.sprite.Sprite, function() {
  var fontSizes = {'xx-small':true, 'x-small':true, 'small':true, 'medium':true, 'large':true, 'x-large':true, 'xx-large':true};
  var fontWeights = {normal:true, bold:true, bolder:true, lighter:true, 100:true, 200:true, 300:true, 400:true, 500:true, 600:true, 700:true, 800:true, 900:true};
  var textAlignments = {start:'start', left:'start', center:'center', middle:'center', end:'end', right:'end'};
  var textBaselines = {top:'top', hanging:'hanging', middle:'middle', center:'middle', alphabetic:'alphabetic', ideographic:'ideographic', bottom:'bottom'};
  return {type:'text', lineBreakRe:/\r?\n/g, inheritableStatics:{def:{animationProcessors:{text:'text'}, processors:{x:'number', y:'number', text:'string', fontSize:function(n) {
    if (Ext.isNumber(+n)) {
      return n + 'px';
    } else {
      if (n.match(Ext.dom.Element.unitRe)) {
        return n;
      } else {
        if (n in fontSizes) {
          return n;
        }
      }
    }
  }, fontStyle:'enums(,italic,oblique)', fontVariant:'enums(,small-caps)', fontWeight:function(n) {
    if (n in fontWeights) {
      return String(n);
    } else {
      return '';
    }
  }, fontFamily:'string', textAlign:function(n) {
    return textAlignments[n] || 'center';
  }, textBaseline:function(n) {
    return textBaselines[n] || 'alphabetic';
  }, font:'string'}, aliases:{'font-size':'fontSize', 'font-family':'fontFamily', 'font-weight':'fontWeight', 'font-variant':'fontVariant', 'text-anchor':'textAlign'}, defaults:{fontStyle:'', fontVariant:'', fontWeight:'', fontSize:'10px', fontFamily:'sans-serif', font:'10px sans-serif', textBaseline:'alphabetic', textAlign:'start', strokeStyle:'rgba(0, 0, 0, 0)', fillStyle:'#000', x:0, y:0, text:''}, triggers:{fontStyle:'fontX,bbox', fontVariant:'fontX,bbox', fontWeight:'fontX,bbox', fontSize:'fontX,bbox', 
  fontFamily:'fontX,bbox', font:'font,bbox,canvas', textBaseline:'bbox', textAlign:'bbox', x:'bbox', y:'bbox', text:'bbox'}, updaters:{fontX:'makeFontShorthand', font:'parseFontShorthand'}}}, config:{preciseMeasurement:undefined}, constructor:function(config) {
    if (config && config.font) {
      config = Ext.clone(config);
      for (var key in config) {
        if (key !== 'font' && key.indexOf('font') === 0) {
          delete config[key];
        }
      }
    }
    Ext.draw.sprite.Sprite.prototype.constructor.call(this, config);
  }, fontValuesMap:{'italic':'fontStyle', 'oblique':'fontStyle', 'small-caps':'fontVariant', 'bold':'fontWeight', 'bolder':'fontWeight', 'lighter':'fontWeight', 100:'fontWeight', 200:'fontWeight', 300:'fontWeight', 400:'fontWeight', 500:'fontWeight', 600:'fontWeight', 700:'fontWeight', 800:'fontWeight', 900:'fontWeight', 'xx-small':'fontSize', 'x-small':'fontSize', 'small':'fontSize', 'medium':'fontSize', 'large':'fontSize', 'x-large':'fontSize', 'xx-large':'fontSize'}, makeFontShorthand:function(attr) {
    var parts = [];
    if (attr.fontStyle) {
      parts.push(attr.fontStyle);
    }
    if (attr.fontVariant) {
      parts.push(attr.fontVariant);
    }
    if (attr.fontWeight) {
      parts.push(attr.fontWeight);
    }
    if (attr.fontSize) {
      parts.push(attr.fontSize);
    }
    if (attr.fontFamily) {
      parts.push(attr.fontFamily);
    }
    this.setAttributes({font:parts.join(' ')}, true);
  }, parseFontShorthand:function(attr) {
    var value = attr.font, ln = value.length, changes = {}, dispatcher = this.fontValuesMap, start = 0, end, slashIndex, part, fontProperty;
    while (start < ln && end !== -1) {
      end = value.indexOf(' ', start);
      if (end < 0) {
        part = value.substr(start);
      } else {
        if (end > start) {
          part = value.substr(start, end - start);
        } else {
          continue;
        }
      }
      slashIndex = part.indexOf('/');
      if (slashIndex > 0) {
        part = part.substr(0, slashIndex);
      } else {
        if (slashIndex === 0) {
          continue;
        }
      }
      if (part !== 'normal' && part !== 'inherit') {
        fontProperty = dispatcher[part];
        if (fontProperty) {
          changes[fontProperty] = part;
        } else {
          if (part.match(Ext.dom.Element.unitRe)) {
            changes.fontSize = part;
          } else {
            changes.fontFamily = value.substr(start);
            break;
          }
        }
      }
      start = end + 1;
    }
    if (!changes.fontStyle) {
      changes.fontStyle = '';
    }
    if (!changes.fontVariant) {
      changes.fontVariant = '';
    }
    if (!changes.fontWeight) {
      changes.fontWeight = '';
    }
    this.setAttributes(changes, true);
  }, fontProperties:{fontStyle:true, fontVariant:true, fontWeight:true, fontSize:true, fontFamily:true}, setAttributes:function(changes, bypassNormalization, avoidCopy) {
    var key, obj;
    if (changes && changes.font) {
      obj = {};
      for (key in changes) {
        if (!(key in this.fontProperties)) {
          obj[key] = changes[key];
        }
      }
      changes = obj;
    }
    Ext.draw.sprite.Sprite.prototype.setAttributes.call(this, changes, bypassNormalization, avoidCopy);
  }, getBBox:function(isWithoutTransform) {
    var me = this, plain = me.attr.bbox.plain, surface = me.getSurface();
    if (plain.dirty) {
      me.updatePlainBBox(plain);
      plain.dirty = false;
    }
    if (surface && surface.getInherited().rtl && surface.getFlipRtlText()) {
      me.updatePlainBBox(plain, true);
    }
    return Ext.draw.sprite.Sprite.prototype.getBBox.call(this, isWithoutTransform);
  }, rtlAlignments:{start:'end', center:'center', end:'start'}, updatePlainBBox:function(plain, useOldSize) {
    var me = this, attr = me.attr, x = attr.x, y = attr.y, dx = [], font = attr.font, text = attr.text, baseline = attr.textBaseline, alignment = attr.textAlign, precise = me.getPreciseMeasurement(), size, textMeasurerPrecision;
    if (useOldSize && me.oldSize) {
      size = me.oldSize;
    } else {
      textMeasurerPrecision = Ext.draw.TextMeasurer.precise;
      if (Ext.isBoolean(precise)) {
        Ext.draw.TextMeasurer.precise = precise;
      }
      size = me.oldSize = Ext.draw.TextMeasurer.measureText(text, font);
      Ext.draw.TextMeasurer.precise = textMeasurerPrecision;
    }
    var surface = me.getSurface(), isRtl = surface && surface.getInherited().rtl || false, flipRtlText = isRtl && surface.getFlipRtlText(), sizes = size.sizes, blockHeight = size.height, blockWidth = size.width, ln = sizes ? sizes.length : 0, lineWidth, rect, i = 0;
    switch(baseline) {
      case 'hanging':
      case 'top':
        break;
      case 'ideographic':
      case 'bottom':
        y -= blockHeight;
        break;
      case 'alphabetic':
        y -= blockHeight * 0.8;
        break;
      case 'middle':
        y -= blockHeight * 0.5;
        break;
    }
    if (flipRtlText) {
      rect = surface.getRect();
      x = rect[2] - rect[0] - x;
      alignment = me.rtlAlignments[alignment];
    }
    switch(alignment) {
      case 'start':
        if (isRtl) {
          for (; i < ln; i++) {
            lineWidth = sizes[i].width;
            dx.push(-(blockWidth - lineWidth));
          }
        }
        break;
      case 'end':
        x -= blockWidth;
        if (isRtl) {
          break;
        }
        for (; i < ln; i++) {
          lineWidth = sizes[i].width;
          dx.push(blockWidth - lineWidth);
        }
        break;
      case 'center':
        x -= blockWidth * 0.5;
        for (; i < ln; i++) {
          lineWidth = sizes[i].width;
          dx.push((isRtl ? -1 : 1) * (blockWidth - lineWidth) * 0.5);
        }
        break;
    }
    attr.textAlignOffsets = dx;
    plain.x = x;
    plain.y = y;
    plain.width = blockWidth;
    plain.height = blockHeight;
  }, setText:function(text) {
    this.setAttributes({text:text}, true);
  }, render:function(surface, ctx, rect) {
    var me = this, attr = me.attr, mat = Ext.draw.Matrix.fly(attr.matrix.elements.slice(0)), bbox = me.getBBox(true), dx = attr.textAlignOffsets, none = Ext.util.Color.RGBA_NONE, x, y, i, lines, lineHeight;
    if (attr.text.length === 0) {
      return;
    }
    lines = attr.text.split(me.lineBreakRe);
    lineHeight = bbox.height / lines.length;
    x = attr.bbox.plain.x;
    y = attr.bbox.plain.y + lineHeight * 0.78;
    mat.toContext(ctx);
    if (surface.getInherited().rtl) {
      x += attr.bbox.plain.width;
    }
    for (i = 0; i < lines.length; i++) {
      if (ctx.fillStyle !== none) {
        ctx.fillText(lines[i], x + (dx[i] || 0), y + lineHeight * i);
      }
      if (ctx.strokeStyle !== none) {
        ctx.strokeText(lines[i], x + (dx[i] || 0), y + lineHeight * i);
      }
    }
  }};
}, 1, 0, 0, 0, ['sprite.text'], 0, [Ext.draw.sprite, 'Text'], 0);
Ext.cmd.derive('Ext.draw.sprite.Tick', Ext.draw.sprite.Line, {inheritableStatics:{def:{processors:{x:'number', y:'number', size:'number'}, defaults:{x:0, y:0, size:4}, triggers:{x:'tick', y:'tick', size:'tick'}, updaters:{tick:function(attr) {
  var size = attr.size * 1.5, halfLineWidth = attr.lineWidth / 2, x = attr.x, y = attr.y;
  this.setAttributes({fromX:x - halfLineWidth, fromY:y - size, toX:x - halfLineWidth, toY:y + size});
}}}}}, 0, 0, 0, 0, ['sprite.tick'], 0, [Ext.draw.sprite, 'Tick'], 0);
Ext.cmd.derive('Ext.draw.sprite.Triangle', Ext.draw.sprite.Path, {inheritableStatics:{def:{processors:{x:'number', y:'number', size:'number'}, defaults:{x:0, y:0, size:4}, triggers:{x:'path', y:'path', size:'path'}}}, updatePath:function(path, attr) {
  var s = attr.size * 2.2, x = attr.x, y = attr.y;
  path.fromSvgString('M'.concat(x, ',', y, 'm0-', s * 0.48, 'l', s * 0.5, ',', s * 0.87, '-', s, ',0z'));
}}, 0, 0, 0, 0, ['sprite.triangle'], 0, [Ext.draw.sprite, 'Triangle'], 0);
Ext.cmd.derive('Ext.draw.gradient.Linear', Ext.draw.gradient.Gradient, {type:'linear', config:{degrees:0, radians:0}, applyRadians:function(radians, oldRadians) {
  if (Ext.isNumber(radians)) {
    return radians;
  }
  return oldRadians;
}, applyDegrees:function(degrees, oldDegrees) {
  if (Ext.isNumber(degrees)) {
    return degrees;
  }
  return oldDegrees;
}, updateRadians:function(radians) {
  this.setDegrees(Ext.draw.Draw.degrees(radians));
}, updateDegrees:function(degrees) {
  this.setRadians(Ext.draw.Draw.rad(degrees));
}, generateGradient:function(ctx, bbox) {
  var angle = this.getRadians(), cos = Math.cos(angle), sin = Math.sin(angle), w = bbox.width, h = bbox.height, cx = bbox.x + w * 0.5, cy = bbox.y + h * 0.5, stops = this.getStops(), ln = stops.length, gradient, l, i;
  if (Ext.isNumber(cx) && Ext.isNumber(cy) && h > 0 && w > 0) {
    l = Math.sqrt(h * h + w * w) * Math.abs(Math.cos(angle - Math.atan(h / w))) / 2;
    gradient = ctx.createLinearGradient(cx + cos * l, cy + sin * l, cx - cos * l, cy - sin * l);
    for (i = 0; i < ln; i++) {
      gradient.addColorStop(stops[i].offset, stops[i].color);
    }
    return gradient;
  }
  return Ext.util.Color.NONE;
}}, 0, 0, 0, 0, 0, 0, [Ext.draw.gradient, 'Linear'], 0);
Ext.cmd.derive('Ext.draw.gradient.Radial', Ext.draw.gradient.Gradient, {type:'radial', config:{start:{x:0, y:0, r:0}, end:{x:0, y:0, r:1}}, applyStart:function(newStart, oldStart) {
  if (!oldStart) {
    return newStart;
  }
  var circle = {x:oldStart.x, y:oldStart.y, r:oldStart.r};
  if ('x' in newStart) {
    circle.x = newStart.x;
  } else {
    if ('centerX' in newStart) {
      circle.x = newStart.centerX;
    }
  }
  if ('y' in newStart) {
    circle.y = newStart.y;
  } else {
    if ('centerY' in newStart) {
      circle.y = newStart.centerY;
    }
  }
  if ('r' in newStart) {
    circle.r = newStart.r;
  } else {
    if ('radius' in newStart) {
      circle.r = newStart.radius;
    }
  }
  return circle;
}, applyEnd:function(newEnd, oldEnd) {
  if (!oldEnd) {
    return newEnd;
  }
  var circle = {x:oldEnd.x, y:oldEnd.y, r:oldEnd.r};
  if ('x' in newEnd) {
    circle.x = newEnd.x;
  } else {
    if ('centerX' in newEnd) {
      circle.x = newEnd.centerX;
    }
  }
  if ('y' in newEnd) {
    circle.y = newEnd.y;
  } else {
    if ('centerY' in newEnd) {
      circle.y = newEnd.centerY;
    }
  }
  if ('r' in newEnd) {
    circle.r = newEnd.r;
  } else {
    if ('radius' in newEnd) {
      circle.r = newEnd.radius;
    }
  }
  return circle;
}, generateGradient:function(ctx, bbox) {
  var start = this.getStart(), end = this.getEnd(), w = bbox.width * 0.5, h = bbox.height * 0.5, x = bbox.x + w, y = bbox.y + h, gradient = ctx.createRadialGradient(x + start.x * w, y + start.y * h, start.r * Math.max(w, h), x + end.x * w, y + end.y * h, end.r * Math.max(w, h)), stops = this.getStops(), ln = stops.length, i;
  for (i = 0; i < ln; i++) {
    gradient.addColorStop(stops[i].offset, stops[i].color);
  }
  return gradient;
}}, 0, 0, 0, 0, 0, 0, [Ext.draw.gradient, 'Radial'], 0);
Ext.cmd.derive('Ext.draw.Surface', Ext.draw.SurfaceBase, {devicePixelRatio:window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI, deprecated:{'5.1.0':{statics:{methods:{stableSort:function(list) {
  return Ext.Array.sort(list, function(a, b) {
    return a.attr.zIndex - b.attr.zIndex;
  });
}}}}}, cls:'x-surface', config:{rect:null, background:null, items:[], dirty:false, flipRtlText:false}, isSurface:true, isPendingRenderFrame:false, dirtyPredecessorCount:0, constructor:function(config) {
  var me = this;
  me.predecessors = [];
  me.successors = [];
  me.map = {};
  Ext.draw.SurfaceBase.prototype.constructor.call(this, config);
  me.matrix = new Ext.draw.Matrix;
  me.inverseMatrix = me.matrix.inverse();
}, roundPixel:function(num) {
  return Math.round(this.devicePixelRatio * num) / this.devicePixelRatio;
}, waitFor:function(surface) {
  var me = this, predecessors = me.predecessors;
  if (!Ext.Array.contains(predecessors, surface)) {
    predecessors.push(surface);
    surface.successors.push(me);
    if (surface.getDirty()) {
      me.dirtyPredecessorCount++;
    }
  }
}, updateDirty:function(dirty) {
  var successors = this.successors, ln = successors.length, i = 0, successor;
  for (; i < ln; i++) {
    successor = successors[i];
    if (dirty) {
      successor.dirtyPredecessorCount++;
      successor.setDirty(true);
    } else {
      successor.dirtyPredecessorCount--;
      if (successor.dirtyPredecessorCount === 0 && successor.isPendingRenderFrame) {
        successor.renderFrame();
      }
    }
  }
}, applyBackground:function(background, oldBackground) {
  this.setDirty(true);
  if (Ext.isString(background)) {
    background = {fillStyle:background};
  }
  return Ext.factory(background, Ext.draw.sprite.Rect, oldBackground);
}, applyRect:function(rect, oldRect) {
  if (oldRect && rect[0] === oldRect[0] && rect[1] === oldRect[1] && rect[2] === oldRect[2] && rect[3] === oldRect[3]) {
    return;
  }
  if (Ext.isArray(rect)) {
    return [rect[0], rect[1], rect[2], rect[3]];
  } else {
    if (Ext.isObject(rect)) {
      return [rect.x || rect.left, rect.y || rect.top, rect.width || rect.right - rect.left, rect.height || rect.bottom - rect.top];
    }
  }
}, updateRect:function(rect) {
  var me = this, l = rect[0], t = rect[1], r = l + rect[2], b = t + rect[3], background = me.getBackground(), element = me.element;
  element.setLocalXY(Math.floor(l), Math.floor(t));
  element.setSize(Math.ceil(r - Math.floor(l)), Math.ceil(b - Math.floor(t)));
  if (background) {
    background.setAttributes({x:0, y:0, width:Math.ceil(r - Math.floor(l)), height:Math.ceil(b - Math.floor(t))});
  }
  me.setDirty(true);
}, resetTransform:function() {
  this.matrix.set(1, 0, 0, 1, 0, 0);
  this.inverseMatrix.set(1, 0, 0, 1, 0, 0);
  this.setDirty(true);
}, get:function(id) {
  return this.map[id] || this.getItems()[id];
}, add:function() {
  var me = this, args = Array.prototype.slice.call(arguments), argIsArray = Ext.isArray(args[0]), map = me.map, results = [], items, item, sprite, oldSurface, i, ln;
  items = Ext.Array.clean(argIsArray ? args[0] : args);
  if (!items.length) {
    return results;
  }
  for (i = 0, ln = items.length; i < ln; i++) {
    item = items[i];
    if (!item || item.destroyed) {
      continue;
    }
    sprite = null;
    if (item.isSprite && !map[item.getId()]) {
      sprite = item;
    } else {
      if (!map[item.id]) {
        sprite = this.createItem(item);
      }
    }
    if (sprite) {
      map[sprite.getId()] = sprite;
      results.push(sprite);
      oldSurface = sprite.getSurface();
      if (oldSurface && oldSurface.isSurface) {
        oldSurface.remove(sprite);
      }
      sprite.setParent(me);
      sprite.setSurface(me);
      me.onAdd(sprite);
    }
  }
  items = me.getItems();
  if (items) {
    items.push.apply(items, results);
  }
  me.dirtyZIndex = true;
  me.setDirty(true);
  if (!argIsArray && results.length === 1) {
    return results[0];
  } else {
    return results;
  }
}, onAdd:Ext.emptyFn, remove:function(sprite, isDestroy) {
  var me = this, destroying = me.clearing, id, isOwnSprite;
  if (sprite) {
    if (sprite.charAt) {
      sprite = me.map[sprite];
    }
    if (!sprite || !sprite.isSprite) {
      return null;
    }
    id = sprite.id;
    isOwnSprite = me.map[id];
    delete me.map[id];
    if (sprite.destroyed || sprite.destroying) {
      if (isOwnSprite && !destroying) {
        Ext.Array.remove(me.getItems(), sprite);
      }
      return sprite;
    }
    if (!isOwnSprite) {
      if (isDestroy) {
        sprite.destroy();
      }
      return sprite;
    }
    sprite.setParent(null);
    sprite.setSurface(null);
    if (isDestroy) {
      sprite.destroy();
    }
    if (!destroying) {
      Ext.Array.remove(me.getItems(), sprite);
      me.dirtyZIndex = true;
      me.setDirty(true);
    }
  }
  return sprite || null;
}, removeAll:function(isDestroy) {
  var me = this, items = me.getItems(), item, ln, i;
  me.clearing = !!isDestroy;
  for (i = items.length - 1; i >= 0; i--) {
    item = items[i];
    if (isDestroy) {
      item.destroy();
    } else {
      item.setParent(null);
      item.setSurface(null);
    }
  }
  me.clearing = false;
  items.length = 0;
  me.map = {};
  me.dirtyZIndex = true;
  if (!me.destroying) {
    me.setDirty(true);
  }
}, applyItems:function(items) {
  if (this.getItems()) {
    this.removeAll(true);
  }
  return Ext.Array.from(this.add(items));
}, createItem:function(config) {
  return Ext.create(config.xclass || 'sprite.' + config.type, config);
}, getBBox:function(sprites, isWithoutTransform) {
  sprites = Ext.Array.from(sprites);
  var left = Infinity, right = -Infinity, top = Infinity, bottom = -Infinity, ln = sprites.length, sprite, bbox, i;
  for (i = 0; i < ln; i++) {
    sprite = sprites[i];
    bbox = sprite.getBBox(isWithoutTransform);
    if (left > bbox.x) {
      left = bbox.x;
    }
    if (right < bbox.x + bbox.width) {
      right = bbox.x + bbox.width;
    }
    if (top > bbox.y) {
      top = bbox.y;
    }
    if (bottom < bbox.y + bbox.height) {
      bottom = bbox.y + bbox.height;
    }
  }
  return {x:left, y:top, width:right - left, height:bottom - top};
}, emptyRect:[0, 0, 0, 0], getEventXY:function(e) {
  var me = this, isRtl = me.getInherited().rtl, pageXY = e.getXY(), container = me.getOwnerBody(), xy = container.getXY(), rect = me.getRect() || me.emptyRect, result = [], width;
  if (isRtl) {
    width = container.getWidth();
    result[0] = xy[0] - pageXY[0] - rect[0] + width;
  } else {
    result[0] = pageXY[0] - xy[0] - rect[0];
  }
  result[1] = pageXY[1] - xy[1] - rect[1];
  return result;
}, clear:Ext.emptyFn, orderByZIndex:function() {
  var me = this, items = me.getItems(), dirtyZIndex = false, i, ln;
  if (me.getDirty()) {
    for (i = 0, ln = items.length; i < ln; i++) {
      if (items[i].attr.dirtyZIndex) {
        dirtyZIndex = true;
        break;
      }
    }
    if (dirtyZIndex) {
      Ext.Array.sort(items, function(a, b) {
        return a.attr.zIndex - b.attr.zIndex;
      });
      this.setDirty(true);
    }
    for (i = 0, ln = items.length; i < ln; i++) {
      items[i].attr.dirtyZIndex = false;
    }
  }
}, repaint:function() {
  var me = this;
  me.repaint = Ext.emptyFn;
  Ext.defer(function() {
    delete me.repaint;
    me.element.repaint();
  }, 1);
}, renderFrame:function() {
  var me = this;
  if (!(me.element && me.getDirty() && me.getRect())) {
    return;
  }
  if (me.dirtyPredecessorCount > 0) {
    me.isPendingRenderFrame = true;
    return;
  }
  var background = me.getBackground(), items = me.getItems(), item, i, ln;
  me.orderByZIndex();
  if (me.getDirty()) {
    me.clear();
    me.clearTransform();
    if (background) {
      me.renderSprite(background);
    }
    for (i = 0, ln = items.length; i < ln; i++) {
      item = items[i];
      if (me.renderSprite(item) === false) {
        return;
      }
      item.attr.textPositionCount = me.textPosition;
    }
    me.setDirty(false);
  }
}, renderSprite:Ext.emptyFn, clearTransform:Ext.emptyFn, destroy:function() {
  var me = this;
  me.destroying = true;
  me.removeAll(true);
  me.destroying = false;
  me.predecessors = me.successors = null;
  if (me.hasListeners.destroy) {
    me.fireEvent('destroy', me);
  }
  Ext.draw.SurfaceBase.prototype.destroy.call(this);
}}, 1, ['surface'], ['widget', 'surface'], {'widget':true, 'surface':true}, ['widget.surface'], 0, [Ext.draw, 'Surface'], 0);
Ext.define('Ext.draw.overrides.hittest.Surface', {override:'Ext.draw.Surface', hitTest:function(point, options) {
  var me = this, sprites = me.getItems(), i, sprite, result;
  options = options || Ext.draw.sprite.Sprite.defaultHitTestOptions;
  for (i = sprites.length - 1; i >= 0; i--) {
    sprite = sprites[i];
    if (sprite.hitTest) {
      result = sprite.hitTest(point, options);
      if (result) {
        return result;
      }
    }
  }
  return null;
}, hitTestEvent:function(event, options) {
  var xy = this.getEventXY(event);
  return this.hitTest(xy, options);
}});
Ext.cmd.derive('Ext.draw.engine.SvgContext', Ext.Base, {toSave:['strokeOpacity', 'strokeStyle', 'fillOpacity', 'fillStyle', 'globalAlpha', 'lineWidth', 'lineCap', 'lineJoin', 'lineDash', 'lineDashOffset', 'miterLimit', 'shadowOffsetX', 'shadowOffsetY', 'shadowBlur', 'shadowColor', 'globalCompositeOperation', 'position', 'fillGradient', 'strokeGradient'], strokeOpacity:1, strokeStyle:'none', fillOpacity:1, fillStyle:'none', lineDas:[], lineDashOffset:0, globalAlpha:1, lineWidth:1, lineCap:'butt', 
lineJoin:'miter', miterLimit:10, shadowOffsetX:0, shadowOffsetY:0, shadowBlur:0, shadowColor:'none', globalCompositeOperation:'src', urlStringRe:/^url\(#([\w\-]+)\)$/, constructor:function(SvgSurface) {
  var me = this;
  me.surface = SvgSurface;
  me.state = [];
  me.matrix = new Ext.draw.Matrix;
  me.path = null;
  me.clear();
}, clear:function() {
  this.group = this.surface.mainGroup;
  this.position = 0;
  this.path = null;
}, getElement:function(tag) {
  return this.surface.getSvgElement(this.group, tag, this.position++);
}, save:function() {
  var toSave = this.toSave, obj = {}, group = this.getElement('g'), key, i;
  for (i = 0; i < toSave.length; i++) {
    key = toSave[i];
    if (key in this) {
      obj[key] = this[key];
    }
  }
  this.position = 0;
  obj.matrix = this.matrix.clone();
  this.state.push(obj);
  this.group = group;
  return group;
}, restore:function() {
  var toSave = this.toSave, obj = this.state.pop(), group = this.group, children = group.dom.childNodes, key, i;
  while (children.length > this.position) {
    group.last().destroy();
  }
  for (i = 0; i < toSave.length; i++) {
    key = toSave[i];
    if (key in obj) {
      this[key] = obj[key];
    } else {
      delete this[key];
    }
  }
  this.setTransform.apply(this, obj.matrix.elements);
  this.group = group.getParent();
}, transform:function(xx, yx, xy, yy, dx, dy) {
  if (this.path) {
    var inv = Ext.draw.Matrix.fly([xx, yx, xy, yy, dx, dy]).inverse();
    this.path.transform(inv);
  }
  this.matrix.append(xx, yx, xy, yy, dx, dy);
}, setTransform:function(xx, yx, xy, yy, dx, dy) {
  if (this.path) {
    this.path.transform(this.matrix);
  }
  this.matrix.reset();
  this.transform(xx, yx, xy, yy, dx, dy);
}, scale:function(x, y) {
  this.transform(x, 0, 0, y, 0, 0);
}, rotate:function(angle) {
  var xx = Math.cos(angle), yx = Math.sin(angle), xy = -Math.sin(angle), yy = Math.cos(angle);
  this.transform(xx, yx, xy, yy, 0, 0);
}, translate:function(x, y) {
  this.transform(1, 0, 0, 1, x, y);
}, setGradientBBox:function(bbox) {
  this.bbox = bbox;
}, beginPath:function() {
  this.path = new Ext.draw.Path;
}, moveTo:function(x, y) {
  if (!this.path) {
    this.beginPath();
  }
  this.path.moveTo(x, y);
  this.path.element = null;
}, lineTo:function(x, y) {
  if (!this.path) {
    this.beginPath();
  }
  this.path.lineTo(x, y);
  this.path.element = null;
}, rect:function(x, y, width, height) {
  this.moveTo(x, y);
  this.lineTo(x + width, y);
  this.lineTo(x + width, y + height);
  this.lineTo(x, y + height);
  this.closePath();
}, strokeRect:function(x, y, width, height) {
  this.beginPath();
  this.rect(x, y, width, height);
  this.stroke();
}, fillRect:function(x, y, width, height) {
  this.beginPath();
  this.rect(x, y, width, height);
  this.fill();
}, closePath:function() {
  if (!this.path) {
    this.beginPath();
  }
  this.path.closePath();
  this.path.element = null;
}, arcSvg:function(r1, r2, rotation, large, swipe, x2, y2) {
  if (!this.path) {
    this.beginPath();
  }
  this.path.arcSvg(r1, r2, rotation, large, swipe, x2, y2);
  this.path.element = null;
}, arc:function(x, y, radius, startAngle, endAngle, anticlockwise) {
  if (!this.path) {
    this.beginPath();
  }
  this.path.arc(x, y, radius, startAngle, endAngle, anticlockwise);
  this.path.element = null;
}, ellipse:function(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
  if (!this.path) {
    this.beginPath();
  }
  this.path.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);
  this.path.element = null;
}, arcTo:function(x1, y1, x2, y2, radiusX, radiusY, rotation) {
  if (!this.path) {
    this.beginPath();
  }
  this.path.arcTo(x1, y1, x2, y2, radiusX, radiusY, rotation);
  this.path.element = null;
}, bezierCurveTo:function(x1, y1, x2, y2, x3, y3) {
  if (!this.path) {
    this.beginPath();
  }
  this.path.bezierCurveTo(x1, y1, x2, y2, x3, y3);
  this.path.element = null;
}, strokeText:function(text, x, y) {
  text = String(text);
  if (this.strokeStyle) {
    var element = this.getElement('text'), tspan = this.surface.getSvgElement(element, 'tspan', 0);
    this.surface.setElementAttributes(element, {'x':x, 'y':y, 'transform':this.matrix.toSvg(), 'stroke':this.strokeStyle, 'fill':'none', 'opacity':this.globalAlpha, 'stroke-opacity':this.strokeOpacity, 'style':'font: ' + this.font, 'stroke-dasharray':this.lineDash.join(','), 'stroke-dashoffset':this.lineDashOffset});
    if (this.lineDash.length) {
      this.surface.setElementAttributes(element, {'stroke-dasharray':this.lineDash.join(','), 'stroke-dashoffset':this.lineDashOffset});
    }
    if (tspan.dom.firstChild) {
      tspan.dom.removeChild(tspan.dom.firstChild);
    }
    this.surface.setElementAttributes(tspan, {'alignment-baseline':'alphabetic'});
    tspan.dom.appendChild(document.createTextNode(Ext.String.htmlDecode(text)));
  }
}, fillText:function(text, x, y) {
  text = String(text);
  if (this.fillStyle) {
    var element = this.getElement('text'), tspan = this.surface.getSvgElement(element, 'tspan', 0);
    this.surface.setElementAttributes(element, {'x':x, 'y':y, 'transform':this.matrix.toSvg(), 'fill':this.fillStyle, 'opacity':this.globalAlpha, 'fill-opacity':this.fillOpacity, 'style':'font: ' + this.font});
    if (tspan.dom.firstChild) {
      tspan.dom.removeChild(tspan.dom.firstChild);
    }
    this.surface.setElementAttributes(tspan, {'alignment-baseline':'alphabetic'});
    tspan.dom.appendChild(document.createTextNode(Ext.String.htmlDecode(text)));
  }
}, drawImage:function(image, sx, sy, sw, sh, dx, dy, dw, dh) {
  var me = this, element = me.getElement('image'), x = sx, y = sy, width = typeof sw === 'undefined' ? image.width : sw, height = typeof sh === 'undefined' ? image.height : sh, viewBox = null;
  if (typeof dh !== 'undefined') {
    viewBox = sx + ' ' + sy + ' ' + sw + ' ' + sh;
    x = dx;
    y = dy;
    width = dw;
    height = dh;
  }
  element.dom.setAttributeNS('http://www.w3.org/1999/xlink', 'href', image.src);
  me.surface.setElementAttributes(element, {viewBox:viewBox, x:x, y:y, width:width, height:height, opacity:me.globalAlpha, transform:me.matrix.toSvg()});
}, fill:function() {
  var me = this;
  if (!me.path) {
    return;
  }
  if (me.fillStyle) {
    var path, fillGradient = me.fillGradient, element = me.path.element, bbox = me.bbox, fill;
    if (!element) {
      path = me.path.toString();
      element = me.path.element = me.getElement('path');
      me.surface.setElementAttributes(element, {'d':path, 'transform':me.matrix.toSvg()});
    }
    if (fillGradient && bbox) {
      fill = fillGradient.generateGradient(me, bbox);
    } else {
      fill = me.fillStyle;
    }
    me.surface.setElementAttributes(element, {'fill':fill, 'fill-opacity':me.fillOpacity * me.globalAlpha});
  }
}, stroke:function() {
  var me = this;
  if (!me.path) {
    return;
  }
  if (me.strokeStyle) {
    var path, strokeGradient = me.strokeGradient, element = me.path.element, bbox = me.bbox, stroke;
    if (!element || !me.path.svgString) {
      path = me.path.toString();
      if (!path) {
        return;
      }
      element = me.path.element = me.getElement('path');
      me.surface.setElementAttributes(element, {'fill':'none', 'd':path, 'transform':me.matrix.toSvg()});
    }
    if (strokeGradient && bbox) {
      stroke = strokeGradient.generateGradient(me, bbox);
    } else {
      stroke = me.strokeStyle;
    }
    me.surface.setElementAttributes(element, {'stroke':stroke, 'stroke-linecap':me.lineCap, 'stroke-linejoin':me.lineJoin, 'stroke-width':me.lineWidth, 'stroke-opacity':me.strokeOpacity * me.globalAlpha, 'stroke-dasharray':me.lineDash.join(','), 'stroke-dashoffset':me.lineDashOffset});
    if (me.lineDash.length) {
      me.surface.setElementAttributes(element, {'stroke-dasharray':me.lineDash.join(','), 'stroke-dashoffset':me.lineDashOffset});
    }
  }
}, fillStroke:function(attr, transformFillStroke) {
  var ctx = this, fillStyle = ctx.fillStyle, strokeStyle = ctx.strokeStyle, fillOpacity = ctx.fillOpacity, strokeOpacity = ctx.strokeOpacity;
  if (transformFillStroke === undefined) {
    transformFillStroke = attr.transformFillStroke;
  }
  if (!transformFillStroke) {
    attr.inverseMatrix.toContext(ctx);
  }
  if (fillStyle && fillOpacity !== 0) {
    ctx.fill();
  }
  if (strokeStyle && strokeOpacity !== 0) {
    ctx.stroke();
  }
}, appendPath:function(path) {
  this.path = path.clone();
}, setLineDash:function(lineDash) {
  this.lineDash = lineDash;
}, getLineDash:function() {
  return this.lineDash;
}, createLinearGradient:function(x0, y0, x1, y1) {
  var me = this, element = me.surface.getNextDef('linearGradient'), gradient;
  me.surface.setElementAttributes(element, {'x1':x0, 'y1':y0, 'x2':x1, 'y2':y1, 'gradientUnits':'userSpaceOnUse'});
  gradient = new Ext.draw.engine.SvgContext.Gradient(me, me.surface, element);
  return gradient;
}, createRadialGradient:function(x0, y0, r0, x1, y1, r1) {
  var me = this, element = me.surface.getNextDef('radialGradient'), gradient;
  me.surface.setElementAttributes(element, {'fx':x0, 'fy':y0, 'cx':x1, 'cy':y1, 'r':r1, 'gradientUnits':'userSpaceOnUse'});
  gradient = new Ext.draw.engine.SvgContext.Gradient(me, me.surface, element, r0 / r1);
  return gradient;
}}, 1, 0, 0, 0, 0, 0, [Ext.draw.engine, 'SvgContext'], 0);
Ext.cmd.derive('Ext.draw.engine.SvgContext.Gradient', Ext.Base, {isGradient:true, constructor:function(ctx, surface, element, compression) {
  var me = this;
  me.ctx = ctx;
  me.surface = surface;
  me.element = element;
  me.position = 0;
  me.compression = compression || 0;
}, addColorStop:function(offset, color) {
  var me = this, stop = me.surface.getSvgElement(me.element, 'stop', me.position++), compression = me.compression;
  me.surface.setElementAttributes(stop, {'offset':(((1 - compression) * offset + compression) * 100).toFixed(2) + '%', 'stop-color':color, 'stop-opacity':Ext.util.Color.fly(color).a.toFixed(15)});
}, toString:function() {
  var children = this.element.dom.childNodes;
  while (children.length > this.position) {
    Ext.fly(children[children.length - 1]).destroy();
  }
  return 'url(#' + this.element.getId() + ')';
}}, 3, 0, 0, 0, 0, 0, [Ext.draw.engine.SvgContext, 'Gradient'], 0);
Ext.cmd.derive('Ext.draw.engine.Svg', Ext.draw.Surface, {isSVG:true, config:{highPrecision:false}, getElementConfig:function() {
  return {reference:'element', style:{position:'absolute'}, children:[{reference:'innerElement', style:{width:'100%', height:'100%', position:'relative'}, children:[{tag:'svg', reference:'svgElement', namespace:'http://www.w3.org/2000/svg', width:'100%', height:'100%', version:1.1}]}]};
}, constructor:function(config) {
  var me = this;
  Ext.draw.Surface.prototype.constructor.call(this, config);
  me.mainGroup = me.createSvgNode('g');
  me.defsElement = me.createSvgNode('defs');
  me.svgElement.appendChild(me.mainGroup);
  me.svgElement.appendChild(me.defsElement);
  me.ctx = new Ext.draw.engine.SvgContext(me);
}, createSvgNode:function(type) {
  var node = document.createElementNS('http://www.w3.org/2000/svg', type);
  return Ext.get(node);
}, getSvgElement:function(group, tag, position) {
  var childNodes = group.dom.childNodes, length = childNodes.length, element;
  if (position < length) {
    element = childNodes[position];
    if (element.tagName === tag) {
      return Ext.get(element);
    } else {
      Ext.destroy(element);
    }
  } else {
    if (position > length) {
      Ext.raise('Invalid position.');
    }
  }
  element = Ext.get(this.createSvgNode(tag));
  if (position === 0) {
    group.insertFirst(element);
  } else {
    element.insertAfter(Ext.fly(childNodes[position - 1]));
  }
  element.cache = {};
  return element;
}, setElementAttributes:function(element, attributes) {
  var dom = element.dom, cache = element.cache, name, value;
  for (name in attributes) {
    value = attributes[name];
    if (cache[name] !== value) {
      cache[name] = value;
      dom.setAttribute(name, value);
    }
  }
}, getNextDef:function(tagName) {
  return this.getSvgElement(this.defsElement, tagName, this.defsPosition++);
}, clearTransform:function() {
  var me = this;
  me.mainGroup.set({transform:me.matrix.toSvg()});
}, clear:function() {
  this.ctx.clear();
  this.removeSurplusDefs();
  this.defsPosition = 0;
}, removeSurplusDefs:function() {
  var defsElement = this.defsElement, defs = defsElement.dom.childNodes, ln = defs.length, i;
  for (i = ln - 1; i > this.defsPosition; i--) {
    defsElement.removeChild(defs[i]);
  }
}, renderSprite:function(sprite) {
  var me = this, rect = me.getRect(), ctx = me.ctx;
  if (sprite.attr.hidden || sprite.attr.globalAlpha === 0) {
    ctx.save();
    ctx.restore();
    return;
  }
  sprite.element = ctx.save();
  sprite.preRender(this);
  sprite.useAttributes(ctx, rect);
  if (false === sprite.render(this, ctx, [0, 0, rect[2], rect[3]])) {
    return false;
  }
  sprite.setDirty(false);
  ctx.restore();
}, toSVG:function(size, surfaces) {
  var className = Ext.getClassName(this), svg, surface, rect, i;
  svg = '\x3csvg version\x3d"1.1" baseProfile\x3d"full" xmlns\x3d"http://www.w3.org/2000/svg" width\x3d"' + size.width + '" height\x3d"' + size.height + '"\x3e';
  for (i = 0; i < surfaces.length; i++) {
    surface = surfaces[i];
    if (Ext.getClassName(surface) !== className) {
      continue;
    }
    rect = surface.getRect();
    svg += '\x3cg transform\x3d"translate(' + rect[0] + ',' + rect[1] + ')"\x3e';
    svg += this.serializeNode(surface.svgElement.dom);
    svg += '\x3c/g\x3e';
  }
  svg += '\x3c/svg\x3e';
  return svg;
}, flatten:function(size, surfaces) {
  var svg = '\x3c?xml version\x3d"1.0" standalone\x3d"yes"?\x3e';
  svg += this.toSVG(size, surfaces);
  return {data:'data:image/svg+xml;utf8,' + encodeURIComponent(svg), type:'svg'};
}, serializeNode:function(node) {
  var result = '', i, n, attr, child;
  if (node.nodeType === document.TEXT_NODE) {
    return node.nodeValue;
  }
  result += '\x3c' + node.nodeName;
  if (node.attributes.length) {
    for (i = 0, n = node.attributes.length; i < n; i++) {
      attr = node.attributes[i];
      result += ' ' + attr.name + '\x3d"' + attr.value + '"';
    }
  }
  result += '\x3e';
  if (node.childNodes && node.childNodes.length) {
    for (i = 0, n = node.childNodes.length; i < n; i++) {
      child = node.childNodes[i];
      result += this.serializeNode(child);
    }
  }
  result += '\x3c/' + node.nodeName + '\x3e';
  return result;
}, destroy:function() {
  var me = this;
  me.ctx.destroy();
  me.mainGroup.destroy();
  me.defsElement.destroy();
  delete me.mainGroup;
  delete me.defsElement;
  delete me.ctx;
  Ext.draw.Surface.prototype.destroy.call(this);
}, remove:function(sprite, destroySprite) {
  if (sprite && sprite.element) {
    sprite.element.destroy();
    sprite.element = null;
  }
  Ext.draw.Surface.prototype.remove.apply(this, arguments);
}}, 1, 0, ['widget', 'surface'], {'widget':true, 'surface':true}, 0, 0, [Ext.draw.engine, 'Svg'], 0);
Ext.draw || (Ext.draw = {});
Ext.draw.engine || (Ext.draw.engine = {});
Ext.draw.engine.excanvas = true;
if (!document.createElement('canvas').getContext) {
  (function() {
    var m = Math;
    var mr = m.round;
    var ms = m.sin;
    var mc = m.cos;
    var abs = m.abs;
    var sqrt = m.sqrt;
    var Z = 10;
    var Z2 = Z / 2;
    var IE_VERSION = +navigator.userAgent.match(/MSIE ([\d.]+)?/)[1];
    function getContext() {
      return this.context_ || (this.context_ = new CanvasRenderingContext2D_(this));
    }
    var slice = Array.prototype.slice;
    function bind(f, obj, var_args) {
      var a = slice.call(arguments, 2);
      return function() {
        return f.apply(obj, a.concat(slice.call(arguments)));
      };
    }
    function encodeHtmlAttribute(s) {
      return String(s).replace(/&/g, '\x26amp;').replace(/"/g, '\x26quot;');
    }
    function addNamespace(doc, prefix, urn) {
      Ext.onReady(function() {
        if (!doc.namespaces[prefix]) {
          doc.namespaces.add(prefix, urn, '#default#VML');
        }
      });
    }
    function addNamespacesAndStylesheet(doc) {
      addNamespace(doc, 'g_vml_', 'urn:schemas-microsoft-com:vml');
      addNamespace(doc, 'g_o_', 'urn:schemas-microsoft-com:office:office');
      if (!doc.styleSheets['ex_canvas_']) {
        var ss = doc.createStyleSheet();
        ss.owningElement.id = 'ex_canvas_';
        ss.cssText = 'canvas{display:inline-block;overflow:hidden;text-align:left;width:300px;height:150px}';
      }
    }
    addNamespacesAndStylesheet(document);
    var G_vmlCanvasManager_ = {init:function(opt_doc) {
      var doc = opt_doc || document;
      doc.createElement('canvas');
      doc.attachEvent('onreadystatechange', bind(this.init_, this, doc));
    }, init_:function(doc) {
      var els = doc.getElementsByTagName('canvas');
      for (var i = 0; i < els.length; i++) {
        this.initElement(els[i]);
      }
    }, initElement:function(el) {
      if (!el.getContext) {
        el.getContext = getContext;
        addNamespacesAndStylesheet(el.ownerDocument);
        el.innerHTML = '';
        el.attachEvent('onpropertychange', onPropertyChange);
        el.attachEvent('onresize', onResize);
        var attrs = el.attributes;
        if (attrs.width && attrs.width.specified) {
          el.style.width = attrs.width.nodeValue + 'px';
        } else {
          el.width = el.clientWidth;
        }
        if (attrs.height && attrs.height.specified) {
          el.style.height = attrs.height.nodeValue + 'px';
        } else {
          el.height = el.clientHeight;
        }
      }
      return el;
    }};
    function onPropertyChange(e) {
      var el = e.srcElement;
      switch(e.propertyName) {
        case 'width':
          el.getContext().clearRect();
          el.style.width = el.attributes.width.nodeValue + 'px';
          el.firstChild.style.width = el.clientWidth + 'px';
          break;
        case 'height':
          el.getContext().clearRect();
          el.style.height = el.attributes.height.nodeValue + 'px';
          el.firstChild.style.height = el.clientHeight + 'px';
          break;
      }
    }
    function onResize(e) {
      var el = e.srcElement;
      if (el.firstChild) {
        el.firstChild.style.width = el.clientWidth + 'px';
        el.firstChild.style.height = el.clientHeight + 'px';
      }
    }
    G_vmlCanvasManager_.init();
    var decToHex = [];
    for (var i = 0; i < 16; i++) {
      for (var j = 0; j < 16; j++) {
        decToHex[i * 16 + j] = i.toString(16) + j.toString(16);
      }
    }
    function createMatrixIdentity() {
      return [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
    }
    function matrixMultiply(m1, m2) {
      var result = createMatrixIdentity();
      for (var x = 0; x < 3; x++) {
        for (var y = 0; y < 3; y++) {
          var sum = 0;
          for (var z = 0; z < 3; z++) {
            sum += m1[x][z] * m2[z][y];
          }
          result[x][y] = sum;
        }
      }
      return result;
    }
    function copyState(o1, o2) {
      o2.fillStyle = o1.fillStyle;
      o2.lineCap = o1.lineCap;
      o2.lineJoin = o1.lineJoin;
      o2.lineDash = o1.lineDash;
      o2.lineWidth = o1.lineWidth;
      o2.miterLimit = o1.miterLimit;
      o2.shadowBlur = o1.shadowBlur;
      o2.shadowColor = o1.shadowColor;
      o2.shadowOffsetX = o1.shadowOffsetX;
      o2.shadowOffsetY = o1.shadowOffsetY;
      o2.strokeStyle = o1.strokeStyle;
      o2.globalAlpha = o1.globalAlpha;
      o2.font = o1.font;
      o2.textAlign = o1.textAlign;
      o2.textBaseline = o1.textBaseline;
      o2.arcScaleX_ = o1.arcScaleX_;
      o2.arcScaleY_ = o1.arcScaleY_;
      o2.lineScale_ = o1.lineScale_;
    }
    var colorData = {aliceblue:'#F0F8FF', antiquewhite:'#FAEBD7', aquamarine:'#7FFFD4', azure:'#F0FFFF', beige:'#F5F5DC', bisque:'#FFE4C4', black:'#000000', blanchedalmond:'#FFEBCD', blueviolet:'#8A2BE2', brown:'#A52A2A', burlywood:'#DEB887', cadetblue:'#5F9EA0', chartreuse:'#7FFF00', chocolate:'#D2691E', coral:'#FF7F50', cornflowerblue:'#6495ED', cornsilk:'#FFF8DC', crimson:'#DC143C', cyan:'#00FFFF', darkblue:'#00008B', darkcyan:'#008B8B', darkgoldenrod:'#B8860B', darkgray:'#A9A9A9', darkgreen:'#006400', 
    darkgrey:'#A9A9A9', darkkhaki:'#BDB76B', darkmagenta:'#8B008B', darkolivegreen:'#556B2F', darkorange:'#FF8C00', darkorchid:'#9932CC', darkred:'#8B0000', darksalmon:'#E9967A', darkseagreen:'#8FBC8F', darkslateblue:'#483D8B', darkslategray:'#2F4F4F', darkslategrey:'#2F4F4F', darkturquoise:'#00CED1', darkviolet:'#9400D3', deeppink:'#FF1493', deepskyblue:'#00BFFF', dimgray:'#696969', dimgrey:'#696969', dodgerblue:'#1E90FF', firebrick:'#B22222', floralwhite:'#FFFAF0', forestgreen:'#228B22', gainsboro:'#DCDCDC', 
    ghostwhite:'#F8F8FF', gold:'#FFD700', goldenrod:'#DAA520', grey:'#808080', greenyellow:'#ADFF2F', honeydew:'#F0FFF0', hotpink:'#FF69B4', indianred:'#CD5C5C', indigo:'#4B0082', ivory:'#FFFFF0', khaki:'#F0E68C', lavender:'#E6E6FA', lavenderblush:'#FFF0F5', lawngreen:'#7CFC00', lemonchiffon:'#FFFACD', lightblue:'#ADD8E6', lightcoral:'#F08080', lightcyan:'#E0FFFF', lightgoldenrodyellow:'#FAFAD2', lightgreen:'#90EE90', lightgrey:'#D3D3D3', lightpink:'#FFB6C1', lightsalmon:'#FFA07A', lightseagreen:'#20B2AA', 
    lightskyblue:'#87CEFA', lightslategray:'#778899', lightslategrey:'#778899', lightsteelblue:'#B0C4DE', lightyellow:'#FFFFE0', limegreen:'#32CD32', linen:'#FAF0E6', magenta:'#FF00FF', mediumaquamarine:'#66CDAA', mediumblue:'#0000CD', mediumorchid:'#BA55D3', mediumpurple:'#9370DB', mediumseagreen:'#3CB371', mediumslateblue:'#7B68EE', mediumspringgreen:'#00FA9A', mediumturquoise:'#48D1CC', mediumvioletred:'#C71585', midnightblue:'#191970', mintcream:'#F5FFFA', mistyrose:'#FFE4E1', moccasin:'#FFE4B5', 
    navajowhite:'#FFDEAD', oldlace:'#FDF5E6', olivedrab:'#6B8E23', orange:'#FFA500', orangered:'#FF4500', orchid:'#DA70D6', palegoldenrod:'#EEE8AA', palegreen:'#98FB98', paleturquoise:'#AFEEEE', palevioletred:'#DB7093', papayawhip:'#FFEFD5', peachpuff:'#FFDAB9', peru:'#CD853F', pink:'#FFC0CB', plum:'#DDA0DD', powderblue:'#B0E0E6', rosybrown:'#BC8F8F', royalblue:'#4169E1', saddlebrown:'#8B4513', salmon:'#FA8072', sandybrown:'#F4A460', seagreen:'#2E8B57', seashell:'#FFF5EE', sienna:'#A0522D', skyblue:'#87CEEB', 
    slateblue:'#6A5ACD', slategray:'#708090', slategrey:'#708090', snow:'#FFFAFA', springgreen:'#00FF7F', steelblue:'#4682B4', tan:'#D2B48C', thistle:'#D8BFD8', tomato:'#FF6347', turquoise:'#40E0D0', violet:'#EE82EE', wheat:'#F5DEB3', whitesmoke:'#F5F5F5', yellowgreen:'#9ACD32'};
    function getRgbHslContent(styleString) {
      var start = styleString.indexOf('(', 3);
      var end = styleString.indexOf(')', start + 1);
      var parts = styleString.substring(start + 1, end).split(',');
      if (parts.length != 4 || styleString.charAt(3) != 'a') {
        parts[3] = 1;
      }
      return parts;
    }
    function percent(s) {
      return parseFloat(s) / 100;
    }
    function clamp(v, min, max) {
      return Math.min(max, Math.max(min, v));
    }
    function hslToRgb(parts) {
      var r, g, b, h, s, l;
      h = parseFloat(parts[0]) / 360 % 360;
      if (h < 0) {
        h++;
      }
      s = clamp(percent(parts[1]), 0, 1);
      l = clamp(percent(parts[2]), 0, 1);
      if (s == 0) {
        r = g = b = l;
      } else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hueToRgb(p, q, h + 1 / 3);
        g = hueToRgb(p, q, h);
        b = hueToRgb(p, q, h - 1 / 3);
      }
      return '#' + decToHex[Math.floor(r * 255)] + decToHex[Math.floor(g * 255)] + decToHex[Math.floor(b * 255)];
    }
    function hueToRgb(m1, m2, h) {
      if (h < 0) {
        h++;
      }
      if (h > 1) {
        h--;
      }
      if (6 * h < 1) {
        return m1 + (m2 - m1) * 6 * h;
      } else {
        if (2 * h < 1) {
          return m2;
        } else {
          if (3 * h < 2) {
            return m1 + (m2 - m1) * (2 / 3 - h) * 6;
          } else {
            return m1;
          }
        }
      }
    }
    var processStyleCache = {};
    function processStyle(styleString) {
      if (styleString in processStyleCache) {
        return processStyleCache[styleString];
      }
      var str, alpha = 1;
      styleString = String(styleString);
      if (styleString.charAt(0) == '#') {
        str = styleString;
      } else {
        if (/^rgb/.test(styleString)) {
          var parts = getRgbHslContent(styleString);
          var str = '#', n;
          for (var i = 0; i < 3; i++) {
            if (parts[i].indexOf('%') != -1) {
              n = Math.floor(percent(parts[i]) * 255);
            } else {
              n = +parts[i];
            }
            str += decToHex[clamp(n, 0, 255)];
          }
          alpha = +parts[3];
        } else {
          if (/^hsl/.test(styleString)) {
            var parts = getRgbHslContent(styleString);
            str = hslToRgb(parts);
            alpha = parts[3];
          } else {
            str = colorData[styleString] || styleString;
          }
        }
      }
      return processStyleCache[styleString] = {color:str, alpha:alpha};
    }
    var DEFAULT_STYLE = {style:'normal', variant:'normal', weight:'normal', size:10, family:'sans-serif'};
    var fontStyleCache = {};
    function processFontStyle(styleString) {
      if (fontStyleCache[styleString]) {
        return fontStyleCache[styleString];
      }
      var el = document.createElement('div');
      var style = el.style;
      try {
        style.font = styleString;
      } catch (ex) {
      }
      return fontStyleCache[styleString] = {style:style.fontStyle || DEFAULT_STYLE.style, variant:style.fontVariant || DEFAULT_STYLE.variant, weight:style.fontWeight || DEFAULT_STYLE.weight, size:style.fontSize || DEFAULT_STYLE.size, family:style.fontFamily || DEFAULT_STYLE.family};
    }
    function getComputedStyle(style, element) {
      var computedStyle = {};
      for (var p in style) {
        computedStyle[p] = style[p];
      }
      var canvasFontSize = parseFloat(element.currentStyle.fontSize), fontSize = parseFloat(style.size);
      if (typeof style.size == 'number') {
        computedStyle.size = style.size;
      } else {
        if (style.size.indexOf('px') != -1) {
          computedStyle.size = fontSize;
        } else {
          if (style.size.indexOf('em') != -1) {
            computedStyle.size = canvasFontSize * fontSize;
          } else {
            if (style.size.indexOf('%') != -1) {
              computedStyle.size = canvasFontSize / 100 * fontSize;
            } else {
              if (style.size.indexOf('pt') != -1) {
                computedStyle.size = fontSize / 0.75;
              } else {
                computedStyle.size = canvasFontSize;
              }
            }
          }
        }
      }
      computedStyle.size *= 0.981;
      return computedStyle;
    }
    function buildStyle(style) {
      return style.style + ' ' + style.variant + ' ' + style.weight + ' ' + style.size + 'px ' + style.family;
    }
    var lineCapMap = {'butt':'flat', 'round':'round'};
    function processLineCap(lineCap) {
      return lineCapMap[lineCap] || 'square';
    }
    function CanvasRenderingContext2D_(canvasElement) {
      this.m_ = createMatrixIdentity();
      this.mStack_ = [];
      this.aStack_ = [];
      this.currentPath_ = [];
      this.strokeStyle = '#000';
      this.fillStyle = '#000';
      this.lineWidth = 1;
      this.lineJoin = 'miter';
      this.lineDash = [];
      this.lineCap = 'butt';
      this.miterLimit = Z * 1;
      this.globalAlpha = 1;
      this.font = '10px sans-serif';
      this.textAlign = 'left';
      this.textBaseline = 'alphabetic';
      this.canvas = canvasElement;
      var cssText = 'width:' + canvasElement.clientWidth + 'px;height:' + canvasElement.clientHeight + 'px;overflow:hidden;position:absolute';
      var el = canvasElement.ownerDocument.createElement('div');
      el.style.cssText = cssText;
      canvasElement.appendChild(el);
      var overlayEl = el.cloneNode(false);
      overlayEl.style.backgroundColor = 'red';
      overlayEl.style.filter = 'alpha(opacity\x3d0)';
      canvasElement.appendChild(overlayEl);
      this.element_ = el;
      this.arcScaleX_ = 1;
      this.arcScaleY_ = 1;
      this.lineScale_ = 1;
    }
    var contextPrototype = CanvasRenderingContext2D_.prototype;
    contextPrototype.clearRect = function() {
      if (this.textMeasureEl_) {
        this.textMeasureEl_.removeNode(true);
        this.textMeasureEl_ = null;
      }
      this.element_.innerHTML = '';
    };
    contextPrototype.beginPath = function() {
      this.currentPath_ = [];
    };
    contextPrototype.moveTo = function(aX, aY) {
      var p = getCoords(this, aX, aY);
      this.currentPath_.push({type:'moveTo', x:p.x, y:p.y});
      this.currentX_ = p.x;
      this.currentY_ = p.y;
    };
    contextPrototype.lineTo = function(aX, aY) {
      var p = getCoords(this, aX, aY);
      this.currentPath_.push({type:'lineTo', x:p.x, y:p.y});
      this.currentX_ = p.x;
      this.currentY_ = p.y;
    };
    contextPrototype.bezierCurveTo = function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
      var p = getCoords(this, aX, aY);
      var cp1 = getCoords(this, aCP1x, aCP1y);
      var cp2 = getCoords(this, aCP2x, aCP2y);
      bezierCurveTo(this, cp1, cp2, p);
    };
    function bezierCurveTo(self, cp1, cp2, p) {
      self.currentPath_.push({type:'bezierCurveTo', cp1x:cp1.x, cp1y:cp1.y, cp2x:cp2.x, cp2y:cp2.y, x:p.x, y:p.y});
      self.currentX_ = p.x;
      self.currentY_ = p.y;
    }
    contextPrototype.quadraticCurveTo = function(aCPx, aCPy, aX, aY) {
      var cp = getCoords(this, aCPx, aCPy);
      var p = getCoords(this, aX, aY);
      var cp1 = {x:this.currentX_ + 2 / 3 * (cp.x - this.currentX_), y:this.currentY_ + 2 / 3 * (cp.y - this.currentY_)};
      var cp2 = {x:cp1.x + (p.x - this.currentX_) / 3, y:cp1.y + (p.y - this.currentY_) / 3};
      bezierCurveTo(this, cp1, cp2, p);
    };
    contextPrototype.arc = function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
      aRadius *= Z;
      var arcType = aClockwise ? 'at' : 'wa';
      var xStart = aX + mc(aStartAngle) * aRadius - Z2;
      var yStart = aY + ms(aStartAngle) * aRadius - Z2;
      var xEnd = aX + mc(aEndAngle) * aRadius - Z2;
      var yEnd = aY + ms(aEndAngle) * aRadius - Z2;
      if (xStart == xEnd && !aClockwise) {
        xStart += 0.125;
      }
      var p = getCoords(this, aX, aY);
      var pStart = getCoords(this, xStart, yStart);
      var pEnd = getCoords(this, xEnd, yEnd);
      this.currentPath_.push({type:arcType, x:p.x, y:p.y, radius:aRadius, xStart:pStart.x, yStart:pStart.y, xEnd:pEnd.x, yEnd:pEnd.y});
    };
    contextPrototype.rect = function(aX, aY, aWidth, aHeight) {
      this.moveTo(aX, aY);
      this.lineTo(aX + aWidth, aY);
      this.lineTo(aX + aWidth, aY + aHeight);
      this.lineTo(aX, aY + aHeight);
      this.closePath();
    };
    contextPrototype.strokeRect = function(aX, aY, aWidth, aHeight) {
      var oldPath = this.currentPath_;
      this.beginPath();
      this.moveTo(aX, aY);
      this.lineTo(aX + aWidth, aY);
      this.lineTo(aX + aWidth, aY + aHeight);
      this.lineTo(aX, aY + aHeight);
      this.closePath();
      this.stroke();
      this.currentPath_ = oldPath;
    };
    contextPrototype.fillRect = function(aX, aY, aWidth, aHeight) {
      var oldPath = this.currentPath_;
      this.beginPath();
      this.moveTo(aX, aY);
      this.lineTo(aX + aWidth, aY);
      this.lineTo(aX + aWidth, aY + aHeight);
      this.lineTo(aX, aY + aHeight);
      this.closePath();
      this.fill();
      this.currentPath_ = oldPath;
    };
    contextPrototype.createLinearGradient = function(aX0, aY0, aX1, aY1) {
      var gradient = new CanvasGradient_('gradient');
      gradient.x0_ = aX0;
      gradient.y0_ = aY0;
      gradient.x1_ = aX1;
      gradient.y1_ = aY1;
      return gradient;
    };
    contextPrototype.createRadialGradient = function(aX0, aY0, aR0, aX1, aY1, aR1) {
      var gradient = new CanvasGradient_('gradientradial');
      gradient.x0_ = aX0;
      gradient.y0_ = aY0;
      gradient.r0_ = aR0;
      gradient.x1_ = aX1;
      gradient.y1_ = aY1;
      gradient.r1_ = aR1;
      return gradient;
    };
    contextPrototype.drawImage = function(image, var_args) {
      var dx, dy, dw, dh, sx, sy, sw, sh;
      var oldRuntimeWidth = image.runtimeStyle.width;
      var oldRuntimeHeight = image.runtimeStyle.height;
      image.runtimeStyle.width = 'auto';
      image.runtimeStyle.height = 'auto';
      var w = image.width;
      var h = image.height;
      image.runtimeStyle.width = oldRuntimeWidth;
      image.runtimeStyle.height = oldRuntimeHeight;
      if (arguments.length == 3) {
        dx = arguments[1];
        dy = arguments[2];
        sx = sy = 0;
        sw = dw = w;
        sh = dh = h;
      } else {
        if (arguments.length == 5) {
          dx = arguments[1];
          dy = arguments[2];
          dw = arguments[3];
          dh = arguments[4];
          sx = sy = 0;
          sw = w;
          sh = h;
        } else {
          if (arguments.length == 9) {
            sx = arguments[1];
            sy = arguments[2];
            sw = arguments[3];
            sh = arguments[4];
            dx = arguments[5];
            dy = arguments[6];
            dw = arguments[7];
            dh = arguments[8];
          } else {
            throw Error('Invalid number of arguments');
          }
        }
      }
      var d = getCoords(this, dx, dy);
      var vmlStr = [];
      var W = 10;
      var H = 10;
      var m = this.m_;
      vmlStr.push(' \x3cg_vml_:group', ' coordsize\x3d"', Z * W, ',', Z * H, '"', ' coordorigin\x3d"0,0"', ' style\x3d"width:', mr(W * m[0][0]), 'px;height:', mr(H * m[1][1]), 'px;position:absolute;', 'top:', mr(d.y / Z), 'px;left:', mr(d.x / Z), 'px; rotation:', mr(Math.atan(m[0][1] / m[1][1]) * 180 / Math.PI), ';');
      vmlStr.push('" \x3e', '\x3cg_vml_:image src\x3d"', image.src, '"', ' style\x3d"width:', Z * dw, 'px;', ' height:', Z * dh, 'px"', ' cropleft\x3d"', sx / w, '"', ' croptop\x3d"', sy / h, '"', ' cropright\x3d"', (w - sx - sw) / w, '"', ' cropbottom\x3d"', (h - sy - sh) / h, '"', ' /\x3e', '\x3c/g_vml_:group\x3e');
      this.element_.insertAdjacentHTML('BeforeEnd', vmlStr.join(''));
    };
    contextPrototype.setLineDash = function(lineDash) {
      if (lineDash.length === 1) {
        lineDash = lineDash.slice();
        lineDash[1] = lineDash[0];
      }
      this.lineDash = lineDash;
    };
    contextPrototype.getLineDash = function() {
      return this.lineDash;
    };
    contextPrototype.stroke = function(aFill) {
      var lineStr = [];
      var W = 10;
      var H = 10;
      lineStr.push('\x3cg_vml_:shape', ' filled\x3d"', !!aFill, '"', ' style\x3d"position:absolute;width:', W, 'px;height:', H, 'px;left:0px;top:0px;"', ' coordorigin\x3d"0,0"', ' coordsize\x3d"', Z * W, ',', Z * H, '"', ' stroked\x3d"', !aFill, '"', ' path\x3d"');
      var min = {x:null, y:null};
      var max = {x:null, y:null};
      for (var i = 0; i < this.currentPath_.length; i++) {
        var p = this.currentPath_[i];
        var c;
        switch(p.type) {
          case 'moveTo':
            c = p;
            lineStr.push(' m ', mr(p.x), ',', mr(p.y));
            break;
          case 'lineTo':
            lineStr.push(' l ', mr(p.x), ',', mr(p.y));
            break;
          case 'close':
            lineStr.push(' x ');
            p = null;
            break;
          case 'bezierCurveTo':
            lineStr.push(' c ', mr(p.cp1x), ',', mr(p.cp1y), ',', mr(p.cp2x), ',', mr(p.cp2y), ',', mr(p.x), ',', mr(p.y));
            break;
          case 'at':
          case 'wa':
            lineStr.push(' ', p.type, ' ', mr(p.x - this.arcScaleX_ * p.radius), ',', mr(p.y - this.arcScaleY_ * p.radius), ' ', mr(p.x + this.arcScaleX_ * p.radius), ',', mr(p.y + this.arcScaleY_ * p.radius), ' ', mr(p.xStart), ',', mr(p.yStart), ' ', mr(p.xEnd), ',', mr(p.yEnd));
            break;
        }
        if (p) {
          if (min.x == null || p.x < min.x) {
            min.x = p.x;
          }
          if (max.x == null || p.x > max.x) {
            max.x = p.x;
          }
          if (min.y == null || p.y < min.y) {
            min.y = p.y;
          }
          if (max.y == null || p.y > max.y) {
            max.y = p.y;
          }
        }
      }
      lineStr.push(' "\x3e');
      if (!aFill) {
        appendStroke(this, lineStr);
      } else {
        appendFill(this, lineStr, min, max);
      }
      lineStr.push('\x3c/g_vml_:shape\x3e');
      this.element_.insertAdjacentHTML('beforeEnd', lineStr.join(''));
    };
    function appendStroke(ctx, lineStr) {
      var a = processStyle(ctx.strokeStyle);
      var color = a.color;
      var opacity = a.alpha * ctx.globalAlpha;
      var lineWidth = ctx.lineScale_ * ctx.lineWidth;
      if (lineWidth < 1) {
        opacity *= lineWidth;
      }
      lineStr.push('\x3cg_vml_:stroke', ' opacity\x3d"', opacity, '"', ' joinstyle\x3d"', ctx.lineJoin, '"', ' dashstyle\x3d"', ctx.lineDash.join(' '), '"', ' miterlimit\x3d"', ctx.miterLimit, '"', ' endcap\x3d"', processLineCap(ctx.lineCap), '"', ' weight\x3d"', lineWidth, 'px"', ' color\x3d"', color, '" /\x3e');
    }
    function appendFill(ctx, lineStr, min, max) {
      var fillStyle = ctx.fillStyle;
      var arcScaleX = ctx.arcScaleX_;
      var arcScaleY = ctx.arcScaleY_;
      var width = max.x - min.x;
      var height = max.y - min.y;
      if (fillStyle instanceof CanvasGradient_) {
        var angle = 0;
        var focus = {x:0, y:0};
        var shift = 0;
        var expansion = 1;
        if (fillStyle.type_ == 'gradient') {
          var x0 = fillStyle.x0_ / arcScaleX;
          var y0 = fillStyle.y0_ / arcScaleY;
          var x1 = fillStyle.x1_ / arcScaleX;
          var y1 = fillStyle.y1_ / arcScaleY;
          var p0 = getCoords(ctx, x0, y0);
          var p1 = getCoords(ctx, x1, y1);
          var dx = p1.x - p0.x;
          var dy = p1.y - p0.y;
          angle = Math.atan2(dx, dy) * 180 / Math.PI;
          if (angle < 0) {
            angle += 360;
          }
          if (angle < 1.0E-6) {
            angle = 0;
          }
        } else {
          var p0 = getCoords(ctx, fillStyle.x0_, fillStyle.y0_);
          focus = {x:(p0.x - min.x) / width, y:(p0.y - min.y) / height};
          width /= arcScaleX * Z;
          height /= arcScaleY * Z;
          var dimension = m.max(width, height);
          shift = 2 * fillStyle.r0_ / dimension;
          expansion = 2 * fillStyle.r1_ / dimension - shift;
        }
        var stops = fillStyle.colors_;
        stops.sort(function(cs1, cs2) {
          return cs1.offset - cs2.offset;
        });
        var length = stops.length;
        var color1 = stops[0].color;
        var color2 = stops[length - 1].color;
        var opacity1 = stops[0].alpha * ctx.globalAlpha;
        var opacity2 = stops[length - 1].alpha * ctx.globalAlpha;
        var colors = [];
        for (var i = 0; i < length; i++) {
          var stop = stops[i];
          colors.push(stop.offset * expansion + shift + ' ' + stop.color);
        }
        lineStr.push('\x3cg_vml_:fill type\x3d"', fillStyle.type_, '"', ' method\x3d"none" focus\x3d"100%"', ' color\x3d"', color1, '"', ' color2\x3d"', color2, '"', ' colors\x3d"', colors.join(','), '"', ' opacity\x3d"', opacity2, '"', ' g_o_:opacity2\x3d"', opacity1, '"', ' angle\x3d"', angle, '"', ' focusposition\x3d"', focus.x, ',', focus.y, '" /\x3e');
      } else {
        if (fillStyle instanceof CanvasPattern_) {
          if (width && height) {
            var deltaLeft = -min.x;
            var deltaTop = -min.y;
            lineStr.push('\x3cg_vml_:fill', ' position\x3d"', deltaLeft / width * arcScaleX * arcScaleX, ',', deltaTop / height * arcScaleY * arcScaleY, '"', ' type\x3d"tile"', ' src\x3d"', fillStyle.src_, '" /\x3e');
          }
        } else {
          var a = processStyle(ctx.fillStyle);
          var color = a.color;
          var opacity = a.alpha * ctx.globalAlpha;
          lineStr.push('\x3cg_vml_:fill color\x3d"', color, '" opacity\x3d"', opacity, '" /\x3e');
        }
      }
    }
    contextPrototype.fill = function() {
      this.$stroke(true);
    };
    contextPrototype.closePath = function() {
      this.currentPath_.push({type:'close'});
    };
    function getCoords(ctx, aX, aY) {
      var m = ctx.m_;
      return {x:Z * (aX * m[0][0] + aY * m[1][0] + m[2][0]) - Z2, y:Z * (aX * m[0][1] + aY * m[1][1] + m[2][1]) - Z2};
    }
    contextPrototype.save = function() {
      var o = {};
      copyState(this, o);
      this.aStack_.push(o);
      this.mStack_.push(this.m_);
    };
    contextPrototype.restore = function() {
      if (this.aStack_.length) {
        copyState(this.aStack_.pop(), this);
        this.m_ = this.mStack_.pop();
      }
    };
    function matrixIsFinite(m) {
      return isFinite(m[0][0]) && isFinite(m[0][1]) && isFinite(m[1][0]) && isFinite(m[1][1]) && isFinite(m[2][0]) && isFinite(m[2][1]);
    }
    function setM(ctx, m, updateLineScale) {
      if (!matrixIsFinite(m)) {
        return;
      }
      ctx.m_ = m;
      if (updateLineScale) {
        var det = m[0][0] * m[1][1] - m[0][1] * m[1][0];
        ctx.lineScale_ = sqrt(abs(det));
      }
    }
    contextPrototype.translate = function(aX, aY) {
      var m1 = [[1, 0, 0], [0, 1, 0], [aX, aY, 1]];
      setM(this, matrixMultiply(m1, this.m_), false);
    };
    contextPrototype.rotate = function(aRot) {
      var c = mc(aRot);
      var s = ms(aRot);
      var m1 = [[c, s, 0], [-s, c, 0], [0, 0, 1]];
      setM(this, matrixMultiply(m1, this.m_), false);
    };
    contextPrototype.scale = function(aX, aY) {
      this.arcScaleX_ *= aX;
      this.arcScaleY_ *= aY;
      var m1 = [[aX, 0, 0], [0, aY, 0], [0, 0, 1]];
      setM(this, matrixMultiply(m1, this.m_), true);
    };
    contextPrototype.transform = function(m11, m12, m21, m22, dx, dy) {
      var m1 = [[m11, m12, 0], [m21, m22, 0], [dx, dy, 1]];
      setM(this, matrixMultiply(m1, this.m_), true);
    };
    contextPrototype.setTransform = function(m11, m12, m21, m22, dx, dy) {
      var m = [[m11, m12, 0], [m21, m22, 0], [dx, dy, 1]];
      setM(this, m, true);
    };
    contextPrototype.drawText_ = function(text, x, y, maxWidth, stroke) {
      var m = this.m_, delta = 1000, left = 0, right = delta, offset = {x:0, y:0}, lineStr = [];
      var fontStyle = getComputedStyle(processFontStyle(this.font), this.element_);
      var fontStyleString = buildStyle(fontStyle);
      var elementStyle = this.element_.currentStyle;
      var textAlign = this.textAlign.toLowerCase();
      switch(textAlign) {
        case 'left':
        case 'center':
        case 'right':
          break;
        case 'end':
          textAlign = elementStyle.direction == 'ltr' ? 'right' : 'left';
          break;
        case 'start':
          textAlign = elementStyle.direction == 'rtl' ? 'right' : 'left';
          break;
        default:
          textAlign = 'left';
      }
      switch(this.textBaseline) {
        case 'hanging':
        case 'top':
          offset.y = fontStyle.size / 1.75;
          break;
        case 'middle':
          break;
        default:
        case null:
        case 'alphabetic':
        case 'ideographic':
        case 'bottom':
          offset.y = -fontStyle.size / 3;
          break;
      }
      switch(textAlign) {
        case 'right':
          left = delta;
          right = 0.05;
          break;
        case 'center':
          left = right = delta / 2;
          break;
      }
      var d = getCoords(this, x + offset.x, y + offset.y);
      lineStr.push('\x3cg_vml_:line from\x3d"', -left, ' 0" to\x3d"', right, ' 0.05" ', ' coordsize\x3d"100 100" coordorigin\x3d"0 0"', ' filled\x3d"', !stroke, '" stroked\x3d"', !!stroke, '" style\x3d"position:absolute;width:1px;height:1px;left:0px;top:0px;"\x3e');
      if (stroke) {
        appendStroke(this, lineStr);
      } else {
        appendFill(this, lineStr, {x:-left, y:0}, {x:right, y:fontStyle.size});
      }
      var skewM = m[0][0].toFixed(3) + ',' + m[1][0].toFixed(3) + ',' + m[0][1].toFixed(3) + ',' + m[1][1].toFixed(3) + ',0,0';
      var skewOffset = mr(d.x / Z) + ',' + mr(d.y / Z);
      lineStr.push('\x3cg_vml_:skew on\x3d"t" matrix\x3d"', skewM, '" ', ' offset\x3d"', skewOffset, '" origin\x3d"', left, ' 0" /\x3e', '\x3cg_vml_:path textpathok\x3d"true" /\x3e', '\x3cg_vml_:textpath on\x3d"true" string\x3d"', encodeHtmlAttribute(text), '" style\x3d"v-text-align:', textAlign, ';font:', encodeHtmlAttribute(fontStyleString), '" /\x3e\x3c/g_vml_:line\x3e');
      this.element_.insertAdjacentHTML('beforeEnd', lineStr.join(''));
    };
    contextPrototype.fillText = function(text, x, y, maxWidth) {
      this.drawText_(text, x, y, maxWidth, false);
    };
    contextPrototype.strokeText = function(text, x, y, maxWidth) {
      this.drawText_(text, x, y, maxWidth, true);
    };
    contextPrototype.measureText = function(text) {
      if (!this.textMeasureEl_) {
        var s = '\x3cspan style\x3d"position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;"\x3e\x3c/span\x3e';
        this.element_.insertAdjacentHTML('beforeEnd', s);
        this.textMeasureEl_ = this.element_.lastChild;
      }
      var doc = this.element_.ownerDocument;
      this.textMeasureEl_.innerHTML = '';
      this.textMeasureEl_.style.font = this.font;
      this.textMeasureEl_.appendChild(doc.createTextNode(text));
      return {width:this.textMeasureEl_.offsetWidth};
    };
    contextPrototype.clip = function() {
    };
    contextPrototype.arcTo = function() {
    };
    contextPrototype.createPattern = function(image, repetition) {
      return new CanvasPattern_(image, repetition);
    };
    function CanvasGradient_(aType) {
      this.type_ = aType;
      this.x0_ = 0;
      this.y0_ = 0;
      this.r0_ = 0;
      this.x1_ = 0;
      this.y1_ = 0;
      this.r1_ = 0;
      this.colors_ = [];
    }
    CanvasGradient_.prototype.addColorStop = function(aOffset, aColor) {
      aColor = processStyle(aColor);
      this.colors_.push({offset:aOffset, color:aColor.color, alpha:aColor.alpha});
    };
    function CanvasPattern_(image, repetition) {
      assertImageIsValid(image);
      switch(repetition) {
        case 'repeat':
        case null:
        case '':
          this.repetition_ = 'repeat';
          break;
        case 'repeat-x':
        case 'repeat-y':
        case 'no-repeat':
          this.repetition_ = repetition;
          break;
        default:
          throwException('SYNTAX_ERR');
      }
      this.src_ = image.src;
      this.width_ = image.width;
      this.height_ = image.height;
    }
    function throwException(s) {
      throw new DOMException_(s);
    }
    function assertImageIsValid(img) {
      if (!img || img.nodeType != 1 || img.tagName != 'IMG') {
        throwException('TYPE_MISMATCH_ERR');
      }
      if (img.readyState != 'complete') {
        throwException('INVALID_STATE_ERR');
      }
    }
    function DOMException_(s) {
      this.code = this[s];
      this.message = s + ': DOM Exception ' + this.code;
    }
    var p = DOMException_.prototype = new Error;
    p.INDEX_SIZE_ERR = 1;
    p.DOMSTRING_SIZE_ERR = 2;
    p.HIERARCHY_REQUEST_ERR = 3;
    p.WRONG_DOCUMENT_ERR = 4;
    p.INVALID_CHARACTER_ERR = 5;
    p.NO_DATA_ALLOWED_ERR = 6;
    p.NO_MODIFICATION_ALLOWED_ERR = 7;
    p.NOT_FOUND_ERR = 8;
    p.NOT_SUPPORTED_ERR = 9;
    p.INUSE_ATTRIBUTE_ERR = 10;
    p.INVALID_STATE_ERR = 11;
    p.SYNTAX_ERR = 12;
    p.INVALID_MODIFICATION_ERR = 13;
    p.NAMESPACE_ERR = 14;
    p.INVALID_ACCESS_ERR = 15;
    p.VALIDATION_ERR = 16;
    p.TYPE_MISMATCH_ERR = 17;
    G_vmlCanvasManager = G_vmlCanvasManager_;
    CanvasRenderingContext2D = CanvasRenderingContext2D_;
    CanvasGradient = CanvasGradient_;
    CanvasPattern = CanvasPattern_;
    DOMException = DOMException_;
  })();
}
Ext.cmd.derive('Ext.draw.engine.Canvas', Ext.draw.Surface, {isCanvas:true, config:{highPrecision:false}, statics:{contextOverrides:{setGradientBBox:function(bbox) {
  this.bbox = bbox;
}, fill:function() {
  var fillStyle = this.fillStyle, fillGradient = this.fillGradient, fillOpacity = this.fillOpacity, alpha = this.globalAlpha, bbox = this.bbox;
  if (fillStyle !== Ext.util.Color.RGBA_NONE && fillOpacity !== 0) {
    if (fillGradient && bbox) {
      this.fillStyle = fillGradient.generateGradient(this, bbox);
    }
    if (fillOpacity !== 1) {
      this.globalAlpha = alpha * fillOpacity;
    }
    this.$fill();
    if (fillOpacity !== 1) {
      this.globalAlpha = alpha;
    }
    if (fillGradient && bbox) {
      this.fillStyle = fillStyle;
    }
  }
}, stroke:function() {
  var strokeStyle = this.strokeStyle, strokeGradient = this.strokeGradient, strokeOpacity = this.strokeOpacity, alpha = this.globalAlpha, bbox = this.bbox;
  if (strokeStyle !== Ext.util.Color.RGBA_NONE && strokeOpacity !== 0) {
    if (strokeGradient && bbox) {
      this.strokeStyle = strokeGradient.generateGradient(this, bbox);
    }
    if (strokeOpacity !== 1) {
      this.globalAlpha = alpha * strokeOpacity;
    }
    this.$stroke();
    if (strokeOpacity !== 1) {
      this.globalAlpha = alpha;
    }
    if (strokeGradient && bbox) {
      this.strokeStyle = strokeStyle;
    }
  }
}, fillStroke:function(attr, transformFillStroke) {
  var ctx = this, fillStyle = this.fillStyle, fillOpacity = this.fillOpacity, strokeStyle = this.strokeStyle, strokeOpacity = this.strokeOpacity, shadowColor = ctx.shadowColor, shadowBlur = ctx.shadowBlur, none = Ext.util.Color.RGBA_NONE;
  if (transformFillStroke === undefined) {
    transformFillStroke = attr.transformFillStroke;
  }
  if (!transformFillStroke) {
    attr.inverseMatrix.toContext(ctx);
  }
  if (fillStyle !== none && fillOpacity !== 0) {
    ctx.fill();
    ctx.shadowColor = none;
    ctx.shadowBlur = 0;
  }
  if (strokeStyle !== none && strokeOpacity !== 0) {
    ctx.stroke();
  }
  ctx.shadowColor = shadowColor;
  ctx.shadowBlur = shadowBlur;
}, setLineDash:function(dashList) {
  if (this.$setLineDash) {
    this.$setLineDash(dashList);
  }
}, getLineDash:function() {
  if (this.$getLineDash) {
    return this.$getLineDash();
  }
}, ellipse:function(cx, cy, rx, ry, rotation, start, end, anticlockwise) {
  var cos = Math.cos(rotation), sin = Math.sin(rotation);
  this.transform(cos * rx, sin * rx, -sin * ry, cos * ry, cx, cy);
  this.arc(0, 0, 1, start, end, anticlockwise);
  this.transform(cos / rx, -sin / ry, sin / rx, cos / ry, -(cos * cx + sin * cy) / rx, (sin * cx - cos * cy) / ry);
}, appendPath:function(path) {
  var me = this, i = 0, j = 0, commands = path.commands, params = path.params, ln = commands.length;
  me.beginPath();
  for (; i < ln; i++) {
    switch(commands[i]) {
      case 'M':
        me.moveTo(params[j], params[j + 1]);
        j += 2;
        break;
      case 'L':
        me.lineTo(params[j], params[j + 1]);
        j += 2;
        break;
      case 'C':
        me.bezierCurveTo(params[j], params[j + 1], params[j + 2], params[j + 3], params[j + 4], params[j + 5]);
        j += 6;
        break;
      case 'Z':
        me.closePath();
        break;
    }
  }
}, save:function() {
  var toSave = this.toSave, ln = toSave.length, obj = ln && {}, i = 0, key;
  for (; i < ln; i++) {
    key = toSave[i];
    if (key in this) {
      obj[key] = this[key];
    }
  }
  this.state.push(obj);
  this.$save();
}, restore:function() {
  var obj = this.state.pop(), key;
  if (obj) {
    for (key in obj) {
      this[key] = obj[key];
    }
  }
  this.$restore();
}}}, splitThreshold:3000, toSave:['fillGradient', 'strokeGradient'], element:{reference:'element', children:[{reference:'innerElement', style:{width:'100%', height:'100%', position:'relative'}}]}, createCanvas:function() {
  var canvas = Ext.Element.create({tag:'canvas', cls:'x-surface-canvas'});
  if (window['G_vmlCanvasManager']) {
    G_vmlCanvasManager.initElement(canvas.dom);
    this.isVML = true;
  }
  var overrides = Ext.draw.engine.Canvas.contextOverrides, ctx = canvas.dom.getContext('2d'), name;
  if (ctx.ellipse) {
    delete overrides.ellipse;
  }
  ctx.state = [];
  ctx.toSave = this.toSave;
  for (name in overrides) {
    ctx['$' + name] = ctx[name];
  }
  Ext.apply(ctx, overrides);
  if (this.getHighPrecision()) {
    this.enablePrecisionCompensation(ctx);
  } else {
    this.disablePrecisionCompensation(ctx);
  }
  this.innerElement.appendChild(canvas);
  this.canvases.push(canvas);
  this.contexts.push(ctx);
}, updateHighPrecision:function(highPrecision) {
  var contexts = this.contexts, ln = contexts.length, i, context;
  for (i = 0; i < ln; i++) {
    context = contexts[i];
    if (highPrecision) {
      this.enablePrecisionCompensation(context);
    } else {
      this.disablePrecisionCompensation(context);
    }
  }
}, precisionNames:['rect', 'fillRect', 'strokeRect', 'clearRect', 'moveTo', 'lineTo', 'arc', 'arcTo', 'save', 'restore', 'updatePrecisionCompensate', 'setTransform', 'transform', 'scale', 'translate', 'rotate', 'quadraticCurveTo', 'bezierCurveTo', 'createLinearGradient', 'createRadialGradient', 'fillText', 'strokeText', 'drawImage'], disablePrecisionCompensation:function(ctx) {
  var regularOverrides = Ext.draw.engine.Canvas.contextOverrides, precisionOverrides = this.precisionNames, ln = precisionOverrides.length, i, name;
  for (i = 0; i < ln; i++) {
    name = precisionOverrides[i];
    if (!(name in regularOverrides)) {
      delete ctx[name];
    }
  }
  this.setDirty(true);
}, enablePrecisionCompensation:function(ctx) {
  var surface = this, xx = 1, yy = 1, dx = 0, dy = 0, matrix = new Ext.draw.Matrix, transStack = [], comp = {}, regularOverrides = Ext.draw.engine.Canvas.contextOverrides, originalCtx = ctx.constructor.prototype;
  var precisionOverrides = {toSave:surface.toSave, rect:function(x, y, w, h) {
    return originalCtx.rect.call(this, x * xx + dx, y * yy + dy, w * xx, h * yy);
  }, fillRect:function(x, y, w, h) {
    this.updatePrecisionCompensateRect();
    originalCtx.fillRect.call(this, x * xx + dx, y * yy + dy, w * xx, h * yy);
    this.updatePrecisionCompensate();
  }, strokeRect:function(x, y, w, h) {
    this.updatePrecisionCompensateRect();
    originalCtx.strokeRect.call(this, x * xx + dx, y * yy + dy, w * xx, h * yy);
    this.updatePrecisionCompensate();
  }, clearRect:function(x, y, w, h) {
    return originalCtx.clearRect.call(this, x * xx + dx, y * yy + dy, w * xx, h * yy);
  }, moveTo:function(x, y) {
    return originalCtx.moveTo.call(this, x * xx + dx, y * yy + dy);
  }, lineTo:function(x, y) {
    return originalCtx.lineTo.call(this, x * xx + dx, y * yy + dy);
  }, arc:function(x, y, radius, startAngle, endAngle, anticlockwise) {
    this.updatePrecisionCompensateRect();
    originalCtx.arc.call(this, x * xx + dx, y * xx + dy, radius * xx, startAngle, endAngle, anticlockwise);
    this.updatePrecisionCompensate();
  }, arcTo:function(x1, y1, x2, y2, radius) {
    this.updatePrecisionCompensateRect();
    originalCtx.arcTo.call(this, x1 * xx + dx, y1 * yy + dy, x2 * xx + dx, y2 * yy + dy, radius * xx);
    this.updatePrecisionCompensate();
  }, save:function() {
    transStack.push(matrix);
    matrix = matrix.clone();
    regularOverrides.save.call(this);
    originalCtx.save.call(this);
  }, restore:function() {
    matrix = transStack.pop();
    regularOverrides.restore.call(this);
    originalCtx.restore.call(this);
    this.updatePrecisionCompensate();
  }, updatePrecisionCompensate:function() {
    matrix.precisionCompensate(surface.devicePixelRatio, comp);
    xx = comp.xx;
    yy = comp.yy;
    dx = comp.dx;
    dy = comp.dy;
    originalCtx.setTransform.call(this, surface.devicePixelRatio, comp.b, comp.c, comp.d, 0, 0);
  }, updatePrecisionCompensateRect:function() {
    matrix.precisionCompensateRect(surface.devicePixelRatio, comp);
    xx = comp.xx;
    yy = comp.yy;
    dx = comp.dx;
    dy = comp.dy;
    originalCtx.setTransform.call(this, surface.devicePixelRatio, comp.b, comp.c, comp.d, 0, 0);
  }, setTransform:function(x2x, x2y, y2x, y2y, newDx, newDy) {
    matrix.set(x2x, x2y, y2x, y2y, newDx, newDy);
    this.updatePrecisionCompensate();
  }, transform:function(x2x, x2y, y2x, y2y, newDx, newDy) {
    matrix.append(x2x, x2y, y2x, y2y, newDx, newDy);
    this.updatePrecisionCompensate();
  }, scale:function(sx, sy) {
    this.transform(sx, 0, 0, sy, 0, 0);
  }, translate:function(dx, dy) {
    this.transform(1, 0, 0, 1, dx, dy);
  }, rotate:function(radians) {
    var cos = Math.cos(radians), sin = Math.sin(radians);
    this.transform(cos, sin, -sin, cos, 0, 0);
  }, quadraticCurveTo:function(cx, cy, x, y) {
    originalCtx.quadraticCurveTo.call(this, cx * xx + dx, cy * yy + dy, x * xx + dx, y * yy + dy);
  }, bezierCurveTo:function(c1x, c1y, c2x, c2y, x, y) {
    originalCtx.bezierCurveTo.call(this, c1x * xx + dx, c1y * yy + dy, c2x * xx + dx, c2y * yy + dy, x * xx + dx, y * yy + dy);
  }, createLinearGradient:function(x0, y0, x1, y1) {
    this.updatePrecisionCompensateRect();
    var grad = originalCtx.createLinearGradient.call(this, x0 * xx + dx, y0 * yy + dy, x1 * xx + dx, y1 * yy + dy);
    this.updatePrecisionCompensate();
    return grad;
  }, createRadialGradient:function(x0, y0, r0, x1, y1, r1) {
    this.updatePrecisionCompensateRect();
    var grad = originalCtx.createLinearGradient.call(this, x0 * xx + dx, y0 * xx + dy, r0 * xx, x1 * xx + dx, y1 * xx + dy, r1 * xx);
    this.updatePrecisionCompensate();
    return grad;
  }, fillText:function(text, x, y, maxWidth) {
    originalCtx.setTransform.apply(this, matrix.elements);
    if (typeof maxWidth === 'undefined') {
      originalCtx.fillText.call(this, text, x, y);
    } else {
      originalCtx.fillText.call(this, text, x, y, maxWidth);
    }
    this.updatePrecisionCompensate();
  }, strokeText:function(text, x, y, maxWidth) {
    originalCtx.setTransform.apply(this, matrix.elements);
    if (typeof maxWidth === 'undefined') {
      originalCtx.strokeText.call(this, text, x, y);
    } else {
      originalCtx.strokeText.call(this, text, x, y, maxWidth);
    }
    this.updatePrecisionCompensate();
  }, fill:function() {
    var fillGradient = this.fillGradient, bbox = this.bbox;
    this.updatePrecisionCompensateRect();
    if (fillGradient && bbox) {
      this.fillStyle = fillGradient.generateGradient(this, bbox);
    }
    originalCtx.fill.call(this);
    this.updatePrecisionCompensate();
  }, stroke:function() {
    var strokeGradient = this.strokeGradient, bbox = this.bbox;
    this.updatePrecisionCompensateRect();
    if (strokeGradient && bbox) {
      this.strokeStyle = strokeGradient.generateGradient(this, bbox);
    }
    originalCtx.stroke.call(this);
    this.updatePrecisionCompensate();
  }, drawImage:function(img_elem, arg1, arg2, arg3, arg4, dst_x, dst_y, dw, dh) {
    switch(arguments.length) {
      case 3:
        return originalCtx.drawImage.call(this, img_elem, arg1 * xx + dx, arg2 * yy + dy);
      case 5:
        return originalCtx.drawImage.call(this, img_elem, arg1 * xx + dx, arg2 * yy + dy, arg3 * xx, arg4 * yy);
      case 9:
        return originalCtx.drawImage.call(this, img_elem, arg1, arg2, arg3, arg4, dst_x * xx + dx, dst_y * yy * dy, dw * xx, dh * yy);
    }
  }};
  Ext.apply(ctx, precisionOverrides);
  this.setDirty(true);
}, updateRect:function(rect) {
  Ext.draw.Surface.prototype.updateRect.call(this, rect);
  var me = this, l = Math.floor(rect[0]), t = Math.floor(rect[1]), r = Math.ceil(rect[0] + rect[2]), b = Math.ceil(rect[1] + rect[3]), devicePixelRatio = me.devicePixelRatio, canvases = me.canvases, w = r - l, h = b - t, splitThreshold = Math.round(me.splitThreshold / devicePixelRatio), xSplits = me.xSplits = Math.ceil(w / splitThreshold), ySplits = me.ySplits = Math.ceil(h / splitThreshold), i, j, k, offsetX, offsetY, dom, width, height;
  for (j = 0, offsetY = 0; j < ySplits; j++, offsetY += splitThreshold) {
    for (i = 0, offsetX = 0; i < xSplits; i++, offsetX += splitThreshold) {
      k = j * xSplits + i;
      if (k >= canvases.length) {
        me.createCanvas();
      }
      dom = canvases[k].dom;
      dom.style.left = offsetX + 'px';
      dom.style.top = offsetY + 'px';
      height = Math.min(splitThreshold, h - offsetY);
      if (height * devicePixelRatio !== dom.height) {
        dom.height = height * devicePixelRatio;
        dom.style.height = height + 'px';
      }
      width = Math.min(splitThreshold, w - offsetX);
      if (width * devicePixelRatio !== dom.width) {
        dom.width = width * devicePixelRatio;
        dom.style.width = width + 'px';
      }
      me.applyDefaults(me.contexts[k]);
    }
  }
  me.activeCanvases = k = xSplits * ySplits;
  while (canvases.length > k) {
    canvases.pop().destroy();
  }
  me.clear();
}, clearTransform:function() {
  var me = this, xSplits = me.xSplits, ySplits = me.ySplits, contexts = me.contexts, splitThreshold = me.splitThreshold, devicePixelRatio = me.devicePixelRatio, i, j, k, ctx;
  for (i = 0; i < xSplits; i++) {
    for (j = 0; j < ySplits; j++) {
      k = j * xSplits + i;
      ctx = contexts[k];
      ctx.translate(-splitThreshold * i, -splitThreshold * j);
      ctx.scale(devicePixelRatio, devicePixelRatio);
      me.matrix.toContext(ctx);
    }
  }
}, renderSprite:function(sprite) {
  var me = this, rect = me.getRect(), surfaceMatrix = me.matrix, parent = sprite.getParent(), matrix = Ext.draw.Matrix.fly([1, 0, 0, 1, 0, 0]), splitThreshold = me.splitThreshold / me.devicePixelRatio, xSplits = me.xSplits, ySplits = me.ySplits, offsetX, offsetY, ctx, bbox, width, height, left = 0, right, top = 0, bottom, w = rect[2], h = rect[3], i, j, k;
  while (parent && parent.isSprite) {
    matrix.prependMatrix(parent.matrix || parent.attr && parent.attr.matrix);
    parent = parent.getParent();
  }
  matrix.prependMatrix(surfaceMatrix);
  bbox = sprite.getBBox();
  if (bbox) {
    bbox = matrix.transformBBox(bbox);
  }
  sprite.preRender(me);
  if (sprite.attr.hidden || sprite.attr.globalAlpha === 0) {
    sprite.setDirty(false);
    return;
  }
  for (j = 0, offsetY = 0; j < ySplits; j++, offsetY += splitThreshold) {
    for (i = 0, offsetX = 0; i < xSplits; i++, offsetX += splitThreshold) {
      k = j * xSplits + i;
      ctx = me.contexts[k];
      width = Math.min(splitThreshold, w - offsetX);
      height = Math.min(splitThreshold, h - offsetY);
      left = offsetX;
      right = left + width;
      top = offsetY;
      bottom = top + height;
      if (bbox) {
        if (bbox.x > right || bbox.x + bbox.width < left || bbox.y > bottom || bbox.y + bbox.height < top) {
          continue;
        }
      }
      ctx.save();
      sprite.useAttributes(ctx, rect);
      if (false === sprite.render(me, ctx, [left, top, width, height])) {
        return false;
      }
      ctx.restore();
    }
  }
  sprite.setDirty(false);
}, flatten:function(size, surfaces) {
  var targetCanvas = document.createElement('canvas'), className = Ext.getClassName(this), ratio = this.devicePixelRatio, ctx = targetCanvas.getContext('2d'), surface, canvas, rect, i, j, xy;
  targetCanvas.width = Math.ceil(size.width * ratio);
  targetCanvas.height = Math.ceil(size.height * ratio);
  for (i = 0; i < surfaces.length; i++) {
    surface = surfaces[i];
    if (Ext.getClassName(surface) !== className) {
      continue;
    }
    rect = surface.getRect();
    for (j = 0; j < surface.canvases.length; j++) {
      canvas = surface.canvases[j];
      xy = canvas.getOffsetsTo(canvas.getParent());
      ctx.drawImage(canvas.dom, (rect[0] + xy[0]) * ratio, (rect[1] + xy[1]) * ratio);
    }
  }
  return {data:targetCanvas.toDataURL(), type:'png'};
}, applyDefaults:function(ctx) {
  var none = Ext.util.Color.RGBA_NONE;
  ctx.strokeStyle = none;
  ctx.fillStyle = none;
  ctx.textAlign = 'start';
  ctx.textBaseline = 'alphabetic';
  ctx.miterLimit = 1;
}, clear:function() {
  var me = this, activeCanvases = me.activeCanvases, i, canvas, ctx;
  for (i = 0; i < activeCanvases; i++) {
    canvas = me.canvases[i].dom;
    ctx = me.contexts[i];
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }
  me.setDirty(true);
}, destroy:function() {
  var me = this, canvases = me.canvases, ln = canvases.length, i;
  for (i = 0; i < ln; i++) {
    me.contexts[i] = null;
    canvases[i].destroy();
    canvases[i] = null;
  }
  me.contexts = me.canvases = null;
  Ext.draw.Surface.prototype.destroy.call(this);
}, privates:{initElement:function() {
  var me = this;
  Ext.draw.Surface.prototype.initElement.call(this);
  me.canvases = [];
  me.contexts = [];
  me.activeCanvases = me.xSplits = me.ySplits = 0;
}}}, 0, 0, ['widget', 'surface'], {'widget':true, 'surface':true}, 0, 0, [Ext.draw.engine, 'Canvas'], function() {
  var me = this, proto = me.prototype, splitThreshold = 1.0E10;
  if (Ext.os.is.Android4 && Ext.browser.is.Chrome) {
    splitThreshold = 3000;
  } else {
    if (Ext.is.iOS) {
      splitThreshold = 2200;
    }
  }
  proto.splitThreshold = splitThreshold;
});
Ext.cmd.derive('Ext.draw.Container', Ext.draw.ContainerBase, {alternateClassName:'Ext.draw.Component', defaultType:'surface', isDrawContainer:true, engine:'Ext.draw.engine.Canvas', config:{cls:['x-draw-container', 'x-unselectable'], resizeHandler:null, sprites:null, gradients:[], touchAction:{panX:false, panY:false, pinchZoom:false, doubleTapZoom:false}, surfaceZIndexes:{main:1}}, defaultDownloadServerUrl:'http://svg.sencha.io', supportedFormats:['png', 'pdf', 'jpeg', 'gif'], supportedOptions:{version:Ext.isNumber, 
data:Ext.isString, format:function(format) {
  return Ext.Array.indexOf(this.supportedFormats, format) >= 0;
}, filename:Ext.isString, width:Ext.isNumber, height:Ext.isNumber, scale:Ext.isNumber, pdf:Ext.isObject, jpeg:Ext.isObject}, initAnimator:function() {
  this.frameCallbackId = Ext.draw.Animator.addFrameCallback('renderFrame', this);
}, applyGradients:function(gradients) {
  var result = [], i, n, gradient, offset;
  if (!Ext.isArray(gradients)) {
    return result;
  }
  for (i = 0, n = gradients.length; i < n; i++) {
    gradient = gradients[i];
    if (!Ext.isObject(gradient)) {
      continue;
    }
    if (typeof gradient.type !== 'string') {
      gradient.type = 'linear';
    }
    if (gradient.angle) {
      gradient.degrees = gradient.angle;
      delete gradient.angle;
    }
    if (Ext.isObject(gradient.stops)) {
      gradient.stops = function(stops) {
        var result = [], stop;
        for (offset in stops) {
          stop = stops[offset];
          stop.offset = offset / 100;
          result.push(stop);
        }
        return result;
      }(gradient.stops);
    }
    result.push(gradient);
  }
  Ext.draw.gradient.GradientDefinition.add(result);
  return result;
}, applySprites:function(sprites) {
  if (!sprites) {
    return;
  }
  sprites = Ext.Array.from(sprites);
  var ln = sprites.length, result = [], i, surface, sprite;
  for (i = 0; i < ln; i++) {
    sprite = sprites[i];
    surface = sprite.surface;
    if (!(surface && surface.isSurface)) {
      if (Ext.isString(surface)) {
        surface = this.getSurface(surface);
        delete sprite.surface;
      } else {
        surface = this.getSurface('main');
      }
    }
    sprite = surface.add(sprite);
    result.push(sprite);
  }
  return result;
}, resizeDelay:500, resizeTimerId:0, size:null, handleResize:function(size, instantly) {
  var me = this, el = me.element, resizeHandler = me.getResizeHandler() || me.defaultResizeHandler, result;
  if (!el) {
    return;
  }
  size = size || el.getSize();
  if (!(size.width && size.height)) {
    return;
  }
  me.size = size;
  me.stopResizeTimer();
  if (!instantly) {
    me.resizeTimerId = Ext.defer(me.handleResize, me.resizeDelay, me, [size, true]);
    return;
  }
  me.fireEvent('bodyresize', me, size);
  result = resizeHandler.call(me, size);
  if (result !== false) {
    me.renderFrame();
  }
}, stopResizeTimer:function() {
  if (this.resizeTimerId) {
    clearTimeout(this.resizeTimerId);
    this.resizeTimerId = 0;
  }
}, defaultResizeHandler:function(size) {
  this.getItems().each(function(surface) {
    surface.setRect([0, 0, size.width, size.height]);
  });
}, getSurface:function(id, type) {
  id = id || 'main';
  type = type || id;
  var me = this, surfaces = me.getItems(), oldCount = surfaces.getCount(), zIndexes = me.getSurfaceZIndexes(), surface;
  surface = me.createSurface(id);
  if (type in zIndexes) {
    surface.element.setStyle('zIndex', zIndexes[type]);
  }
  if (surfaces.getCount() > oldCount) {
    me.handleResize(null, true);
  }
  return surface;
}, createSurface:function(id) {
  id = this.getId() + '-' + (id || 'main');
  var me = this, surfaces = me.getItems(), surface = surfaces.get(id);
  if (!surface) {
    surface = me.add({xclass:me.engine, id:id});
  }
  return surface;
}, renderFrame:function() {
  var me = this, surfaces = me.getItems(), i, ln, item;
  for (i = 0, ln = surfaces.length; i < ln; i++) {
    item = surfaces.items[i];
    if (item.isSurface) {
      item.renderFrame();
    }
  }
}, getImage:function(format) {
  var size = this.innerElement.getSize(), surfaces = Array.prototype.slice.call(this.items.items), zIndexes = this.getSurfaceZIndexes(), image, imageElement, i, j, surface, zIndex;
  for (j = 1; j < surfaces.length; j++) {
    surface = surfaces[j];
    zIndex = zIndexes[surface.type];
    i = j - 1;
    while (i >= 0 && zIndexes[surfaces[i].type] > zIndex) {
      surfaces[i + 1] = surfaces[i];
      i--;
    }
    surfaces[i + 1] = surface;
  }
  surface = surfaces[0];
  if ((Ext.isIE || Ext.isEdge) && surface.isSVG) {
    image = {data:surface.toSVG(size, surfaces), type:'svg-markup'};
  } else {
    image = surface.flatten(size, surfaces);
    if (format === 'image') {
      imageElement = new Image;
      imageElement.src = image.data;
      image.data = imageElement;
      return image;
    }
    if (format === 'stream') {
      image.data = image.data.replace(/^data:image\/[^;]+/, 'data:application/octet-stream');
      return image;
    }
  }
  return image;
}, download:function(config) {
  var me = this, inputs = [], markup, name, value;
  if (Ext.isIE8) {
    return false;
  }
  config = Ext.apply({version:2, data:me.getImage().data}, config);
  for (name in config) {
    if (config.hasOwnProperty(name)) {
      value = config[name];
      if (name in me.supportedOptions) {
        if (me.supportedOptions[name].call(me, value)) {
          inputs.push({tag:'input', type:'hidden', name:name, value:Ext.String.htmlEncode(Ext.isObject(value) ? Ext.JSON.encode(value) : value)});
        }
      }
    }
  }
  markup = Ext.dom.Helper.markup({tag:'html', children:[{tag:'head'}, {tag:'body', children:[{tag:'form', method:'POST', action:config.url || me.defaultDownloadServerUrl, children:inputs}, {tag:'script', type:'text/javascript', children:'document.getElementsByTagName("form")[0].submit();'}]}]});
  window.open('', 'ImageDownload_' + Date.now()).document.write(markup);
}, destroy:function() {
  var me = this, callbackId = me.frameCallbackId;
  if (callbackId) {
    Ext.draw.Animator.removeFrameCallback(callbackId);
  }
  me.stopResizeTimer();
  Ext.draw.ContainerBase.prototype.destroy.call(this);
}}, 0, ['draw'], ['component', 'box', 'container', 'panel', 'draw'], {'component':true, 'box':true, 'container':true, 'panel':true, 'draw':true}, ['widget.draw'], 0, [Ext.draw, 'Container', Ext.draw, 'Component'], function() {
  if (location.search.match('svg')) {
    Ext.draw.Container.prototype.engine = 'Ext.draw.engine.Svg';
  } else {
    if (Ext.os.is.BlackBerry && Ext.os.version.getMajor() === 10 || Ext.browser.is.AndroidStock4 && (Ext.os.version.getMinor() === 1 || Ext.os.version.getMinor() === 2 || Ext.os.version.getMinor() === 3)) {
      Ext.draw.Container.prototype.engine = 'Ext.draw.engine.Svg';
    }
  }
});
Ext.cmd.derive('Ext.draw.PathUtil', Ext.Base, function() {
  var abs = Math.abs, pow = Math.pow, cos = Math.cos, acos = Math.acos, sqrt = Math.sqrt, PI = Math.PI;
  return {singleton:true, cubicRoots:function(P) {
    var a = P[0], b = P[1], c = P[2], d = P[3];
    if (a === 0) {
      return this.quadraticRoots(b, c, d);
    }
    var A = b / a, B = c / a, C = d / a, Q = (3 * B - pow(A, 2)) / 9, R = (9 * A * B - 27 * C - 2 * pow(A, 3)) / 54, D = pow(Q, 3) + pow(R, 2), t = [], S, T, Im, th, i, sign = Ext.Number.sign;
    if (D >= 0) {
      S = sign(R + sqrt(D)) * pow(abs(R + sqrt(D)), 1 / 3);
      T = sign(R - sqrt(D)) * pow(abs(R - sqrt(D)), 1 / 3);
      t[0] = -A / 3 + (S + T);
      t[1] = -A / 3 - (S + T) / 2;
      t[2] = t[1];
      Im = abs(sqrt(3) * (S - T) / 2);
      if (Im !== 0) {
        t[1] = -1;
        t[2] = -1;
      }
    } else {
      th = acos(R / sqrt(-pow(Q, 3)));
      t[0] = 2 * sqrt(-Q) * cos(th / 3) - A / 3;
      t[1] = 2 * sqrt(-Q) * cos((th + 2 * PI) / 3) - A / 3;
      t[2] = 2 * sqrt(-Q) * cos((th + 4 * PI) / 3) - A / 3;
    }
    for (i = 0; i < 3; i++) {
      if (t[i] < 0 || t[i] > 1) {
        t[i] = -1;
      }
    }
    return t;
  }, quadraticRoots:function(a, b, c) {
    var D, rD, t, i;
    if (a === 0) {
      return this.linearRoot(b, c);
    }
    D = b * b - 4 * a * c;
    if (D === 0) {
      t = [-b / (2 * a)];
    } else {
      if (D > 0) {
        rD = sqrt(D);
        t = [(-b - rD) / (2 * a), (-b + rD) / (2 * a)];
      } else {
        return [];
      }
    }
    for (i = 0; i < t.length; i++) {
      if (t[i] < 0 || t[i] > 1) {
        t[i] = -1;
      }
    }
    return t;
  }, linearRoot:function(a, b) {
    var t = -b / a;
    if (a === 0 || t < 0 || t > 1) {
      return [];
    }
    return [t];
  }, bezierCoeffs:function(P0, P1, P2, P3) {
    var Z = [];
    Z[0] = -P0 + 3 * P1 - 3 * P2 + P3;
    Z[1] = 3 * P0 - 6 * P1 + 3 * P2;
    Z[2] = -3 * P0 + 3 * P1;
    Z[3] = P0;
    return Z;
  }, cubicLineIntersections:function(px1, px2, px3, px4, py1, py2, py3, py4, x1, y1, x2, y2) {
    var P = [], intersections = [], A = y1 - y2, B = x2 - x1, C = x1 * (y2 - y1) - y1 * (x2 - x1), bx = this.bezierCoeffs(px1, px2, px3, px4), by = this.bezierCoeffs(py1, py2, py3, py4), i, r, s, t, tt, ttt, cx, cy;
    P[0] = A * bx[0] + B * by[0];
    P[1] = A * bx[1] + B * by[1];
    P[2] = A * bx[2] + B * by[2];
    P[3] = A * bx[3] + B * by[3] + C;
    r = this.cubicRoots(P);
    for (i = 0; i < r.length; i++) {
      t = r[i];
      if (t < 0 || t > 1) {
        continue;
      }
      tt = t * t;
      ttt = tt * t;
      cx = bx[0] * ttt + bx[1] * tt + bx[2] * t + bx[3];
      cy = by[0] * ttt + by[1] * tt + by[2] * t + by[3];
      if (x2 - x1 !== 0) {
        s = (cx - x1) / (x2 - x1);
      } else {
        s = (cy - y1) / (y2 - y1);
      }
      if (!(s < 0 || s > 1)) {
        intersections.push([cx, cy]);
      }
    }
    return intersections;
  }, splitCubic:function(P1, P2, P3, P4, z) {
    var zz = z * z, zzz = z * zz, iz = z - 1, izz = iz * iz, izzz = iz * izz, P = zzz * P4 - 3 * zz * iz * P3 + 3 * z * izz * P2 - izzz * P1;
    return [[P1, z * P2 - iz * P1, zz * P3 - 2 * z * iz * P2 + izz * P1, P], [P, zz * P4 - 2 * z * iz * P3 + izz * P2, z * P4 - iz * P3, P4]];
  }, cubicDimension:function(a, b, c, d) {
    var qa = 3 * (-a + 3 * (b - c) + d), qb = 6 * (a - 2 * b + c), qc = -3 * (a - b), x, y, min = Math.min(a, d), max = Math.max(a, d), delta;
    if (qa === 0) {
      if (qb === 0) {
        return [min, max];
      } else {
        x = -qc / qb;
        if (0 < x && x < 1) {
          y = this.interpolateCubic(a, b, c, d, x);
          min = Math.min(min, y);
          max = Math.max(max, y);
        }
      }
    } else {
      delta = qb * qb - 4 * qa * qc;
      if (delta >= 0) {
        delta = sqrt(delta);
        x = (delta - qb) / 2 / qa;
        if (0 < x && x < 1) {
          y = this.interpolateCubic(a, b, c, d, x);
          min = Math.min(min, y);
          max = Math.max(max, y);
        }
        if (delta > 0) {
          x -= delta / qa;
          if (0 < x && x < 1) {
            y = this.interpolateCubic(a, b, c, d, x);
            min = Math.min(min, y);
            max = Math.max(max, y);
          }
        }
      }
    }
    return [min, max];
  }, interpolateCubic:function(a, b, c, d, t) {
    if (t === 0) {
      return a;
    }
    if (t === 1) {
      return d;
    }
    var rate = (1 - t) / t;
    return t * t * t * (d + rate * (3 * c + rate * (3 * b + rate * a)));
  }, cubicsIntersections:function(ax1, ax2, ax3, ax4, ay1, ay2, ay3, ay4, bx1, bx2, bx3, bx4, by1, by2, by3, by4) {
    var me = this, axDim = me.cubicDimension(ax1, ax2, ax3, ax4), ayDim = me.cubicDimension(ay1, ay2, ay3, ay4), bxDim = me.cubicDimension(bx1, bx2, bx3, bx4), byDim = me.cubicDimension(by1, by2, by3, by4), splitAx, splitAy, splitBx, splitBy, points = [];
    if (axDim[0] > bxDim[1] || axDim[1] < bxDim[0] || ayDim[0] > byDim[1] || ayDim[1] < byDim[0]) {
      return [];
    }
    if (abs(ay1 - ay2) < 1 && abs(ay3 - ay4) < 1 && abs(ax1 - ax4) < 1 && abs(ax2 - ax3) < 1 && abs(by1 - by2) < 1 && abs(by3 - by4) < 1 && abs(bx1 - bx4) < 1 && abs(bx2 - bx3) < 1) {
      return [[(ax1 + ax4) * 0.5, (ay1 + ay2) * 0.5]];
    }
    splitAx = me.splitCubic(ax1, ax2, ax3, ax4, 0.5);
    splitAy = me.splitCubic(ay1, ay2, ay3, ay4, 0.5);
    splitBx = me.splitCubic(bx1, bx2, bx3, bx4, 0.5);
    splitBy = me.splitCubic(by1, by2, by3, by4, 0.5);
    points.push.apply(points, me.cubicsIntersections.apply(me, splitAx[0].concat(splitAy[0], splitBx[0], splitBy[0])));
    points.push.apply(points, me.cubicsIntersections.apply(me, splitAx[0].concat(splitAy[0], splitBx[1], splitBy[1])));
    points.push.apply(points, me.cubicsIntersections.apply(me, splitAx[1].concat(splitAy[1], splitBx[0], splitBy[0])));
    points.push.apply(points, me.cubicsIntersections.apply(me, splitAx[1].concat(splitAy[1], splitBx[1], splitBy[1])));
    return points;
  }, linesIntersection:function(x1, y1, x2, y2, x3, y3, x4, y4) {
    var d = (x2 - x1) * (y4 - y3) - (y2 - y1) * (x4 - x3), ua, ub;
    if (d === 0) {
      return null;
    }
    ua = ((x4 - x3) * (y1 - y3) - (x1 - x3) * (y4 - y3)) / d;
    ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / d;
    if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
      return [x1 + ua * (x2 - x1), y1 + ua * (y2 - y1)];
    }
    return null;
  }, pointOnLine:function(x1, y1, x2, y2, x, y) {
    var t, _;
    if (abs(x2 - x1) < abs(y2 - y1)) {
      _ = x1;
      x1 = y1;
      y1 = _;
      _ = x2;
      x2 = y2;
      y2 = _;
      _ = x;
      x = y;
      y = _;
    }
    t = (x - x1) / (x2 - x1);
    if (t < 0 || t > 1) {
      return false;
    }
    return abs(y1 + t * (y2 - y1) - y) < 4;
  }, pointOnCubic:function(px1, px2, px3, px4, py1, py2, py3, py4, x, y) {
    var me = this, bx = me.bezierCoeffs(px1, px2, px3, px4), by = me.bezierCoeffs(py1, py2, py3, py4), i, j, rx, ry, t;
    bx[3] -= x;
    by[3] -= y;
    rx = me.cubicRoots(bx);
    ry = me.cubicRoots(by);
    for (i = 0; i < rx.length; i++) {
      t = rx[i];
      for (j = 0; j < ry.length; j++) {
        if (t >= 0 && t <= 1 && abs(t - ry[j]) < 0.05) {
          return true;
        }
      }
    }
    return false;
  }};
}, 0, 0, 0, 0, 0, 0, [Ext.draw, 'PathUtil'], 0);
Ext.cmd.derive('Ext.draw.overrides.hittest.All', Ext.Base, {}, 0, 0, 0, 0, 0, 0, [Ext.draw.overrides.hittest, 'All'], 0);
Ext.cmd.derive('Ext.draw.plugin.SpriteEvents', Ext.plugin.Abstract, {mouseMoveEvents:{mousemove:true, mouseover:true, mouseout:true}, spriteMouseMoveEvents:{spritemousemove:true, spritemouseover:true, spritemouseout:true}, init:function(drawContainer) {
  var handleEvent = 'handleEvent';
  this.drawContainer = drawContainer;
  drawContainer.addElementListener({click:handleEvent, dblclick:handleEvent, mousedown:handleEvent, mousemove:handleEvent, mouseup:handleEvent, mouseover:handleEvent, mouseout:handleEvent, priority:1001, scope:this});
}, hasSpriteMouseMoveListeners:function() {
  var listeners = this.drawContainer.hasListeners, name;
  for (name in this.spriteMouseMoveEvents) {
    if (name in listeners) {
      return true;
    }
  }
  return false;
}, hitTestEvent:function(e) {
  var items = this.drawContainer.getItems(), surface, sprite, i;
  for (i = items.length - 1; i >= 0; i--) {
    surface = items.get(i);
    sprite = surface.hitTestEvent(e);
    if (sprite) {
      return sprite;
    }
  }
  return null;
}, handleEvent:function(e) {
  var me = this, drawContainer = me.drawContainer, isMouseMoveEvent = e.type in me.mouseMoveEvents, lastSprite = me.lastSprite, sprite;
  if (isMouseMoveEvent && !me.hasSpriteMouseMoveListeners()) {
    return;
  }
  sprite = me.hitTestEvent(e);
  if (isMouseMoveEvent && !Ext.Object.equals(sprite, lastSprite)) {
    if (lastSprite) {
      drawContainer.fireEvent('spritemouseout', lastSprite, e);
    }
    if (sprite) {
      drawContainer.fireEvent('spritemouseover', sprite, e);
    }
  }
  if (sprite) {
    drawContainer.fireEvent('sprite' + e.type, sprite, e);
  }
  me.lastSprite = sprite;
}}, 0, 0, 0, 0, ['plugin.spriteevents'], 0, [Ext.draw.plugin, 'SpriteEvents'], 0);
Ext.cmd.derive('photoViewer.Values', Ext.Base, {singleton:true, MSR_ZERO_POINTS:0, MSR_ONE_POINTS:1, MSR_TWO_POINTS:2, MSR_CALCULATING:3, MSR_DONE:4, DRAW_OFF:0, DRAW_ANNOTATING:1, DRAW_MEASURING:2, VIEW_TRUVIEW:1, VIEW_SITEWALK360:2}, 0, 0, 0, 0, 0, 0, [photoViewer, 'Values'], 0);
Ext.cmd.derive('photoViewer.controller.PanoramaMarkerController', Ext.app.Controller, {config:{markerLayer:null, directionMarker:null, directionArrow:null}, getFloorplan:function() {
  return Ext.ComponentQuery.query('photoviewer')[0].getController().getFloorplan();
}, createMarkerLayer:function() {
  if (this.getMarkerLayer() == null && !!this.map) {
    var leaflet = MVLeaflet || L;
    this.setMarkerLayer(new leaflet.layerGroup);
    this.map.addLayer(this.getMarkerLayer());
    this.mapZoomHandler = this.mapZoomEndHandler.bind(this);
    this.map.on('zoomend', this.mapZoomHandler);
  } else {
    this.removeMarkerLayer();
  }
  return this.getMarkerLayer();
}, removeMarkerLayer:function(destroyMarkerLayer) {
  this.setDirectionMarker(null);
  if (this.getMarkerLayer()) {
    this.getMarkerLayer().clearLayers();
    if (destroyMarkerLayer) {
      this.setMarkerLayer(null);
    }
  }
}, mapZoomEndHandler:function(e) {
  if (!this.getMarkerLayer()) {
    return;
  }
  var zoom = e.target.getZoom();
  var arrow = this.getDirectionArrow();
  if (arrow && arrow.classList) {
    if (zoom == 0) {
      arrow.classList.add('small');
    } else {
      arrow.classList.remove('small');
    }
  }
  this.updateMarkerFOV();
}, getHotspot:function() {
  var viewModel = this.getViewModel(), floorplan = this.getFloorplan(), hotspotArray = floorplan.getHotspotsArray(), hotspotID = viewModel.get('activePhoto.HotspotID');
  var result = Ext.Array.findBy(hotspotArray, function(hotspot) {
    return hotspot.id == hotspotID;
  });
  if (!result) {
    return;
  }
  return result;
}, getHotspotLatLng:function() {
  var hotspot = this.getHotspot();
  if (!hotspot) {
    return;
  }
  return {lng:hotspot.geometry.coordinates[0], lat:hotspot.geometry.coordinates[1]};
}, checkFloorplanReady:function() {
  var floorplan = this.getFloorplan();
  if (floorplan.map) {
    this.map = floorplan.map;
    if (!floorplan.hotspotsLoaded) {
      floorplan.on({hotspotsLoaded:{fn:function() {
        this.checkFloorplanReady();
      }, scope:this, single:true}});
      return;
    }
    this.floorplanReady();
  } else {
    floorplan.on({afterinitfloorplan:{fn:function() {
      this.checkFloorplanReady();
    }, scope:this, single:true}});
  }
}, floorplanReady:function() {
  this.createMarkerLayer();
  this.updateMarkerFOV();
}, updateMarkerFOV:function() {
  var position = this.getHotspotLatLng();
  var angle = this.getViewerAngle();
  if (Ext.isNumber(angle)) {
    this.updateDirectionMarkerOnFloorplan(position, angle);
  } else {
    this.removeMarkerLayer();
  }
}, addDirectionMarkerToLayer:function(layer, latlng) {
  var leaflet = MVLeaflet || L;
  var zoom = this.map ? this.map.getZoom() : 0;
  var icon = leaflet.divIcon({className:'matterportDirectionMarker', div:true, html:'\x3cdiv class\x3d"matterportDirectionArrow' + (zoom == 0 ? ' small' : '') + '"\x3e\x3c/div\x3e'});
  var iconMarker = leaflet.marker(latlng, {clickable:false, icon:icon});
  layer.addLayer(iconMarker);
  return iconMarker;
}, updateDirectionMarkerOnFloorplan:function(coordinates, angle) {
  try {
    var directionMarker = this.getDirectionMarker();
    if (!directionMarker) {
      directionMarker = this.addDirectionMarkerToLayer(this.getMarkerLayer(), coordinates);
      this.setDirectionMarker(directionMarker);
      this.setDirectionArrow(directionMarker._icon.firstChild);
    } else {
      var latlng = directionMarker.getLatLng();
      latlng.lat = coordinates.lat;
      latlng.lng = coordinates.lng;
      directionMarker.setLatLng(latlng);
    }
    this.rotateMarker(angle);
  } catch (ex) {
    console.log('Error placing direction marker on floorplan');
    console.log(ex.message);
  }
}, rotateMarker:function(angle) {
  while (angle < 0) {
    angle += 360;
  }
  var arrow = this.getDirectionArrow();
  if (arrow) {
    var transform = 'rotate(' + angle + 'deg)';
    if (transform != arrow.style.transform) {
      arrow.style.transform = transform;
      var radius = 15;
      var marginLeft = Math.round(radius * Math.sin(this.toRadians(angle)));
      var marginTop = Math.round(-radius * Math.cos(this.toRadians(angle)) + radius);
      arrow.style.marginLeft = marginLeft + 'px';
      arrow.style.marginTop = marginTop + 'px';
    }
  }
}, toDegrees:function(radians) {
  return 180 * radians / Math.PI;
}, toRadians:function(degrees) {
  return Math.PI * degrees / 180;
}}, 0, 0, 0, 0, 0, 0, [photoViewer.controller, 'PanoramaMarkerController'], 0);
Ext.cmd.derive('photoViewer.controller.SiteWalk360Controller', Ext.app.Controller, {config:{panos:[], activePano:null, panoMarkersMap:{}, directionMarker:null, currentRotation:null, floorplanTheta:0, viewerReady:false, truViewModel:null, matterportModel:null, primaryModelIsTruView:false, currentScanUuid:null, currentModelId:null}, init:function() {
  this.showcaseSDK = Ext.create('siteWalk360.MatterportShowcaseSDK');
  this.showcaseSDK.on('panoselect', this.panoSelected, this);
  this.showcaseSDK.on('panoselect', this.logViewPhotoEvent, this, {buffer:1});
  this.showcaseSDK.on('rotationchange', this.rotationChanged, this);
  this.showcaseSDK.on('showcaseconnected', this.showcaseConnected, this);
  this.showcaseSDK.on('initialpanosload', this.initialPanosLoaded, this);
  this.truViewSDK = Ext.create('siteWalk360.TruViewSDK');
  this.truViewSDK.on('scanviewerready', this.truViewScanViewerReady, this);
  this.truViewSDK.on('panoselect', this.panoSelected, this);
  this.truViewSDK.on('rotationchange', this.rotationChanged, this);
  window.sw360c = this;
}, getViewModel:function() {
  if (!this.viewModel) {
    this.viewModel = Ext.getCmp('mainView').getViewModel();
  }
  return this.viewModel;
}, useImperial:function() {
  return !!(this.getViewModel().get('account.MeasurePreferenceID') == mdsData.PreferenceValues.MEASURE_PREFERENCE_IMPERIAL);
}, isTruView:function() {
  return this.getViewModel().get('photoState.isTruView');
}, setTruView:function(on) {
  this.getViewModel().set('photoState.isTruView', on === true);
}, isMatterport:function() {
  return !this.getViewModel().get('photoState.isTruView');
}, clearAll:function() {
  this.clearFloorplan();
  this.clearModels();
  this.clearViewer();
}, clearFloorplan:function() {
  this.debug('Clearing floorplan');
  this.setPanos([]);
  this.selectPano(null);
  this.setActivePano(null);
  this.setPanoMarkersMap({});
  this.removeDirectionMarker();
  this.setCurrentRotation(null);
  this.setFloorplanTheta(0);
  this.removePanoLayer();
}, clearModels:function() {
  this.setTruViewModel(null);
  this.setMatterportModel(null);
  this.setPrimaryModelIsTruView(false);
  this.setCurrentScanUuid(null);
  this.setCurrentModelId(null);
}, clearViewer:function() {
  if (this.isTruView()) {
    this.truViewSDK.clear();
  } else {
    this.showcaseSDK.clear();
  }
  this.setViewerReady(false);
  this.removeDirectionMarker();
}, takeScreenShot:function(resolution) {
  if (this.isTruView()) {
    return this.truViewSDK.takeScreenShot();
  }
  return this.showcaseSDK.takeScreenShot(resolution);
}, getPose:function() {
  if (this.isTruView()) {
    return new Promise(function(resolve, reject) {
      reject('Not supported in TruView');
    });
  }
  return this.showcaseSDK.getPose();
}, switchViewer:function(truView) {
  var model = truView ? this.getTruViewModel() : this.getMatterportModel();
  if (!model) {
    return;
  }
  var selectedUuid = null;
  var oldPano = this.getActivePano();
  var newPano = null;
  if (oldPano) {
    newPano = this.findNearestPano(oldPano, model.panos);
    selectedUuid = newPano ? newPano.uuid : null;
  }
  var rotation = this.getCurrentRotation();
  var oldModel = truView ? this.getMatterportModel() : this.getTruViewModel();
  if (oldModel && oldModel.floorplanTheta != model.floorplanTheta) {
    var thetaDiff = model.floorplanTheta - oldModel.floorplanTheta;
    if (rotation) {
      rotation.y = this.constrainAngle(rotation.y + thetaDiff);
      this.debug('Adjusting current rotation by ' + thetaDiff + ' degrees', rotation);
    }
  }
  if (newPano) {
    this.setActivePano(newPano);
  }
  this.clearFloorplan();
  this.setCurrentRotation(rotation);
  if (truView) {
    this.setupTruView(model, selectedUuid);
  } else {
    this.setupMatterportFrame(model, selectedUuid);
  }
}, setupViewer:function(photoId) {
  Ext.Ajax.request({url:mdslink.server + '/index.cfm?fuseaction\x3daClientPanorama.getModelValues\x26photoId\x3d' + photoId, success:function(response, opts) {
    try {
      var result = Ext.decode(response.responseText);
      if (result && result.success && result.data) {
        this.debug('Interior pano model values', result);
        this.setModelValues(result.data);
      } else {
        throw new Error(mvstr['SW360_Failed to set up Site'] + ': ' + (result ? result.message : mvstr['G_UnexpectedError']));
      }
    } catch (ex) {
      this.error(ex.message);
      Ext.Msg.alert(mvstr['G_Error'], ex.message);
    }
  }, failure:function(response) {
    this.error(arguments);
    Ext.Msg.alert(mvstr['G_Error'], mvstr['SW360_Failed to set up Site']);
    this.clearFloorplan();
    this.clearModels();
  }, scope:this});
}, setModelValues:function(data) {
  this.debug('Loaded TruView/Matterport details', data);
  var vm = this.getViewModel();
  var isTruView = !!data.isTruView;
  var viewModeChanged = vm.get('photoState.isTruView') !== isTruView;
  vm.set('photoState.isTruView', isTruView);
  if (isTruView) {
    this.setTruViewModel(data.truViewModel);
    this.setPrimaryModelIsTruView(true);
    if (!viewModeChanged) {
      this.setupTruView(data.truViewModel);
    }
    this.setMatterportModel(data.matterportModel || null);
    vm.set('hasMatterportAndTruView', data.matterportModel != null);
  } else {
    this.setMatterportModel(data.matterportModel);
    this.setPrimaryModelIsTruView(false);
    this.setupMatterportFrame(data.matterportModel);
    this.setTruViewModel(data.truViewModel || null);
    vm.set('hasMatterportAndTruView', data.truViewModel != null);
  }
}, setupMatterportFrame:function(data, selectedUuid) {
  var photoViewer = Ext.ComponentQuery.query('photoviewer')[0];
  if (!photoViewer) {
    return this.setupMatterportFrame2(data, selectedUuid);
  }
  if (this.matterportScriptLoaded) {
    return this.setupMatterportFrame2(data, selectedUuid);
  }
  photoViewer.setLoading(true);
  Ext.Loader.loadScript({url:'https://static.matterport.com/showcase-sdk/1.2.0-0-g1d0799d/sdk.js', onLoad:function() {
    this.matterportScriptLoaded = true;
    photoViewer.setLoading(false);
    this.setupMatterportFrame(data, selectedUuid);
  }, scope:this});
}, setupMatterportFrame2:function(data, selectedUuid) {
  Ext.Loader.loadScript({url:'https://static.matterport.com/showcase-sdk/1.2.0-0-g1d0799d/sdk.js'});
  var modelId = data.modelId;
  var modelStart = data.modelStart;
  if (!selectedUuid && modelStart && modelStart.uuid) {
    selectedUuid = modelStart.uuid;
  }
  var vm = this.getViewModel();
  var modelChanged = true;
  var currentModelId = this.getCurrentModelId();
  if (currentModelId == modelId) {
    this.debug('Matterport model already loaded: ' + modelId);
    modelChanged = false;
  }
  if (modelChanged) {
    this.showcaseSDK.clear();
  }
  this.debug('Matterport floorplan theta', data.floorplanTheta);
  this.setFloorplanTheta(data.floorplanTheta);
  var needToAddPanoMarkers = false;
  if (data.panos) {
    if (this.getPanos().length === 0) {
      needToAddPanoMarkers = true;
    }
    this.setPanos(data.panos);
  }
  var rotation = this.getCurrentRotation();
  if (modelStart && modelStart.hasOwnProperty('camera_quaternion')) {
    rotation = this.quaternionToEulerAngles(modelStart.camera_quaternion);
    this.setCurrentRotation(rotation);
    this.debug('Starting rotation', rotation);
  }
  if (modelChanged) {
    this.displayPanoMarkersOnFloorplan(selectedUuid);
    this.debug('Loading new Matterport model: ' + currentModelId + ' -\x3e ' + modelId);
    this.showcaseSDK.addInteriorPanoIframeLoadListener(this.getInteriorPanoFrame());
    vm.set('interiorPanoUrl', data.url);
    this.setCurrentModelId(data.modelId);
    this.setActivePano(this.getPanoFromUuid(selectedUuid));
  } else {
    if (needToAddPanoMarkers) {
      this.displayPanoMarkersOnFloorplan(selectedUuid);
    }
    if (selectedUuid) {
      this.showcaseSDK.moveToPano(selectedUuid, rotation, this.showcaseSDK.getInstantTransition());
    }
    this.getInteriorPanoFrame().focus();
  }
}, getInteriorPanoFrame:function() {
  return document.getElementById('interiorPanoFrame-iframeEl');
}, showcaseConnected:function(on) {
  this.debug('Showcase connected', on);
  this.setViewerReady(on);
  this.updateDirectionMarkerOnFloorplan();
  this.fireEvent('showcaseconnected', on);
}, initialPanosLoaded:function(panos) {
  var activePano = this.getActivePano();
  if (activePano) {
    this.showcaseSDK.moveToPano(activePano.uuid, this.getCurrentRotation(), this.showcaseSDK.getInstantTransition());
    this.updateDirectionMarkerOnFloorplan();
    this.panToMarker(activePano.x, activePano.y, false);
  } else {
    this.showcaseSDK.getPose().then(function(pose) {
      if (pose && pose.rotation && pose.sweep) {
        this.rotationChanged(pose.rotation, pose.sweep);
        var activePano = this.getActivePano();
        if (activePano) {
          this.panToMarker(activePano.x, activePano.y, false);
        }
        this.logViewPhotoEvent();
      }
      return pose;
    }.bind(this));
  }
}, setupTruView:function(data, selectedUuid) {
  var photoViewer = Ext.ComponentQuery.query('photoviewer')[0];
  if (!photoViewer) {
    return this.setupTruView2(data, selectedUuid);
  }
  if (this.truViewViewerScriptLoaded && this.truViewMapScriptLoaded) {
    return this.setupTruView2(data, selectedUuid);
  }
  photoViewer.setLoading(true);
  Ext.Loader.loadScript({url:'https://multivista.truView-cloud.com/scripts/dist/viewer.js', onLoad:function() {
    this.truViewViewerScriptLoaded = true;
    if (this.truViewMapScriptLoaded) {
      this.setupTruView(data, selectedUuid);
    }
  }, scope:this});
  Ext.Loader.loadScript({url:'https://multivista.truView-cloud.com/scripts/dist/map.js', onLoad:function() {
    this.truViewMapScriptLoaded = true;
    if (this.truViewViewerScriptLoaded) {
      this.setupTruView(data, selectedUuid);
    }
  }, scope:this});
}, setupTruView2:function(data, selectedUuid) {
  var scanUuid = selectedUuid || data.scanUuid;
  var modelChanged = true;
  var currentScanUuid = this.getCurrentScanUuid();
  if (scanUuid && currentScanUuid == scanUuid) {
    this.debug('TruView scan already loaded: ' + scanUuid);
    modelChanged = false;
  }
  this.setFloorplanTheta(data.floorplanTheta);
  var needToAddPanoMarkers = false;
  if (data.panos) {
    if (this.getPanos().length === 0) {
      needToAddPanoMarkers = true;
    }
    this.setPanos(data.panos);
  }
  if (modelChanged) {
    this.setCurrentScanUuid(scanUuid);
    this.displayPanoMarkersOnFloorplan(scanUuid);
    this.debug('Loading new TruView scan:', scanUuid);
    this.loadTruViewScan(scanUuid);
  } else {
    if (needToAddPanoMarkers) {
      this.displayPanoMarkersOnFloorplan(scanUuid);
      this.logViewPhotoEvent();
    }
  }
}, loadTruViewScan:function(scanUuid) {
  this.setViewerReady(false);
  this.setTruView(true);
  this.truViewSDK.showScanViewer('truViewComponent', scanUuid, this.getCurrentRotation(), this.useImperial());
}, truViewScanViewerReady:function(viewer, err) {
  if (err) {
    this.error('Failed to load TruView Viewer', err);
    return;
  }
  this.debug('TruView viewer ready', viewer);
  this.setViewerReady(true);
  this.updateDirectionMarkerOnFloorplan();
  this.logViewPhotoEvent();
}, panoSelected:function(uuid) {
  this.selectPanoByUuid(uuid, false, true);
}, rotationChanged:function(rotation, uuid) {
  var pano = this.getActivePano();
  if (pano && pano.uuid === uuid) {
    this.setCurrentRotation(rotation);
    this.updateDirectionMarkerOnFloorplan();
  }
}, getPanoFromUuid:function(panoUuid) {
  if (panoUuid) {
    var panos = this.getPanos();
    for (var i = 0; i < panos.length; i++) {
      var pano = panos[i];
      if (pano.uuid == panoUuid) {
        return pano;
      }
    }
  }
  return null;
}, selectPanoInViewer:function(uuid, rotation, transition) {
  rotation = rotation || this.getCurrentRotation();
  if (rotation != null) {
    this.setCurrentRotation(rotation);
  }
  if (this.isTruView()) {
    this.loadTruViewScan(uuid);
  } else {
    this.showcaseSDK.moveToPano(uuid, rotation, transition);
  }
}, selectPano:function(pano, selectInViewer, panMarker, force) {
  var oldPano = this.getFloorplan().map ? this.getFloorplan().map.activePano : null;
  if (pano != oldPano || force) {
    var markersMap = this.getPanoMarkersMap();
    if (oldPano) {
      this.removeMarkerClass(markersMap[oldPano.uuid], 'active');
    }
    this.setActivePano(pano);
    if (this.map) {
      this.map.activePano = pano;
    }
    if (pano) {
      this.addMarkerClass(markersMap[pano.uuid], 'active');
      var floorplan = this.getFloorplan();
      if (floorplan.highlightLayer) {
        floorplan.highlightLayer.clearLayers();
      }
      if (selectInViewer) {
        var rotation = pano.rotation ? this.quaternionToEulerAngles(pano.rotation) : null;
        this.selectPanoInViewer(pano.uuid, rotation);
      }
      this.updateDirectionMarkerOnFloorplan();
      this.panToMarker(pano.x, pano.y, panMarker);
    }
  }
}, selectPanoByUuid:function(uuid, selectInViewer, panMarker) {
  var newPano = this.getPanoFromUuid(uuid);
  this.selectPano(newPano, selectInViewer, panMarker);
  return newPano;
}, getFloorplan:function() {
  return Ext.ComponentQuery.query('photoviewer')[0].getController().getFloorplan();
}, displayPanoMarkersOnFloorplan:function(selectedUuid) {
  selectedUuid = selectedUuid || (this.getActivePano() ? this.getActivePano().uuid : null);
  var floorplan = this.getFloorplan();
  if (floorplan.map) {
    this.map = floorplan.map;
    if (!floorplan.hotspotsLoaded) {
      this.debug('Waiting for hotspots to be loaded...');
      floorplan.on({hotspotsLoaded:{fn:function() {
        this.displayPanoMarkersOnFloorplan(selectedUuid);
      }, scope:this, single:true}});
      return;
    }
    var panos = this.getPanos();
    this.debug('Displaying ' + panos.length + ' panos');
    var layer = this.createPanoLayer();
    var radius = this.getPanoMarkerRadius();
    this.setPanoMarkersMap({});
    for (var i = 0; i < panos.length; i++) {
      var pano = panos[i];
      var isActive = pano.uuid === selectedUuid;
      this.createPanoMarker(layer, pano, isActive, radius);
    }
  } else {
    this.debug('Floorplan not ready');
    floorplan.on({afterinitfloorplan:{fn:function() {
      this.displayPanoMarkersOnFloorplan(selectedUuid);
    }, scope:this, single:true}});
  }
}, createPanoMarker:function(layer, pano, isActive, radius) {
  var marker;
  if (pano.photoId > 0) {
    return;
  } else {
    marker = this.addPanoScanMarker(layer, pano.x, pano.y, {radius:radius, className:'panoMarker'});
    marker.scan = true;
  }
  marker.pano = pano;
  var markersMap = this.getPanoMarkersMap();
  markersMap[pano.uuid] = marker;
  if (isActive) {
    this.selectPano(pano, false, true, true);
  }
  this.addPanoMarkerEventListeners(marker);
  return marker;
}, addPanoMarkerEventListeners:function(marker) {
  marker.on('click', function(e) {
    var pano = e.target.pano;
    this.selectPano(pano, true);
  }, this);
  marker.on('mouseover', function(e) {
    marker.setRadius(this.getPanoMarkerRadius(true));
    marker.bringToFront();
  }, this);
  marker.on('mouseout', function(e) {
    marker.setRadius(this.getPanoMarkerRadius());
  }, this);
}, getDirectionMarker:function() {
  return this.getFloorplan().map ? this.getFloorplan().map.directionMarker : null;
}, setDirectionMarker:function(value) {
  var map = this.getFloorplan().map;
  if (map) {
    map.directionMarker = value;
  }
}, getPanoScanLayer:function() {
  return this.getFloorplan().map ? this.getFloorplan().map.panoScanLayer : null;
}, setPanoScanLayer:function(value) {
  var map = this.getFloorplan().map;
  if (map) {
    map.panoScanLayer = value;
  }
}, getDirectionArrow:function() {
  return this.getFloorplan().map ? this.getFloorplan().map.directionArrow : null;
}, setDirectionArrow:function(value) {
  var map = this.getFloorplan().map;
  if (map) {
    map.directionArrow = value;
  }
}, panoHasPhoto:function() {
  if (!this.getActivePano()) {
    return false;
  }
  if (!this.getPrimaryModelIsTruView() && this.isTruView() && this.getMatterportModel()) {
    var matterportMatch = this.findNearestPano(this.getActivePano(), this.getMatterportModel().panos);
    if (matterportMatch) {
      return !!matterportMatch.photoId;
    }
  } else {
    return !!this.getActivePano().photoId;
  }
  return false;
}, logViewPhotoEvent:function() {
  if (this.panoHasPhoto()) {
    if (this.isMatterport()) {
      analytics.Ctrl.log('Viewed Photo', {'Photo Type':'SW360'}, ['Photo ID', 'Photo ID with Prefix']);
    } else {
      analytics.Ctrl.log('Viewed Photo', {'Photo Type':'TruView'}, ['Photo ID', 'Photo ID with Prefix']);
    }
  }
}}, 0, 0, 0, 0, 0, [[siteWalk360.SW360Util.prototype.mixinId || siteWalk360.SW360Util.$className, siteWalk360.SW360Util], [SiteWalk360.FloorplanPanoUtil.prototype.mixinId || SiteWalk360.FloorplanPanoUtil.$className, SiteWalk360.FloorplanPanoUtil]], [photoViewer.controller, 'SiteWalk360Controller'], 0);
Ext.cmd.derive('photoViewer.model.Annotation', Ext.data.Model, {fields:[{name:'AnnotationUID', type:'string'}, {name:'Type', type:'string'}, {name:'Attr0', type:'auto', defaultValue:undefined}, {name:'Attr1', type:'auto', defaultValue:undefined}, {name:'Attr2', type:'auto', defaultValue:undefined}, {name:'Attr3', type:'auto', defaultValue:undefined}, {name:'Attr4', type:'auto', defaultValue:undefined}, {name:'Attr5', type:'auto', convert:function(value, record) {
  var type = record.get('Type');
  if (type && type.substr && type.substr(0, 4) == 'text') {
    return String(value);
  }
  return value;
}, depends:['Type'], persist:true}, {name:'Attr6', type:'auto', defaultValue:undefined}, {name:'Attr7', type:'auto', defaultValue:undefined}, {name:'Attr8', type:'auto', defaultValue:undefined}, {name:'Attr9', type:'auto', defaultValue:undefined}, {name:'Attr10', type:'auto', defaultValue:undefined}, {name:'Attr11', type:'auto', defaultValue:undefined}, {name:'Attr12', type:'auto', defaultValue:undefined, convert:function(v) {
  return v && isNaN(v) ? Number(v.match(/^\d+/)[0]) : v;
}}, {name:'ShareTypeID', type:'int', defaultValue:1}, {name:'MemberUIDArray', defaultValue:[]}, {name:'ReadOnly', type:'boolean', defaultValue:false}, {name:'Color', type:'string', calculate:function(data) {
  return data.Attr4;
}}, {name:'MemberFirstName', type:'string', persist:false}, {name:'MemberLastName', type:'string', persist:false}, {name:'Title'}, {name:'MemberInitials', calculate:function(data) {
  var values = [];
  if (data.MemberFirstName) {
    values.push(data.MemberFirstName.charAt(0).toUpperCase());
  }
  if (data.MemberLastName) {
    values.push(data.MemberLastName.charAt(0).toUpperCase());
  }
  return values.join('');
}}, {name:'MemberName', calculate:function(data) {
  return Ext.String.trim(data.MemberFirstName + ' ' + data.MemberLastName);
}}, {name:'Visible', type:'boolean', persist:false, defaultValue:true}, {name:'CanEdit', calculate:function(data) {
  return !data.ReadOnly;
}}, {name:'Length', calculate:function(data) {
  return data.Type == 'measure' && data.Attr7 ? Number(data.Attr7) : 0;
}}, {name:'MeasurementString', calculate:function(data) {
  if (data.Type != 'measure' || !data.Length) {
    return '';
  }
  if (data.IsMetric) {
    return '' + data.Length.toFixed(3) + 'm';
  }
  var feet = data.Length * 3.28084, flooredFeet = Math.floor(feet), inches = (feet - flooredFeet) * 12, inchesString = Math.inchesToString(inches, 32), stringParts = [];
  if (flooredFeet) {
    stringParts.push('' + flooredFeet + "'");
  }
  if (inchesString != '0' || !stringParts.length) {
    stringParts.push('' + inchesString + '"');
  }
  return stringParts.join(' ');
}}, {name:'TitleDisplayValue', calculate:function(data) {
  if (data.Type == 'measure') {
    var title = data.TitleDisplayName;
    if (data.MeasurementString) {
      return title + ' (' + data.MeasurementString + ')';
    } else {
      return mvstr['PM_Pending Measurement'];
    }
  }
  return data.Title;
}}, {name:'TitleDisplayName', calculate:function(data) {
  return data.Title || mvstr['PM_Measurement'];
}}, {name:'IsMetric', type:'boolean', persist:false}], idProperty:'AnnotationUID', setShape:function(shape) {
  this.shape = shape;
  shape.record = this;
  this.set('Type', shape.getType());
  this.updateFields();
  shape.addListener('datachanged', this.updateFields, this);
}, updateFields:function() {
  if (this.get('ReadOnly')) {
    return;
  }
  var suspendSync = this.store && this.store.getProxy().type != 'memory';
  if (suspendSync) {
    this.store.suspendAutoSync();
  }
  var changes = false;
  for (var i = 0; i < this.shape.shapeAttributes.length; i++) {
    if (Ext.Array.contains(this.shape.dataAttributes, this.shape.shapeAttributes[i])) {
      continue;
    }
    var attrName = 'Attr' + i, attrValue = this.shape.getAttribute(this.shape.shapeAttributes[i]);
    if (this.get(attrName) !== attrValue) {
      changes = true;
      this.set(attrName, attrValue);
    }
  }
  if (suspendSync) {
    this.store.resumeAutoSync(changes);
  }
}, destroy:function() {
  if (this.shape) {
    this.shape.destroy();
  }
}, redraw:function() {
  if (this.shape) {
    var drawComponent = this.shape.drawComponent;
    this.shape.destroy();
    this.createShape(drawComponent);
  }
}, createShape:function(drawComponent) {
  var config = {};
  config.model = this;
  config.drawComponent = drawComponent;
  var type = this.get('Type');
  var uppercaseType = type.substring(0, 1).toUpperCase() + type.substring(1);
  this.shape = Ext.create('photoViewer.view.annotations.shapes.' + uppercaseType, config);
  this.shape.addListener('datachanged', this.updateFields, this);
}, set:function(fieldName, newValue) {
  Ext.data.Model.prototype.set.apply(this, arguments);
  if (this.shape) {
    if (fieldName == 'Title') {
      this.shape.onTitleChange(newValue);
    } else {
      if (fieldName == 'IsMetric') {
        this.shape.onIsMetricChange(newValue);
      }
    }
  }
}, getRecordValueByAttrName:function(attrName) {
  return this.shape.getRecordValueByAttrName(attrName);
}, getAttrFieldName:function(attrName) {
  return this.shape.getAttrFieldName(attrName);
}, setAttr:function(attrName, value) {
  this.set(this.getAttrFieldName(attrName), value);
}, setAttrs:function(attrs) {
  var values = {};
  for (var attrName in attrs) {
    values[this.getAttrFieldName(attrName)] = attrs[attrName];
  }
  this.set(values);
}}, 0, 0, 0, 0, 0, 0, [photoViewer.model, 'Annotation'], 0);
Ext.cmd.derive('photoViewer.model.Timelapse', Ext.data.Model, {fields:[{name:'WebcamUID', type:'string'}, {name:'ArchivePositionID', type:'int'}, {name:'TimelapseURL', type:'string'}]}, 0, 0, 0, 0, 0, 0, [photoViewer.model, 'Timelapse'], 0);
Ext.cmd.derive('photoViewer.model.Webcam', Ext.data.Model, {fullWebcamData:null, PTZLimits:null, fields:[{name:'WebcamUID', type:'string'}, {name:'MostRecentPhotoDate', type:'tzadate'}, {name:'FirstPhotoDate', type:'tzadate'}, {name:'WebcamLabel', type:'string'}, {name:'WebcamIsStreaming', type:'int'}, {name:'TimelapseURL', type:'string'}, {name:'TimelapseIsAvailable', convert:function(value) {
  return value ? 1 : 0;
}}, {name:'PTZPresets'}, {name:'ArchivePositions'}], idProperty:'WebcamUID', getFullWebcamData:function(ProjectUID) {
  var webcamModel = this;
  var WebcamUID = webcamModel.get('WebcamUID');
  return new Ext.Promise(Ext.bind(function(resolve, reject) {
    if (webcamModel.fullWebcamData) {
      resolve(webcamModel.fullWebcamData);
    } else {
      mdsAjax.doAjaxRequest({url:'/index.cfm?fuseaction\x3daClientWebcam.getWebcam\x26ProjectUID\x3d' + ProjectUID + '\x26WebcamUID\x3d' + WebcamUID, successCallback:function(data) {
        data.ProjectUID = ProjectUID;
        data.WebcamUID = webcamModel.getId();
        webcamModel.fullWebcamData = data;
        resolve(webcamModel.fullWebcamData);
      }, afterFailMessageCallback:function() {
        reject();
      }, noResponseCallback:function() {
        Ext.Msg.alert('', 'Webcam is currently unavailable');
        reject();
      }, scope:webcamModel});
    }
  }, webcamModel));
}}, 0, 0, 0, 0, 0, 0, [photoViewer.model, 'Webcam'], 0);
Ext.cmd.derive('photoViewer.store.Annotations', Ext.data.Store, {model:'photoViewer.model.Annotation', autoSync:true, statics:{getDefaultAnnotationTitle:function(type, itemNumber) {
  return mvstr['PAN_' + type] + ' ' + itemNumber;
}}, constructor:function(config) {
  var store = this;
  this.config.proxy = {type:'jsonp', api:{create:'/index.cfm?fuseaction\x3daClientPhotoViewer.addAnnotations', read:'/index.cfm?fuseaction\x3daClientPhotoViewer.getAnnotations', update:'/index.cfm?fuseaction\x3daClientPhotoViewer.updateAnnotations', destroy:'/index.cfm?fuseaction\x3daClientPhotoViewer.deleteAnnotations'}, reader:{type:'json', rootProperty:'data', transform:{fn:function(data) {
    var typeCounts = {};
    for (var i = 0; i < data.data.length; i++) {
      var item = data.data[i];
      item.IsMetric = !!store.usingMetric;
      if (!item.Title) {
        var title;
        do {
          typeCounts[item.Type] = typeCounts[item.Type] ? typeCounts[item.Type] + 1 : 1;
          title = photoViewer.store.Annotations.getDefaultAnnotationTitle(item.Type, typeCounts[item.Type]);
        } while (store.isInDataOrStore(data.data, 'Title', title));
        item.Title = title;
      } else {
        item.HasDefaultTitle = false;
      }
    }
    return data;
  }, scope:store}}, writer:{writeAllFields:true}};
  store.callParent(arguments);
}, isInDataOrStore:function(data, fieldName, value) {
  if (this.findExact(fieldName, value) != -1) {
    return true;
  }
  for (var i = 0; i < data.length; i++) {
    if (data[i][fieldName] == value) {
      return true;
    }
  }
  return false;
}, sync:function(options) {
  options = options || {};
  options.silentSuccess = true;
  if (this.isSyncing) {
    if (this.syncListener) {
      this.syncListener.destroy();
    }
    this.syncListener = this.addListener('datachanged', Ext.bind(this.sync, this, [options]), this, {destroyable:true});
  } else {
    var photoWithType = this.getProxy().getExtraParams().photo, modifiedRecords = this.getModifiedRecords(), event = modifiedRecords.length ? 'Annotated Photo' : '';
    for (var i = 0; i < modifiedRecords.length; i++) {
      if (modifiedRecords[i].get('Type') == 'measure') {
        event = 'Saved New Measurement';
      }
    }
    if (event) {
      this.fireEvent('logevent', photoWithType, event);
    }
    Ext.data.Store.prototype.sync.call(this, options);
  }
}, destroyShapes:function() {
  this.each(function(rec) {
    if (rec.shape) {
      rec.shape.destroy();
    }
  });
}}, 1, 0, 0, 0, ['store.photoviewerannotations'], 0, [photoViewer.store, 'Annotations'], 0);
Ext.cmd.derive('photoViewer.store.ExifData', Ext.data.Store, {proxy:{type:'ajax', url:'/index.cfm?fuseaction\x3daClientPhotoViewer.getExifData', reader:{type:'json', rootProperty:'data'}}, fields:[{name:'name'}, {name:'description'}], tagFilter:new Ext.util.Filter({id:'tagFilter', filterFn:function(item) {
  var tagArray = ['photooriginaldate', 'photometeringmode', 'make', 'model', 'exposure comp', 'exposure program', 'iso', 'focusmode', 'focus mode', 'shootingmode', 'shooting mode', 'af type', 'afareamode', 'af-area mode', 'focallength', 'focal length', 'flash', 'shuttercount', 'shutter count', 'serialnumber', 'serial number', 'body serial number', 'camera serial number', 'quality', 'quality \x26 file format', 'whitebalance', 'white balance', 'copyright', 'artist', 'imagecomment', 'image comment'];
  return tagArray.indexOf(item.data.name.toLowerCase()) != -1;
}}), filterTags:function() {
  this.addFilter(this.tagFilter);
  this.refreshFilters();
}, unFilterTags:function() {
  this.removeFilter('tagFilter');
  this.refreshFilters();
}}, 0, 0, 0, 0, ['store.exifdata'], 0, [photoViewer.store, 'ExifData'], 0);
Ext.cmd.derive('photoViewer.store.Webcams', Ext.data.Store, {model:'photoViewer.model.Webcam', autoLoad:false, proxy:{type:'jsonp', url:'/index.cfm?fuseaction\x3daClientWebcam.getWebcams', reader:{type:'json', rootProperty:'data'}}}, 0, 0, 0, 0, ['store.pvwebcams'], 0, [photoViewer.store, 'Webcams'], 0);
Ext.cmd.derive('photoViewer.dd.DragDropManager', Ext.Base, {singleton:true, alternateClassName:['Ext.dd.DragDropMgr', 'Ext.dd.DDM'], ids:{}, handleIds:{}, dragCurrent:null, dragOvers:{}, deltaX:0, deltaY:0, preventDefault:true, stopPropagation:true, initialized:false, locked:false, init:function() {
  this.initialized = true;
}, POINT:0, INTERSECT:1, mode:0, notifyOccluded:false, dragCls:'x-dd-drag-current', _execOnAll:function(sMethod, args) {
  var ids = this.ids, i, j, oDD, item;
  for (i in ids) {
    if (ids.hasOwnProperty(i)) {
      item = ids[i];
      for (j in item) {
        if (item.hasOwnProperty(j)) {
          oDD = item[j];
          if (!this.isTypeOfDD(oDD)) {
            continue;
          }
          oDD[sMethod].apply(oDD, args);
        }
      }
    }
  }
}, addListeners:function() {
  var me = this;
  me.init();
  Ext.getDoc().on({mouseup:{fn:me.handleMouseUp, capture:false, priority:-1000}, mousemove:{fn:me.handleMouseMove, capture:false}, dragstart:me.preventDrag, drag:me.preventDrag, dragend:me.preventDrag, capture:true, scope:me});
  Ext.getWin().on({unload:me._onUnload, resize:me._onResize, scope:me});
}, preventDrag:function(e) {
  if (this.isMouseDown) {
    e.stopPropagation();
  }
}, _onResize:function(e) {
  this._execOnAll('resetConstraints', []);
}, lock:function() {
  this.locked = true;
}, unlock:function() {
  this.locked = false;
}, isLocked:function() {
  return this.locked;
}, locationCache:{}, useCache:true, clickPixelThresh:8, dragThreshMet:false, clickTimeout:null, startX:0, startY:0, regDragDrop:function(oDD, sGroup) {
  if (!this.initialized) {
    this.init();
  }
  if (!this.ids[sGroup]) {
    this.ids[sGroup] = {};
  }
  this.ids[sGroup][oDD.id] = oDD;
}, removeDDFromGroup:function(oDD, sGroup) {
  if (!this.ids[sGroup]) {
    this.ids[sGroup] = {};
  }
  var obj = this.ids[sGroup];
  if (obj && obj[oDD.id]) {
    delete obj[oDD.id];
  }
}, _remove:function(oDD, clearGroup) {
  var me = this, ids = me.ids, groups = oDD.groups, g;
  if (me.clearingAll) {
    return;
  }
  if (me.dragCurrent === oDD) {
    me.dragCurrent = null;
  }
  for (g in groups) {
    if (groups.hasOwnProperty(g)) {
      if (clearGroup) {
        delete ids[g];
      } else {
        if (ids[g]) {
          delete ids[g][oDD.id];
        }
      }
    }
  }
  delete me.handleIds[oDD.id];
  delete me.locationCache[oDD.id];
}, regHandle:function(sDDId, sHandleId) {
  if (!this.handleIds[sDDId]) {
    this.handleIds[sDDId] = {};
  }
  this.handleIds[sDDId][sHandleId] = sHandleId;
}, isDragDrop:function(id) {
  return this.getDDById(id) ? true : false;
}, getRelated:function(p_oDD, bTargetsOnly) {
  var oDDs = [], i, j, dd;
  for (i in p_oDD.groups) {
    for (j in this.ids[i]) {
      dd = this.ids[i][j];
      if (!this.isTypeOfDD(dd)) {
        continue;
      }
      if (!bTargetsOnly || dd.isTarget) {
        oDDs[oDDs.length] = dd;
      }
    }
  }
  return oDDs;
}, isLegalTarget:function(oDD, oTargetDD) {
  var targets = this.getRelated(oDD, true), i, len;
  for (i = 0, len = targets.length; i < len; ++i) {
    if (targets[i].id === oTargetDD.id) {
      return true;
    }
  }
  return false;
}, isTypeOfDD:function(oDD) {
  return oDD && oDD.__ygDragDrop;
}, isHandle:function(sDDId, sHandleId) {
  return this.handleIds[sDDId] && this.handleIds[sDDId][sHandleId];
}, getDDById:function(id, force) {
  var i, dd;
  for (i in this.ids) {
    dd = this.ids[i][id];
    if (dd instanceof photoViewer.dd.DDTarget || force) {
      return dd;
    }
  }
  return null;
}, handleMouseDown:function(e, oDD) {
  var me = this, xy, el;
  me.isMouseDown = true;
  if (Ext.quickTipsActive) {
    Ext.tip.QuickTipManager.ddDisable();
  }
  me.currentPoint = e.getPoint();
  if (me.dragCurrent) {
    me.handleMouseUp(e);
  }
  me.mousedownEvent = e;
  me.currentTarget = e.getTarget();
  me.dragCurrent = oDD;
  el = oDD.getEl();
  Ext.fly(el).setCapture();
  xy = e.getXY();
  me.startX = xy[0];
  me.startY = xy[1];
  me.offsetX = me.offsetY = 0;
  me.deltaX = me.startX - el.offsetLeft;
  me.deltaY = me.startY - el.offsetTop;
  me.dragThreshMet = false;
}, startDrag:function(x, y) {
  var me = this, current = me.dragCurrent, dragEl;
  clearTimeout(me.clickTimeout);
  if (current) {
    current.b4StartDrag(x, y);
    current.startDrag(x, y);
    dragEl = Ext.fly(current.getDragEl());
    if (dragEl) {
      dragEl.addCls(me.dragCls);
      if (dragEl.shim) {
        dragEl.shim.el.addCls(me.dragCls);
      }
    }
  }
  me.dragThreshMet = true;
}, handleMouseUp:function(e) {
  var me = this;
  me.isMouseDown = false;
  if (Ext.quickTipsActive) {
    Ext.tip.QuickTipManager.ddEnable();
  }
  if (!me.dragCurrent) {
    return;
  }
  if (Ext.isIE && document.releaseCapture) {
    document.releaseCapture();
  }
  clearTimeout(me.clickTimeout);
  if (me.dragThreshMet) {
    me.fireEvents(e, true);
  }
  me.stopDrag(e);
  if (me.dragThreshMet) {
    me.stopEvent(e);
  }
  me.mousedownEvent = me.currentTarget = null;
}, stopEvent:function(e) {
  if (this.stopPropagation) {
    e.stopPropagation();
  }
  if (this.preventDefault) {
    e.preventDefault();
  }
}, stopDrag:function(e) {
  var me = this, current = me.dragCurrent, dragEl;
  if (current) {
    if (me.dragThreshMet) {
      dragEl = Ext.fly(current.getDragEl());
      if (dragEl) {
        dragEl.removeCls(me.dragCls);
        if (dragEl.shim) {
          dragEl.shim.el.removeCls(me.dragCls);
        }
      }
      current.b4EndDrag(e);
      current.endDrag(e);
    }
    me.dragCurrent.onMouseUp(e);
  }
  me.dragCurrent = null;
  me.dragOvers = {};
}, handleMouseMove:function(e) {
  var me = this, current = me.dragCurrent, point = me.currentPoint = e.getPoint(), currentX = point.x, currentY = point.y, diffX, diffY;
  me.offsetX = currentX - me.startX;
  me.offsetY = currentY - me.startY;
  if (!current) {
    return true;
  }
  if (!me.dragThreshMet) {
    diffX = Math.abs(me.offsetX);
    diffY = Math.abs(me.offsetY);
    if (diffX > me.clickPixelThresh || diffY > me.clickPixelThresh) {
      me.startDrag(me.startX, me.startY);
    }
  }
  if (me.dragThreshMet) {
    current.b4Drag(e);
    current.onDrag(e);
    if (!current.moveOnly) {
      me.fireEvents(e, false);
    }
  }
  me.stopEvent(e);
  return true;
}, fireEvents:function(e, isDrop) {
  var me = this, isTouch = Ext.supports.Touch, dragCurrent = me.dragCurrent, mousePoint = me.currentPoint, currentX = mousePoint.x, currentY = mousePoint.y, allTargets = [], oldOvers = [], outEvts = [], overEvts = [], dropEvts = [], enterEvts = [], dragEl, overTarget, overTargetEl, needsSort, i, len, sGroup, overDragEl;
  if (!dragCurrent || dragCurrent.isLocked()) {
    return;
  }
  overDragEl = !(dragCurrent.deltaX < 0 || dragCurrent.deltaY < 0);
  if (isTouch || !me.notifyOccluded && (!Ext.supports.CSSPointerEvents || Ext.isIE10m || Ext.isOpera) && overDragEl) {
    dragEl = dragCurrent.getDragEl();
    if (overDragEl) {
      dragEl.style.visibility = 'hidden';
    }
    e.target = me.elementFromPoint(currentX, currentY) || document.documentElement;
    if (overDragEl) {
      dragEl.style.visibility = 'visible';
    }
  }
  for (i in me.dragOvers) {
    overTarget = me.dragOvers[i];
    delete me.dragOvers[i];
    if (!me.isTypeOfDD(overTarget) || overTarget.destroyed) {
      continue;
    }
    if (me.notifyOccluded) {
      if (!this.isOverTarget(mousePoint, overTarget, me.mode)) {
        outEvts.push(overTarget);
      }
    } else {
      if (!e.within(overTarget.getEl())) {
        outEvts.push(overTarget);
      }
    }
    oldOvers[i] = true;
  }
  for (sGroup in dragCurrent.groups) {
    if ('string' !== typeof sGroup) {
      continue;
    }
    for (i in me.ids[sGroup]) {
      overTarget = me.ids[sGroup][i];
      if (me.isTypeOfDD(overTarget) && (overTargetEl = overTarget.getEl()) && overTarget.isTarget && !overTarget.isLocked() && Ext.fly(overTargetEl).isVisible(true) && (overTarget !== dragCurrent || dragCurrent.ignoreSelf === false)) {
        if (me.notifyOccluded) {
          if ((overTarget.zIndex = me.getZIndex(overTargetEl)) !== -1) {
            needsSort = true;
          }
          allTargets.push(overTarget);
        } else {
          if (e.within(overTarget.getEl())) {
            allTargets.push(overTarget);
            break;
          }
        }
      }
    }
  }
  if (needsSort) {
    Ext.Array.sort(allTargets, me.byZIndex);
  }
  for (i = 0, len = allTargets.length; i < len; i++) {
    overTarget = allTargets[i];
    if (me.isOverTarget(mousePoint, overTarget, me.mode)) {
      if (isDrop) {
        dropEvts.push(overTarget);
      } else {
        if (!oldOvers[overTarget.id]) {
          enterEvts.push(overTarget);
        } else {
          overEvts.push(overTarget);
        }
        me.dragOvers[overTarget.id] = overTarget;
      }
      if (!me.notifyOccluded) {
        break;
      }
    }
  }
  if (me.mode) {
    if (outEvts.length) {
      dragCurrent.b4DragOut(e, outEvts);
      dragCurrent.onDragOut(e, outEvts);
    }
    if (enterEvts.length) {
      dragCurrent.onDragEnter(e, enterEvts);
    }
    if (overEvts.length) {
      dragCurrent.b4DragOver(e, overEvts);
      dragCurrent.onDragOver(e, overEvts);
    }
    if (dropEvts.length) {
      dragCurrent.b4DragDrop(e, dropEvts);
      dragCurrent.onDragDrop(e, dropEvts);
    }
  } else {
    for (i = 0, len = outEvts.length; i < len; ++i) {
      dragCurrent.b4DragOut(e, outEvts[i].id);
      dragCurrent.onDragOut(e, outEvts[i].id);
    }
    for (i = 0, len = enterEvts.length; i < len; ++i) {
      dragCurrent.onDragEnter(e, enterEvts[i].id);
    }
    for (i = 0, len = overEvts.length; i < len; ++i) {
      dragCurrent.b4DragOver(e, overEvts[i].id);
      dragCurrent.onDragOver(e, overEvts[i].id);
    }
    for (i = 0, len = dropEvts.length; i < len; ++i) {
      dragCurrent.b4DragDrop(e, dropEvts[i].id);
      dragCurrent.onDragDrop(e, dropEvts[i].id);
    }
  }
  if (isDrop && !dropEvts.length) {
    dragCurrent.onInvalidDrop(e);
  }
}, elementFromPoint:function(x, y) {
  if (Ext.rootInheritedState.rtl) {
    x = Ext.Element.getViewportWidth() - x;
  }
  return document.elementFromPoint(x, y);
}, getZIndex:function(element) {
  var body = document.body, z, zIndex = -1;
  element = Ext.getDom(element);
  while (element !== body) {
    if (!isNaN(z = Number(Ext.fly(element).getStyle('zIndex')))) {
      zIndex = z;
    }
    element = element.parentNode;
  }
  return zIndex;
}, byZIndex:function(d1, d2) {
  return d1.zIndex < d2.zIndex;
}, getBestMatch:function(dds) {
  var winner = null, len = dds.length, i, dd;
  if (len === 1) {
    winner = dds[0];
  } else {
    for (i = 0; i < len; ++i) {
      dd = dds[i];
      if (dd.cursorIsOver) {
        winner = dd;
        break;
      } else {
        if (!winner || winner.overlap.getArea() < dd.overlap.getArea()) {
          winner = dd;
        }
      }
    }
  }
  return winner;
}, refreshCache:function(groups) {
  var sGroup, i, oDD, loc;
  for (sGroup in groups) {
    if ('string' !== typeof sGroup) {
      continue;
    }
    for (i in this.ids[sGroup]) {
      oDD = this.ids[sGroup][i];
      if (this.isTypeOfDD(oDD)) {
        loc = this.getLocation(oDD);
        if (loc) {
          this.locationCache[oDD.id] = loc;
        } else {
          delete this.locationCache[oDD.id];
        }
      }
    }
  }
}, verifyEl:function(el) {
  return Ext.getBody().contains(el);
}, getLocation:function(oDD) {
  if (!this.isTypeOfDD(oDD)) {
    return null;
  }
  if (oDD.getRegion) {
    return oDD.getRegion();
  }
  var el = oDD.getEl(), pos, x1, x2, y1, y2, t, r, b, l;
  try {
    pos = Ext.fly(el).getXY();
  } catch (e$9) {
  }
  if (!pos) {
    return null;
  }
  x1 = pos[0];
  x2 = x1 + el.offsetWidth;
  y1 = pos[1];
  y2 = y1 + el.offsetHeight;
  t = y1 - oDD.padding[0];
  r = x2 + oDD.padding[1];
  b = y2 + oDD.padding[2];
  l = x1 - oDD.padding[3];
  return new Ext.util.Region(t, r, b, l);
}, isOverTarget:function(pt, oTarget, intersect) {
  var loc = this.locationCache[oTarget.id], dc, pos, el, curRegion, overlap;
  if (!loc || !this.useCache) {
    loc = this.getLocation(oTarget);
    this.locationCache[oTarget.id] = loc;
  }
  if (!loc) {
    return false;
  }
  oTarget.cursorIsOver = loc.contains(pt);
  dc = this.dragCurrent;
  if (!dc || !dc.getTargetCoord || !intersect && !dc.constrainX && !dc.constrainY) {
    return oTarget.cursorIsOver;
  }
  oTarget.overlap = null;
  pos = dc.getTargetCoord(pt.x, pt.y);
  el = dc.getDragEl();
  curRegion = new Ext.util.Region(pos.y, pos.x + el.offsetWidth, pos.y + el.offsetHeight, pos.x);
  overlap = curRegion.intersect(loc);
  if (overlap) {
    oTarget.overlap = overlap;
    return intersect ? true : oTarget.cursorIsOver;
  } else {
    return false;
  }
}, _onUnload:function(e, me) {
  photoViewer.dd.DragDropManager.unregAll();
}, unregAll:function() {
  var me = this, cache = me.elementCache, i;
  if (me.dragCurrent) {
    me.stopDrag();
    me.dragCurrent = null;
  }
  me.clearingAll = true;
  me._execOnAll('unreg', []);
  delete me.clearingAll;
  for (i in cache) {
    delete cache[i];
  }
  me.elementCache = {};
  me.ids = {};
  me.handleIds = {};
}, elementCache:{}, getElWrapper:function(id) {
  var oWrapper = this.elementCache[id];
  if (!oWrapper || !oWrapper.el) {
    oWrapper = this.elementCache[id] = new this.ElementWrapper(Ext.getDom(id));
  }
  return oWrapper;
}, getElement:function(id) {
  return Ext.getDom(id);
}, getCss:function(id) {
  var el = Ext.getDom(id);
  return el ? el.style : null;
}, ElementWrapper:function(el) {
  this.el = el || null;
  this.id = this.el && el.id;
  this.css = this.el && el.style;
}, getPosX:function(el) {
  return Ext.fly(el).getX();
}, getPosY:function(el) {
  return Ext.fly(el).getY();
}, swapNode:function(n1, n2) {
  if (n1.swapNode) {
    n1.swapNode(n2);
  } else {
    var p = n2.parentNode, s = n2.nextSibling;
    if (s === n1) {
      p.insertBefore(n1, n2);
    } else {
      if (n2 === n1.nextSibling) {
        p.insertBefore(n2, n1);
      } else {
        n1.parentNode.replaceChild(n2, n1);
        p.insertBefore(n1, s);
      }
    }
  }
}, getScroll:function() {
  var doc = window.document, docEl = doc.documentElement, body = doc.body, top = 0, left = 0;
  if (docEl && (docEl.scrollTop || docEl.scrollLeft)) {
    top = docEl.scrollTop;
    left = docEl.scrollLeft;
  } else {
    if (body) {
      top = body.scrollTop;
      left = body.scrollLeft;
    }
  }
  return {top:top, left:left};
}, getStyle:function(el, styleProp) {
  return Ext.fly(el).getStyle(styleProp);
}, getScrollTop:function() {
  return this.getScroll().top;
}, getScrollLeft:function() {
  return this.getScroll().left;
}, moveToEl:function(moveEl, targetEl) {
  var aCoord = Ext.fly(targetEl).getXY();
  Ext.fly(moveEl).setXY(aCoord);
}, numericSort:function(a, b) {
  return a - b;
}, handleWasClicked:function(node, id) {
  if (this.isHandle(id, node.id)) {
    return true;
  } else {
    var p = node.parentNode;
    while (p) {
      if (this.isHandle(id, p.id)) {
        return true;
      } else {
        p = p.parentNode;
      }
    }
  }
  return false;
}}, 0, 0, 0, 0, 0, 0, [photoViewer.dd, 'DragDropManager', Ext.dd, 'DragDropMgr', Ext.dd, 'DDM'], function(DragDropManager) {
  Ext.onInternalReady(function() {
    DragDropManager.addListeners();
  });
});
Ext.cmd.derive('photoViewer.dd.DragDrop', Ext.Base, {constructor:function(id, sGroup, config) {
  if (id) {
    this.init(id, sGroup, config);
  }
}, id:null, config:null, dragElId:null, handleElId:null, invalidHandleTypes:null, invalidHandleIds:null, invalidHandleClasses:null, startPageX:0, startPageY:0, groups:null, locked:false, lock:function() {
  this.locked = true;
}, moveOnly:false, unlock:function() {
  this.locked = false;
}, isTarget:true, padding:null, _domRef:null, __ygDragDrop:true, constrainX:false, constrainY:false, minX:0, maxX:0, minY:0, maxY:0, maintainOffset:false, xTicks:null, yTicks:null, primaryButtonOnly:true, available:false, hasOuterHandles:false, triggerEvent:'mousedown', b4StartDrag:function(x, y) {
}, startDrag:function(x, y) {
}, b4Drag:function(e) {
}, onDrag:function(e) {
}, onDragEnter:function(e, id) {
}, b4DragOver:function(e) {
}, onDragOver:function(e, id) {
}, b4DragOut:function(e) {
}, onDragOut:function(e, id) {
}, b4DragDrop:function(e) {
}, onDragDrop:function(e, id) {
}, onInvalidDrop:function(e) {
}, b4EndDrag:function(e) {
}, endDrag:function(e) {
}, b4MouseDown:function(e) {
}, onMouseDown:function(e) {
}, onMouseUp:function(e) {
}, onAvailable:function() {
}, defaultPadding:{left:0, right:0, top:0, bottom:0}, constrainTo:function(constrainTo, pad, inContent) {
  if (Ext.isNumber(pad)) {
    pad = {left:pad, right:pad, top:pad, bottom:pad};
  }
  pad = pad || this.defaultPadding;
  var ddBox = Ext.get(this.getEl()).getBox(), constrainEl = Ext.get(constrainTo), s = constrainEl.getScroll(), c, constrainDom = constrainEl.dom, xy, topSpace, leftSpace;
  if (constrainDom === document.body) {
    c = {x:s.left, y:s.top, width:Ext.Element.getViewportWidth(), height:Ext.Element.getViewportHeight()};
  } else {
    xy = constrainEl.getXY();
    c = {x:xy[0], y:xy[1], width:constrainDom.clientWidth, height:constrainDom.clientHeight};
  }
  topSpace = ddBox.y - c.y;
  leftSpace = ddBox.x - c.x;
  this.resetConstraints();
  this.setXConstraint(leftSpace - (pad.left || 0), c.width - leftSpace - ddBox.width - (pad.right || 0), this.xTickSize);
  this.setYConstraint(topSpace - (pad.top || 0), c.height - topSpace - ddBox.height - (pad.bottom || 0), this.yTickSize);
}, getEl:function() {
  if (!this._domRef) {
    this._domRef = Ext.getDom(this.id);
  }
  return this._domRef;
}, getDragEl:function() {
  return Ext.getDom(this.dragElId);
}, init:function(id, sGroup, config) {
  var me = this;
  me.el = me.el || Ext.get(id);
  me.initTarget(id, sGroup, config);
  Ext.get(me.id).on(me.triggerEvent, me.handleMouseDown, me);
  if (Ext.supports.Touch && me.triggerEvent === 'longpress') {
    Ext.get(me.id).swallowEvent('contextmenu', true);
  }
}, initTarget:function(id, sGroup, config) {
  this.config = config || {};
  this.DDMInstance = photoViewer.dd.DragDropManager;
  this.groups = {};
  if (typeof id !== 'string') {
    id = Ext.id(id);
  }
  this.id = id;
  this.addToGroup(sGroup ? sGroup : 'default');
  this.handleElId = id;
  this.setDragElId(id);
  this.invalidHandleTypes = {A:'A'};
  this.invalidHandleIds = {};
  this.invalidHandleClasses = [];
  this.applyConfig();
  this.handleOnAvailable();
}, applyConfig:function() {
  this.padding = this.config.padding || [0, 0, 0, 0];
  this.isTarget = this.config.isTarget !== false;
  this.maintainOffset = this.config.maintainOffset;
  this.primaryButtonOnly = this.config.primaryButtonOnly !== false;
}, handleOnAvailable:function() {
  this.available = true;
  this.resetConstraints();
  this.onAvailable();
}, setPadding:function(iTop, iRight, iBot, iLeft) {
  if (!iRight && 0 !== iRight) {
    this.padding = [iTop, iTop, iTop, iTop];
  } else {
    if (!iBot && 0 !== iBot) {
      this.padding = [iTop, iRight, iTop, iRight];
    } else {
      this.padding = [iTop, iRight, iBot, iLeft];
    }
  }
}, setInitPosition:function(diffX, diffY) {
  var el = this.getEl(), dx, dy, p;
  if (!this.DDMInstance.verifyEl(el)) {
    return;
  }
  dx = diffX || 0;
  dy = diffY || 0;
  p = Ext.fly(el).getXY();
  this.initPageX = p[0] - dx;
  this.initPageY = p[1] - dy;
  this.lastPageX = p[0];
  this.lastPageY = p[1];
  this.setStartPosition(p);
}, setStartPosition:function(pos) {
  var p = pos || Ext.fly(this.getEl()).getXY();
  this.deltaSetXY = null;
  this.startPageX = p[0];
  this.startPageY = p[1];
}, addToGroup:function(sGroup) {
  this.groups[sGroup] = true;
  this.DDMInstance.regDragDrop(this, sGroup);
}, removeFromGroup:function(sGroup) {
  if (this.groups[sGroup]) {
    delete this.groups[sGroup];
  }
  this.DDMInstance.removeDDFromGroup(this, sGroup);
}, setDragElId:function(id) {
  this.dragElId = id;
}, setHandleElId:function(id) {
  if (typeof id !== 'string') {
    id = Ext.id(id);
  }
  this.handleElId = id;
  this.DDMInstance.regHandle(this.id, id);
}, setOuterHandleElId:function(id) {
  if (typeof id !== 'string') {
    id = Ext.id(id);
  }
  Ext.get(id).on(this.triggerEvent, this.handleMouseDown, this);
  this.setHandleElId(id);
  this.hasOuterHandles = true;
}, unreg:function() {
  var me = this, el;
  if (me._domRef) {
    el = Ext.fly(me.id);
    if (el) {
      el.un(me.triggerEvent, me.handleMouseDown, me);
    }
  }
  me._domRef = null;
  me.DDMInstance._remove(me, me.autoGroup);
}, destroy:function() {
  this.unreg();
  this.callParent();
}, isLocked:function() {
  return this.DDMInstance.isLocked() || this.locked;
}, handleMouseDown:function(e, oDD) {
  var me = this;
  if (me.primaryButtonOnly && e.button || me.isLocked()) {
    return;
  }
  me.DDMInstance.refreshCache(me.groups);
  if (me.hasOuterHandles || me.DDMInstance.isOverTarget(e.getPoint(), me)) {
    if (me.clickValidator(e)) {
      me.setStartPosition();
      me.b4MouseDown(e);
      me.onMouseDown(e);
      me.DDMInstance.handleMouseDown(e, me);
      me.DDMInstance.stopEvent(e);
    }
  }
}, clickValidator:function(e) {
  var target = e.getTarget();
  return this.isValidHandleChild(target) && (this.id === this.handleElId || this.DDMInstance.handleWasClicked(target, this.id));
}, addInvalidHandleType:function(tagName) {
  var type = tagName.toUpperCase();
  this.invalidHandleTypes[type] = type;
}, addInvalidHandleId:function(id) {
  if (typeof id !== 'string') {
    id = Ext.id(id);
  }
  this.invalidHandleIds[id] = id;
}, addInvalidHandleClass:function(cssClass) {
  this.invalidHandleClasses.push(cssClass);
}, removeInvalidHandleType:function(tagName) {
  var type = tagName.toUpperCase();
  delete this.invalidHandleTypes[type];
}, removeInvalidHandleId:function(id) {
  if (typeof id !== 'string') {
    id = Ext.id(id);
  }
  delete this.invalidHandleIds[id];
}, removeInvalidHandleClass:function(cssClass) {
  var invalidHandleClasses = this.invalidHandleClasses, len = invalidHandleClasses.length, i;
  for (i = 0; i < len; ++i) {
    if (invalidHandleClasses[i] === cssClass) {
      delete invalidHandleClasses[i];
    }
  }
}, isValidHandleChild:function(node) {
  var valid = true, nodeName, i, len;
  try {
    nodeName = node.nodeName.toUpperCase();
  } catch (e$10) {
    nodeName = node.nodeName;
  }
  valid = valid && !this.invalidHandleTypes[nodeName];
  valid = valid && !this.invalidHandleIds[node.id];
  for (i = 0, len = this.invalidHandleClasses.length; valid && i < len; ++i) {
    valid = !Ext.fly(node).hasCls(this.invalidHandleClasses[i]);
  }
  return valid;
}, setXTicks:function(iStartX, iTickSize) {
  this.xTicks = [];
  this.xTickSize = iTickSize;
  var tickMap = {}, i;
  for (i = this.initPageX; i >= this.minX; i = i - iTickSize) {
    if (!tickMap[i]) {
      this.xTicks[this.xTicks.length] = i;
      tickMap[i] = true;
    }
  }
  for (i = this.initPageX; i <= this.maxX; i = i + iTickSize) {
    if (!tickMap[i]) {
      this.xTicks[this.xTicks.length] = i;
      tickMap[i] = true;
    }
  }
  Ext.Array.sort(this.xTicks, this.DDMInstance.numericSort);
}, setYTicks:function(iStartY, iTickSize) {
  this.yTicks = [];
  this.yTickSize = iTickSize;
  var tickMap = {}, i;
  for (i = this.initPageY; i >= this.minY; i = i - iTickSize) {
    if (!tickMap[i]) {
      this.yTicks[this.yTicks.length] = i;
      tickMap[i] = true;
    }
  }
  for (i = this.initPageY; i <= this.maxY; i = i + iTickSize) {
    if (!tickMap[i]) {
      this.yTicks[this.yTicks.length] = i;
      tickMap[i] = true;
    }
  }
  Ext.Array.sort(this.yTicks, this.DDMInstance.numericSort);
}, setXConstraint:function(iLeft, iRight, iTickSize) {
  this.leftConstraint = iLeft;
  this.rightConstraint = iRight;
  this.minX = this.initPageX - iLeft;
  this.maxX = this.initPageX + iRight;
  if (iTickSize) {
    this.setXTicks(this.initPageX, iTickSize);
  }
  this.constrainX = true;
}, clearConstraints:function() {
  this.constrainX = false;
  this.constrainY = false;
  this.clearTicks();
}, clearTicks:function() {
  this.xTicks = null;
  this.yTicks = null;
  this.xTickSize = 0;
  this.yTickSize = 0;
}, setYConstraint:function(iUp, iDown, iTickSize) {
  this.topConstraint = iUp;
  this.bottomConstraint = iDown;
  this.minY = this.initPageY - iUp;
  this.maxY = this.initPageY + iDown;
  if (iTickSize) {
    this.setYTicks(this.initPageY, iTickSize);
  }
  this.constrainY = true;
}, resetConstraints:function() {
  if (this.initPageX || this.initPageX === 0) {
    var dx = this.maintainOffset ? this.lastPageX - this.initPageX : 0, dy = this.maintainOffset ? this.lastPageY - this.initPageY : 0;
    this.setInitPosition(dx, dy);
  } else {
    this.setInitPosition();
  }
  if (this.constrainX) {
    this.setXConstraint(this.leftConstraint, this.rightConstraint, this.xTickSize);
  }
  if (this.constrainY) {
    this.setYConstraint(this.topConstraint, this.bottomConstraint, this.yTickSize);
  }
}, getTick:function(val, tickArray) {
  if (!tickArray) {
    return val;
  } else {
    if (tickArray[0] >= val) {
      return tickArray[0];
    } else {
      var i, len, next, diff1, diff2;
      for (i = 0, len = tickArray.length; i < len; ++i) {
        next = i + 1;
        if (tickArray[next] && tickArray[next] >= val) {
          diff1 = val - tickArray[i];
          diff2 = tickArray[next] - val;
          return diff2 > diff1 ? tickArray[i] : tickArray[next];
        }
      }
      return tickArray[tickArray.length - 1];
    }
  }
}, toString:function() {
  return 'DragDrop ' + this.id;
}}, 3, 0, 0, 0, 0, 0, [photoViewer.dd, 'DragDrop'], 0);
Ext.cmd.derive('photoViewer.dd.DD', photoViewer.dd.DragDrop, {constructor:function(id, sGroup, config) {
  if (id) {
    this.init(id, sGroup, config);
  }
}, scroll:true, autoOffset:function(iPageX, iPageY) {
  var x = iPageX - this.startPageX, y = iPageY - this.startPageY;
  this.setDelta(x, y);
}, setDelta:function(iDeltaX, iDeltaY) {
  this.deltaX = iDeltaX;
  this.deltaY = iDeltaY;
}, setDragElPos:function(iPageX, iPageY) {
  var el = this.getDragEl();
  this.alignElWithMouse(el, iPageX, iPageY);
}, alignElWithMouse:function(el, iPageX, iPageY) {
  var oCoord = this.getTargetCoord(iPageX, iPageY), fly = el.dom ? el : Ext.fly(el, '_dd'), elSize = fly.getSize(), EL = Ext.Element, vpSize, aCoord, newLeft, newTop;
  if (!this.deltaSetXY) {
    vpSize = this.cachedViewportSize = {width:EL.getDocumentWidth(), height:EL.getDocumentHeight()};
    aCoord = [Math.max(0, Math.min(oCoord.x, vpSize.width - elSize.width)), Math.max(0, Math.min(oCoord.y, vpSize.height - elSize.height))];
    fly.setXY(aCoord);
    newLeft = this.getLocalX(fly);
    newTop = fly.getLocalY();
    this.deltaSetXY = [newLeft - oCoord.x, newTop - oCoord.y];
  } else {
    vpSize = this.cachedViewportSize;
    this.setLocalXY(fly, Math.max(0, Math.min(oCoord.x + this.deltaSetXY[0], vpSize.width - elSize.width)), Math.max(0, Math.min(oCoord.y + this.deltaSetXY[1], vpSize.height - elSize.height)));
  }
  this.cachePosition(oCoord.x, oCoord.y);
  this.autoScroll(oCoord.x, oCoord.y, el.offsetHeight, el.offsetWidth);
  return oCoord;
}, cachePosition:function(iPageX, iPageY) {
  if (iPageX) {
    this.lastPageX = iPageX;
    this.lastPageY = iPageY;
  } else {
    var aCoord = Ext.fly(this.getEl()).getXY();
    this.lastPageX = aCoord[0];
    this.lastPageY = aCoord[1];
  }
}, autoScroll:function(x, y, h, w) {
  if (this.scroll) {
    var clientH = Ext.Element.getViewportHeight(), clientW = Ext.Element.getViewportWidth(), st = this.DDMInstance.getScrollTop(), sl = this.DDMInstance.getScrollLeft(), bot = h + y, right = w + x, toBot = clientH + st - y - this.deltaY, toRight = clientW + sl - x - this.deltaX, thresh = 40, scrAmt = document.all ? 80 : 30;
    if (bot > clientH && toBot < thresh) {
      window.scrollTo(sl, st + scrAmt);
    }
    if (y < st && st > 0 && y - st < thresh) {
      window.scrollTo(sl, st - scrAmt);
    }
    if (right > clientW && toRight < thresh) {
      window.scrollTo(sl + scrAmt, st);
    }
    if (x < sl && sl > 0 && x - sl < thresh) {
      window.scrollTo(sl - scrAmt, st);
    }
  }
}, getTargetCoord:function(iPageX, iPageY) {
  var x = iPageX - this.deltaX, y = iPageY - this.deltaY;
  if (this.constrainX) {
    if (x < this.minX) {
      x = this.minX;
    }
    if (x > this.maxX) {
      x = this.maxX;
    }
  }
  if (this.constrainY) {
    if (y < this.minY) {
      y = this.minY;
    }
    if (y > this.maxY) {
      y = this.maxY;
    }
  }
  x = this.getTick(x, this.xTicks);
  y = this.getTick(y, this.yTicks);
  return {x:x, y:y};
}, applyConfig:function() {
  photoViewer.dd.DragDrop.prototype.applyConfig.call(this);
  this.scroll = this.config.scroll !== false;
}, b4MouseDown:function(e) {
  var xy = e.getXY();
  this.autoOffset(xy[0], xy[1]);
}, b4Drag:function(e) {
  var xy = e.getXY();
  this.setDragElPos(xy[0], xy[1]);
}, toString:function() {
  return 'DD ' + this.id;
}, getLocalX:function(el) {
  return el.getLocalX();
}, setLocalXY:function(el, x, y) {
  el.setLocalXY(x, y);
}}, 3, 0, 0, 0, 0, 0, [photoViewer.dd, 'DD'], 0);
Ext.cmd.derive('photoViewer.dd.DDProxy', photoViewer.dd.DD, {statics:{dragElId:'ygddfdiv'}, constructor:function(id, sGroup, config) {
  if (id) {
    this.init(id, sGroup, config);
    this.initFrame();
  }
}, resizeFrame:true, centerFrame:false, createFrame:function() {
  var self = this, body = document.body, div, s;
  if (!body || !body.firstChild) {
    Ext.defer(function() {
      self.createFrame();
    }, 50);
    return;
  }
  div = this.getDragEl();
  if (!div) {
    div = document.createElement('div');
    div.id = this.dragElId;
    div.setAttribute('role', 'presentation');
    s = div.style;
    s.position = 'absolute';
    s.visibility = 'hidden';
    s.cursor = 'move';
    s.border = '2px solid #aaa';
    s.zIndex = 999;
    body.insertBefore(div, body.firstChild);
  }
}, initFrame:function() {
  this.createFrame();
}, applyConfig:function() {
  photoViewer.dd.DD.prototype.applyConfig.call(this);
  this.resizeFrame = this.config.resizeFrame !== false;
  this.centerFrame = this.config.centerFrame;
  this.setDragElId(this.config.dragElId || photoViewer.dd.DDProxy.dragElId);
}, showFrame:function(iPageX, iPageY) {
  var me = this, dragEl = me.getDragEl(), s = dragEl.style;
  me._resizeProxy();
  if (me.centerFrame) {
    me.setDelta(Math.round(parseInt(s.width, 10) / 2), Math.round(parseInt(s.height, 10) / 2));
  }
  me.setDragElPos(iPageX, iPageY);
  Ext.fly(dragEl).show();
}, _resizeProxy:function() {
  if (this.resizeFrame) {
    var el = this.getEl();
    Ext.fly(this.getDragEl()).setSize(el.offsetWidth, el.offsetHeight);
  }
}, b4MouseDown:function(e) {
  var xy = e.getXY(), x = xy[0], y = xy[1];
  this.autoOffset(x, y);
  this.setDragElPos(x, y);
}, b4StartDrag:function(x, y) {
  this.showFrame(x, y);
}, b4EndDrag:function(e) {
  Ext.fly(this.getDragEl()).hide();
}, endDrag:function(e) {
  var lel = this.getEl(), del = this.getDragEl();
  del.style.visibility = '';
  this.beforeMove();
  lel.style.visibility = 'hidden';
  Ext.dd.DDM.moveToEl(lel, del);
  del.style.visibility = 'hidden';
  lel.style.visibility = '';
  this.afterDrag();
}, beforeMove:function() {
}, afterDrag:function() {
}, toString:function() {
  return 'DDProxy ' + this.id;
}}, 3, 0, 0, 0, 0, 0, [photoViewer.dd, 'DDProxy'], 0);
Ext.cmd.derive('photoViewer.dd.DDTarget', photoViewer.dd.DragDrop, {constructor:function(id, sGroup, config) {
  if (id) {
    this.initTarget(id, sGroup, config);
  }
}, getDragEl:Ext.emptyFn, isValidHandleChild:Ext.emptyFn, startDrag:Ext.emptyFn, endDrag:Ext.emptyFn, onDrag:Ext.emptyFn, onDragDrop:Ext.emptyFn, onDragEnter:Ext.emptyFn, onDragOut:Ext.emptyFn, onDragOver:Ext.emptyFn, onInvalidDrop:Ext.emptyFn, onMouseDown:Ext.emptyFn, onMouseUp:Ext.emptyFn, setXConstraint:Ext.emptyFn, setYConstraint:Ext.emptyFn, resetConstraints:Ext.emptyFn, clearConstraints:Ext.emptyFn, clearTicks:Ext.emptyFn, setInitPosition:Ext.emptyFn, setDragElId:Ext.emptyFn, setHandleElId:Ext.emptyFn, 
setOuterHandleElId:Ext.emptyFn, addInvalidHandleClass:Ext.emptyFn, addInvalidHandleId:Ext.emptyFn, addInvalidHandleType:Ext.emptyFn, removeInvalidHandleClass:Ext.emptyFn, removeInvalidHandleId:Ext.emptyFn, removeInvalidHandleType:Ext.emptyFn, toString:function() {
  return 'DDTarget ' + this.id;
}}, 3, 0, 0, 0, 0, 0, [photoViewer.dd, 'DDTarget'], 0);
Ext.cmd.derive('photoViewer.dd.StatusProxy', Ext.Component, {animRepair:false, childEls:['ghost'], renderTpl:['\x3cdiv class\x3d"x-dd-drop-icon" role\x3d"presentation"\x3e\x3c/div\x3e\x3cdiv id\x3d"{id}-ghost" data-ref\x3d"ghost" class\x3d"x-dd-drag-ghost" role\x3d"presentation"\x3e\x3c/div\x3e'], repairCls:'x-dd-drag-repair', ariaRole:'presentation', skipLayout:true, alignOnScroll:false, constructor:function(config) {
  var me = this;
  config = config || {};
  Ext.apply(me, {hideMode:'visibility', hidden:true, floating:true, id:me.id || Ext.id(), cls:'x-dd-drag-proxy ' + this.dropNotAllowed, shadow:config.shadow || false, renderTo:Ext.getDetachedBody()});
  Ext.Component.prototype.constructor.apply(this, arguments);
  this.dropStatus = this.dropNotAllowed;
}, dropAllowed:'x-dd-drop-ok', dropNotAllowed:'x-dd-drop-nodrop', setStatus:function(cssClass) {
  cssClass = cssClass || this.dropNotAllowed;
  if (this.dropStatus !== cssClass) {
    this.el.replaceCls(this.dropStatus, cssClass);
    this.dropStatus = cssClass;
  }
}, reset:function(clearGhost) {
  var me = this, clsPrefix = 'x-dd-drag-proxy ';
  me.el.replaceCls(clsPrefix + me.dropAllowed, clsPrefix + me.dropNotAllowed);
  me.dropStatus = me.dropNotAllowed;
  if (clearGhost) {
    me.ghost.setHtml('');
  }
}, update:function(html) {
  if (typeof html === 'string') {
    this.ghost.setHtml(html);
  } else {
    this.ghost.setHtml('');
    html.style.margin = '0';
    this.ghost.dom.appendChild(html);
  }
  var el = this.ghost.dom.firstChild;
  if (el) {
    Ext.fly(el).setStyle('float', 'none');
  }
}, getGhost:function() {
  return this.ghost;
}, hide:function(clear) {
  Ext.Component.prototype.hide.call(this);
  if (clear) {
    this.reset(true);
  }
}, stop:function() {
  if (this.anim && this.anim.isAnimated && this.anim.isAnimated()) {
    this.anim.stop();
  }
}, sync:function() {
  this.el.syncUnderlays();
}, repair:function(xy, callback, scope) {
  var me = this;
  me.callback = callback;
  me.scope = scope;
  if (xy && me.animRepair !== false) {
    me.el.addCls(me.repairCls);
    me.el.setUnderlaysVisible(false);
    me.anim = me.el.animate({duration:me.repairDuration || 500, easing:'ease-out', to:{x:xy[0], y:xy[1]}, stopAnimation:true, callback:me.afterRepair, scope:me});
  } else {
    me.afterRepair();
  }
}, afterRepair:function() {
  var me = this;
  me.hide(true);
  me.el.removeCls(me.repairCls);
  if (typeof me.callback === 'function') {
    me.callback.call(me.scope || me);
  }
  delete me.callback;
  delete me.scope;
}}, 1, 0, ['component', 'box'], {'component':true, 'box':true}, 0, 0, [photoViewer.dd, 'StatusProxy'], 0);
Ext.cmd.derive('photoViewer.dd.DragSource', photoViewer.dd.DDProxy, {dropAllowed:'x-dd-drop-ok', dropNotAllowed:'x-dd-drop-nodrop', animRepair:true, repairHighlightColor:'c3daf9', constructor:function(el, config) {
  this.el = Ext.get(el);
  if (!this.dragData) {
    this.dragData = {};
  }
  Ext.apply(this, config);
  if (!this.proxy) {
    this.proxy = new photoViewer.dd.StatusProxy({id:this.el.id + '-drag-status-proxy', animRepair:this.animRepair});
  }
  photoViewer.dd.DDProxy.prototype.constructor.call(this, this.el.dom, this.ddGroup || this.group, {dragElId:this.proxy.id, resizeFrame:false, isTarget:false, scroll:this.scroll === true});
  this.dragging = false;
}, getDragData:function(e) {
  return this.dragData;
}, onDragEnter:function(e, id) {
  var target = photoViewer.dd.DragDropManager.getDDById(id), status;
  this.cachedTarget = target;
  if (this.beforeDragEnter(target, e, id) !== false) {
    if (target.isNotifyTarget) {
      status = target.notifyEnter(this, e, this.dragData);
      this.proxy.setStatus(status);
    } else {
      this.proxy.setStatus(this.dropAllowed);
    }
    if (this.afterDragEnter) {
      this.afterDragEnter(target, e, id);
    }
  }
}, beforeDragEnter:function(target, e, id) {
  return true;
}, onDragOver:function(e, id) {
  var target = this.cachedTarget || photoViewer.dd.DragDropManager.getDDById(id), status;
  if (this.beforeDragOver(target, e, id) !== false) {
    if (target.isNotifyTarget) {
      status = target.notifyOver(this, e, this.dragData);
      this.proxy.setStatus(status);
    }
    if (this.afterDragOver) {
      this.afterDragOver(target, e, id);
    }
  }
}, beforeDragOver:function(target, e, id) {
  return true;
}, onDragOut:function(e, id) {
  var target = this.cachedTarget || photoViewer.dd.DragDropManager.getDDById(id);
  if (this.beforeDragOut(target, e, id) !== false) {
    if (target.isNotifyTarget) {
      target.notifyOut(this, e, this.dragData);
    }
    this.proxy.reset();
    if (this.afterDragOut) {
      this.afterDragOut(target, e, id);
    }
  }
  this.cachedTarget = null;
}, beforeDragOut:function(target, e, id) {
  return true;
}, onDragDrop:function(e, id) {
  var target = this.cachedTarget || photoViewer.dd.DragDropManager.getDDById(id);
  if (this.beforeDragDrop(target, e, id) !== false) {
    if (target.isNotifyTarget) {
      if (target.notifyDrop(this, e, this.dragData) !== false) {
        this.onValidDrop(target, e, id);
      } else {
        this.onInvalidDrop(target, e, id);
      }
    } else {
      this.onValidDrop(target, e, id);
    }
    if (this.afterDragDrop) {
      this.afterDragDrop(target, e, id);
    }
  }
  delete this.cachedTarget;
}, beforeDragDrop:function(target, e, id) {
  return true;
}, onValidDrop:function(target, e, id) {
  this.hideProxy();
  if (this.afterValidDrop) {
    this.afterValidDrop(target, e, id);
  }
}, getRepairXY:function(e, data) {
  return this.el.getXY();
}, onInvalidDrop:function(target, e, id) {
  var me = this;
  if (!e) {
    e = target;
    target = null;
    id = e.getTarget().id;
  }
  if (me.beforeInvalidDrop(target, e, id) !== false) {
    if (me.cachedTarget) {
      if (me.cachedTarget.isNotifyTarget) {
        me.cachedTarget.notifyOut(me, e, me.dragData);
      }
      me.cacheTarget = null;
    }
    me.proxy.repair(me.getRepairXY(e, me.dragData), me.afterRepair, me);
    if (me.afterInvalidDrop) {
      me.afterInvalidDrop(e, id);
    }
  }
}, afterRepair:function() {
  var me = this;
  if (Ext.enableFx) {
    me.el.highlight(me.repairHighlightColor);
  }
  me.dragging = false;
}, beforeInvalidDrop:function(target, e, id) {
  return true;
}, handleMouseDown:function(e) {
  if (this.dragging) {
    return;
  }
  var data = this.getDragData(e);
  if (data && this.onBeforeDrag(data, e) !== false) {
    this.dragData = data;
    this.proxy.stop();
    photoViewer.dd.DDProxy.prototype.handleMouseDown.apply(this, arguments);
  }
}, onBeforeDrag:function(data, e) {
  return true;
}, onStartDrag:Ext.emptyFn, alignElWithMouse:function() {
  this.proxy.ensureAttachedToBody(true);
  return photoViewer.dd.DDProxy.prototype.alignElWithMouse.apply(this, arguments);
}, startDrag:function(x, y) {
  this.proxy.reset();
  this.proxy.hidden = false;
  this.dragging = true;
  this.proxy.update('');
  this.onInitDrag(x, y);
  this.proxy.show();
}, onInitDrag:function(x, y) {
  var clone = this.el.dom.cloneNode(true);
  clone.id = Ext.id();
  this.proxy.update(clone);
  this.onStartDrag(x, y);
  return true;
}, getProxy:function() {
  return this.proxy;
}, hideProxy:function() {
  this.proxy.hide();
  this.proxy.reset(true);
  this.dragging = false;
}, triggerCacheRefresh:function() {
  Ext.dd.DDM.refreshCache(this.groups);
}, b4EndDrag:function(e) {
}, endDrag:function(e) {
  this.onEndDrag(this.dragData, e);
}, onEndDrag:function(data, e) {
}, autoOffset:function(x, y) {
  this.setDelta(-12, -20);
}, destroy:function() {
  photoViewer.dd.DDProxy.prototype.destroy.call(this);
  Ext.destroy(this.proxy);
}}, 1, 0, 0, 0, 0, 0, [photoViewer.dd, 'DragSource'], 0);
Ext.cmd.derive('photoViewer.dd.DragTracker', Ext.Base, {active:false, trackOver:false, tolerance:5, autoStart:false, constructor:function(config) {
  var me = this;
  Ext.apply(me, config);
  me.dragRegion = new Ext.util.Region(0, 0, 0, 0);
  if (me.el) {
    me.initEl(me.el);
  }
  me.mixins.observable.constructor.call(me);
  if (me.disabled) {
    me.disable();
  }
}, initEl:function(el) {
  var me = this, delegate = me.delegate;
  me.el = el = Ext.get(el);
  if (delegate && delegate.isElement) {
    me.handle = delegate;
  }
  me.delegate = me.handle ? undefined : me.delegate;
  if (!me.handle) {
    me.handle = el;
  }
  me.handleListeners = {scope:me, delegate:me.delegate, mousedown:me.onMouseDown, dragstart:me.onDragStart};
  if (!Ext.supports.TouchEvents && (me.trackOver || me.overCls)) {
    Ext.apply(me.handleListeners, {mouseover:me.onMouseOver, mouseout:me.onMouseOut});
  }
  me.mon(me.handle, me.handleListeners);
  me.keyNav = new Ext.util.KeyNav({target:el, up:me.onResizeKeyDown, left:me.onResizeKeyDown, right:me.onResizeKeyDown, down:me.onResizeKeyDown, scope:me});
}, disable:function() {
  this.disabled = true;
}, enable:function() {
  this.disabled = false;
}, destroy:function() {
  var me = this;
  me.endDrag({});
  me.el = me.handle = me.onBeforeStart = me.onStart = me.onDrag = me.onEnd = me.onCancel = null;
  me.callParent();
}, onMouseOver:function(e, target) {
  var me = this, handleCls, el, i, len, cls;
  if (!me.disabled) {
    if (e.within(e.target, true, true) || me.delegate) {
      handleCls = me.handleCls;
      me.mouseIsOut = false;
      if (handleCls) {
        for (i = 0, len = me.handleEls.length; i < len; i++) {
          el = me.handleEls[i];
          cls = el.delegateCls;
          if (!cls) {
            cls = el.delegateCls = [handleCls, '-', el.region, '-over'].join('');
          }
          el.addCls([cls, me.overCls]);
        }
      }
      me.fireEvent('mouseover', me, e, me.delegate ? e.getTarget(me.delegate, target) : me.handle);
    }
  }
}, onMouseOut:function(e) {
  var me = this, el, i, len;
  if (me.mouseIsDown) {
    me.mouseIsOut = true;
  } else {
    if (me.handleCls) {
      for (i = 0, len = me.handleEls.length; i < len; i++) {
        el = me.handleEls[i];
        el.removeCls([el.delegateCls, me.overCls]);
      }
    }
    me.fireEvent('mouseout', me, e);
  }
}, onMouseDown:function(e, target) {
  var me = this;
  if (me.disabled || e.dragTracked) {
    return;
  }
  me.dragTarget = me.delegate ? target : me.handle.dom;
  me.startXY = me.lastXY = e.getXY();
  me.startRegion = Ext.fly(me.dragTarget).getRegion();
  if (me.fireEvent('mousedown', me, e) === false || me.fireEvent('beforedragstart', me, e) === false || me.onBeforeStart(e) === false) {
    return;
  }
  me.mouseIsDown = true;
  e.dragTracked = true;
  me.el.setCapture();
  e.stopPropagation();
  if (me.preventDefault !== false) {
    e.preventDefault();
  }
  Ext.getDoc().on({scope:me, capture:true, mouseup:me.onMouseUp, mousemove:me.onMouseMove, selectstart:me.stopSelect});
  me.dragEnded = false;
  if (!me.tolerance) {
    me.triggerStart();
  } else {
    if (me.autoStart) {
      me.timer = Ext.defer(me.triggerStart, me.autoStart === true ? 1000 : me.autoStart, me, [e]);
    }
  }
}, onMouseMove:function(e, target) {
  var me = this, xy = e.getXY(), s = me.startXY;
  e.stopPropagation();
  if (me.preventDefault !== false) {
    e.preventDefault();
  }
  if (me.dragEnded) {
    return;
  }
  me.lastXY = xy;
  if (!me.active) {
    if (Math.max(Math.abs(s[0] - xy[0]), Math.abs(s[1] - xy[1])) > me.tolerance) {
      me.triggerStart(e);
    } else {
      return;
    }
  }
  if (me.fireEvent('mousemove', me, e) === false) {
    me.onMouseUp(e);
  } else {
    me.onDrag(e);
    me.fireEvent('drag', me, e);
  }
}, onMouseUp:function(e) {
  var me = this;
  me.mouseIsDown = false;
  if (me.mouseIsOut) {
    me.mouseIsOut = false;
    me.onMouseOut(e);
  }
  if (me.preventDefault !== false) {
    e.preventDefault();
  }
  if (Ext.isIE && document.releaseCapture) {
    document.releaseCapture();
  }
  me.fireEvent('mouseup', me, e);
  me.endDrag(e);
}, endDrag:function(e) {
  var me = this, wasActive = me.active;
  Ext.getDoc().un({mousemove:me.onMouseMove, mouseup:me.onMouseUp, selectstart:me.stopSelect, capture:true, scope:me});
  me.clearStart();
  me.active = false;
  me.dragEnded = true;
  if (wasActive) {
    me.onEnd(e);
    me.fireEvent('dragend', me, e);
  } else {
    me.onCancel(e);
  }
  me._constrainRegion = null;
}, triggerStart:function(e) {
  var me = this;
  me.clearStart();
  me.active = true;
  me.onStart(e);
  me.fireEvent('dragstart', me, e);
}, clearStart:function() {
  var timer = this.timer;
  if (timer) {
    clearTimeout(timer);
    this.timer = null;
  }
}, stopSelect:function(e) {
  e.stopEvent();
  return false;
}, onBeforeStart:function(e) {
}, onStart:function(xy) {
}, onDrag:function(e) {
}, onCancel:function(e) {
}, onEnd:function(e) {
}, getDragTarget:function() {
  return this.dragTarget;
}, getDragCt:function() {
  return this.el;
}, getConstrainRegion:function() {
  var me = this;
  if (me.constrainTo) {
    if (me.constrainTo instanceof Ext.util.Region) {
      return me.constrainTo;
    }
    if (!me._constrainRegion) {
      me._constrainRegion = Ext.fly(me.constrainTo).getViewRegion();
    }
  } else {
    if (!me._constrainRegion) {
      me._constrainRegion = me.getDragCt().getViewRegion();
    }
  }
  return me._constrainRegion;
}, getXY:function(constrain) {
  return constrain ? this.constrainModes[constrain](this, this.lastXY) : this.lastXY;
}, getOffset:function(constrain) {
  var xy = this.getXY(constrain), s = this.startXY;
  return [xy[0] - s[0], xy[1] - s[1]];
}, onDragStart:function(e) {
  e.stopPropagation();
}, constrainModes:{point:function(me, xy) {
  var dr = me.dragRegion, constrainTo = me.getConstrainRegion();
  if (!constrainTo) {
    return xy;
  }
  dr.x = dr.left = dr[0] = dr.right = xy[0];
  dr.y = dr.top = dr[1] = dr.bottom = xy[1];
  dr.constrainTo(constrainTo);
  return [dr.left, dr.top];
}, dragTarget:function(me, xy) {
  var s = me.startXY, dr = me.startRegion.copy(), constrainTo = me.getConstrainRegion(), adjust;
  if (!constrainTo) {
    return xy;
  }
  dr.translateBy(xy[0] - s[0], xy[1] - s[1]);
  if (dr.right > constrainTo.right) {
    xy[0] += adjust = constrainTo.right - dr.right;
    dr.left += adjust;
  }
  if (dr.left < constrainTo.left) {
    xy[0] += constrainTo.left - dr.left;
  }
  if (dr.bottom > constrainTo.bottom) {
    xy[1] += adjust = constrainTo.bottom - dr.bottom;
    dr.top += adjust;
  }
  if (dr.top < constrainTo.top) {
    xy[1] += constrainTo.top - dr.top;
  }
  return xy;
}}}, 1, 0, 0, 0, 0, [['observable', Ext.util.Observable]], [photoViewer.dd, 'DragTracker'], 0);
Ext.cmd.derive('photoViewer.dd.DragZone', photoViewer.dd.DragSource, {constructor:function(el, config) {
  var me = this, scroll;
  photoViewer.dd.DragSource.prototype.constructor.call(this, el, config);
  scroll = me.containerScroll;
  if (scroll) {
    el = me.scrollEl || el;
    el = Ext.get(el);
    if (Ext.isObject(scroll)) {
      el.ddScrollConfig = scroll;
    }
    photoViewer.dd.ScrollManager.register(el);
  }
}, getDragData:function(e) {
  return photoViewer.dd.Registry.getHandleFromEvent(e);
}, onInitDrag:function(x, y) {
  this.proxy.update(this.dragData.ddel.cloneNode(true));
  this.onStartDrag(x, y);
  return true;
}, getRepairXY:function(e) {
  return Ext.fly(this.dragData.ddel).getXY();
}, destroy:function() {
  photoViewer.dd.DragSource.prototype.destroy.call(this);
  if (this.containerScroll) {
    photoViewer.dd.ScrollManager.unregister(this.scrollEl || this.el);
  }
}}, 1, 0, 0, 0, 0, 0, [photoViewer.dd, 'DragZone'], 0);
Ext.cmd.derive('photoViewer.dd.ScrollManager', Ext.Base, {singleton:true, dirTrans:{up:-1, left:-1, down:1, right:1}, constructor:function() {
  var ddm = photoViewer.dd.DragDropManager;
  ddm.fireEvents = Ext.Function.createSequence(ddm.fireEvents, this.onFire, this);
  ddm.stopDrag = Ext.Function.createSequence(ddm.stopDrag, this.onStop, this);
  this.doScroll = this.doScroll.bind(this);
  this.ddmInstance = ddm;
  this.els = {};
  this.dragEl = null;
  this.proc = {};
}, onStop:function(e) {
  var sm = photoViewer.dd.ScrollManager;
  sm.dragEl = null;
  sm.clearProc();
}, triggerRefresh:function() {
  if (this.ddmInstance.dragCurrent) {
    this.ddmInstance.refreshCache(this.ddmInstance.dragCurrent.groups);
  }
}, doScroll:function() {
  var me = this;
  if (me.ddmInstance.dragCurrent) {
    var proc = me.proc, procEl = proc.el, scrollComponent = proc.component, ddScrollConfig = proc.el.ddScrollConfig, distance = ddScrollConfig && ddScrollConfig.increment ? ddScrollConfig.increment : me.increment, animate = ddScrollConfig && 'animate' in ddScrollConfig ? ddScrollConfig.animate : me.animate, afterScroll = function() {
      me.triggerRefresh();
    };
    if (animate) {
      if (animate === true) {
        animate = {callback:afterScroll};
      } else {
        animate.callback = animate.callback ? Ext.Function.createSequence(animate.callback, afterScroll) : afterScroll;
      }
    }
    if (scrollComponent) {
      distance = distance * me.dirTrans[proc.dir];
      if (proc.dir === 'up' || proc.dir === 'down') {
        scrollComponent.scrollBy(0, distance, animate);
      } else {
        scrollComponent.scrollBy(distance, 0, animate);
      }
    } else {
      procEl.scroll(proc.dir, distance, animate);
    }
    if (!animate) {
      afterScroll();
    }
  }
}, clearProc:function() {
  var proc = this.proc;
  if (proc.id) {
    clearInterval(proc.id);
  }
  proc.id = 0;
  proc.el = null;
  proc.dir = '';
}, startProc:function(el, dir) {
  var me = this, proc = me.proc, group, freq;
  me.clearProc();
  proc.el = el;
  proc.dir = dir;
  group = el.ddScrollConfig ? el.ddScrollConfig.ddGroup : undefined;
  freq = el.ddScrollConfig && el.ddScrollConfig.frequency ? el.ddScrollConfig.frequency : me.frequency;
  if (group === undefined || me.ddmInstance.dragCurrent.ddGroup === group) {
    proc.id = Ext.interval(me.doScroll, freq);
  }
}, onFire:function(e, isDrop) {
  var me = this, pt, proc, els, id, el, elementRegion, configSource;
  if (isDrop || !me.ddmInstance.dragCurrent) {
    return;
  }
  if (!me.dragEl || me.dragEl !== me.ddmInstance.dragCurrent) {
    me.dragEl = me.ddmInstance.dragCurrent;
    me.refreshCache();
  }
  pt = e.getPoint();
  proc = me.proc;
  els = me.els;
  for (id in els) {
    el = els[id];
    elementRegion = el._region;
    configSource = el.ddScrollConfig || me;
    if (elementRegion && elementRegion.contains(pt) && el.isScrollable()) {
      if (elementRegion.bottom - pt.y <= configSource.vthresh) {
        if (proc.el !== el) {
          me.startProc(el, 'down');
        }
        return;
      } else {
        if (elementRegion.right - pt.x <= configSource.hthresh) {
          if (proc.el !== el) {
            me.startProc(el, 'right');
          }
          return;
        } else {
          if (pt.y - elementRegion.top <= configSource.vthresh) {
            if (proc.el !== el) {
              me.startProc(el, 'up');
            }
            return;
          } else {
            if (pt.x - elementRegion.left <= configSource.hthresh) {
              if (proc.el !== el) {
                me.startProc(el, 'left');
              }
              return;
            }
          }
        }
      }
    }
  }
  me.clearProc();
}, register:function(el) {
  if (Ext.isArray(el)) {
    for (var i = 0, len = el.length; i < len; i++) {
      this.register(el[i]);
    }
  } else {
    el = Ext.get(el);
    this.els[el.id] = el;
  }
}, unregister:function(el) {
  if (Ext.isArray(el)) {
    for (var i = 0, len = el.length; i < len; i++) {
      this.unregister(el[i]);
    }
  } else {
    el = Ext.get(el);
    delete this.els[el.id];
  }
}, vthresh:25 * (window.devicePixelRatio || 1), hthresh:25 * (window.devicePixelRatio || 1), increment:100, frequency:500, animate:true, animDuration:0.4, ddGroup:undefined, refreshCache:function() {
  var els = this.els, id;
  for (id in els) {
    if (typeof els[id] === 'object') {
      els[id]._region = els[id].getRegion();
    }
  }
}}, 1, 0, 0, 0, 0, 0, [photoViewer.dd, 'ScrollManager'], 0);
Ext.cmd.derive('photoViewer.dd.DropTarget', photoViewer.dd.DDTarget, {constructor:function(el, config) {
  this.el = Ext.get(el);
  Ext.apply(this, config);
  if (this.containerScroll) {
    photoViewer.dd.ScrollManager.register(this.el);
  }
  photoViewer.dd.DDTarget.prototype.constructor.call(this, this.el.dom, this.ddGroup || this.group, {isTarget:true});
}, containerScroll:false, dropAllowed:'x-dd-drop-ok', dropNotAllowed:'x-dd-drop-nodrop', isTarget:true, isNotifyTarget:true, notifyEnter:function(dd, e, data) {
  if (this.overClass) {
    this.el.addCls(this.overClass);
  }
  return this.dropAllowed;
}, notifyOver:function(dd, e, data) {
  return this.dropAllowed;
}, notifyOut:function(dd, e, data) {
  if (this.overClass) {
    this.el.removeCls(this.overClass);
  }
}, notifyDrop:function(dd, e, data) {
  if (this.overClass) {
    this.el.removeCls(this.overClass);
  }
  return false;
}, destroy:function() {
  photoViewer.dd.DDTarget.prototype.destroy.call(this);
  if (this.containerScroll) {
    photoViewer.dd.ScrollManager.unregister(this.el);
  }
}}, 1, 0, 0, 0, 0, 0, [photoViewer.dd, 'DropTarget'], 0);
Ext.cmd.derive('photoViewer.dd.Registry', Ext.Base, {singleton:true, constructor:function() {
  this.elements = {};
  this.handles = {};
  this.autoIdSeed = 0;
}, getId:function(el, autogen) {
  if (typeof el === 'string') {
    return el;
  }
  var id = el.id;
  if (!id && autogen !== false) {
    id = 'extdd-' + ++this.autoIdSeed;
    el.id = id;
  }
  return id;
}, register:function(el, data) {
  data = data || {};
  if (typeof el === 'string') {
    el = document.getElementById(el);
  }
  data.ddel = el;
  this.elements[this.getId(el)] = data;
  if (data.isHandle !== false) {
    this.handles[data.ddel.id] = data;
  }
  if (data.handles) {
    var hs = data.handles, i, len;
    for (i = 0, len = hs.length; i < len; i++) {
      this.handles[this.getId(hs[i])] = data;
    }
  }
}, unregister:function(el) {
  var id = this.getId(el, false), data = this.elements[id], hs, i, len;
  if (data) {
    delete this.elements[id];
    if (data.handles) {
      hs = data.handles;
      for (i = 0, len = hs.length; i < len; i++) {
        delete this.handles[this.getId(hs[i], false)];
      }
    }
  }
}, getHandle:function(id) {
  if (typeof id !== 'string') {
    id = id.id;
  }
  return this.handles[id];
}, getHandleFromEvent:function(e) {
  var t = e.getTarget();
  return t ? this.handles[t.id] : null;
}, getTarget:function(id) {
  if (typeof id !== 'string') {
    id = id.id;
  }
  return this.elements[id];
}, getTargetFromEvent:function(e) {
  var t = e.getTarget();
  return t ? this.elements[t.id] || this.handles[t.id] : null;
}}, 1, 0, 0, 0, 0, 0, [photoViewer.dd, 'Registry'], 0);
Ext.cmd.derive('photoViewer.dd.DropZone', photoViewer.dd.DropTarget, {getTargetFromEvent:function(e) {
  return photoViewer.dd.Registry.getTargetFromEvent(e);
}, onNodeEnter:function(n, dd, e, data) {
}, onNodeOver:function(n, dd, e, data) {
  return this.dropAllowed;
}, onNodeOut:function(n, dd, e, data) {
}, onNodeDrop:function(n, dd, e, data) {
  return false;
}, onContainerOver:function(dd, e, data) {
  return this.dropNotAllowed;
}, onContainerDrop:function(dd, e, data) {
  return false;
}, notifyEnter:function(dd, e, data) {
  return this.dropNotAllowed;
}, notifyOver:function(dd, e, data) {
  var me = this, n = me.getTargetFromEvent(e);
  if (!n) {
    if (me.lastOverNode) {
      me.onNodeOut(me.lastOverNode, dd, e, data);
      me.lastOverNode = null;
    }
    return me.onContainerOver(dd, e, data);
  }
  if (me.lastOverNode !== n) {
    if (me.lastOverNode) {
      me.onNodeOut(me.lastOverNode, dd, e, data);
    }
    me.onNodeEnter(n, dd, e, data);
    me.lastOverNode = n;
  }
  return me.onNodeOver(n, dd, e, data);
}, notifyOut:function(dd, e, data) {
  if (this.lastOverNode) {
    this.onNodeOut(this.lastOverNode, dd, e, data);
    this.lastOverNode = null;
  }
}, notifyDrop:function(dd, e, data) {
  var me = this, n = me.getTargetFromEvent(e), result = n ? me.onNodeDrop(n, dd, e, data) : me.onContainerDrop(dd, e, data);
  if (me.lastOverNode) {
    me.onNodeOut(me.lastOverNode, dd, e, data);
    me.lastOverNode = null;
  }
  return result;
}, triggerCacheRefresh:function() {
  Ext.dd.DDM.refreshCache(this.groups);
}}, 0, 0, 0, 0, 0, 0, [photoViewer.dd, 'DropZone'], 0);
Ext.cmd.derive('photoViewer.draw.Color', Ext.Base, {isColor:true, colorToHexRe:/(.*?)rgb\((\d+),\s*(\d+),\s*(\d+)\)/, rgbRe:/\s*rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)\s*/, hexRe:/\s*#([0-9a-fA-F][0-9a-fA-F]?)([0-9a-fA-F][0-9a-fA-F]?)([0-9a-fA-F][0-9a-fA-F]?)\s*/, lightnessFactor:0.2, constructor:function(red, green, blue) {
  var me = this, clamp = Ext.Number.constrain;
  me.r = clamp(red, 0, 255);
  me.g = clamp(green, 0, 255);
  me.b = clamp(blue, 0, 255);
}, getRed:function() {
  return this.r;
}, getGreen:function() {
  return this.g;
}, getBlue:function() {
  return this.b;
}, getRGB:function() {
  var me = this;
  return [me.r, me.g, me.b];
}, getHSL:function() {
  var me = this, r = me.r / 255, g = me.g / 255, b = me.b / 255, max = Math.max(r, g, b), min = Math.min(r, g, b), delta = max - min, h, s = 0, l = 0.5 * (max + min);
  if (min != max) {
    s = l <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
    if (r == max) {
      h = 60 * (g - b) / delta;
    } else {
      if (g == max) {
        h = 120 + 60 * (b - r) / delta;
      } else {
        h = 240 + 60 * (r - g) / delta;
      }
    }
    if (h < 0) {
      h += 360;
    }
    if (h >= 360) {
      h -= 360;
    }
  }
  return [h, s, l];
}, getHSV:function() {
  var me = this, r = me.r / 255, g = me.g / 255, b = me.b / 255, max = Math.max(r, g, b), min = Math.min(r, g, b), C = max - min, h, s = 0, v = max;
  if (min != max) {
    s = v ? C / v : 0;
    if (r === max) {
      h = 60 * (g - b) / C;
    } else {
      if (g === max) {
        h = 60 * (b - r) / C + 120;
      } else {
        h = 60 * (r - g) / C + 240;
      }
    }
    if (h < 0) {
      h += 360;
    }
    if (h >= 360) {
      h -= 360;
    }
  }
  return [h, s, v];
}, getLighter:function(factor) {
  var hsl = this.getHSL();
  factor = factor || this.lightnessFactor;
  hsl[2] = Ext.Number.constrain(hsl[2] + factor, 0, 1);
  return this.fromHSL(hsl[0], hsl[1], hsl[2]);
}, getDarker:function(factor) {
  factor = factor || this.lightnessFactor;
  return this.getLighter(-factor);
}, toString:function() {
  var me = this, round = Math.round, r = round(me.r).toString(16), g = round(me.g).toString(16), b = round(me.b).toString(16);
  r = r.length == 1 ? '0' + r : r;
  g = g.length == 1 ? '0' + g : g;
  b = b.length == 1 ? '0' + b : b;
  return ['#', r, g, b].join('');
}, toHex:function(color) {
  if (Ext.isArray(color)) {
    color = color[0];
  }
  if (!Ext.isString(color)) {
    return '';
  }
  if (color.substr(0, 1) === '#') {
    return color;
  }
  var digits = this.colorToHexRe.exec(color), red, green, blue, rgb;
  if (Ext.isArray(digits)) {
    red = parseInt(digits[2], 10);
    green = parseInt(digits[3], 10);
    blue = parseInt(digits[4], 10);
    rgb = blue | green << 8 | red << 16;
    return digits[1] + '#' + ('000000' + rgb.toString(16)).slice(-6);
  } else {
    return color;
  }
}, fromString:function(str) {
  var values, r, g, b, parse = parseInt, firstChar = str.substr(0, 1), colorValue;
  if (firstChar != '#') {
    colorValue = photoViewer.draw.Color.cssColors[str];
    if (colorValue) {
      str = colorValue;
      firstChar = str.substr(0, 1);
    }
  }
  if ((str.length == 4 || str.length == 7) && firstChar === '#') {
    values = str.match(this.hexRe);
    if (values) {
      r = parse(values[1], 16) >> 0;
      g = parse(values[2], 16) >> 0;
      b = parse(values[3], 16) >> 0;
      if (str.length == 4) {
        r += r * 16;
        g += g * 16;
        b += b * 16;
      }
    }
  } else {
    values = str.match(this.rgbRe);
    if (values) {
      r = values[1];
      g = values[2];
      b = values[3];
    }
  }
  return typeof r == 'undefined' ? undefined : new photoViewer.draw.Color(r, g, b);
}, getGrayscale:function() {
  return this.r * 0.3 + this.g * 0.59 + this.b * 0.11;
}, fromHSL:function(h, s, l) {
  var C, X, m, rgb = [], abs = Math.abs;
  if (s == 0 || h == null) {
    rgb = [l, l, l];
  } else {
    h /= 60;
    C = s * (1 - abs(2 * l - 1));
    X = C * (1 - abs(h % 2 - 1));
    m = l - C / 2;
    switch(Math.floor(h)) {
      case 0:
        rgb = [C, X, 0];
        break;
      case 1:
        rgb = [X, C, 0];
        break;
      case 2:
        rgb = [0, C, X];
        break;
      case 3:
        rgb = [0, X, C];
        break;
      case 4:
        rgb = [X, 0, C];
        break;
      case 5:
        rgb = [C, 0, X];
        break;
    }
    rgb = [rgb[0] + m, rgb[1] + m, rgb[2] + m];
  }
  return new photoViewer.draw.Color(rgb[0] * 255, rgb[1] * 255, rgb[2] * 255);
}, fromHSV:function(h, s, v) {
  var C, X, m, rgb = [];
  if (s == 0 || h == null) {
    rgb = [v, v, v];
  } else {
    h /= 60;
    C = v * s;
    X = C * (1 - Math.abs(h % 2 - 1));
    m = v - C;
    switch(Math.floor(h)) {
      case 0:
        rgb = [C, X, 0];
        break;
      case 1:
        rgb = [X, C, 0];
        break;
      case 2:
        rgb = [0, C, X];
        break;
      case 3:
        rgb = [0, X, C];
        break;
      case 4:
        rgb = [X, 0, C];
        break;
      case 5:
        rgb = [C, 0, X];
        break;
    }
    rgb = [rgb[0] + m, rgb[1] + m, rgb[2] + m];
  }
  return new photoViewer.draw.Color(rgb[0] * 255, rgb[1] * 255, rgb[2] * 255);
}}, 3, 0, 0, 0, 0, 0, [photoViewer.draw, 'Color'], function() {
  var prototype = this.prototype, staticMethods = ['fromHSL', 'fromHSV', 'fromString', 'toHex'], statics = {};
  Ext.Array.each(staticMethods, function(name) {
    statics[name] = function() {
      return prototype[name].apply(prototype, arguments);
    };
  });
  statics.cssColors = {aliceblue:'#F0F8FF', antiquewhite:'#FAEBD7', aqua:'#00FFFF', aquamarine:'#7FFFD4', azure:'#F0FFFF', beige:'#F5F5DC', bisque:'#FFE4C4', black:'#000000', blanchedalmond:'#FFEBCD', blue:'#0000FF', blueviolet:'#8A2BE2', brown:'#A52A2A', burlywood:'#DEB887', cadetblue:'#5F9EA0', chartreuse:'#7FFF00', chocolate:'#D2691E', coral:'#FF7F50', cornflowerblue:'#6495ED', cornsilk:'#FFF8DC', crimson:'#DC143C', cyan:'#00FFFF', darkblue:'#00008B', darkcyan:'#008B8B', darkgoldenrod:'#B8860B', 
  darkgray:'#A9A9A9', darkgreen:'#006400', darkgrey:'#A9A9A9', darkkhaki:'#BDB76B', darkmagenta:'#8B008B', darkolivegreen:'#556B2F', darkorange:'#FF8C00', darkorchid:'#9932CC', darkred:'#8B0000', darksalmon:'#E9967A', darkseagreen:'#8FBC8F', darkslateblue:'#483D8B', darkslategray:'#2F4F4F', darkslategrey:'#2F4F4F', darkturquoise:'#00CED1', darkviolet:'#9400D3', deeppink:'#FF1493', deepskyblue:'#00BFFF', dimgray:'#696969', dimgrey:'#696969', dodgerblue:'#1E90FF', firebrick:'#B22222', floralwhite:'#FFFAF0', 
  forestgreen:'#228B22', fuchsia:'#FF00FF', gainsboro:'#DCDCDC', ghostwhite:'#F8F8FF', gold:'#FFD700', goldenrod:'#DAA520', gray:'#808080', grey:'#808080', green:'#008000', greenyellow:'#ADFF2F', honeydew:'#F0FFF0', hotpink:'#FF69B4', indianred:'#CD5C5C', indigo:'#4B0082', ivory:'#FFFFF0', khaki:'#F0E68C', lavender:'#E6E6FA', lavenderblush:'#FFF0F5', lawngreen:'#7CFC00', lemonchiffon:'#FFFACD', lightblue:'#ADD8E6', lightcoral:'#F08080', lightcyan:'#E0FFFF', lightgoldenrodyellow:'#FAFAD2', lightgray:'#D3D3D3', 
  lightgreen:'#90EE90', lightgrey:'#D3D3D3', lightpink:'#FFB6C1', lightsalmon:'#FFA07A', lightseagreen:'#20B2AA', lightskyblue:'#87CEFA', lightslategray:'#778899', lightslategrey:'#778899', lightsteelblue:'#B0C4DE', lightyellow:'#FFFFE0', lime:'#00FF00', limegreen:'#32CD32', linen:'#FAF0E6', magenta:'#FF00FF', maroon:'#800000', mediumaquamarine:'#66CDAA', mediumblue:'#0000CD', mediumorchid:'#BA55D3', mediumpurple:'#9370DB', mediumseagreen:'#3CB371', mediumslateblue:'#7B68EE', mediumspringgreen:'#00FA9A', 
  mediumturquoise:'#48D1CC', mediumvioletred:'#C71585', midnightblue:'#191970', mintcream:'#F5FFFA', mistyrose:'#FFE4E1', moccasin:'#FFE4B5', navajowhite:'#FFDEAD', navy:'#000080', oldlace:'#FDF5E6', olive:'#808000', olivedrab:'#6B8E23', orange:'#FFA500', orangered:'#FF4500', orchid:'#DA70D6', palegoldenrod:'#EEE8AA', palegreen:'#98FB98', paleturquoise:'#AFEEEE', palevioletred:'#DB7093', papayawhip:'#FFEFD5', peachpuff:'#FFDAB9', peru:'#CD853F', pink:'#FFC0CB', plum:'#DDA0DD', powderblue:'#B0E0E6', 
  purple:'#800080', red:'#FF0000', rosybrown:'#BC8F8F', royalblue:'#4169E1', saddlebrown:'#8B4513', salmon:'#FA8072', sandybrown:'#F4A460', seagreen:'#2E8B57', seashell:'#FFF5EE', sienna:'#A0522D', silver:'#C0C0C0', skyblue:'#87CEEB', slateblue:'#6A5ACD', slategray:'#708090', slategrey:'#708090', snow:'#FFFAFA', springgreen:'#00FF7F', steelblue:'#4682B4', tan:'#D2B48C', teal:'#008080', thistle:'#D8BFD8', tomato:'#FF6347', turquoise:'#40E0D0', violet:'#EE82EE', wheat:'#F5DEB3', white:'#FFFFFF', whitesmoke:'#F5F5F5', 
  yellow:'#FFFF00', yellowgreen:'#9ACD32'};
  this.addStatics(statics);
});
Ext.cmd.derive('photoViewer.draw.CompositeSprite', Ext.util.MixedCollection, {autoDestroy:false, isCompositeSprite:true, constructor:function(config) {
  var me = this;
  me.myConfig = config;
  Ext.apply(me, config);
  me.id = Ext.id(null, 'ext-sprite-group-');
  Ext.util.MixedCollection.prototype.constructor.call(this);
}, onClick:function(e) {
  this.fireEvent('click', e);
}, onMouseUp:function(e) {
  this.fireEvent('mouseup', e);
}, onMouseDown:function(e) {
  this.fireEvent('mousedown', e);
}, onMouseOver:function(e) {
  this.fireEvent('mouseover', e);
}, onMouseOut:function(e) {
  this.fireEvent('mouseout', e);
}, attachEvents:function(o) {
  var me = this;
  o.on({scope:me, mousedown:me.onMouseDown, mouseup:me.onMouseUp, mouseover:me.onMouseOver, mouseout:me.onMouseOut, click:me.onClick});
}, add:function(key, o) {
  var result = Ext.util.MixedCollection.prototype.add.apply(this, arguments);
  this.attachEvents(result);
  return result;
}, insert:function(index, key, o) {
  return Ext.util.MixedCollection.prototype.insert.apply(this, arguments);
}, remove:function(o) {
  var me = this;
  o.un({scope:me, mousedown:me.onMouseDown, mouseup:me.onMouseUp, mouseover:me.onMouseOver, mouseout:me.onMouseOut, click:me.onClick});
  return Ext.util.MixedCollection.prototype.remove.apply(this, arguments);
}, getBBox:function() {
  var i = 0, sprite, bb, items = this.items, len = this.length, infinity = Infinity, minX = infinity, maxHeight = -infinity, minY = infinity, maxWidth = -infinity, maxWidthBBox, maxHeightBBox;
  for (; i < len; i++) {
    sprite = items[i];
    if (sprite.el && !sprite.bboxExcluded) {
      bb = sprite.getBBox();
      minX = Math.min(minX, bb.x);
      minY = Math.min(minY, bb.y);
      maxHeight = Math.max(maxHeight, bb.height + bb.y);
      maxWidth = Math.max(maxWidth, bb.width + bb.x);
    }
  }
  return {x:minX, y:minY, height:maxHeight - minY, width:maxWidth - minX};
}, setAttributes:function(attrs, redraw) {
  var i = 0, items = this.items, len = this.length;
  for (; i < len; i++) {
    items[i].setAttributes(attrs, redraw);
  }
  return this;
}, hide:function(redraw) {
  var i = 0, items = this.items, len = this.length;
  for (; i < len; i++) {
    items[i].hide(redraw);
  }
  return this;
}, show:function(redraw) {
  var i = 0, items = this.items, len = this.length;
  for (; i < len; i++) {
    items[i].show(redraw);
  }
  return this;
}, redraw:function() {
  var me = this, i = 0, items = me.items, surface = me.getSurface(), len = me.length;
  if (surface) {
    for (; i < len; i++) {
      surface.renderItem(items[i]);
    }
  }
  return me;
}, setStyle:function(obj) {
  var i = 0, items = this.items, len = this.length, item, el;
  for (; i < len; i++) {
    item = items[i];
    el = item.el;
    if (el) {
      el.setStyle(obj);
    }
  }
}, addCls:function(obj) {
  var i = 0, items = this.items, surface = this.getSurface(), len = this.length;
  if (surface) {
    for (; i < len; i++) {
      surface.addCls(items[i], obj);
    }
  }
}, removeCls:function(obj) {
  var i = 0, items = this.items, surface = this.getSurface(), len = this.length;
  if (surface) {
    for (; i < len; i++) {
      surface.removeCls(items[i], obj);
    }
  }
}, getSurface:function() {
  var first = this.first();
  if (first) {
    return first.surface;
  }
  return null;
}, destroy:function() {
  var me = this, surface = me.getSurface(), destroySprites = me.autoDestroy, item;
  if (surface) {
    while (me.getCount() > 0) {
      item = me.first();
      me.remove(item);
      surface.remove(item, destroySprites);
    }
  }
  me.clearListeners();
}}, 1, 0, 0, 0, 0, [['animate', Ext.util.Animate]], [photoViewer.draw, 'CompositeSprite'], 0);
Ext.cmd.derive('photoViewer.draw.Surface', Ext.Base, {separatorRe:/[, ]+/, enginePriority:['Svg', 'Vml'], statics:{create:function(config, enginePriority) {
  enginePriority = enginePriority || this.prototype.enginePriority;
  var i = 0, len = enginePriority.length;
  for (; i < len; i++) {
    if (Ext.supports[enginePriority[i]]) {
      return Ext.create('photoViewer.draw.engine.' + enginePriority[i], config);
    }
  }
  return false;
}, save:function(surface, config) {
  config = config || {};
  var exportTypes = {'image/png':'Image', 'image/jpeg':'Image', 'image/svg+xml':'Svg'}, prefix = exportTypes[config.type] || 'Svg', exporter = photoViewer.draw.engine[prefix + 'Exporter'];
  return exporter.generate(surface, config);
}}, availableAttrs:{blur:0, 'clip-rect':'0 0 1e9 1e9', cursor:'default', cx:0, cy:0, 'dominant-baseline':'auto', fill:'none', 'fill-opacity':1, font:'10px "Arial"', 'font-family':'"Arial"', 'font-size':'10', 'font-style':'normal', 'font-weight':400, gradient:'', height:0, hidden:false, href:'http://sencha.com/', opacity:1, path:'M0,0', radius:0, rx:0, ry:0, scale:'1 1', src:'', stroke:'none', 'stroke-dasharray':'', 'stroke-linecap':'butt', 'stroke-linejoin':'butt', 'stroke-miterlimit':0, 'stroke-opacity':1, 
'stroke-width':1, target:'_blank', text:'', 'text-anchor':'middle', title:'Ext Draw', width:0, x:0, y:0, zIndex:0}, container:undefined, height:352, width:512, x:0, y:0, orderSpritesByZIndex:true, constructor:function(config) {
  var me = this;
  config = config || {};
  Ext.apply(me, config);
  me.domRef = Ext.getDoc().dom;
  me.customAttributes = {};
  me.mixins.observable.constructor.call(me);
  me.getId();
  me.initGradients();
  me.initItems();
  if (me.renderTo) {
    me.render(me.renderTo);
    delete me.renderTo;
  }
  me.initBackground(config.background);
}, initSurface:Ext.emptyFn, renderItem:Ext.emptyFn, renderItems:Ext.emptyFn, setViewBox:function(x, y, width, height) {
  if (isFinite(x) && isFinite(y) && isFinite(width) && isFinite(height)) {
    this.viewBox = {x:x, y:y, width:width, height:height};
    this.applyViewBox();
  }
}, addCls:Ext.emptyFn, removeCls:Ext.emptyFn, setStyle:Ext.emptyFn, initGradients:function() {
  if (this.hasOwnProperty('gradients')) {
    var gradients = this.gradients, fn = this.addGradient, g, gLen;
    if (gradients) {
      for (g = 0, gLen = gradients.length; g < gLen; g++) {
        if (fn.call(this, gradients[g], g, gLen) === false) {
          break;
        }
      }
    }
  }
}, initItems:function() {
  var items = this.items;
  this.items = new photoViewer.draw.CompositeSprite;
  this.items.autoDestroy = true;
  this.groups = new photoViewer.draw.CompositeSprite;
  if (items) {
    this.add(items);
  }
}, initBackground:function(config) {
  var me = this, width = me.width, height = me.height, gradientId, gradient;
  if (Ext.isString(config)) {
    config = {fill:config};
  }
  if (config) {
    if (config.gradient) {
      gradient = config.gradient;
      gradientId = gradient.id;
      me.addGradient(gradient);
      me.background = me.add({type:'rect', isBackground:true, x:0, y:0, width:width, height:height, fill:'url(#' + gradientId + ')', zIndex:-1});
    } else {
      if (config.fill) {
        me.background = me.add({type:'rect', isBackground:true, x:0, y:0, width:width, height:height, fill:config.fill, zIndex:-1});
      } else {
        if (config.image) {
          me.background = me.add({type:'image', isBackground:true, x:0, y:0, width:width, height:height, src:config.image, zIndex:-1});
        }
      }
    }
    me.background.bboxExcluded = true;
  }
}, setSize:function(w, h) {
  this.applyViewBox();
}, scrubAttrs:function(sprite) {
  var i, attrs = {}, exclude = {}, sattr = sprite.attr;
  for (i in sattr) {
    if (this.translateAttrs.hasOwnProperty(i)) {
      attrs[this.translateAttrs[i]] = sattr[i];
      exclude[this.translateAttrs[i]] = true;
    } else {
      if (this.availableAttrs.hasOwnProperty(i) && !exclude[i]) {
        attrs[i] = sattr[i];
      }
    }
  }
  return attrs;
}, onClick:function(e) {
  this.processEvent('click', e);
}, onDblClick:function(e) {
  this.processEvent('dblclick', e);
}, onMouseUp:function(e) {
  this.processEvent('mouseup', e);
}, onMouseDown:function(e) {
  this.processEvent('mousedown', e);
}, onMouseOver:function(e) {
  this.processEvent('mouseover', e);
}, onMouseOut:function(e) {
  this.processEvent('mouseout', e);
}, onMouseMove:function(e) {
  this.fireEvent('mousemove', e);
}, onMouseEnter:Ext.emptyFn, onMouseLeave:Ext.emptyFn, addGradient:Ext.emptyFn, add:function() {
  var args = Array.prototype.slice.call(arguments), sprite, hasMultipleArgs = args.length > 1, items, results, i, ln, item;
  if (hasMultipleArgs || Ext.isArray(args[0])) {
    items = hasMultipleArgs ? args : args[0];
    results = [];
    for (i = 0, ln = items.length; i < ln; i++) {
      item = items[i];
      item = this.add(item);
      results.push(item);
    }
    return results;
  }
  sprite = this.prepareItems(args[0], true)[0];
  this.insertByZIndex(sprite);
  this.onAdd(sprite);
  return sprite;
}, insertByZIndex:function(sprite) {
  var me = this, sprites = me.items.items, len = sprites.length, ceil = Math.ceil, zIndex = sprite.attr.zIndex, idx = len, high = idx - 1, low = 0, otherZIndex;
  if (me.orderSpritesByZIndex && len && zIndex < sprites[high].attr.zIndex) {
    while (low <= high) {
      idx = ceil((low + high) / 2);
      otherZIndex = sprites[idx].attr.zIndex;
      if (otherZIndex > zIndex) {
        high = idx - 1;
      } else {
        if (otherZIndex < zIndex) {
          low = idx + 1;
        } else {
          break;
        }
      }
    }
    while (idx < len && sprites[idx].attr.zIndex <= zIndex) {
      idx++;
    }
  }
  me.items.insert(idx, sprite);
  return idx;
}, onAdd:function(sprite) {
  var group = sprite.group, draggable = sprite.draggable, groups, ln, i;
  if (group) {
    groups = [].concat(group);
    ln = groups.length;
    for (i = 0; i < ln; i++) {
      group = groups[i];
      this.getGroup(group).add(sprite);
    }
    delete sprite.group;
  }
  if (draggable) {
    sprite.initDraggable();
  }
}, remove:function(sprite, destroySprite) {
  if (sprite) {
    this.items.remove(sprite);
    var groups = [].concat(this.groups.items), gLen = groups.length, g;
    for (g = 0; g < gLen; g++) {
      groups[g].remove(sprite);
    }
    sprite.onRemove();
    if (destroySprite === true) {
      sprite.destroy();
    }
  }
}, removeAll:function(destroySprites) {
  var items = this.items.items, ln = items.length, i;
  for (i = ln - 1; i > -1; i--) {
    this.remove(items[i], destroySprites);
  }
}, onRemove:Ext.emptyFn, onDestroy:Ext.emptyFn, applyViewBox:function() {
  var me = this, viewBox = me.viewBox, width = me.width || 1, height = me.height || 1, viewBoxX, viewBoxY, viewBoxWidth, viewBoxHeight, relativeHeight, relativeWidth, size;
  if (viewBox && (width || height)) {
    viewBoxX = viewBox.x;
    viewBoxY = viewBox.y;
    viewBoxWidth = viewBox.width;
    viewBoxHeight = viewBox.height;
    relativeHeight = height / viewBoxHeight;
    relativeWidth = width / viewBoxWidth;
    size = Math.min(relativeWidth, relativeHeight);
    if (viewBoxWidth * size < width) {
      viewBoxX -= (width - viewBoxWidth * size) / 2 / size;
    }
    if (viewBoxHeight * size < height) {
      viewBoxY -= (height - viewBoxHeight * size) / 2 / size;
    }
    me.viewBoxShift = {dx:-viewBoxX, dy:-viewBoxY, scale:size};
    if (me.background) {
      me.background.setAttributes(Ext.apply({}, {x:viewBoxX, y:viewBoxY, width:width / size, height:height / size}, {hidden:false}), true);
    }
  } else {
    if (me.background && width && height) {
      me.background.setAttributes(Ext.apply({x:0, y:0, width:width, height:height}, {hidden:false}), true);
    }
  }
}, getBBox:function(sprite, isWithoutTransform) {
  var realPath = this['getPath' + sprite.type](sprite);
  if (isWithoutTransform) {
    sprite.bbox.plain = sprite.bbox.plain || photoViewer.draw.Draw.pathDimensions(realPath);
    return sprite.bbox.plain;
  }
  if (sprite.dirtyTransform) {
    this.applyTransformations(sprite, true);
  }
  sprite.bbox.transform = sprite.bbox.transform || photoViewer.draw.Draw.pathDimensions(photoViewer.draw.Draw.mapPath(realPath, sprite.matrix));
  return sprite.bbox.transform;
}, transformToViewBox:function(x, y) {
  if (this.viewBoxShift) {
    var me = this, shift = me.viewBoxShift;
    return [x / shift.scale - shift.dx, y / shift.scale - shift.dy];
  } else {
    return [x, y];
  }
}, applyTransformations:function(sprite, onlyMatrix) {
  if (sprite.type == 'text') {
    sprite.bbox.transform = 0;
    this.transform(sprite, false);
  }
  sprite.dirtyTransform = false;
  var me = this, attr = sprite.attr;
  if (attr.translation.x != null || attr.translation.y != null) {
    me.translate(sprite);
  }
  if (attr.scaling.x != null || attr.scaling.y != null) {
    me.scale(sprite);
  }
  if (attr.rotation.degrees != null) {
    me.rotate(sprite);
  }
  sprite.bbox.transform = 0;
  this.transform(sprite, onlyMatrix);
  sprite.transformations = [];
}, rotate:function(sprite) {
  var bbox, deg = sprite.attr.rotation.degrees, centerX = sprite.attr.rotation.x, centerY = sprite.attr.rotation.y;
  if (!Ext.isNumber(centerX) || !Ext.isNumber(centerY)) {
    bbox = this.getBBox(sprite, true);
    centerX = !Ext.isNumber(centerX) ? bbox.x + bbox.width / 2 : centerX;
    centerY = !Ext.isNumber(centerY) ? bbox.y + bbox.height / 2 : centerY;
  }
  sprite.transformations.push({type:'rotate', degrees:deg, x:centerX, y:centerY});
}, translate:function(sprite) {
  var x = sprite.attr.translation.x || 0, y = sprite.attr.translation.y || 0;
  sprite.transformations.push({type:'translate', x:x, y:y});
}, scale:function(sprite) {
  var bbox, x = sprite.attr.scaling.x || 1, y = sprite.attr.scaling.y || 1, centerX = sprite.attr.scaling.centerX, centerY = sprite.attr.scaling.centerY;
  if (!Ext.isNumber(centerX) || !Ext.isNumber(centerY)) {
    bbox = this.getBBox(sprite, true);
    centerX = !Ext.isNumber(centerX) ? bbox.x + bbox.width / 2 : centerX;
    centerY = !Ext.isNumber(centerY) ? bbox.y + bbox.height / 2 : centerY;
  }
  sprite.transformations.push({type:'scale', x:x, y:y, centerX:centerX, centerY:centerY});
}, rectPath:function(x, y, w, h, r) {
  if (r) {
    return [['M', x + r, y], ['l', w - r * 2, 0], ['a', r, r, 0, 0, 1, r, r], ['l', 0, h - r * 2], ['a', r, r, 0, 0, 1, -r, r], ['l', r * 2 - w, 0], ['a', r, r, 0, 0, 1, -r, -r], ['l', 0, r * 2 - h], ['a', r, r, 0, 0, 1, r, -r], ['z']];
  }
  return [['M', x, y], ['l', w, 0], ['l', 0, h], ['l', -w, 0], ['z']];
}, ellipsePath:function(x, y, rx, ry) {
  if (ry == null) {
    ry = rx;
  }
  return [['M', x, y], ['m', 0, -ry], ['a', rx, ry, 0, 1, 1, 0, 2 * ry], ['a', rx, ry, 0, 1, 1, 0, -2 * ry], ['z']];
}, getPathpath:function(el) {
  return el.attr.path;
}, getPathcircle:function(el) {
  var a = el.attr;
  return this.ellipsePath(a.x, a.y, a.radius, a.radius);
}, getPathellipse:function(el) {
  var a = el.attr;
  return this.ellipsePath(a.x, a.y, a.radiusX || a.width / 2 || 0, a.radiusY || a.height / 2 || 0);
}, getPathrect:function(el) {
  var a = el.attr;
  return this.rectPath(a.x || 0, a.y || 0, a.width || 0, a.height || 0, a.r || 0);
}, getPathimage:function(el) {
  var a = el.attr;
  return this.rectPath(a.x || 0, a.y || 0, a.width, a.height);
}, getPathtext:function(el) {
  var bbox = this.getBBoxText(el);
  return this.rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
}, createGroup:function(id) {
  var group = this.groups.get(id);
  if (!group) {
    group = new photoViewer.draw.CompositeSprite({surface:this});
    group.id = id || Ext.id(null, 'ext-surface-group-');
    this.groups.add(group);
  }
  return group;
}, getGroup:function(id) {
  var group;
  if (typeof id == 'string') {
    group = this.groups.get(id);
    if (!group) {
      group = this.createGroup(id);
    }
  } else {
    group = id;
  }
  return group;
}, prepareItems:function(items, applyDefaults) {
  items = [].concat(items);
  var item, i, ln;
  for (i = 0, ln = items.length; i < ln; i++) {
    item = items[i];
    if (!(item instanceof photoViewer.draw.Sprite)) {
      item.surface = this;
      items[i] = this.createItem(item);
    } else {
      item.surface = this;
    }
  }
  return items;
}, setText:Ext.emptyFn, createItem:Ext.emptyFn, getId:function() {
  return this.id || (this.id = Ext.id(null, 'ext-surface-'));
}, destroy:function() {
  var me = this;
  delete me.domRef;
  if (me.background) {
    me.background.destroy();
  }
  me.removeAll(true);
  Ext.destroy(me.groups.items);
}}, 1, 0, 0, 0, 0, [['observable', Ext.util.Observable]], [photoViewer.draw, 'Surface'], 0);
Ext.cmd.derive('photoViewer.draw.layout.Component', Ext.layout.component.Auto, {setHeightInDom:true, setWidthInDom:true, type:'draw', measureContentWidth:function(ownerContext) {
  var target = ownerContext.target, paddingInfo = ownerContext.getPaddingInfo(), bbox = this.getBBox(ownerContext);
  if (!target.viewBox) {
    if (target.autoSize) {
      return bbox.width + paddingInfo.width;
    } else {
      return bbox.x + bbox.width + paddingInfo.width;
    }
  } else {
    if (ownerContext.heightModel.shrinkWrap) {
      return paddingInfo.width;
    } else {
      return bbox.width / bbox.height * (ownerContext.getProp('contentHeight') - paddingInfo.height) + paddingInfo.width;
    }
  }
}, measureContentHeight:function(ownerContext) {
  var target = ownerContext.target, paddingInfo = ownerContext.getPaddingInfo(), bbox = this.getBBox(ownerContext);
  if (!ownerContext.target.viewBox) {
    if (target.autoSize) {
      return bbox.height + paddingInfo.height;
    } else {
      return bbox.y + bbox.height + paddingInfo.height;
    }
  } else {
    if (ownerContext.widthModel.shrinkWrap) {
      return paddingInfo.height;
    } else {
      return bbox.height / bbox.width * (ownerContext.getProp('contentWidth') - paddingInfo.width) + paddingInfo.height;
    }
  }
}, getBBox:function(ownerContext) {
  var bbox = ownerContext.surfaceBBox;
  if (!bbox) {
    bbox = ownerContext.target.surface.items.getBBox();
    if (bbox.width === -Infinity && bbox.height === -Infinity) {
      bbox.width = bbox.height = bbox.x = bbox.y = 0;
    }
    ownerContext.surfaceBBox = bbox;
  }
  return bbox;
}, publishInnerWidth:function(ownerContext, width) {
  ownerContext.setContentWidth(width - ownerContext.getFrameInfo().width, true);
}, publishInnerHeight:function(ownerContext, height) {
  ownerContext.setContentHeight(height - ownerContext.getFrameInfo().height, true);
}, finishedLayout:function(ownerContext) {
  var props = ownerContext.props, paddingInfo = ownerContext.getPaddingInfo();
  this.owner.setSurfaceSize(props.contentWidth - paddingInfo.width, props.contentHeight - paddingInfo.height);
  Ext.layout.component.Auto.prototype.finishedLayout.apply(this, arguments);
}}, 0, 0, 0, 0, ['layout.draw'], 0, [photoViewer.draw.layout, 'Component'], 0);
Ext.cmd.derive('photoViewer.draw.Component', Ext.Component, {enginePriority:['Svg', 'Vml'], baseCls:'x-surface', componentLayout:'draw', viewBox:true, shrinkWrap:3, autoSize:false, suspendSizing:0, onRender:function() {
  Ext.Component.prototype.onRender.apply(this, arguments);
  if (this.createSurface() !== false) {
    this.configureSurfaceSize();
  }
}, configureSurfaceSize:function() {
  var me = this, viewBox = me.viewBox, autoSize = me.autoSize, bbox;
  if ((viewBox || autoSize) && !me.suspendSizing) {
    bbox = me.surface.items.getBBox();
    if (viewBox) {
      me.surface.setViewBox(bbox.x, bbox.y, bbox.width, bbox.height);
    } else {
      me.autoSizeSurface(bbox);
    }
  }
}, autoSizeSurface:function(bbox) {
  bbox = bbox || this.surface.items.getBBox();
  this.setSurfaceSize(bbox.width, bbox.height);
}, setSurfaceSize:function(width, height) {
  this.surface.setSize(width, height);
  if (this.autoSize) {
    var bbox = this.surface.items.getBBox();
    this.surface.setViewBox(bbox.x, bbox.y - +Ext.isOpera, width, height);
  }
}, createSurface:function() {
  var me = this, cfg = Ext.applyIf({renderTo:me.el, height:me.height, width:me.width, items:me.items}, me.initialConfig), surface;
  delete cfg.listeners;
  if (!cfg.gradients) {
    cfg.gradients = me.gradients;
  }
  me.initSurfaceCfg(cfg);
  surface = photoViewer.draw.Surface.create(cfg, me.enginePriority);
  if (!surface) {
    return false;
  }
  me.surface = surface;
  surface.owner = me;
  function refire(eventName) {
    return function(e) {
      me.fireEvent(eventName, e);
    };
  }
  surface.on({scope:me, mouseup:refire('mouseup'), mousedown:refire('mousedown'), mousemove:refire('mousemove'), mouseenter:refire('mouseenter'), mouseleave:refire('mouseleave'), click:refire('click'), dblclick:refire('dblclick')});
}, initSurfaceCfg:Ext.emptyFn, onDestroy:function() {
  Ext.destroy(this.surface);
  Ext.Component.prototype.onDestroy.apply(this, arguments);
}}, 0, 0, ['component', 'box'], {'component':true, 'box':true}, 0, 0, [photoViewer.draw, 'Component'], 0);
Ext.cmd.derive('photoViewer.draw.Draw', Ext.Base, {singleton:true, pathToStringRE:/,?([achlmqrstvxz]),?/gi, pathCommandRE:/([achlmqstvz])[\s,]*((-?\d*\.?\d*(?:e[-+]?\d+)?\s*,?\s*)+)/ig, pathValuesRE:/(-?\d*\.?\d*(?:e[-+]?\d+)?)\s*,?\s*/ig, stopsRE:/^(\d+%?)$/, radian:Math.PI / 180, availableAnimAttrs:{along:'along', blur:null, 'clip-rect':'csv', cx:null, cy:null, fill:'color', 'fill-opacity':null, 'font-size':null, height:null, opacity:null, path:'path', r:null, rotation:'csv', rx:null, ry:null, 
scale:'csv', stroke:'color', 'stroke-opacity':null, 'stroke-width':null, translation:'csv', width:null, x:null, y:null}, is:function(o, type) {
  type = String(type).toLowerCase();
  return type == 'object' && o === Object(o) || type == 'undefined' && typeof o == type || type == 'null' && o === null || type == 'array' && Array.isArray && Array.isArray(o) || Object.prototype.toString.call(o).toLowerCase().slice(8, -1) == type;
}, ellipsePath:function(sprite) {
  var attr = sprite.attr;
  return Ext.String.format('M{0},{1}A{2},{3},0,1,1,{0},{4}A{2},{3},0,1,1,{0},{1}z', attr.x, attr.y - attr.ry, attr.rx, attr.ry, attr.y + attr.ry);
}, rectPath:function(sprite) {
  var attr = sprite.attr;
  if (attr.radius) {
    return Ext.String.format('M{0},{1}l{2},0a{3},{3},0,0,1,{3},{3}l0,{5}a{3},{3},0,0,1,{4},{3}l{6},0a{3},{3},0,0,1,{4},{4}l0,{7}a{3},{3},0,0,1,{3},{4}z', attr.x + attr.radius, attr.y, attr.width - attr.radius * 2, attr.radius, -attr.radius, attr.height - attr.radius * 2, attr.radius * 2 - attr.width, attr.radius * 2 - attr.height);
  } else {
    return Ext.String.format('M{0},{1}L{2},{1},{2},{3},{0},{3}z', attr.x, attr.y, attr.width + attr.x, attr.height + attr.y);
  }
}, path2string:function() {
  return this.join(',').replace(photoViewer.draw.Draw.pathToStringRE, '$1');
}, pathToString:function(arrayPath) {
  return arrayPath.join(',').replace(photoViewer.draw.Draw.pathToStringRE, '$1');
}, parsePathString:function(pathString) {
  if (!pathString) {
    return null;
  }
  var paramCounts = {a:7, c:6, h:1, l:2, m:2, q:4, s:4, t:2, v:1, z:0}, data = [], me = this;
  if (me.is(pathString, 'array') && me.is(pathString[0], 'array')) {
    data = me.pathClone(pathString);
  }
  if (!data.length) {
    String(pathString).replace(me.pathCommandRE, function(a, b, c) {
      var params = [], name = b.toLowerCase();
      c.replace(me.pathValuesRE, function(a, b) {
        b && params.push(+b);
      });
      if (name == 'm' && params.length > 2) {
        data.push([b].concat(Ext.Array.splice(params, 0, 2)));
        name = 'l';
        b = b == 'm' ? 'l' : 'L';
      }
      while (params.length >= paramCounts[name]) {
        data.push([b].concat(Ext.Array.splice(params, 0, paramCounts[name])));
        if (!paramCounts[name]) {
          break;
        }
      }
    });
  }
  data.toString = me.path2string;
  return data;
}, mapPath:function(path, matrix) {
  if (!matrix) {
    return path;
  }
  var x, y, i, ii, j, jj, pathi;
  path = this.path2curve(path);
  for (i = 0, ii = path.length; i < ii; i++) {
    pathi = path[i];
    for (j = 1, jj = pathi.length; j < jj - 1; j += 2) {
      x = matrix.x(pathi[j], pathi[j + 1]);
      y = matrix.y(pathi[j], pathi[j + 1]);
      pathi[j] = x;
      pathi[j + 1] = y;
    }
  }
  return path;
}, pathClone:function(pathArray) {
  var res = [], j, jj, i, ii;
  if (!this.is(pathArray, 'array') || !this.is(pathArray && pathArray[0], 'array')) {
    pathArray = this.parsePathString(pathArray);
  }
  for (i = 0, ii = pathArray.length; i < ii; i++) {
    res[i] = [];
    for (j = 0, jj = pathArray[i].length; j < jj; j++) {
      res[i][j] = pathArray[i][j];
    }
  }
  res.toString = this.path2string;
  return res;
}, pathToAbsolute:function(pathArray) {
  if (!this.is(pathArray, 'array') || !this.is(pathArray && pathArray[0], 'array')) {
    pathArray = this.parsePathString(pathArray);
  }
  var res = [], x = 0, y = 0, mx = 0, my = 0, i = 0, ln = pathArray.length, r, pathSegment, j, ln2;
  if (ln && pathArray[0][0] == 'M') {
    x = +pathArray[0][1];
    y = +pathArray[0][2];
    mx = x;
    my = y;
    i++;
    res[0] = ['M', x, y];
  }
  for (; i < ln; i++) {
    r = res[i] = [];
    pathSegment = pathArray[i];
    if (pathSegment[0] != pathSegment[0].toUpperCase()) {
      r[0] = pathSegment[0].toUpperCase();
      switch(r[0]) {
        case 'A':
          r[1] = pathSegment[1];
          r[2] = pathSegment[2];
          r[3] = pathSegment[3];
          r[4] = pathSegment[4];
          r[5] = pathSegment[5];
          r[6] = +(pathSegment[6] + x);
          r[7] = +(pathSegment[7] + y);
          break;
        case 'V':
          r[1] = +pathSegment[1] + y;
          break;
        case 'H':
          r[1] = +pathSegment[1] + x;
          break;
        case 'M':
          mx = +pathSegment[1] + x;
          my = +pathSegment[2] + y;
        default:
          j = 1;
          ln2 = pathSegment.length;
          for (; j < ln2; j++) {
            r[j] = +pathSegment[j] + (j % 2 ? x : y);
          }
      }
    } else {
      j = 0;
      ln2 = pathSegment.length;
      for (; j < ln2; j++) {
        res[i][j] = pathSegment[j];
      }
    }
    switch(r[0]) {
      case 'Z':
        x = mx;
        y = my;
        break;
      case 'H':
        x = r[1];
        break;
      case 'V':
        y = r[1];
        break;
      case 'M':
        pathSegment = res[i];
        ln2 = pathSegment.length;
        mx = pathSegment[ln2 - 2];
        my = pathSegment[ln2 - 1];
      default:
        pathSegment = res[i];
        ln2 = pathSegment.length;
        x = pathSegment[ln2 - 2];
        y = pathSegment[ln2 - 1];
    }
  }
  res.toString = this.path2string;
  return res;
}, pathToRelative:function(pathArray) {
  if (!this.is(pathArray, 'array') || !this.is(pathArray && pathArray[0], 'array')) {
    pathArray = this.parsePathString(pathArray);
  }
  var res = [], x = 0, y = 0, mx = 0, my = 0, start = 0, r, pa, i, j, k, len, ii, jj, kk;
  if (pathArray[0][0] == 'M') {
    x = pathArray[0][1];
    y = pathArray[0][2];
    mx = x;
    my = y;
    start++;
    res.push(['M', x, y]);
  }
  for (i = start, ii = pathArray.length; i < ii; i++) {
    r = res[i] = [];
    pa = pathArray[i];
    if (pa[0] != pa[0].toLowerCase()) {
      r[0] = pa[0].toLowerCase();
      switch(r[0]) {
        case 'a':
          r[1] = pa[1];
          r[2] = pa[2];
          r[3] = pa[3];
          r[4] = pa[4];
          r[5] = pa[5];
          r[6] = +(pa[6] - x).toFixed(3);
          r[7] = +(pa[7] - y).toFixed(3);
          break;
        case 'v':
          r[1] = +(pa[1] - y).toFixed(3);
          break;
        case 'm':
          mx = pa[1];
          my = pa[2];
        default:
          for (j = 1, jj = pa.length; j < jj; j++) {
            r[j] = +(pa[j] - (j % 2 ? x : y)).toFixed(3);
          }
      }
    } else {
      r = res[i] = [];
      if (pa[0] == 'm') {
        mx = pa[1] + x;
        my = pa[2] + y;
      }
      for (k = 0, kk = pa.length; k < kk; k++) {
        res[i][k] = pa[k];
      }
    }
    len = res[i].length;
    switch(res[i][0]) {
      case 'z':
        x = mx;
        y = my;
        break;
      case 'h':
        x += +res[i][len - 1];
        break;
      case 'v':
        y += +res[i][len - 1];
        break;
      default:
        x += +res[i][len - 2];
        y += +res[i][len - 1];
    }
  }
  res.toString = this.path2string;
  return res;
}, path2curve:function(path) {
  var me = this, points = me.pathToAbsolute(path), ln = points.length, attrs = {x:0, y:0, bx:0, by:0, X:0, Y:0, qx:null, qy:null}, i, seg, segLn, point;
  for (i = 0; i < ln; i++) {
    points[i] = me.command2curve(points[i], attrs);
    if (points[i].length > 7) {
      points[i].shift();
      point = points[i];
      while (point.length) {
        Ext.Array.splice(points, i++, 0, ['C'].concat(Ext.Array.splice(point, 0, 6)));
      }
      Ext.Array.erase(points, i, 1);
      ln = points.length;
      i--;
    }
    seg = points[i];
    segLn = seg.length;
    attrs.x = seg[segLn - 2];
    attrs.y = seg[segLn - 1];
    attrs.bx = parseFloat(seg[segLn - 4]) || attrs.x;
    attrs.by = parseFloat(seg[segLn - 3]) || attrs.y;
  }
  return points;
}, interpolatePaths:function(path, path2) {
  var me = this, p = me.pathToAbsolute(path), p2 = me.pathToAbsolute(path2), attrs = {x:0, y:0, bx:0, by:0, X:0, Y:0, qx:null, qy:null}, attrs2 = {x:0, y:0, bx:0, by:0, X:0, Y:0, qx:null, qy:null}, fixArc = function(pp, i) {
    if (pp[i].length > 7) {
      pp[i].shift();
      var pi = pp[i];
      while (pi.length) {
        Ext.Array.splice(pp, i++, 0, ['C'].concat(Ext.Array.splice(pi, 0, 6)));
      }
      Ext.Array.erase(pp, i, 1);
      ii = Math.max(p.length, p2.length || 0);
    }
  }, fixM = function(path1, path2, a1, a2, i) {
    if (path1 && path2 && path1[i][0] == 'M' && path2[i][0] != 'M') {
      Ext.Array.splice(path2, i, 0, ['M', a2.x, a2.y]);
      a1.bx = 0;
      a1.by = 0;
      a1.x = path1[i][1];
      a1.y = path1[i][2];
      ii = Math.max(p.length, p2.length || 0);
    }
  }, i, ii, seg, seg2, seglen, seg2len;
  for (i = 0, ii = Math.max(p.length, p2.length || 0); i < ii; i++) {
    p[i] = me.command2curve(p[i], attrs);
    fixArc(p, i);
    p2[i] = me.command2curve(p2[i], attrs2);
    fixArc(p2, i);
    fixM(p, p2, attrs, attrs2, i);
    fixM(p2, p, attrs2, attrs, i);
    seg = p[i];
    seg2 = p2[i];
    seglen = seg.length;
    seg2len = seg2.length;
    attrs.x = seg[seglen - 2];
    attrs.y = seg[seglen - 1];
    attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
    attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
    attrs2.bx = parseFloat(seg2[seg2len - 4]) || attrs2.x;
    attrs2.by = parseFloat(seg2[seg2len - 3]) || attrs2.y;
    attrs2.x = seg2[seg2len - 2];
    attrs2.y = seg2[seg2len - 1];
  }
  return [p, p2];
}, command2curve:function(pathCommand, d) {
  var me = this;
  if (!pathCommand) {
    return ['C', d.x, d.y, d.x, d.y, d.x, d.y];
  }
  if (pathCommand[0] != 'T' && pathCommand[0] != 'Q') {
    d.qx = d.qy = null;
  }
  switch(pathCommand[0]) {
    case 'M':
      d.X = pathCommand[1];
      d.Y = pathCommand[2];
      break;
    case 'A':
      pathCommand = ['C'].concat(me.arc2curve.apply(me, [d.x, d.y].concat(pathCommand.slice(1))));
      break;
    case 'S':
      pathCommand = ['C', d.x + (d.x - (d.bx || d.x)), d.y + (d.y - (d.by || d.y))].concat(pathCommand.slice(1));
      break;
    case 'T':
      d.qx = d.x + (d.x - (d.qx || d.x));
      d.qy = d.y + (d.y - (d.qy || d.y));
      pathCommand = ['C'].concat(me.quadratic2curve(d.x, d.y, d.qx, d.qy, pathCommand[1], pathCommand[2]));
      break;
    case 'Q':
      d.qx = pathCommand[1];
      d.qy = pathCommand[2];
      pathCommand = ['C'].concat(me.quadratic2curve(d.x, d.y, pathCommand[1], pathCommand[2], pathCommand[3], pathCommand[4]));
      break;
    case 'L':
      pathCommand = ['C'].concat(d.x, d.y, pathCommand[1], pathCommand[2], pathCommand[1], pathCommand[2]);
      break;
    case 'H':
      pathCommand = ['C'].concat(d.x, d.y, pathCommand[1], d.y, pathCommand[1], d.y);
      break;
    case 'V':
      pathCommand = ['C'].concat(d.x, d.y, d.x, pathCommand[1], d.x, pathCommand[1]);
      break;
    case 'Z':
      pathCommand = ['C'].concat(d.x, d.y, d.X, d.Y, d.X, d.Y);
      break;
  }
  return pathCommand;
}, quadratic2curve:function(x1, y1, ax, ay, x2, y2) {
  var _13 = 1 / 3, _23 = 2 / 3;
  return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];
}, rotate:function(x, y, rad) {
  var cos = Math.cos(rad), sin = Math.sin(rad), X = x * cos - y * sin, Y = x * sin + y * cos;
  return {x:X, y:Y};
}, arc2curve:function(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
  var me = this, PI = Math.PI, radian = me.radian, _120 = PI * 120 / 180, rad = radian * (+angle || 0), res = [], math = Math, mcos = math.cos, msin = math.sin, msqrt = math.sqrt, mabs = math.abs, masin = math.asin, xy, x, y, h, rx2, ry2, k, cx, cy, f1, f2, df, c1, s1, c2, s2, t, hx, hy, m1, m2, m3, m4, newres, i, ln, f2old, x2old, y2old;
  if (!recursive) {
    xy = me.rotate(x1, y1, -rad);
    x1 = xy.x;
    y1 = xy.y;
    xy = me.rotate(x2, y2, -rad);
    x2 = xy.x;
    y2 = xy.y;
    x = (x1 - x2) / 2;
    y = (y1 - y2) / 2;
    h = x * x / (rx * rx) + y * y / (ry * ry);
    if (h > 1) {
      h = msqrt(h);
      rx = h * rx;
      ry = h * ry;
    }
    rx2 = rx * rx;
    ry2 = ry * ry;
    k = (large_arc_flag == sweep_flag ? -1 : 1) * msqrt(mabs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
    cx = k * rx * y / ry + (x1 + x2) / 2;
    cy = k * -ry * x / rx + (y1 + y2) / 2;
    f1 = masin(((y1 - cy) / ry).toFixed(7));
    f2 = masin(((y2 - cy) / ry).toFixed(7));
    f1 = x1 < cx ? PI - f1 : f1;
    f2 = x2 < cx ? PI - f2 : f2;
    if (f1 < 0) {
      f1 = PI * 2 + f1;
    }
    if (f2 < 0) {
      f2 = PI * 2 + f2;
    }
    if (sweep_flag && f1 > f2) {
      f1 = f1 - PI * 2;
    }
    if (!sweep_flag && f2 > f1) {
      f2 = f2 - PI * 2;
    }
  } else {
    f1 = recursive[0];
    f2 = recursive[1];
    cx = recursive[2];
    cy = recursive[3];
  }
  df = f2 - f1;
  if (mabs(df) > _120) {
    f2old = f2;
    x2old = x2;
    y2old = y2;
    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
    x2 = cx + rx * mcos(f2);
    y2 = cy + ry * msin(f2);
    res = me.arc2curve(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
  }
  df = f2 - f1;
  c1 = mcos(f1);
  s1 = msin(f1);
  c2 = mcos(f2);
  s2 = msin(f2);
  t = math.tan(df / 4);
  hx = 4 / 3 * rx * t;
  hy = 4 / 3 * ry * t;
  m1 = [x1, y1];
  m2 = [x1 + hx * s1, y1 - hy * c1];
  m3 = [x2 + hx * s2, y2 - hy * c2];
  m4 = [x2, y2];
  m2[0] = 2 * m1[0] - m2[0];
  m2[1] = 2 * m1[1] - m2[1];
  if (recursive) {
    return [m2, m3, m4].concat(res);
  } else {
    res = [m2, m3, m4].concat(res).join().split(',');
    newres = [];
    ln = res.length;
    for (i = 0; i < ln; i++) {
      newres[i] = i % 2 ? me.rotate(res[i - 1], res[i], rad).y : me.rotate(res[i], res[i + 1], rad).x;
    }
    return newres;
  }
}, rotateAndTranslatePath:function(sprite) {
  var alpha = sprite.rotation.degrees, cx = sprite.rotation.x, cy = sprite.rotation.y, dx = sprite.translation.x, dy = sprite.translation.y, path, i, p, xy, j, res = [];
  if (!alpha && !dx && !dy) {
    return this.pathToAbsolute(sprite.attr.path);
  }
  dx = dx || 0;
  dy = dy || 0;
  path = this.pathToAbsolute(sprite.attr.path);
  for (i = path.length; i--;) {
    p = res[i] = path[i].slice();
    if (p[0] == 'A') {
      xy = this.rotatePoint(p[6], p[7], alpha, cx, cy);
      p[6] = xy.x + dx;
      p[7] = xy.y + dy;
    } else {
      j = 1;
      while (p[j + 1] != null) {
        xy = this.rotatePoint(p[j], p[j + 1], alpha, cx, cy);
        p[j] = xy.x + dx;
        p[j + 1] = xy.y + dy;
        j += 2;
      }
    }
  }
  return res;
}, rotatePoint:function(x, y, alpha, cx, cy) {
  if (!alpha) {
    return {x:x, y:y};
  }
  cx = cx || 0;
  cy = cy || 0;
  x = x - cx;
  y = y - cy;
  alpha = alpha * this.radian;
  var cos = Math.cos(alpha), sin = Math.sin(alpha);
  return {x:x * cos - y * sin + cx, y:x * sin + y * cos + cy};
}, pathDimensions:function(path) {
  if (!path || !(path + '')) {
    return {x:0, y:0, width:0, height:0};
  }
  path = this.path2curve(path);
  var x = 0, y = 0, X = [], Y = [], i = 0, ln = path.length, p, xmin, ymin, xmax, ymax, dim;
  for (; i < ln; i++) {
    p = path[i];
    if (p[0] == 'M') {
      x = p[1];
      y = p[2];
      X.push(x);
      Y.push(y);
    } else {
      dim = this.curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
      X = X.concat(dim.min.x, dim.max.x);
      Y = Y.concat(dim.min.y, dim.max.y);
      x = p[5];
      y = p[6];
    }
  }
  xmin = Math.min.apply(0, X);
  ymin = Math.min.apply(0, Y);
  xmax = Math.max.apply(0, X);
  ymax = Math.max.apply(0, Y);
  return {x:Math.round(xmin), y:Math.round(ymin), path:path, width:Math.round(xmax - xmin), height:Math.round(ymax - ymin)};
}, intersectInside:function(path, cp1, cp2) {
  return (cp2[0] - cp1[0]) * (path[1] - cp1[1]) > (cp2[1] - cp1[1]) * (path[0] - cp1[0]);
}, intersectIntersection:function(s, e, cp1, cp2) {
  var p = [], dcx = cp1[0] - cp2[0], dcy = cp1[1] - cp2[1], dpx = s[0] - e[0], dpy = s[1] - e[1], n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0], n2 = s[0] * e[1] - s[1] * e[0], n3 = 1 / (dcx * dpy - dcy * dpx);
  p[0] = (n1 * dpx - n2 * dcx) * n3;
  p[1] = (n1 * dpy - n2 * dcy) * n3;
  return p;
}, intersect:function(subjectPolygon, clipPolygon) {
  var me = this, i = 0, ln = clipPolygon.length, cp1 = clipPolygon[ln - 1], outputList = subjectPolygon, cp2, s, e, ln2, inputList, j;
  for (; i < ln; ++i) {
    cp2 = clipPolygon[i];
    inputList = outputList;
    outputList = [];
    s = inputList[inputList.length - 1];
    j = 0;
    ln2 = inputList.length;
    for (; j < ln2; j++) {
      e = inputList[j];
      if (me.intersectInside(e, cp1, cp2)) {
        if (!me.intersectInside(s, cp1, cp2)) {
          outputList.push(me.intersectIntersection(s, e, cp1, cp2));
        }
        outputList.push(e);
      } else {
        if (me.intersectInside(s, cp1, cp2)) {
          outputList.push(me.intersectIntersection(s, e, cp1, cp2));
        }
      }
      s = e;
    }
    cp1 = cp2;
  }
  return outputList;
}, bezier:function(a, b, c, d, x) {
  if (x === 0) {
    return a;
  } else {
    if (x === 1) {
      return d;
    }
  }
  var du = 1 - x, d3 = du * du * du, r = x / du;
  return d3 * (a + r * (3 * b + r * (3 * c + d * r)));
}, bezierDim:function(a, b, c, d) {
  var points = [], r, A, top, C, delta, bottom, s, min, max, i;
  if (a + 3 * c == d + 3 * b) {
    r = a - b;
    r /= 2 * (a - b - b + c);
    if (r < 1 && r > 0) {
      points.push(r);
    }
  } else {
    A = a - 3 * b + 3 * c - d;
    top = 2 * (a - b - b + c);
    C = a - b;
    delta = top * top - 4 * A * C;
    bottom = A + A;
    if (delta === 0) {
      r = top / bottom;
      if (r < 1 && r > 0) {
        points.push(r);
      }
    } else {
      if (delta > 0) {
        s = Math.sqrt(delta);
        r = (s + top) / bottom;
        if (r < 1 && r > 0) {
          points.push(r);
        }
        r = (top - s) / bottom;
        if (r < 1 && r > 0) {
          points.push(r);
        }
      }
    }
  }
  min = Math.min(a, d);
  max = Math.max(a, d);
  for (i = 0; i < points.length; i++) {
    min = Math.min(min, this.bezier(a, b, c, d, points[i]));
    max = Math.max(max, this.bezier(a, b, c, d, points[i]));
  }
  return [min, max];
}, curveDim:function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
  var x = this.bezierDim(p1x, c1x, c2x, p2x), y = this.bezierDim(p1y, c1y, c2y, p2y);
  return {min:{x:x[0], y:y[0]}, max:{x:x[1], y:y[1]}};
}, getAnchors:function(prevX, prevY, curX, curY, nextX, nextY, value) {
  value = value || 4;
  var M = Math, PI = M.PI, halfPI = PI / 2, abs = M.abs, sin = M.sin, cos = M.cos, atan = M.atan, control1Length, control2Length, control1Angle, control2Angle, control1X, control1Y, control2X, control2Y, alpha;
  control1Length = (curX - prevX) / value;
  control2Length = (nextX - curX) / value;
  if (curY >= prevY && curY >= nextY || curY <= prevY && curY <= nextY) {
    control1Angle = control2Angle = halfPI;
  } else {
    control1Angle = atan((curX - prevX) / abs(curY - prevY));
    if (prevY < curY) {
      control1Angle = PI - control1Angle;
    }
    control2Angle = atan((nextX - curX) / abs(curY - nextY));
    if (nextY < curY) {
      control2Angle = PI - control2Angle;
    }
  }
  alpha = halfPI - (control1Angle + control2Angle) % (PI * 2) / 2;
  if (alpha > halfPI) {
    alpha -= PI;
  }
  control1Angle += alpha;
  control2Angle += alpha;
  control1X = curX - control1Length * sin(control1Angle);
  control1Y = curY + control1Length * cos(control1Angle);
  control2X = curX + control2Length * sin(control2Angle);
  control2Y = curY + control2Length * cos(control2Angle);
  if (curY > prevY && control1Y < prevY || curY < prevY && control1Y > prevY) {
    control1X += abs(prevY - control1Y) * (control1X - curX) / (control1Y - curY);
    control1Y = prevY;
  }
  if (curY > nextY && control2Y < nextY || curY < nextY && control2Y > nextY) {
    control2X -= abs(nextY - control2Y) * (control2X - curX) / (control2Y - curY);
    control2Y = nextY;
  }
  return {x1:control1X, y1:control1Y, x2:control2X, y2:control2Y};
}, smooth:function(originalPath, value) {
  var path = this.path2curve(originalPath), newp = [path[0]], x = path[0][1], y = path[0][2], j, points, i = 1, ii = path.length, beg = 1, mx = x, my = y, pathi, pathil, pathim, pathiml, pathip, pathipl, begl;
  for (; i < ii; i++) {
    pathi = path[i];
    pathil = pathi.length;
    pathim = path[i - 1];
    pathiml = pathim.length;
    pathip = path[i + 1];
    pathipl = pathip && pathip.length;
    if (pathi[0] == 'M') {
      mx = pathi[1];
      my = pathi[2];
      j = i + 1;
      while (path[j][0] != 'C') {
        j++;
      }
      newp.push(['M', mx, my]);
      beg = newp.length;
      x = mx;
      y = my;
      continue;
    }
    if (pathi[pathil - 2] == mx && pathi[pathil - 1] == my && (!pathip || pathip[0] == 'M')) {
      begl = newp[beg].length;
      points = this.getAnchors(pathim[pathiml - 2], pathim[pathiml - 1], mx, my, newp[beg][begl - 2], newp[beg][begl - 1], value);
      newp[beg][1] = points.x2;
      newp[beg][2] = points.y2;
    } else {
      if (!pathip || pathip[0] == 'M') {
        points = {x1:pathi[pathil - 2], y1:pathi[pathil - 1]};
      } else {
        points = this.getAnchors(pathim[pathiml - 2], pathim[pathiml - 1], pathi[pathil - 2], pathi[pathil - 1], pathip[pathipl - 2], pathip[pathipl - 1], value);
      }
    }
    newp.push(['C', x, y, points.x1, points.y1, pathi[pathil - 2], pathi[pathil - 1]]);
    x = points.x2;
    y = points.y2;
  }
  return newp;
}, findDotAtSegment:function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
  var t1 = 1 - t;
  return {x:Math.pow(t1, 3) * p1x + Math.pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + Math.pow(t, 3) * p2x, y:Math.pow(t1, 3) * p1y + Math.pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + Math.pow(t, 3) * p2y};
}, snapEnds:function(from, to, stepsMax, prettyNumbers) {
  if (Ext.isDate(from)) {
    return this.snapEndsByDate(from, to, stepsMax);
  }
  var step = (to - from) / stepsMax, level = Math.floor(Math.log(step) / Math.LN10) + 1, m = Math.pow(10, level), cur, floor, modulo = Math.round(step % m * Math.pow(10, 2 - level)), interval = [[0, 15], [10, 1], [20, 4], [25, 2], [50, 9], [100, 15]], stepCount = 0, value, weight, i, topValue, topWeight = 1000000000, ln = interval.length;
  floor = Math.floor(from / m) * m;
  if (from == floor && floor > 0) {
    floor = Math.floor((from - m / 10) / m) * m;
  }
  if (prettyNumbers) {
    for (i = 0; i < ln; i++) {
      value = interval[i][0];
      weight = value - modulo < 0 ? 1000000 : (value - modulo) / interval[i][1];
      if (weight < topWeight) {
        topValue = value;
        topWeight = weight;
      }
    }
    step = Math.floor(step * Math.pow(10, -level)) * Math.pow(10, level) + topValue * Math.pow(10, level - 2);
    if (from < 0 && to >= 0) {
      cur = 0;
      while (cur > from) {
        cur -= step;
        stepCount++;
      }
      from = +cur.toFixed(10);
      cur = 0;
      while (cur < to) {
        cur += step;
        stepCount++;
      }
      to = +cur.toFixed(10);
    } else {
      cur = from = floor;
      while (cur < to) {
        cur += step;
        stepCount++;
      }
    }
    to = +cur.toFixed(10);
  } else {
    from = floor;
    stepCount = stepsMax;
  }
  return {from:from, to:to, power:level, step:step, steps:stepCount};
}, snapEndsByDate:function(from, to, stepsMax, lockEnds) {
  var selectedStep = false, scales = [[Ext.Date.MILLI, [1, 2, 5, 10, 20, 50, 100, 200, 250, 500]], [Ext.Date.SECOND, [1, 2, 5, 10, 15, 30]], [Ext.Date.MINUTE, [1, 2, 5, 10, 15, 30]], [Ext.Date.HOUR, [1, 2, 3, 4, 6, 12]], [Ext.Date.DAY, [1, 2, 7, 14]], [Ext.Date.MONTH, [1, 2, 3, 6]]], sLen = scales.length, stop = false, scale, j, yearDiff, s;
  for (s = 0; s < sLen; s++) {
    scale = scales[s];
    if (!stop) {
      for (j = 0; j < scale[1].length; j++) {
        if (to < Ext.Date.add(from, scale[0], scale[1][j] * stepsMax)) {
          selectedStep = [scale[0], scale[1][j]];
          stop = true;
          break;
        }
      }
    }
  }
  if (!selectedStep) {
    yearDiff = this.snapEnds(from.getFullYear(), to.getFullYear() + 1, stepsMax, lockEnds);
    selectedStep = [Date.YEAR, Math.round(yearDiff.step)];
  }
  return this.snapEndsByDateAndStep(from, to, selectedStep, lockEnds);
}, snapEndsByDateAndStep:function(from, to, step, lockEnds) {
  var fromStat = [from.getFullYear(), from.getMonth(), from.getDate(), from.getHours(), from.getMinutes(), from.getSeconds(), from.getMilliseconds()], testFrom, testTo, date, year, month, day, fractionalMonth, stepsArray, stepUnit = step[0], stepValue = step[1], steps = 0;
  if (lockEnds) {
    testFrom = from;
  } else {
    switch(stepUnit) {
      case Ext.Date.MILLI:
        testFrom = new Date(fromStat[0], fromStat[1], fromStat[2], fromStat[3], fromStat[4], fromStat[5], Math.floor(fromStat[6] / stepValue) * stepValue);
        break;
      case Ext.Date.SECOND:
        testFrom = new Date(fromStat[0], fromStat[1], fromStat[2], fromStat[3], fromStat[4], Math.floor(fromStat[5] / stepValue) * stepValue, 0);
        break;
      case Ext.Date.MINUTE:
        testFrom = new Date(fromStat[0], fromStat[1], fromStat[2], fromStat[3], Math.floor(fromStat[4] / stepValue) * stepValue, 0, 0);
        break;
      case Ext.Date.HOUR:
        testFrom = new Date(fromStat[0], fromStat[1], fromStat[2], Math.floor(fromStat[3] / stepValue) * stepValue, 0, 0, 0);
        break;
      case Ext.Date.DAY:
        testFrom = new Date(fromStat[0], fromStat[1], Math.floor((fromStat[2] - 1) / stepValue) * stepValue + 1, 0, 0, 0, 0);
        break;
      case Ext.Date.MONTH:
        testFrom = new Date(fromStat[0], Math.floor(fromStat[1] / stepValue) * stepValue, 1, 0, 0, 0, 0);
        steps = [];
        stepsArray = true;
        break;
      default:
        testFrom = new Date(Math.floor(fromStat[0] / stepValue) * stepValue, 0, 1, 0, 0, 0, 0);
        steps = [];
        stepsArray = true;
        break;
    }
  }
  fractionalMonth = stepUnit === Ext.Date.MONTH && (stepValue == 1 / 2 || stepValue == 1 / 3 || stepValue == 1 / 4);
  testTo = new Date(testFrom);
  while (testTo < to) {
    if (fractionalMonth) {
      date = new Date(testTo);
      year = date.getFullYear();
      month = date.getMonth();
      day = date.getDate();
      switch(stepValue) {
        case 1 / 2:
          if (day >= 15) {
            day = 1;
            if (++month > 11) {
              year++;
            }
          } else {
            day = 15;
          }
          break;
        case 1 / 3:
          if (day >= 20) {
            day = 1;
            if (++month > 11) {
              year++;
            }
          } else {
            if (day >= 10) {
              day = 20;
            } else {
              day = 10;
            }
          }
          break;
        case 1 / 4:
          if (day >= 22) {
            day = 1;
            if (++month > 11) {
              year++;
            }
          } else {
            if (day >= 15) {
              day = 22;
            } else {
              if (day >= 8) {
                day = 15;
              } else {
                day = 8;
              }
            }
          }
          break;
      }
      testTo.setYear(year);
      testTo.setMonth(month);
      testTo.setDate(day);
      steps.push(new Date(testTo));
    } else {
      if (stepsArray) {
        testTo = Ext.Date.add(testTo, stepUnit, stepValue);
        steps.push(new Date(testTo));
      } else {
        testTo = Ext.Date.add(testTo, stepUnit, stepValue);
        steps++;
      }
    }
  }
  if (lockEnds) {
    testTo = to;
  }
  if (stepsArray) {
    return {from:+testFrom, to:+testTo, steps:steps};
  } else {
    return {from:+testFrom, to:+testTo, step:(testTo - testFrom) / steps, steps:steps};
  }
}, sorter:function(a, b) {
  return a.offset - b.offset;
}, rad:function(degrees) {
  return degrees % 360 * Math.PI / 180;
}, normalizeRadians:function(radian) {
  var twoPi = 2 * Math.PI;
  if (radian >= 0) {
    return radian % twoPi;
  }
  return (radian % twoPi + twoPi) % twoPi;
}, degrees:function(radian) {
  return radian * 180 / Math.PI % 360;
}, normalizeDegrees:function(degrees) {
  if (degrees >= 0) {
    return degrees % 360;
  }
  return (degrees % 360 + 360) % 360;
}, withinBox:function(x, y, bbox) {
  bbox = bbox || {};
  return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;
}, parseGradient:function(gradient) {
  var me = this, type = gradient.type || 'linear', angle = gradient.angle || 0, radian = me.radian, stops = gradient.stops, stopsArr = [], stop, vector, max, stopObj;
  if (type == 'linear') {
    vector = [0, 0, Math.cos(angle * radian), Math.sin(angle * radian)];
    max = 1 / (Math.max(Math.abs(vector[2]), Math.abs(vector[3])) || 1);
    vector[2] *= max;
    vector[3] *= max;
    if (vector[2] < 0) {
      vector[0] = -vector[2];
      vector[2] = 0;
    }
    if (vector[3] < 0) {
      vector[1] = -vector[3];
      vector[3] = 0;
    }
  }
  for (stop in stops) {
    if (stops.hasOwnProperty(stop) && me.stopsRE.test(stop)) {
      stopObj = {offset:parseInt(stop, 10), color:photoViewer.draw.Color.toHex(stops[stop].color) || '#ffffff', opacity:stops[stop].opacity || 1};
      stopsArr.push(stopObj);
    }
  }
  Ext.Array.sort(stopsArr, me.sorter);
  if (type == 'linear') {
    return {id:gradient.id, type:type, vector:vector, stops:stopsArr};
  } else {
    return {id:gradient.id, type:type, centerX:gradient.centerX, centerY:gradient.centerY, focalX:gradient.focalX, focalY:gradient.focalY, radius:gradient.radius, vector:vector, stops:stopsArr};
  }
}}, 0, 0, 0, 0, 0, 0, [photoViewer.draw, 'Draw'], 0);
Ext.cmd.derive('photoViewer.draw.Matrix', Ext.Base, {constructor:function(a, b, c, d, e, f) {
  if (a != null) {
    this.matrix = [[a, c, e], [b, d, f], [0, 0, 1]];
  } else {
    this.matrix = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
  }
}, add:function(a, b, c, d, e, f) {
  var me = this, out = [[], [], []], matrix = [[a, c, e], [b, d, f], [0, 0, 1]], x, y, z, res;
  for (x = 0; x < 3; x++) {
    for (y = 0; y < 3; y++) {
      res = 0;
      for (z = 0; z < 3; z++) {
        res += me.matrix[x][z] * matrix[z][y];
      }
      out[x][y] = res;
    }
  }
  me.matrix = out;
}, prepend:function(a, b, c, d, e, f) {
  var me = this, out = [[], [], []], matrix = [[a, c, e], [b, d, f], [0, 0, 1]], x, y, z, res;
  for (x = 0; x < 3; x++) {
    for (y = 0; y < 3; y++) {
      res = 0;
      for (z = 0; z < 3; z++) {
        res += matrix[x][z] * me.matrix[z][y];
      }
      out[x][y] = res;
    }
  }
  me.matrix = out;
}, invert:function() {
  var matrix = this.matrix, a = matrix[0][0], b = matrix[1][0], c = matrix[0][1], d = matrix[1][1], e = matrix[0][2], f = matrix[1][2], x = a * d - b * c;
  return new photoViewer.draw.Matrix(d / x, -b / x, -c / x, a / x, (c * f - d * e) / x, (b * e - a * f) / x);
}, clone:function() {
  var matrix = this.matrix, a = matrix[0][0], b = matrix[1][0], c = matrix[0][1], d = matrix[1][1], e = matrix[0][2], f = matrix[1][2];
  return new photoViewer.draw.Matrix(a, b, c, d, e, f);
}, translate:function(x, y) {
  this.prepend(1, 0, 0, 1, x, y);
}, scale:function(x, y, cx, cy) {
  var me = this;
  if (y == null) {
    y = x;
  }
  me.add(x, 0, 0, y, cx * (1 - x), cy * (1 - y));
}, rotate:function(a, x, y) {
  a = photoViewer.draw.Draw.rad(a);
  var me = this, cos = +Math.cos(a).toFixed(9), sin = +Math.sin(a).toFixed(9);
  me.add(cos, sin, -sin, cos, x - cos * x + sin * y, -(sin * x) + y - cos * y);
}, x:function(x, y) {
  var matrix = this.matrix;
  return x * matrix[0][0] + y * matrix[0][1] + matrix[0][2];
}, y:function(x, y) {
  var matrix = this.matrix;
  return x * matrix[1][0] + y * matrix[1][1] + matrix[1][2];
}, get:function(i, j) {
  return +this.matrix[i][j].toFixed(4);
}, toString:function() {
  var me = this;
  return [me.get(0, 0), me.get(0, 1), me.get(1, 0), me.get(1, 1), 0, 0].join();
}, toSvg:function() {
  var me = this;
  return 'matrix(' + [me.get(0, 0), me.get(1, 0), me.get(0, 1), me.get(1, 1), me.get(0, 2), me.get(1, 2)].join() + ')';
}, toFilter:function(dx, dy) {
  var me = this;
  dx = dx || 0;
  dy = dy || 0;
  return "progid:DXImageTransform.Microsoft.Matrix(sizingMethod\x3d'auto expand', filterType\x3d'bilinear', M11\x3d" + me.get(0, 0) + ', M12\x3d' + me.get(0, 1) + ', M21\x3d' + me.get(1, 0) + ', M22\x3d' + me.get(1, 1) + ', Dx\x3d' + (me.get(0, 2) + dx) + ', Dy\x3d' + (me.get(1, 2) + dy) + ')';
}, offset:function() {
  var matrix = this.matrix;
  return [(matrix[0][2] || 0).toFixed(4), (matrix[1][2] || 0).toFixed(4)];
}, split:function() {
  function norm(a) {
    return a[0] * a[0] + a[1] * a[1];
  }
  function normalize(a) {
    var mag = Math.sqrt(norm(a));
    a[0] /= mag;
    a[1] /= mag;
  }
  var matrix = this.matrix, out = {translateX:matrix[0][2], translateY:matrix[1][2]}, row;
  row = [[matrix[0][0], matrix[0][1]], [matrix[1][1], matrix[1][1]]];
  out.scaleX = Math.sqrt(norm(row[0]));
  normalize(row[0]);
  out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];
  row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];
  out.scaleY = Math.sqrt(norm(row[1]));
  normalize(row[1]);
  out.shear /= out.scaleY;
  out.rotate = Math.asin(-row[0][1]);
  out.isSimple = !+out.shear.toFixed(9) && (out.scaleX.toFixed(9) == out.scaleY.toFixed(9) || !out.rotate);
  return out;
}}, 3, 0, 0, 0, 0, 0, [photoViewer.draw, 'Matrix'], 0);
(function() {
  var PI2_3 = 2.0943951023931953, abs = Math.abs, sin = Math.cos, cos = Math.cos, acos = Math.acos, sqrt = Math.sqrt, exp = Math.exp, log = Math.log;
  Ext.cmd.derive('photoViewer.draw.Solver', Ext.Base, {singleton:true, cubicRoot:function(number) {
    if (number > 0) {
      return exp(log(number) / 3);
    } else {
      if (number < 0) {
        return -exp(log(-number) / 3);
      } else {
        return 0;
      }
    }
  }, linearFunction:function(a, b) {
    var result;
    if (a === 0) {
      result = function(t) {
        return b;
      };
      result.solve = function(y) {
        return [];
      };
    } else {
      result = function(t) {
        return a * t + b;
      };
      result.solve = function(y) {
        return [(y - b) / a];
      };
    }
    return result;
  }, quadraticFunction:function(a, b, c) {
    var result;
    if (a === 0) {
      return this.linearFunction(b, c);
    } else {
      result = function(t) {
        return (a * t + b) * t + c;
      };
      var delta0temp = b * b - 4 * a * c, delta = function(y) {
        return delta0temp + 4 * a * y;
      }, solveTemp0 = 1 / a * 0.5, solveTemp1 = -solveTemp0 * b;
      solveTemp0 = abs(solveTemp0);
      result.solve = function(y) {
        var deltaTemp = delta(y);
        if (deltaTemp < 0) {
          return [];
        }
        deltaTemp = sqrt(deltaTemp);
        return [solveTemp1 - deltaTemp * solveTemp0, solveTemp1 + deltaTemp * solveTemp0];
      };
    }
    return result;
  }, cubicFunction:function(a, b, c, d) {
    var result;
    if (a === 0) {
      return this.quadraticFunction(b, c, d);
    } else {
      result = function(t) {
        return ((a * t + b) * t + c) * t + d;
      };
      var b_a_3 = b / a / 3, c_a = c / a, d_a = d / a, b2 = b_a_3 * b_a_3, deltaTemp0 = (b_a_3 * c_a - d_a) * 0.5 - b_a_3 * b2, deltaTemp1 = b2 - c_a / 3, deltaTemp13 = deltaTemp1 * deltaTemp1 * deltaTemp1;
      if (deltaTemp1 === 0) {
        result.solve = function(y) {
          return [-b_a_3 + this.cubicRoot(deltaTemp0 * 2 + y / a)];
        };
      } else {
        if (deltaTemp1 > 0) {
          var deltaTemp1_2 = sqrt(deltaTemp1), deltaTemp13_2 = deltaTemp1_2 * deltaTemp1_2 * deltaTemp1_2;
          deltaTemp1_2 += deltaTemp1_2;
        }
        result.solve = function(y) {
          y /= a;
          var d0 = deltaTemp0 + y * 0.5, deltaTemp = d0 * d0 - deltaTemp13;
          if (deltaTemp > 0) {
            deltaTemp = sqrt(deltaTemp);
            return [-b_a_3 + this.cubicRoot(d0 + deltaTemp) + this.cubicRoot(d0 - deltaTemp)];
          } else {
            if (deltaTemp === 0) {
              var cr = this.cubicRoot(d0), root0 = -b_a_3 - cr;
              if (d0 >= 0) {
                return [root0, root0, -b_a_3 + 2 * cr];
              } else {
                return [-b_a_3 + 2 * cr, root0, root0];
              }
            } else {
              var theta = acos(d0 / deltaTemp13_2) / 3, ra = deltaTemp1_2 * cos(theta) - b_a_3, rb = deltaTemp1_2 * cos(theta + PI2_3) - b_a_3, rc = deltaTemp1_2 * cos(theta - PI2_3) - b_a_3;
              if (ra < rb) {
                if (rb < rc) {
                  return [ra, rb, rc];
                } else {
                  if (ra < rc) {
                    return [ra, rc, rb];
                  } else {
                    return [rc, ra, rb];
                  }
                }
              } else {
                if (ra < rc) {
                  return [rb, ra, rc];
                } else {
                  if (rb < rc) {
                    return [rb, rc, ra];
                  } else {
                    return [rc, rb, ra];
                  }
                }
              }
            }
          }
        };
      }
    }
    return result;
  }, createBezierSolver:function(a, b, c, d) {
    return this.cubicFunction(3 * (b - c) + d - a, 3 * (a - 2 * b + c), 3 * (b - a), a);
  }}, 0, 0, 0, 0, 0, 0, [photoViewer.draw, 'Solver'], 0);
})();
Ext.cmd.derive('photoViewer.draw.Path', Ext.Base, {statics:{pathRe:/,?([achlmqrstvxz]),?/gi, pathRe2:/-/gi, pathSplitRe:/\s|,/g}, svgString:'', constructor:function(pathString) {
  var me = this;
  me.coords = [];
  me.types = [];
  me.cursor = null;
  me.startX = 0;
  me.startY = 0;
  me.solvers = {};
  if (pathString) {
    me.fromSvgString(pathString);
  }
}, clear:function() {
  var me = this;
  me.coords.length = 0;
  me.types.length = 0;
  me.cursor = null;
  me.startX = 0;
  me.startY = 0;
  me.solvers = {};
  me.dirt();
}, dirt:function() {
  this.svgString = '';
}, moveTo:function(x, y) {
  var me = this;
  if (!me.cursor) {
    me.cursor = [x, y];
  }
  me.coords.push(x, y);
  me.types.push('M');
  me.startX = x;
  me.startY = y;
  me.cursor[0] = x;
  me.cursor[1] = y;
  me.dirt();
}, lineTo:function(x, y) {
  var me = this;
  if (!me.cursor) {
    me.cursor = [x, y];
    me.coords.push(x, y);
    me.types.push('M');
  } else {
    me.coords.push(x, y);
    me.types.push('L');
  }
  me.cursor[0] = x;
  me.cursor[1] = y;
  me.dirt();
}, bezierCurveTo:function(cx1, cy1, cx2, cy2, x, y) {
  var me = this;
  if (!me.cursor) {
    me.moveTo(cx1, cy1);
  }
  me.coords.push(cx1, cy1, cx2, cy2, x, y);
  me.types.push('C');
  me.cursor[0] = x;
  me.cursor[1] = y;
  me.dirt();
}, quadraticCurveTo:function(cx, cy, x, y) {
  var me = this;
  if (!me.cursor) {
    me.moveTo(cx, cy);
  }
  me.bezierCurveTo((me.cursor[0] * 2 + cx) / 3, (me.cursor[1] * 2 + cy) / 3, (x * 2 + cx) / 3, (y * 2 + cy) / 3, x, y);
}, closePath:function() {
  var me = this;
  if (me.cursor) {
    me.types.push('Z');
    me.dirt();
  }
}, arcTo:function(x1, y1, x2, y2, rx, ry, rotation) {
  var me = this;
  if (ry === undefined) {
    ry = rx;
  }
  if (rotation === undefined) {
    rotation = 0;
  }
  if (!me.cursor) {
    me.moveTo(x1, y1);
    return;
  }
  if (rx === 0 || ry === 0) {
    me.lineTo(x1, y1);
    return;
  }
  x2 -= x1;
  y2 -= y1;
  var x0 = me.cursor[0] - x1, y0 = me.cursor[1] - y1, area = x2 * y0 - y2 * x0, cos, sin, xx, yx, xy, yy, l0 = Math.sqrt(x0 * x0 + y0 * y0), l2 = Math.sqrt(x2 * x2 + y2 * y2), dist, cx, cy;
  if (area === 0) {
    me.lineTo(x1, y1);
    return;
  }
  if (ry !== rx) {
    cos = Math.cos(rotation);
    sin = Math.sin(rotation);
    xx = cos / rx;
    yx = sin / ry;
    xy = -sin / rx;
    yy = cos / ry;
    var temp = xx * x0 + yx * y0;
    y0 = xy * x0 + yy * y0;
    x0 = temp;
    temp = xx * x2 + yx * y2;
    y2 = xy * x2 + yy * y2;
    x2 = temp;
  } else {
    x0 /= rx;
    y0 /= ry;
    x2 /= rx;
    y2 /= ry;
  }
  cx = x0 * l2 + x2 * l0;
  cy = y0 * l2 + y2 * l0;
  dist = 1 / (Math.sin(Math.asin(Math.abs(area) / (l0 * l2)) * 0.5) * Math.sqrt(cx * cx + cy * cy));
  cx *= dist;
  cy *= dist;
  var k0 = (cx * x0 + cy * y0) / (x0 * x0 + y0 * y0), k2 = (cx * x2 + cy * y2) / (x2 * x2 + y2 * y2);
  var cosStart = x0 * k0 - cx, sinStart = y0 * k0 - cy, cosEnd = x2 * k2 - cx, sinEnd = y2 * k2 - cy, startAngle = Math.atan2(sinStart, cosStart), endAngle = Math.atan2(sinEnd, cosEnd);
  if (area > 0) {
    if (endAngle < startAngle) {
      endAngle += Math.PI * 2;
    }
  } else {
    if (startAngle < endAngle) {
      startAngle += Math.PI * 2;
    }
  }
  if (ry !== rx) {
    cx = cos * cx * rx - sin * cy * ry + x1;
    cy = sin * cy * ry + cos * cy * ry + y1;
    me.lineTo(cos * rx * cosStart - sin * ry * sinStart + cx, sin * rx * cosStart + cos * ry * sinStart + cy);
    me.ellipse(cx, cy, rx, ry, rotation, startAngle, endAngle, area < 0);
  } else {
    cx = cx * rx + x1;
    cy = cy * ry + y1;
    me.lineTo(rx * cosStart + cx, ry * sinStart + cy);
    me.ellipse(cx, cy, rx, ry, rotation, startAngle, endAngle, area < 0);
  }
}, ellipse:function(cx, cy, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
  var me = this, coords = me.coords, start = coords.length, count, i, j;
  if (endAngle - startAngle >= Math.PI * 2) {
    me.ellipse(cx, cy, radiusX, radiusY, rotation, startAngle, startAngle + Math.PI, anticlockwise);
    me.ellipse(cx, cy, radiusX, radiusY, rotation, startAngle + Math.PI, endAngle, anticlockwise);
    return;
  }
  if (!anticlockwise) {
    if (endAngle < startAngle) {
      endAngle += Math.PI * 2;
    }
    count = me.approximateArc(coords, cx, cy, radiusX, radiusY, rotation, startAngle, endAngle);
  } else {
    if (startAngle < endAngle) {
      startAngle += Math.PI * 2;
    }
    count = me.approximateArc(coords, cx, cy, radiusX, radiusY, rotation, endAngle, startAngle);
    for (i = start, j = coords.length - 2; i < j; i += 2, j -= 2) {
      var temp = coords[i];
      coords[i] = coords[j];
      coords[j] = temp;
      temp = coords[i + 1];
      coords[i + 1] = coords[j + 1];
      coords[j + 1] = temp;
    }
  }
  if (!me.cursor) {
    me.cursor = [coords[coords.length - 2], coords[coords.length - 1]];
    me.types.push('M');
  } else {
    me.cursor[0] = coords[coords.length - 2];
    me.cursor[1] = coords[coords.length - 1];
    me.types.push('L');
  }
  for (i = 2; i < count; i += 6) {
    me.types.push('C');
  }
  me.dirt();
}, arc:function(x, y, radius, startAngle, endAngle, anticlockwise) {
  this.ellipse(x, y, radius, radius, 0, startAngle, endAngle, anticlockwise);
}, rect:function(x, y, width, height) {
  if (width == 0 || height == 0) {
    return;
  }
  var me = this;
  me.moveTo(x, y);
  me.lineTo(x + width, y);
  me.lineTo(x + width, y + height);
  me.lineTo(x, y + height);
  me.closePath();
}, approximateArc:function(result, cx, cy, rx, ry, phi, theta1, theta2) {
  var cosPhi = Math.cos(phi), sinPhi = Math.sin(phi), cosTheta1 = Math.cos(theta1), sinTheta1 = Math.sin(theta1), xx = cosPhi * cosTheta1 * rx - sinPhi * sinTheta1 * ry, yx = -cosPhi * sinTheta1 * rx - sinPhi * cosTheta1 * ry, xy = sinPhi * cosTheta1 * rx + cosPhi * sinTheta1 * ry, yy = -sinPhi * sinTheta1 * rx + cosPhi * cosTheta1 * ry, rightAngle = Math.PI / 2, count = 2, exx = xx, eyx = yx, exy = xy, eyy = yy, rho = 0.547443256150549, temp, y1, x3, y3, x2, y2;
  theta2 -= theta1;
  if (theta2 < 0) {
    theta2 += Math.PI * 2;
  }
  result.push(xx + cx, xy + cy);
  while (theta2 >= rightAngle) {
    result.push(exx + eyx * rho + cx, exy + eyy * rho + cy, exx * rho + eyx + cx, exy * rho + eyy + cy, eyx + cx, eyy + cy);
    count += 6;
    theta2 -= rightAngle;
    temp = exx;
    exx = eyx;
    eyx = -temp;
    temp = exy;
    exy = eyy;
    eyy = -temp;
  }
  if (theta2) {
    y1 = (0.3294738052815987 + 0.012120855841304373 * theta2) * theta2;
    x3 = Math.cos(theta2);
    y3 = Math.sin(theta2);
    x2 = x3 + y1 * y3;
    y2 = y3 - y1 * x3;
    result.push(exx + eyx * y1 + cx, exy + eyy * y1 + cy, exx * x2 + eyx * y2 + cx, exy * x2 + eyy * y2 + cy, exx * x3 + eyx * y3 + cx, exy * x3 + eyy * y3 + cy);
    count += 6;
  }
  return count;
}, arcSvg:function(rx, ry, rotation, fA, fS, x2, y2) {
  if (rx < 0) {
    rx = -rx;
  }
  if (ry < 0) {
    ry = -ry;
  }
  var me = this, x1 = me.cursor[0], y1 = me.cursor[1], hdx = (x1 - x2) / 2, hdy = (y1 - y2) / 2, cosPhi = Math.cos(rotation), sinPhi = Math.sin(rotation), xp = hdx * cosPhi + hdy * sinPhi, yp = -hdx * sinPhi + hdy * cosPhi, ratX = xp / rx, ratY = yp / ry, lambda = ratX * ratX + ratY * ratY, cx = (x1 + x2) * 0.5, cy = (y1 + y2) * 0.5, cpx = 0, cpy = 0;
  if (lambda >= 1) {
    lambda = Math.sqrt(lambda);
    rx *= lambda;
    ry *= lambda;
  } else {
    lambda = Math.sqrt(1 / lambda - 1);
    if (fA === fS) {
      lambda = -lambda;
    }
    cpx = lambda * rx * ratY;
    cpy = -lambda * ry * ratX;
    cx += cosPhi * cpx - sinPhi * cpy;
    cy += sinPhi * cpx + cosPhi * cpy;
  }
  var theta1 = Math.atan2((yp - cpy) / ry, (xp - cpx) / rx), deltaTheta = Math.atan2((-yp - cpy) / ry, (-xp - cpx) / rx) - theta1;
  if (fS) {
    if (deltaTheta <= 0) {
      deltaTheta += Math.PI * 2;
    }
  } else {
    if (deltaTheta >= 0) {
      deltaTheta -= Math.PI * 2;
    }
  }
  me.ellipse(cx, cy, rx, ry, rotation, theta1, theta1 + deltaTheta, 1 - fS);
}, fromSvgString:function(pathString) {
  if (!pathString) {
    return;
  }
  var me = this, parts, paramCounts = {a:7, c:6, h:1, l:2, m:2, q:4, s:4, t:2, v:1, z:0, A:7, C:6, H:1, L:2, M:2, Q:4, S:4, T:2, V:1, Z:0}, lastCommand = '', lastControlX, lastControlY, lastX = 0, lastY = 0, part = false, i, partLength, relative;
  if (Ext.isString(pathString)) {
    parts = pathString.replace(photoViewer.draw.Path.pathRe, ' $1 ').replace(photoViewer.draw.Path.pathRe2, ' -').split(photoViewer.draw.Path.pathSplitRe);
  } else {
    if (Ext.isArray(pathString)) {
      parts = pathString.join(',').split(photoViewer.draw.Path.pathSplitRe);
    }
  }
  for (i = 0, partLength = 0; i < parts.length; i++) {
    if (parts[i] !== '') {
      parts[partLength++] = parts[i];
    }
  }
  parts.length = partLength;
  me.clear();
  for (i = 0; i < parts.length;) {
    lastCommand = part;
    part = parts[i];
    relative = part.toUpperCase() !== part;
    i++;
    switch(part) {
      case 'M':
        me.moveTo(lastX = +parts[i], lastY = +parts[i + 1]);
        i += 2;
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.lineTo(lastX = +parts[i], lastY = +parts[i + 1]);
          i += 2;
        }
        break;
      case 'L':
        me.lineTo(lastX = +parts[i], lastY = +parts[i + 1]);
        i += 2;
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.lineTo(lastX = +parts[i], lastY = +parts[i + 1]);
          i += 2;
        }
        break;
      case 'A':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.arcSvg(+parts[i], +parts[i + 1], +parts[i + 2] * Math.PI / 180, +parts[i + 3], +parts[i + 4], lastX = +parts[i + 5], lastY = +parts[i + 6]);
          i += 7;
        }
        break;
      case 'C':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.bezierCurveTo(+parts[i], +parts[i + 1], lastControlX = +parts[i + 2], lastControlY = +parts[i + 3], lastX = +parts[i + 4], lastY = +parts[i + 5]);
          i += 6;
        }
        break;
      case 'Z':
        me.closePath();
        break;
      case 'm':
        me.moveTo(lastX += +parts[i], lastY += +parts[i + 1]);
        i += 2;
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.lineTo(lastX += +parts[i], lastY += +parts[i + 1]);
          i += 2;
        }
        break;
      case 'l':
        me.lineTo(lastX += +parts[i], lastY += +parts[i + 1]);
        i += 2;
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.lineTo(lastX += +parts[i], lastY += +parts[i + 1]);
          i += 2;
        }
        break;
      case 'a':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.arcSvg(+parts[i], +parts[i + 1], +parts[i + 2] * Math.PI / 180, +parts[i + 3], +parts[i + 4], lastX += +parts[i + 5], lastY += +parts[i + 6]);
          i += 7;
        }
        break;
      case 'c':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.bezierCurveTo(lastX + +parts[i], lastY + +parts[i + 1], lastControlX = lastX + +parts[i + 2], lastControlY = lastY + +parts[i + 3], lastX += +parts[i + 4], lastY += +parts[i + 5]);
          i += 6;
        }
        break;
      case 'z':
        me.closePath();
        break;
      case 's':
        if (!(lastCommand === 'c' || lastCommand === 'C' || lastCommand === 's' || lastCommand === 'S')) {
          lastControlX = lastX;
          lastControlY = lastY;
        }
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.bezierCurveTo(lastX + lastX - lastControlX, lastY + lastY - lastControlY, lastControlX = lastX + +parts[i], lastControlY = lastY + +parts[i + 1], lastX += +parts[i + 2], lastY += +parts[i + 3]);
          i += 4;
        }
        break;
      case 'S':
        if (!(lastCommand === 'c' || lastCommand === 'C' || lastCommand === 's' || lastCommand === 'S')) {
          lastControlX = lastX;
          lastControlY = lastY;
        }
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.bezierCurveTo(lastX + lastX - lastControlX, lastY + lastY - lastControlY, lastControlX = +parts[i], lastControlY = +parts[i + 1], lastX = +parts[i + 2], lastY = +parts[i + 3]);
          i += 4;
        }
        break;
      case 'q':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.quadraticCurveTo(lastControlX = lastX + +parts[i], lastControlY = lastY + +parts[i + 1], lastX += +parts[i + 2], lastY += +parts[i + 3]);
          i += 4;
        }
        break;
      case 'Q':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.quadraticCurveTo(lastControlX = +parts[i], lastControlY = +parts[i + 1], lastX = +parts[i + 2], lastY = +parts[i + 3]);
          i += 4;
        }
        break;
      case 't':
        if (!(lastCommand === 'q' || lastCommand === 'Q' || lastCommand === 't' || lastCommand === 'T')) {
          lastControlX = lastX;
          lastControlY = lastY;
        }
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.quadraticCurveTo(lastControlX = lastX + lastX - lastControlX, lastControlY = lastY + lastY - lastControlY, lastX += +parts[i + 1], lastY += +parts[i + 2]);
          i += 2;
        }
        break;
      case 'T':
        if (!(lastCommand === 'q' || lastCommand === 'Q' || lastCommand === 't' || lastCommand === 'T')) {
          lastControlX = lastX;
          lastControlY = lastY;
        }
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.quadraticCurveTo(lastControlX = lastX + lastX - lastControlX, lastControlY = lastY + lastY - lastControlY, lastX = +parts[i + 1], lastY = +parts[i + 2]);
          i += 2;
        }
        break;
      case 'h':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.lineTo(lastX += +parts[i], lastY);
          i++;
        }
        break;
      case 'H':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.lineTo(lastX = +parts[i], lastY);
          i++;
        }
        break;
      case 'v':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.lineTo(lastX, lastY += +parts[i]);
          i++;
        }
        break;
      case 'V':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.lineTo(lastX, lastY = +parts[i]);
          i++;
        }
        break;
    }
  }
}, rayTestLine:function(x1, y1, x2, y2, x, y) {
  var cx;
  if (y1 === y2) {
    if (y === y1) {
      if (Math.min(x1, x2) <= x && x <= Math.max(x1, x2)) {
        return -1;
      }
    } else {
      return 0;
    }
  }
  if (y1 < y && y < y2 || y2 < y && y < y1) {
    cx = (y - y1) * (x2 - x1) / (y2 - y1) + x1;
    if (cx === x) {
      return -1;
    } else {
      if (cx < x) {
        return 0;
      } else {
        return 1;
      }
    }
  } else {
    return 0;
  }
}, rayTestCubicBezier:function(x1, y1, x2, y2, x3, y3, x4, y4, x, y, idx) {
  if (Math.min(x1, x2, x3, x4) <= x && x <= Math.max(x1, x2, x3, x4)) {
    if (Math.min(y1, y2, y3, y4) <= y && y <= Math.max(y1, y2, y3, y4)) {
      var me = this, solver = me.solvers[idx] || (me.solvers[idx] = photoViewer.app.view.photoViewer.annotations.imports.Solver.createBezierSolver(x1, x2, x3, x4)), result = solver.solve(y);
      return +(x <= result[0] && 0 <= result[0] && result[0] <= 1) + +(x <= result[1] && 0 <= result[1] && result[1] <= 1) + +(x <= result[2] && 0 <= result[2] && result[2] <= 1);
    }
  }
  return 0;
}, isPointInPath:function(x, y) {
  var me = this, i, j, count = 0, test = 0, types = me.types, coords = me.coords, ln = types.length, firstX = null, firstY = null, lastX = 0, lastY = 0;
  for (i = 0, j = 0; i < ln; i++) {
    switch(types[i]) {
      case 'M':
        if (firstX !== null) {
          test = me.rayTestLine(firstX, firstY, lastX, lastY, x, y);
          if (test < 0) {
            count += 1;
          } else {
            count += test;
          }
        }
        firstX = lastX = coords[j];
        firstY = lastY = coords[j + 1];
        j += 2;
        break;
      case 'L':
        test = me.rayTestLine(lastX, lastY, coords[j], coords[j + 1], x, y);
        if (test < 0) {
          return true;
        }
        count += test;
        lastX = coords[j];
        lastY = coords[j + 1];
        j += 2;
        break;
      case 'C':
        test = me.rayTestCubicBezier(lastX, lastY, coords[j], coords[j + 1], coords[j + 2], coords[j + 3], coords[j + 4], coords[j + 5], x, y, i);
        if (test < 0) {
          return true;
        }
        count += test;
        lastX = coords[j + 4];
        lastY = coords[j + 5];
        j += 6;
        break;
      case 'Z':
        break;
    }
  }
  return count % 2 === 1;
}, clone:function() {
  var me = this, path = new photoViewer.draw.Path;
  path.coords = me.coords.slice(0);
  path.types = me.types.slice(0);
  path.cursor = me.cursor ? me.cursor.slice(0) : null;
  path.startX = me.startX;
  path.startY = me.startY;
  path.svgString = me.svgString;
  return path;
}, transform:function(matrix) {
  if (matrix.isIdentity()) {
    return;
  }
  var xx = matrix.getXX(), yx = matrix.getYX(), dx = matrix.getDX(), xy = matrix.getXY(), yy = matrix.getYY(), dy = matrix.getDY(), coords = this.coords, i = 0, ln = coords.length, x, y;
  for (; i < ln; i += 2) {
    x = coords[i];
    y = coords[i + 1];
    coords[i] = x * xx + y * yx + dx;
    coords[i + 1] = x * xy + y * yy + dy;
  }
  this.dirt();
}, getDimension:function(target) {
  if (!target) {
    target = {};
  }
  if (!this.types || !this.types.length) {
    target.x = 0;
    target.y = 0;
    target.width = 0;
    target.height = 0;
    return target;
  }
  target.left = Infinity;
  target.top = Infinity;
  target.right = -Infinity;
  target.bottom = -Infinity;
  var i = 0, j = 0, types = this.types, coords = this.coords, ln = types.length, x, y;
  for (; i < ln; i++) {
    switch(types[i]) {
      case 'M':
      case 'L':
        x = coords[j];
        y = coords[j + 1];
        target.left = Math.min(x, target.left);
        target.top = Math.min(y, target.top);
        target.right = Math.max(x, target.right);
        target.bottom = Math.max(y, target.bottom);
        j += 2;
        break;
      case 'C':
        this.expandDimension(target, x, y, coords[j], coords[j + 1], coords[j + 2], coords[j + 3], x = coords[j + 4], y = coords[j + 5]);
        j += 6;
        break;
    }
  }
  target.x = target.left;
  target.y = target.top;
  target.width = target.right - target.left;
  target.height = target.bottom - target.top;
  return target;
}, getDimensionWithTransform:function(matrix, target) {
  if (!this.types || !this.types.length) {
    if (!target) {
      target = {};
    }
    target.x = 0;
    target.y = 0;
    target.width = 0;
    target.height = 0;
    return target;
  }
  target.left = Infinity;
  target.top = Infinity;
  target.right = -Infinity;
  target.bottom = -Infinity;
  var xx = matrix.getXX(), yx = matrix.getYX(), dx = matrix.getDX(), xy = matrix.getXY(), yy = matrix.getYY(), dy = matrix.getDY(), i = 0, j = 0, types = this.types, coords = this.coords, ln = types.length, x, y;
  for (; i < ln; i++) {
    switch(types[i]) {
      case 'M':
      case 'L':
        x = coords[j] * xx + coords[j + 1] * yx + dx;
        y = coords[j] * xy + coords[j + 1] * yy + dy;
        target.left = Math.min(x, target.left);
        target.top = Math.min(y, target.top);
        target.right = Math.max(x, target.right);
        target.bottom = Math.max(y, target.bottom);
        j += 2;
        break;
      case 'C':
        this.expandDimension(target, x, y, coords[j] * xx + coords[j + 1] * yx + dx, coords[j] * xy + coords[j + 1] * yy + dy, coords[j + 2] * xx + coords[j + 3] * yx + dx, coords[j + 2] * xy + coords[j + 3] * yy + dy, x = coords[j + 4] * xx + coords[j + 5] * yx + dx, y = coords[j + 4] * xy + coords[j + 5] * yy + dy);
        j += 6;
        break;
    }
  }
  if (!target) {
    target = {};
  }
  target.x = target.left;
  target.y = target.top;
  target.width = target.right - target.left;
  target.height = target.bottom - target.top;
  return target;
}, expandDimension:function(target, x1, y1, cx1, cy1, cx2, cy2, x2, y2) {
  var me = this, l = target.left, r = target.right, t = target.top, b = target.bottom, dim = me.dim || (me.dim = []);
  me.curveDimension(x1, cx1, cx2, x2, dim);
  l = Math.min(l, dim[0]);
  r = Math.max(r, dim[1]);
  me.curveDimension(y1, cy1, cy2, y2, dim);
  t = Math.min(t, dim[0]);
  b = Math.max(b, dim[1]);
  target.left = l;
  target.right = r;
  target.top = t;
  target.bottom = b;
}, curveDimension:function(a, b, c, d, dim) {
  var qa = 3 * (-a + 3 * (b - c) + d), qb = 6 * (a - 2 * b + c), qc = -3 * (a - b), x, y, min = Math.min(a, d), max = Math.max(a, d), delta;
  if (qa === 0) {
    if (qb === 0) {
      dim[0] = min;
      dim[1] = max;
      return;
    } else {
      x = -qc / qb;
      if (0 < x && x < 1) {
        y = this.interpolate(a, b, c, d, x);
        min = Math.min(min, y);
        max = Math.max(max, y);
      }
    }
  } else {
    delta = qb * qb - 4 * qa * qc;
    if (delta >= 0) {
      delta = Math.sqrt(delta);
      x = (delta - qb) / 2 / qa;
      if (0 < x && x < 1) {
        y = this.interpolate(a, b, c, d, x);
        min = Math.min(min, y);
        max = Math.max(max, y);
      }
      if (delta > 0) {
        x -= delta / qa;
        if (0 < x && x < 1) {
          y = this.interpolate(a, b, c, d, x);
          min = Math.min(min, y);
          max = Math.max(max, y);
        }
      }
    }
  }
  dim[0] = min;
  dim[1] = max;
}, interpolate:function(a, b, c, d, t) {
  if (t === 0) {
    return a;
  }
  if (t === 1) {
    return d;
  }
  var rate = (1 - t) / t;
  return t * t * t * (d + rate * (3 * c + rate * (3 * b + rate * a)));
}, fromStripes:function(stripes) {
  var me = this, i = 0, ln = stripes.length, j, ln2, stripe;
  me.clear();
  for (; i < ln; i++) {
    stripe = stripes[i];
    me.coords.push.apply(me.coords, stripe);
    me.types.push('M');
    for (j = 2, ln2 = stripe.length; j < ln2; j += 6) {
      me.types.push('C');
    }
  }
  if (!me.cursor) {
    me.cursor = [];
  }
  me.cursor[0] = me.coords[me.coords.length - 2];
  me.cursor[1] = me.coords[me.coords.length - 1];
  me.dirt();
}, toStripes:function(target) {
  var stripes = target || [], curr, x, y, lastX, lastY, startX, startY, i, j, types = this.types, coords = this.coords, ln = types.length;
  for (i = 0, j = 0; i < ln; i++) {
    switch(types[i]) {
      case 'M':
        curr = [startX = lastX = coords[j++], startY = lastY = coords[j++]];
        stripes.push(curr);
        break;
      case 'L':
        x = coords[j++];
        y = coords[j++];
        curr.push((lastX + lastX + x) / 3, (lastY + lastY + y) / 3, (lastX + x + x) / 3, (lastY + y + y) / 3, lastX = x, lastY = y);
        break;
      case 'C':
        curr.push(coords[j++], coords[j++], coords[j++], coords[j++], lastX = coords[j++], lastY = coords[j++]);
        break;
      case 'Z':
        x = startX;
        y = startY;
        curr.push((lastX + lastX + x) / 3, (lastY + lastY + y) / 3, (lastX + x + x) / 3, (lastY + y + y) / 3, lastX = x, lastY = y);
        break;
    }
  }
  return stripes;
}, updateSvgString:function() {
  var result = [], types = this.types, coords = this.coords, ln = types.length, i = 0, j = 0;
  for (; i < ln; i++) {
    switch(types[i]) {
      case 'M':
      case 'm':
        result.push(types[i] + coords[j] + ',' + coords[j + 1]);
        j += 2;
        break;
      case 'L':
        result.push('L' + coords[j] + ',' + coords[j + 1]);
        j += 2;
        break;
      case 'C':
      case 'c':
        result.push(types[i] + coords[j] + ',' + coords[j + 1] + ' ' + coords[j + 2] + ',' + coords[j + 3] + ' ' + coords[j + 4] + ',' + coords[j + 5]);
        j += 6;
        break;
      case 'Z':
        result.push('Z');
        break;
    }
  }
  this.svgString = result.join('');
}, toString:function() {
  if (!this.svgString) {
    this.updateSvgString();
  }
  return this.svgString;
}, relativeMoveTo:function(x, y) {
  var me = this;
  if (!me.cursor) {
    me.moveTo(x, y);
    return;
  }
  me.coords.push(x - me.cursor[0], y - me.cursor[1]);
  me.types.push('m');
  me.startX = x;
  me.startY = y;
  me.cursor[0] = x;
  me.cursor[1] = y;
  me.dirt();
}, convertAbsToRelPathBezierCurveTo:function(cx1, cy1, cx2, cy2, x, y) {
  var me = this, coordLength = 0;
  if (!me.cursor) {
    me.moveTo(cx1, cy1);
  }
  for (var i = 0; i < arguments.length; i++) {
    var relativeCoord = arguments[i] - me.cursor[i % 2];
    me.coords.push(relativeCoord);
    coordLength += relativeCoord.toString().length;
  }
  me.types.push('c');
  me.cursor[0] = x;
  me.cursor[1] = y;
  me.dirt();
  return coordLength;
}, convertRelToAbsPathBezierCurveTo:function(relCx1, relCy1, relCx2, relCy2, relX, relY) {
  var me = this;
  me.bezierCurveTo(me.cursor[0] + relCx1, me.cursor[1] + relCy1, me.cursor[0] + relCx2, me.cursor[1] + relCy2, me.cursor[0] + relX, me.cursor[1] + relY);
}}, 3, 0, 0, 0, 0, 0, [photoViewer.draw, 'Path'], 0);
Ext.cmd.derive('photoViewer.draw.SpriteDD', photoViewer.dd.DragSource, {constructor:function(sprite, cfg) {
  var me = this, el = sprite.el;
  me.sprite = sprite;
  me.el = el;
  me.dragData = {el:el, sprite:sprite};
  photoViewer.dd.DragSource.prototype.constructor.call(this, el, cfg);
  me.sprite.setStyle('cursor', 'move');
}, showFrame:Ext.emptyFn, createFrame:Ext.emptyFn, getDragEl:function(e) {
  return this.el;
}, getRegion:function() {
  var me = this, el = me.el, pos, x1, x2, y1, y2, t, r, b, l, bbox, sprite, scale, strokeWidth;
  sprite = me.sprite;
  bbox = sprite.getBBox();
  scale = sprite.drawComponent ? sprite.drawComponent.getScale() : 1;
  strokeWidth = sprite.el ? Number(sprite.el.dom.getAttribute('stroke-width')) * scale : 0;
  try {
    pos = el.getXY();
  } catch (e$11) {
  }
  if (!pos) {
    return null;
  }
  x1 = pos[0] - strokeWidth;
  x2 = x1 + bbox.width * scale + strokeWidth * 2;
  y1 = pos[1] - strokeWidth;
  y2 = y1 + bbox.height * scale + strokeWidth * 2;
  return new Ext.util.Region(y1, x2, y2, x1);
}, startDrag:function(x, y) {
  var me = this, attr = me.sprite.attr;
  me.prev = me.sprite.surface.transformToViewBox(x, y);
}, onDrag:function(e) {
  var xy = e.getXY(), me = this, sprite = me.sprite, attr = sprite.attr, dx, dy;
  xy = me.sprite.surface.transformToViewBox(xy[0], xy[1]);
  dx = xy[0] - me.prev[0];
  dy = xy[1] - me.prev[1];
  sprite.setAttributes({translate:{x:attr.translation.x + dx, y:attr.translation.y + dy}}, true);
  me.prev = xy;
}, setDragElPos:function() {
  return false;
}}, 1, 0, 0, 0, 0, 0, [photoViewer.draw, 'SpriteDD'], 0);
Ext.cmd.derive('photoViewer.draw.Sprite', Ext.Base, {dirty:false, dirtyHidden:false, dirtyTransform:false, dirtyPath:true, dirtyFont:true, zIndexDirty:true, isSprite:true, zIndex:0, fontProperties:['font', 'font-size', 'font-weight', 'font-style', 'font-family', 'text-anchor', 'text'], pathProperties:['x', 'y', 'd', 'path', 'height', 'width', 'radius', 'r', 'rx', 'ry', 'cx', 'cy'], constructor:function(config) {
  var me = this;
  config = Ext.merge({}, config || {});
  me.id = Ext.id(null, 'ext-sprite-');
  me.transformations = [];
  Ext.copyTo(this, config, 'surface,group,type,draggable');
  me.bbox = {};
  me.attr = {zIndex:0, translation:{x:null, y:null}, rotation:{degrees:null, x:null, y:null}, scaling:{x:null, y:null, cx:null, cy:null}};
  delete config.surface;
  delete config.group;
  delete config.type;
  delete config.draggable;
  me.setAttributes(config);
  me.mixins.observable.constructor.apply(this, arguments);
}, initDraggable:function() {
  var me = this;
  if (!me.el) {
    me.surface.createSpriteElement(me);
  }
  me.dd = new photoViewer.draw.SpriteDD(me, Ext.isBoolean(me.draggable) ? me.draggable : null);
  me.on('beforedestroy', me.dd.destroy, me.dd);
}, setAttributes:function(attrs, redraw) {
  var me = this, fontProps = me.fontProperties, fontPropsLength = fontProps.length, pathProps = me.pathProperties, pathPropsLength = pathProps.length, hasSurface = !!me.surface, custom = hasSurface && me.surface.customAttributes || {}, spriteAttrs = me.attr, dirtyBBox = false, attr, i, newTranslation, translation, newRotate, rotation, newScaling, scaling;
  attrs = Ext.apply({}, attrs);
  for (attr in custom) {
    if (attrs.hasOwnProperty(attr) && typeof custom[attr] == 'function') {
      Ext.apply(attrs, custom[attr].apply(me, [].concat(attrs[attr])));
    }
  }
  if (!!attrs.hidden !== !!spriteAttrs.hidden) {
    me.dirtyHidden = true;
  }
  for (i = 0; i < pathPropsLength; i++) {
    attr = pathProps[i];
    if (attr in attrs && attrs[attr] !== spriteAttrs[attr]) {
      me.dirtyPath = true;
      dirtyBBox = true;
      break;
    }
  }
  if ('zIndex' in attrs) {
    me.zIndexDirty = true;
  }
  if ('text' in attrs) {
    me.dirtyFont = true;
    dirtyBBox = true;
    attrs.text = me.transformText(attrs.text);
  }
  for (i = 0; i < fontPropsLength; i++) {
    attr = fontProps[i];
    if (attr in attrs && attrs[attr] !== spriteAttrs[attr]) {
      me.dirtyFont = true;
      dirtyBBox = true;
      break;
    }
  }
  newTranslation = attrs.translation || attrs.translate;
  delete attrs.translate;
  delete attrs.translation;
  translation = spriteAttrs.translation;
  if (newTranslation) {
    if ('x' in newTranslation && newTranslation.x !== translation.x || 'y' in newTranslation && newTranslation.y !== translation.y) {
      me.dirtyTransform = true;
      translation.x = newTranslation.x;
      translation.y = newTranslation.y;
    }
  }
  newRotate = attrs.rotation || attrs.rotate;
  rotation = spriteAttrs.rotation;
  delete attrs.rotate;
  delete attrs.rotation;
  if (newRotate) {
    if ('x' in newRotate && newRotate.x !== rotation.x || 'y' in newRotate && newRotate.y !== rotation.y || 'degrees' in newRotate && newRotate.degrees !== rotation.degrees) {
      me.dirtyTransform = true;
      rotation.x = newRotate.x;
      rotation.y = newRotate.y;
      rotation.degrees = newRotate.degrees;
    }
  }
  newScaling = attrs.scaling || attrs.scale;
  scaling = spriteAttrs.scaling;
  delete attrs.scale;
  delete attrs.scaling;
  if (newScaling) {
    if ('x' in newScaling && newScaling.x !== scaling.x || 'y' in newScaling && newScaling.y !== scaling.y || 'cx' in newScaling && newScaling.cx !== scaling.cx || 'cy' in newScaling && newScaling.cy !== scaling.cy) {
      me.dirtyTransform = true;
      scaling.x = newScaling.x;
      scaling.y = newScaling.y;
      scaling.cx = newScaling.cx;
      scaling.cy = newScaling.cy;
    }
  }
  if (!me.dirtyTransform && dirtyBBox) {
    if (spriteAttrs.scaling.x === null || spriteAttrs.scaling.y === null || spriteAttrs.rotation.y === null || spriteAttrs.rotation.y === null) {
      me.dirtyTransform = true;
    }
  }
  Ext.apply(spriteAttrs, attrs);
  me.dirty = true;
  if (redraw === true && hasSurface) {
    me.redraw();
  }
  return this;
}, transformText:Ext.identityFn, getBBox:function() {
  return this.surface.getBBox(this);
}, setText:function(text) {
  this.attr.text = text;
  this.surface.applyAttrs(this);
  return this;
}, hide:function(redraw) {
  this.setAttributes({hidden:true}, redraw);
  return this;
}, show:function(redraw) {
  this.setAttributes({hidden:false}, redraw);
  return this;
}, remove:function() {
  if (this.surface) {
    this.surface.remove(this);
    return true;
  }
  return false;
}, onRemove:function() {
  this.surface.onRemove(this);
}, destroy:function() {
  var me = this;
  if (me.fireEvent('beforedestroy', me) !== false) {
    me.remove();
    me.surface.onDestroy(me);
    me.clearListeners();
    me.fireEvent('destroy');
  }
}, redraw:function() {
  var me = this, changed = !me.el || me.dirty, surface = me.surface, owner;
  surface.renderItem(me);
  if (changed) {
    owner = surface.owner;
    if (!me.isBackground && owner && (owner.viewBox || owner.autoSize)) {
      owner.configureSurfaceSize();
    }
  }
  return this;
}, setStyle:function() {
  this.el.setStyle.apply(this.el, arguments);
  return this;
}, addCls:function(obj) {
  this.surface.addCls(this, obj);
  return this;
}, removeCls:function(obj) {
  this.surface.removeCls(this, obj);
  return this;
}}, 1, 0, 0, 0, 0, [['observable', Ext.util.Observable], ['animate', Ext.util.Animate]], [photoViewer.draw, 'Sprite'], 0);
Ext.cmd.derive('photoViewer.draw.engine.ImageExporter', Ext.Base, {singleton:true, defaultUrl:'http://svg.sencha.io', supportedTypes:['image/png', 'image/jpeg'], widthParam:'width', heightParam:'height', typeParam:'type', svgParam:'svg', formCls:'x-hide-display', generate:function(surface, config) {
  config = config || {};
  var me = this, type = config.type, form;
  if (Ext.Array.indexOf(me.supportedTypes, type) === -1) {
    return false;
  }
  form = Ext.getBody().createChild({tag:'form', method:'POST', action:config.url || me.defaultUrl, cls:me.formCls, children:[{tag:'input', type:'hidden', name:config.widthParam || me.widthParam, value:config.width || surface.width}, {tag:'input', type:'hidden', name:config.heightParam || me.heightParam, value:config.height || surface.height}, {tag:'input', type:'hidden', name:config.typeParam || me.typeParam, value:type}, {tag:'input', type:'hidden', name:config.svgParam || me.svgParam}]});
  form.last(null, true).value = photoViewer.draw.engine.SvgExporter.generate(surface);
  form.dom.submit();
  form.remove();
  return true;
}}, 0, 0, 0, 0, 0, 0, [photoViewer.draw.engine, 'ImageExporter'], 0);
Ext.cmd.derive('photoViewer.draw.engine.Svg', photoViewer.draw.Surface, {engine:'Svg', trimRe:/^\s+|\s+$/g, spacesRe:/\s+/, xlink:'http://www.w3.org/1999/xlink', translateAttrs:{radius:'r', radiusX:'rx', radiusY:'ry', path:'d', lineWidth:'stroke-width', fillOpacity:'fill-opacity', strokeOpacity:'stroke-opacity', strokeLinejoin:'stroke-linejoin'}, parsers:{}, fontRe:/^font-?/, minDefaults:{circle:{cx:0, cy:0, r:0, fill:'none', stroke:null, 'stroke-width':null, opacity:null, 'fill-opacity':null, 'stroke-opacity':null}, 
ellipse:{cx:0, cy:0, rx:0, ry:0, fill:'none', stroke:null, 'stroke-width':null, opacity:null, 'fill-opacity':null, 'stroke-opacity':null}, rect:{x:0, y:0, width:0, height:0, rx:0, ry:0, fill:'none', stroke:null, 'stroke-width':null, opacity:null, 'fill-opacity':null, 'stroke-opacity':null}, text:{x:0, y:0, 'text-anchor':'start', 'font-family':null, 'font-size':null, 'font-weight':null, 'font-style':null, fill:'#000', stroke:null, 'stroke-width':null, opacity:null, 'fill-opacity':null, 'stroke-opacity':null}, 
path:{d:'M0,0', fill:'none', stroke:null, 'stroke-width':null, opacity:null, 'fill-opacity':null, 'stroke-opacity':null}, image:{x:0, y:0, width:0, height:0, preserveAspectRatio:'none', opacity:null}}, createSvgElement:function(type, attrs) {
  var el = this.domRef.createElementNS('http://www.w3.org/2000/svg', type), key;
  if (attrs) {
    for (key in attrs) {
      el.setAttribute(key, String(attrs[key]));
    }
  }
  return el;
}, createSpriteElement:function(sprite) {
  var el = this.createSvgElement(sprite.type);
  el.id = sprite.id;
  if (el.style) {
    el.style.webkitTapHighlightColor = 'rgba(0,0,0,0)';
  }
  sprite.el = Ext.get(el);
  this.applyZIndex(sprite);
  sprite.matrix = new photoViewer.draw.Matrix;
  sprite.bbox = {plain:0, transform:0};
  this.applyAttrs(sprite);
  this.applyTransformations(sprite);
  sprite.fireEvent('render', sprite);
  return el;
}, getBBoxText:function(sprite) {
  var bbox = {}, bb, height, width, i, ln, el;
  if (sprite && sprite.el) {
    el = sprite.el.dom;
    try {
      bbox = el.getBBox();
      return bbox;
    } catch (e$12) {
    }
    bbox = {x:bbox.x, y:Infinity, width:0, height:0};
    ln = el.getNumberOfChars();
    for (i = 0; i < ln; i++) {
      bb = el.getExtentOfChar(i);
      bbox.y = Math.min(bb.y, bbox.y);
      height = bb.y + bb.height - bbox.y;
      bbox.height = Math.max(bbox.height, height);
      width = bb.x + bb.width - bbox.x;
      bbox.width = Math.max(bbox.width, width);
    }
    return bbox;
  }
}, hide:function() {
  Ext.get(this.el).hide();
}, show:function() {
  Ext.get(this.el).show();
}, hidePrim:function(sprite) {
  this.addCls(sprite, 'x-hide-visibility');
}, showPrim:function(sprite) {
  this.removeCls(sprite, 'x-hide-visibility');
}, getDefs:function() {
  return this._defs || (this._defs = this.createSvgElement('defs'));
}, transform:function(sprite, matrixOnly) {
  var me = this, matrix = new photoViewer.draw.Matrix, transforms = sprite.transformations, transformsLength = transforms.length, i = 0, transform, type;
  for (; i < transformsLength; i++) {
    transform = transforms[i];
    type = transform.type;
    if (type == 'translate') {
      matrix.translate(transform.x, transform.y);
    } else {
      if (type == 'rotate') {
        matrix.rotate(transform.degrees, transform.x, transform.y);
      } else {
        if (type == 'scale') {
          matrix.scale(transform.x, transform.y, transform.centerX, transform.centerY);
        }
      }
    }
  }
  sprite.matrix = matrix;
  if (!matrixOnly) {
    sprite.el.set({transform:matrix.toSvg()});
  }
}, setSize:function(width, height) {
  var me = this, el = me.el;
  width = +width || me.width;
  height = +height || me.height;
  me.width = width;
  me.height = height;
  el.setSize(width, height);
  el.set({width:width, height:height});
  photoViewer.draw.Surface.prototype.setSize.call(this, width, height);
}, getRegion:function() {
  var svgXY = this.el.getXY(), rectXY = this.bgRect.getXY(), max = Math.max, x = max(svgXY[0], rectXY[0]), y = max(svgXY[1], rectXY[1]);
  return {left:x, top:y, right:x + this.width, bottom:y + this.height};
}, onRemove:function(sprite) {
  if (sprite.el) {
    sprite.el.destroy();
    delete sprite.el;
  }
  photoViewer.draw.Surface.prototype.onRemove.apply(this, arguments);
}, setViewBox:function(x, y, width, height) {
  if (isFinite(x) && isFinite(y) && isFinite(width) && isFinite(height)) {
    photoViewer.draw.Surface.prototype.setViewBox.apply(this, arguments);
    this.el.dom.setAttribute('viewBox', [x, y, width, height].join(' '));
  }
}, render:function(container) {
  var me = this, cfg, el, defs, bgRect, webkitRect;
  if (!me.el) {
    cfg = {xmlns:'http://www.w3.org/2000/svg', version:1.1, width:me.width || 0, height:me.height || 0};
    if (me.forceLtr) {
      cfg.direction = 'ltr';
    }
    el = me.createSvgElement('svg', cfg);
    defs = me.getDefs();
    bgRect = me.createSvgElement('rect', {width:'100%', height:'100%', fill:'#000', stroke:'none', opacity:0});
    if (Ext.isSafari3) {
      webkitRect = me.createSvgElement('rect', {x:-10, y:-10, width:'110%', height:'110%', fill:'none', stroke:'#000'});
    }
    el.appendChild(defs);
    if (Ext.isSafari3) {
      el.appendChild(webkitRect);
    }
    el.appendChild(bgRect);
    container.appendChild(el);
    me.el = Ext.get(el);
    me.bgRect = Ext.get(bgRect);
    if (Ext.isSafari3) {
      me.webkitRect = Ext.get(webkitRect);
      me.webkitRect.hide();
    }
    me.el.on({scope:me, mouseup:me.onMouseUp, mousedown:me.onMouseDown, mouseover:me.onMouseOver, mouseout:me.onMouseOut, mousemove:me.onMouseMove, mouseenter:me.onMouseEnter, mouseleave:me.onMouseLeave, click:me.onClick, dblclick:me.onDblClick});
  }
  me.renderAll();
}, onMouseEnter:function(e) {
  if (this.el.parent().getRegion().contains(e.getPoint())) {
    this.fireEvent('mouseenter', e);
  }
}, onMouseLeave:function(e) {
  if (!this.el.parent().getRegion().contains(e.getPoint())) {
    this.fireEvent('mouseleave', e);
  }
}, processEvent:function(name, e) {
  var target = e.getTarget(), surface = this.surface, sprite;
  this.fireEvent(name, e);
  if (target.nodeName == 'tspan' && target.parentNode) {
    target = target.parentNode;
  }
  sprite = this.items.get(target.id);
  if (sprite) {
    sprite.fireEvent(name, sprite, e);
  }
}, tuneText:function(sprite, attrs) {
  var el = sprite.el.dom, tspans = [], height, tspan, text, i, ln, texts, factor, x;
  if (attrs.hasOwnProperty('text')) {
    text = sprite.tspans && Ext.Array.map(sprite.tspans, function(t) {
      return t.textContent;
    }).join('');
    if (!sprite.tspans || attrs.text != text) {
      tspans = this.setText(sprite, attrs.text);
      sprite.tspans = tspans;
    } else {
      tspans = sprite.tspans || [];
    }
  }
  if (tspans.length) {
    height = this.getBBoxText(sprite).height;
    x = sprite.el.dom.getAttribute('x');
    for (i = 0, ln = tspans.length; i < ln; i++) {
      factor = Ext.isFF3_0 || Ext.isFF3_5 ? 2 : 4;
      tspans[i].setAttribute('x', x);
      tspans[i].setAttribute('dy', i ? height * 1.2 : height / factor);
    }
    sprite.dirty = true;
  }
}, setText:function(sprite, textString) {
  var me = this, el = sprite.el.dom, tspans = [], height, tspan, text, i, ln, texts;
  while (el.firstChild) {
    el.removeChild(el.firstChild);
  }
  texts = String(textString).split('\n');
  for (i = 0, ln = texts.length; i < ln; i++) {
    text = texts[i];
    if (text) {
      tspan = me.createSvgElement('tspan');
      tspan.appendChild(document.createTextNode(Ext.htmlDecode(text)));
      el.appendChild(tspan);
      tspans[i] = tspan;
    }
  }
  return tspans;
}, renderAll:function() {
  this.items.each(this.renderItem, this);
}, renderItem:function(sprite) {
  if (!this.el) {
    return;
  }
  if (!sprite.el) {
    this.createSpriteElement(sprite);
  }
  if (sprite.zIndexDirty) {
    this.applyZIndex(sprite);
  }
  if (sprite.dirty) {
    this.applyAttrs(sprite);
    if (sprite.dirtyTransform) {
      this.applyTransformations(sprite);
    }
  }
}, redraw:function(sprite) {
  sprite.dirty = sprite.zIndexDirty = true;
  this.renderItem(sprite);
}, applyAttrs:function(sprite) {
  var me = this, el = sprite.el, group = sprite.group, sattr = sprite.attr, parsers = me.parsers, gradientsMap = me.gradientsMap || {}, safariFix = Ext.isSafari && !Ext.isStrict, fontRe = me.fontRe, groups, i, ln, attrs, font, key, style, name, rect, fontProps, val;
  if (group) {
    groups = [].concat(group);
    ln = groups.length;
    for (i = 0; i < ln; i++) {
      group = groups[i];
      me.getGroup(group).add(sprite);
    }
    delete sprite.group;
  }
  attrs = me.scrubAttrs(sprite) || {};
  sprite.bbox.plain = 0;
  sprite.bbox.transform = 0;
  if (sprite.type == 'circle' || sprite.type == 'ellipse') {
    attrs.cx = attrs.cx || attrs.x;
    attrs.cy = attrs.cy || attrs.y;
  } else {
    if (sprite.type == 'rect') {
      attrs.rx = attrs.ry = attrs.r;
    } else {
      if (sprite.type == 'path' && attrs.d) {
        attrs.d = photoViewer.draw.Draw.pathToString(photoViewer.draw.Draw.pathToAbsolute(attrs.d));
      }
    }
  }
  sprite.dirtyPath = false;
  if (attrs['clip-rect']) {
    me.setClip(sprite, attrs);
    delete attrs['clip-rect'];
  }
  if (sprite.type == 'text' && attrs.font && sprite.dirtyFont) {
    el.set({style:'font: ' + attrs.font});
  }
  if (sprite.type == 'image') {
    el.dom.setAttributeNS(me.xlink, 'href', attrs.src);
  }
  Ext.applyIf(attrs, me.minDefaults[sprite.type]);
  if (sprite.dirtyHidden) {
    sattr.hidden ? me.hidePrim(sprite) : me.showPrim(sprite);
    sprite.dirtyHidden = false;
  }
  for (key in attrs) {
    val = attrs[key];
    if (attrs.hasOwnProperty(key) && val != null) {
      if (safariFix && 'color|stroke|fill'.indexOf(key) > -1 && val in gradientsMap) {
        val = gradientsMap[val];
      }
      if (key == 'hidden' && sprite.type == 'text') {
        continue;
      }
      if (key in parsers) {
        el.dom.setAttribute(key, parsers[key](val, sprite, me));
      } else {
        el.dom.setAttribute(key, val);
        if (fontRe.test(key)) {
          fontProps = fontProps || {};
          fontProps[key] = val;
          el.setStyle(key, val);
        }
      }
    }
  }
  if (sprite.type == 'text') {
    me.tuneText(sprite, attrs);
  }
  sprite.dirtyFont = false;
  style = sattr.style;
  if (style) {
    el.setStyle(style);
  }
  sprite.dirty = false;
  if (Ext.isSafari3) {
    me.webkitRect.show();
    Ext.defer(function() {
      me.webkitRect.hide();
    }, 1);
  }
}, setClip:function(sprite, params) {
  var me = this, rect = params['clip-rect'], clipEl, clipPath;
  if (rect) {
    if (sprite.clip) {
      sprite.clip.parentNode.parentNode.removeChild(sprite.clip.parentNode);
    }
    clipEl = me.createSvgElement('clipPath');
    clipPath = me.createSvgElement('rect');
    clipEl.id = Ext.id(null, 'ext-clip-');
    clipPath.setAttribute('x', rect.x);
    clipPath.setAttribute('y', rect.y);
    clipPath.setAttribute('width', rect.width);
    clipPath.setAttribute('height', rect.height);
    clipEl.appendChild(clipPath);
    me.getDefs().appendChild(clipEl);
    sprite.el.dom.setAttribute('clip-path', 'url(#' + clipEl.id + ')');
    sprite.clip = clipPath;
  }
}, applyZIndex:function(sprite) {
  var me = this, items = me.items, idx = items.indexOf(sprite), el = sprite.el, prevEl;
  if (me.el.dom.childNodes[idx + 2] !== el.dom) {
    if (idx > 0) {
      do {
        prevEl = items.getAt(--idx).el;
      } while (!prevEl && idx > 0);
    }
    el.insertAfter(prevEl || me.bgRect);
  }
  sprite.zIndexDirty = false;
}, createItem:function(config) {
  var sprite = new photoViewer.draw.Sprite(config);
  sprite.surface = this;
  return sprite;
}, addGradient:function(gradient) {
  gradient = photoViewer.draw.Draw.parseGradient(gradient);
  var me = this, ln = gradient.stops.length, vector = gradient.vector, usePlain = Ext.isSafari && !Ext.isStrict, gradientEl, stop, stopEl, i, gradientsMap;
  gradientsMap = me.gradientsMap || {};
  if (!usePlain) {
    if (gradient.type == 'linear') {
      gradientEl = me.createSvgElement('linearGradient');
      gradientEl.setAttribute('x1', vector[0]);
      gradientEl.setAttribute('y1', vector[1]);
      gradientEl.setAttribute('x2', vector[2]);
      gradientEl.setAttribute('y2', vector[3]);
    } else {
      gradientEl = me.createSvgElement('radialGradient');
      gradientEl.setAttribute('cx', gradient.centerX);
      gradientEl.setAttribute('cy', gradient.centerY);
      gradientEl.setAttribute('r', gradient.radius);
      if (Ext.isNumber(gradient.focalX) && Ext.isNumber(gradient.focalY)) {
        gradientEl.setAttribute('fx', gradient.focalX);
        gradientEl.setAttribute('fy', gradient.focalY);
      }
    }
    gradientEl.id = gradient.id;
    me.getDefs().appendChild(gradientEl);
    for (i = 0; i < ln; i++) {
      stop = gradient.stops[i];
      stopEl = me.createSvgElement('stop');
      stopEl.setAttribute('offset', stop.offset + '%');
      stopEl.setAttribute('stop-color', stop.color);
      stopEl.setAttribute('stop-opacity', stop.opacity);
      gradientEl.appendChild(stopEl);
    }
  } else {
    gradientsMap['url(#' + gradient.id + ')'] = gradient.stops[0].color;
  }
  me.gradientsMap = gradientsMap;
}, hasCls:function(sprite, className) {
  return className && (' ' + (sprite.el.dom.getAttribute('class') || '') + ' ').indexOf(' ' + className + ' ') != -1;
}, addCls:function(sprite, className) {
  var el = sprite.el, i, len, v, cls = [], curCls = el.getAttribute('class') || '';
  if (!Ext.isArray(className)) {
    if (typeof className == 'string' && !this.hasCls(sprite, className)) {
      el.set({'class':curCls + ' ' + className});
    }
  } else {
    for (i = 0, len = className.length; i < len; i++) {
      v = className[i];
      if (typeof v == 'string' && (' ' + curCls + ' ').indexOf(' ' + v + ' ') == -1) {
        cls.push(v);
      }
    }
    if (cls.length) {
      el.set({'class':' ' + cls.join(' ')});
    }
  }
}, removeCls:function(sprite, className) {
  var me = this, el = sprite.el, curCls = el.getAttribute('class') || '', i, idx, len, cls, elClasses;
  if (!Ext.isArray(className)) {
    className = [className];
  }
  if (curCls) {
    elClasses = curCls.replace(me.trimRe, ' ').split(me.spacesRe);
    for (i = 0, len = className.length; i < len; i++) {
      cls = className[i];
      if (typeof cls == 'string') {
        cls = cls.replace(me.trimRe, '');
        idx = Ext.Array.indexOf(elClasses, cls);
        if (idx != -1) {
          Ext.Array.erase(elClasses, idx, 1);
        }
      }
    }
    el.set({'class':elClasses.join(' ')});
  }
}, destroy:function() {
  var me = this;
  photoViewer.draw.Surface.prototype.destroy.call(this);
  if (me.el) {
    me.el.destroy();
  }
  if (me._defs) {
    Ext.get(me._defs).destroy();
  }
  if (me.bgRect) {
    Ext.get(me.bgRect).destroy();
  }
  if (me.webkitRect) {
    Ext.get(me.webkitRect).destroy();
  }
  delete me.el;
}}, 0, 0, 0, 0, 0, 0, [photoViewer.draw.engine, 'Svg'], 0);
Ext.cmd.derive('photoViewer.draw.engine.SvgExporter', Ext.Base, function() {
  var commaRe = /,/g, fontRegex = /(-?\d*\.?\d*){1}(em|ex|px|in|cm|mm|pt|pc|%)\s('*.*'*)/, rgbColorRe = /rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/g, rgbaColorRe = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,([\d\.]+)\)/g, surface, len, width, height, init = function(s) {
    surface = s;
    len = surface.length;
    width = surface.width;
    height = surface.height;
  }, spriteProcessor = {path:function(sprite) {
    var attr = sprite.attr, path = attr.path, pathString = '', props, p, pLen;
    if (Ext.isArray(path[0])) {
      pLen = path.length;
      for (p = 0; p < pLen; p++) {
        pathString += path[p].join(' ');
      }
    } else {
      if (Ext.isArray(path)) {
        pathString = path.join(' ');
      } else {
        pathString = path.replace(commaRe, ' ');
      }
    }
    props = toPropertyString({d:pathString, fill:attr.fill || 'none', stroke:attr.stroke, 'fill-opacity':attr.opacity, 'stroke-width':attr['stroke-width'], 'stroke-opacity':attr['stroke-opacity'], 'z-index':attr.zIndex, transform:sprite.matrix.toSvg()});
    return '\x3cpath ' + props + '/\x3e';
  }, text:function(sprite) {
    var attr = sprite.attr, match = fontRegex.exec(attr.font), size = match && match[1] || '12', family = match && match[3] || 'Arial', text = attr.text, factor = Ext.isFF3_0 || Ext.isFF3_5 ? 2 : 4, tspanString = '', props;
    sprite.getBBox();
    tspanString += '\x3ctspan x\x3d"' + (attr.x || '') + '" dy\x3d"';
    tspanString += size / factor + '"\x3e';
    tspanString += Ext.htmlEncode(text) + '\x3c/tspan\x3e';
    props = toPropertyString({x:attr.x, y:attr.y, 'font-size':size, 'font-family':family, 'font-weight':attr['font-weight'], 'text-anchor':attr['text-anchor'], fill:attr.fill || '#000', 'fill-opacity':attr.opacity, transform:sprite.matrix.toSvg()});
    return '\x3ctext ' + props + '\x3e' + tspanString + '\x3c/text\x3e';
  }, rect:function(sprite) {
    var attr = sprite.attr, props = toPropertyString({x:attr.x, y:attr.y, rx:attr.rx, ry:attr.ry, width:attr.width, height:attr.height, fill:attr.fill || 'none', 'fill-opacity':attr.opacity, stroke:attr.stroke, 'stroke-opacity':attr['stroke-opacity'], 'stroke-width':attr['stroke-width'], transform:sprite.matrix && sprite.matrix.toSvg()});
    return '\x3crect ' + props + '/\x3e';
  }, circle:function(sprite) {
    var attr = sprite.attr, props = toPropertyString({cx:attr.x, cy:attr.y, r:attr.radius, fill:attr.translation.fill || attr.fill || 'none', 'fill-opacity':attr.opacity, stroke:attr.stroke, 'stroke-opacity':attr['stroke-opacity'], 'stroke-width':attr['stroke-width'], transform:sprite.matrix.toSvg()});
    return '\x3ccircle ' + props + ' /\x3e';
  }, image:function(sprite) {
    var attr = sprite.attr, props = toPropertyString({x:attr.x - (attr.width / 2 >> 0), y:attr.y - (attr.height / 2 >> 0), width:attr.width, height:attr.height, 'xlink:href':attr.src, transform:sprite.matrix.toSvg()});
    return '\x3cimage ' + props + ' /\x3e';
  }}, svgHeader = function() {
    var svg = '\x3c?xml version\x3d"1.0" standalone\x3d"yes"?\x3e';
    svg += '\x3c!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"\x3e';
    return svg;
  }, svgContent = function() {
    var svg = '\x3csvg width\x3d"' + width + 'px" height\x3d"' + height + 'px" xmlns\x3d"http://www.w3.org/2000/svg" xmlns:xlink\x3d"http://www.w3.org/1999/xlink" version\x3d"1.1"\x3e', defs = '', item, itemsLen, items, gradient, getSvgString, colorstops, stop, coll, keys, colls, k, kLen, key, collI, i, j, stopsLen, sortedItems, za, zb;
    items = surface.items.items;
    itemsLen = items.length;
    getSvgString = function(node) {
      var childs = node.childNodes, childLength = childs.length, i = 0, attrLength, j, svgString = '', child, attr, tagName, attrItem;
      for (; i < childLength; i++) {
        child = childs[i];
        attr = child.attributes;
        tagName = child.tagName;
        svgString += '\x3c' + tagName;
        for (j = 0, attrLength = attr.length; j < attrLength; j++) {
          attrItem = attr.item(j);
          svgString += ' ' + attrItem.name + '\x3d"' + attrItem.value + '"';
        }
        svgString += '\x3e';
        if (child.childNodes.length > 0) {
          svgString += getSvgString(child);
        }
        svgString += '\x3c/' + tagName + '\x3e';
      }
      return svgString;
    };
    if (surface.getDefs) {
      defs = getSvgString(surface.getDefs());
    } else {
      coll = surface.gradientsColl;
      if (coll) {
        keys = coll.keys;
        colls = coll.items;
        k = 0;
        kLen = keys.length;
      }
      for (; k < kLen; k++) {
        key = keys[k];
        collI = colls[k];
        gradient = surface.gradientsColl.getByKey(key);
        defs += '\x3clinearGradient id\x3d"' + key + '" x1\x3d"0" y1\x3d"0" x2\x3d"1" y2\x3d"1"\x3e';
        var color = gradient.colors.replace(rgbColorRe, 'rgb($1|$2|$3)');
        color = color.replace(rgbaColorRe, 'rgba($1|$2|$3|$4)');
        colorstops = color.split(',');
        for (i = 0, stopsLen = colorstops.length; i < stopsLen; i++) {
          stop = colorstops[i].split(' ');
          color = photoViewer.draw.Color.fromString(stop[1].replace(/\|/g, ','));
          defs += '\x3cstop offset\x3d"' + stop[0] + '" stop-color\x3d"' + color.toString() + '" stop-opacity\x3d"1"\x3e\x3c/stop\x3e';
        }
        defs += '\x3c/linearGradient\x3e';
      }
    }
    svg += '\x3cdefs\x3e' + defs + '\x3c/defs\x3e';
    svg += spriteProcessor.rect({attr:{width:'100%', height:'100%', fill:'#fff', stroke:'none', opacity:'0'}});
    sortedItems = new Array(itemsLen);
    for (i = 0; i < itemsLen; i++) {
      sortedItems[i] = i;
    }
    sortedItems.sort(function(a, b) {
      za = items[a].attr.zIndex || 0;
      zb = items[b].attr.zIndex || 0;
      if (za == zb) {
        return a - b;
      }
      return za - zb;
    });
    for (i = 0; i < itemsLen; i++) {
      item = items[sortedItems[i]];
      if (!item.attr.hidden) {
        svg += spriteProcessor[item.type](item);
      }
    }
    svg += '\x3c/svg\x3e';
    return svg;
  }, toPropertyString = function(obj) {
    var propString = '', key;
    for (key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] != null) {
        propString += key + '\x3d"' + obj[key] + '" ';
      }
    }
    return propString;
  };
  return {singleton:true, generate:function(surface, config) {
    config = config || {};
    init(surface);
    return svgHeader() + svgContent();
  }};
}, 0, 0, 0, 0, 0, 0, [photoViewer.draw.engine, 'SvgExporter'], 0);
Ext.cmd.derive('photoViewer.draw.engine.Vml', photoViewer.draw.Surface, {engine:'Vml', map:{M:'m', L:'l', C:'c', Z:'x', m:'t', l:'r', c:'v', z:'x'}, bitesRe:/([clmz]),?([^clmz]*)/gi, valRe:/-?[^,\s\-]+/g, fillUrlRe:/^url\(\s*['"]?([^\)]+?)['"]?\s*\)$/i, pathlike:/^(path|rect)$/, NonVmlPathRe:/[ahqstv]/ig, partialPathRe:/[clmz]/g, fontFamilyRe:/^['"]+|['"]+$/g, baseVmlCls:'x-vml-base', vmlGroupCls:'x-vml-group', spriteCls:'x-vml-sprite', measureSpanCls:'x-vml-measure-span', zoom:21600, coordsize:1000, 
coordorigin:'0 0', zIndexShift:0, orderSpritesByZIndex:false, path2vml:function(path) {
  var me = this, nonVML = me.NonVmlPathRe, map = me.map, val = me.valRe, zoom = me.zoom, bites = me.bitesRe, command = Ext.Function.bind(photoViewer.draw.Draw.pathToAbsolute, photoViewer.draw.Draw), res, pa, p, r, i, ii, j, jj;
  if (String(path).match(nonVML)) {
    command = Ext.Function.bind(photoViewer.draw.Draw.path2curve, photoViewer.draw.Draw);
  } else {
    if (!String(path).match(me.partialPathRe)) {
      res = String(path).replace(bites, function(all, command, args) {
        var vals = [], isMove = command.toLowerCase() == 'm', res = map[command];
        args.replace(val, function(value) {
          if (isMove && vals.length === 2) {
            res += vals + map[command == 'm' ? 'l' : 'L'];
            vals = [];
          }
          vals.push(Math.round(value * zoom));
        });
        return res + vals;
      });
      return res;
    }
  }
  pa = command(path);
  res = [];
  for (i = 0, ii = pa.length; i < ii; i++) {
    p = pa[i];
    r = pa[i][0].toLowerCase();
    if (r == 'z') {
      r = 'x';
    }
    for (j = 1, jj = p.length; j < jj; j++) {
      r += Math.round(p[j] * me.zoom) + (j != jj - 1 ? ',' : '');
    }
    res.push(r);
  }
  return res.join(' ');
}, translateAttrs:{radius:'r', radiusX:'rx', radiusY:'ry', lineWidth:'stroke-width', fillOpacity:'fill-opacity', strokeOpacity:'stroke-opacity', strokeLinejoin:'stroke-linejoin'}, minDefaults:{circle:{fill:'none', stroke:null, 'stroke-width':null, opacity:null, 'fill-opacity':null, 'stroke-opacity':null}, ellipse:{cx:0, cy:0, rx:0, ry:0, fill:'none', stroke:null, 'stroke-width':null, opacity:null, 'fill-opacity':null, 'stroke-opacity':null}, rect:{x:0, y:0, width:0, height:0, rx:0, ry:0, fill:'none', 
stroke:null, 'stroke-width':null, opacity:null, 'fill-opacity':null, 'stroke-opacity':null}, text:{x:0, y:0, 'text-anchor':'start', font:'10px "Arial"', fill:'#000', stroke:null, 'stroke-width':null, opacity:null, 'fill-opacity':null, 'stroke-opacity':null}, path:{d:'M0,0', fill:'none', stroke:null, 'stroke-width':null, opacity:null, 'fill-opacity':null, 'stroke-opacity':null}, image:{x:0, y:0, width:0, height:0, preserveAspectRatio:'none', opacity:null}}, onMouseEnter:function(e) {
  this.fireEvent('mouseenter', e);
}, onMouseLeave:function(e) {
  this.fireEvent('mouseleave', e);
}, processEvent:function(name, e) {
  var target = e.getTarget(), sprite;
  this.fireEvent(name, e);
  sprite = this.items.get(target.id);
  if (sprite) {
    sprite.fireEvent(name, sprite, e);
  }
}, createSpriteElement:function(sprite) {
  var me = this, attr = sprite.attr, type = sprite.type, zoom = me.zoom, vml = sprite.vml || (sprite.vml = {}), el = type === 'image' ? me.createNode('image') : me.createNode('shape'), path, skew, textPath;
  el.coordsize = zoom + ' ' + zoom;
  el.coordorigin = attr.coordorigin || '0 0';
  Ext.get(el).addCls(me.spriteCls);
  if (type == 'text') {
    vml.path = path = me.createNode('path');
    path.textpathok = true;
    vml.textpath = textPath = me.createNode('textpath');
    textPath.on = true;
    el.appendChild(textPath);
    el.appendChild(path);
  }
  el.id = sprite.id;
  sprite.el = Ext.get(el);
  sprite.el.setStyle('zIndex', -me.zIndexShift);
  me.el.appendChild(el);
  if (type !== 'image') {
    skew = me.createNode('skew');
    skew.on = true;
    el.appendChild(skew);
    sprite.skew = skew;
  }
  sprite.matrix = new photoViewer.draw.Matrix;
  sprite.bbox = {plain:null, transform:null};
  this.applyAttrs(sprite);
  this.applyTransformations(sprite);
  sprite.fireEvent('render', sprite);
  return sprite.el;
}, getBBoxText:function(sprite) {
  var vml = sprite.vml;
  return {x:vml.X + (vml.bbx || 0) - vml.W / 2, y:vml.Y - vml.H / 2, width:vml.W, height:vml.H};
}, applyAttrs:function(sprite) {
  var me = this, group = sprite.group, spriteAttr = sprite.attr, el = sprite.el, dom = el.dom, style, groups, i, ln, scrubbedAttrs, cx, cy, rx, ry;
  if (group) {
    groups = [].concat(group);
    ln = groups.length;
    for (i = 0; i < ln; i++) {
      group = groups[i];
      me.getGroup(group).add(sprite);
    }
    delete sprite.group;
  }
  scrubbedAttrs = me.scrubAttrs(sprite) || {};
  if (sprite.zIndexDirty) {
    me.setZIndex(sprite);
  }
  Ext.applyIf(scrubbedAttrs, me.minDefaults[sprite.type]);
  if (sprite.type == 'image') {
    Ext.apply(sprite.attr, {x:scrubbedAttrs.x, y:scrubbedAttrs.y, width:scrubbedAttrs.width, height:scrubbedAttrs.height});
    el.setStyle({width:scrubbedAttrs.width + 'px', height:scrubbedAttrs.height + 'px'});
    dom.src = scrubbedAttrs.src;
  }
  if (dom.href) {
    dom.href = scrubbedAttrs.href;
  }
  if (dom.title) {
    dom.title = scrubbedAttrs.title;
  }
  if (dom.target) {
    dom.target = scrubbedAttrs.target;
  }
  if (dom.cursor) {
    dom.cursor = scrubbedAttrs.cursor;
  }
  if (sprite.dirtyHidden) {
    scrubbedAttrs.hidden ? me.hidePrim(sprite) : me.showPrim(sprite);
    sprite.dirtyHidden = false;
  }
  if (sprite.dirtyPath) {
    if (sprite.type == 'circle' || sprite.type == 'ellipse') {
      cx = scrubbedAttrs.x;
      cy = scrubbedAttrs.y;
      rx = scrubbedAttrs.rx || scrubbedAttrs.r || 0;
      ry = scrubbedAttrs.ry || scrubbedAttrs.r || 0;
      dom.path = Ext.String.format('ar{0},{1},{2},{3},{4},{1},{4},{1}', Math.round((cx - rx) * me.zoom), Math.round((cy - ry) * me.zoom), Math.round((cx + rx) * me.zoom), Math.round((cy + ry) * me.zoom), Math.round(cx * me.zoom));
      sprite.dirtyPath = false;
    } else {
      sprite.attr.path = scrubbedAttrs.path = me.setPaths(sprite, scrubbedAttrs) || scrubbedAttrs.path;
      dom.path = me.path2vml(scrubbedAttrs.path);
      sprite.dirtyPath = false;
    }
  }
  if ('clip-rect' in scrubbedAttrs) {
    me.setClip(sprite, scrubbedAttrs);
  }
  if (sprite.type == 'text') {
    me.setTextAttributes(sprite, scrubbedAttrs);
  }
  if (scrubbedAttrs.opacity || scrubbedAttrs['stroke-opacity'] || scrubbedAttrs.fill) {
    me.setFill(sprite, scrubbedAttrs);
  }
  if (scrubbedAttrs.stroke || scrubbedAttrs['stroke-opacity'] || scrubbedAttrs.fill) {
    me.setStroke(sprite, scrubbedAttrs);
  }
  style = spriteAttr.style;
  if (style) {
    el.setStyle(style);
  }
  sprite.dirty = false;
}, setZIndex:function(sprite) {
  var me = this, zIndex = sprite.attr.zIndex, shift = me.zIndexShift, items, iLen, item, i;
  if (zIndex < shift) {
    items = me.items.items;
    iLen = items.length;
    for (i = 0; i < iLen; i++) {
      if ((zIndex = items[i].attr.zIndex) && zIndex < shift) {
        shift = zIndex;
      }
    }
    me.zIndexShift = shift;
    for (i = 0; i < iLen; i++) {
      item = items[i];
      if (item.el) {
        item.el.setStyle('zIndex', item.attr.zIndex - shift);
      }
      item.zIndexDirty = false;
    }
  } else {
    if (sprite.el) {
      sprite.el.setStyle('zIndex', zIndex - shift);
      sprite.zIndexDirty = false;
    }
  }
}, setPaths:function(sprite, params) {
  var spriteAttr = sprite.attr;
  sprite.bbox.plain = null;
  sprite.bbox.transform = null;
  if (sprite.type == 'circle') {
    spriteAttr.rx = spriteAttr.ry = params.r;
    return photoViewer.draw.Draw.ellipsePath(sprite);
  } else {
    if (sprite.type == 'ellipse') {
      spriteAttr.rx = params.rx;
      spriteAttr.ry = params.ry;
      return photoViewer.draw.Draw.ellipsePath(sprite);
    } else {
      if (sprite.type == 'rect') {
        spriteAttr.rx = spriteAttr.ry = params.r;
        return photoViewer.draw.Draw.rectPath(sprite);
      } else {
        if (sprite.type == 'path' && spriteAttr.path) {
          return photoViewer.draw.Draw.pathToAbsolute(spriteAttr.path);
        }
      }
    }
  }
  return false;
}, setFill:function(sprite, params) {
  var me = this, el = sprite.el.dom, fillEl = el.fill, newfill = false, gradient, fillUrl, rotation, angle;
  if (!fillEl) {
    fillEl = el.fill = me.createNode('fill');
    newfill = true;
  }
  if (Ext.isArray(params.fill)) {
    params.fill = params.fill[0];
  }
  if (params.fill == 'none') {
    fillEl.on = false;
  } else {
    if (typeof params.opacity == 'number') {
      fillEl.opacity = params.opacity;
    }
    if (typeof params['fill-opacity'] == 'number') {
      fillEl.opacity = params['fill-opacity'];
    }
    fillEl.on = true;
    if (typeof params.fill == 'string') {
      fillUrl = params.fill.match(me.fillUrlRe);
      if (fillUrl) {
        fillUrl = fillUrl[1];
        if (fillUrl.charAt(0) == '#') {
          gradient = me.gradientsColl.getByKey(fillUrl.substring(1));
        }
        if (gradient) {
          rotation = params.rotation;
          angle = -(gradient.angle + 270 + (rotation ? rotation.degrees : 0)) % 360;
          if (angle === 0) {
            angle = 180;
          }
          fillEl.angle = angle;
          fillEl.type = 'gradient';
          fillEl.method = 'sigma';
          if (fillEl.colors) {
            fillEl.colors.value = gradient.colors;
          } else {
            fillEl.colors = gradient.colors;
          }
        } else {
          fillEl.src = fillUrl;
          fillEl.type = 'tile';
        }
      } else {
        fillEl.color = photoViewer.draw.Color.toHex(params.fill);
        fillEl.src = '';
        fillEl.type = 'solid';
      }
    }
  }
  if (newfill) {
    el.appendChild(fillEl);
  }
}, setStroke:function(sprite, params) {
  var me = this, el = sprite.el.dom, strokeEl = sprite.strokeEl, newStroke = false, width, opacity;
  if (!strokeEl) {
    strokeEl = sprite.strokeEl = me.createNode('stroke');
    newStroke = true;
  }
  if (Ext.isArray(params.stroke)) {
    params.stroke = params.stroke[0];
  }
  if (!params.stroke || params.stroke == 'none' || params.stroke == 0 || params['stroke-width'] == 0) {
    strokeEl.on = false;
  } else {
    strokeEl.on = true;
    if (params.stroke && !params.stroke.match(me.fillUrlRe)) {
      strokeEl.color = photoViewer.draw.Color.toHex(params.stroke);
    }
    strokeEl.dashstyle = params['stroke-dasharray'] ? 'dash' : 'solid';
    strokeEl.joinstyle = params['stroke-linejoin'];
    strokeEl.endcap = params['stroke-linecap'] || 'round';
    strokeEl.miterlimit = params['stroke-miterlimit'] || 8;
    width = parseFloat(params['stroke-width'] || 1) * 0.75;
    opacity = params['stroke-opacity'] || 1;
    if (Ext.isNumber(width) && width < 1) {
      strokeEl.weight = 1;
      strokeEl.opacity = opacity * width;
    } else {
      strokeEl.weight = width;
      strokeEl.opacity = opacity;
    }
  }
  if (newStroke) {
    el.appendChild(strokeEl);
  }
}, setClip:function(sprite, params) {
  var me = this, clipEl = sprite.clipEl, rect = String(params['clip-rect']).split(me.separatorRe);
  if (!clipEl) {
    clipEl = sprite.clipEl = me.el.insertFirst(Ext.getDoc().dom.createElement('div'));
    clipEl.addCls('x-vml-sprite');
  }
  if (rect.length == 4) {
    rect[2] = +rect[2] + +rect[0];
    rect[3] = +rect[3] + +rect[1];
    clipEl.setStyle('clip', Ext.String.format('rect({1}px {2}px {3}px {0}px)', rect[0], rect[1], rect[2], rect[3]));
    clipEl.setSize(me.el.width, me.el.height);
  } else {
    clipEl.setStyle('clip', '');
  }
}, setTextAttributes:function(sprite, params) {
  var me = this, vml = sprite.vml, textStyle = vml.textpath.style, spanCacheStyle = me.span.style, zoom = me.zoom, fontObj = {fontSize:'font-size', fontWeight:'font-weight', fontStyle:'font-style'}, fontProp, paramProp;
  if (sprite.dirtyFont) {
    if (params.font) {
      textStyle.font = spanCacheStyle.font = params.font;
    }
    if (params['font-family']) {
      textStyle.fontFamily = '"' + params['font-family'].split(',')[0].replace(me.fontFamilyRe, '') + '"';
      spanCacheStyle.fontFamily = params['font-family'];
    }
    for (fontProp in fontObj) {
      paramProp = params[fontObj[fontProp]];
      if (paramProp) {
        textStyle[fontProp] = spanCacheStyle[fontProp] = paramProp;
      }
    }
    me.setText(sprite, params.text);
    if (vml.textpath.string) {
      me.span.innerHTML = String(vml.textpath.string).replace(/</g, '\x26#60;').replace(/&/g, '\x26#38;').replace(/\n/g, '\x3cbr/\x3e');
    }
    vml.W = me.span.offsetWidth;
    vml.H = me.span.offsetHeight + 2;
    if (params['text-anchor'] == 'middle') {
      textStyle['v-text-align'] = 'center';
    } else {
      if (params['text-anchor'] == 'end') {
        textStyle['v-text-align'] = 'right';
        vml.bbx = -Math.round(vml.W / 2);
      } else {
        textStyle['v-text-align'] = 'left';
        vml.bbx = Math.round(vml.W / 2);
      }
    }
  }
  vml.X = params.x;
  vml.Y = params.y;
  vml.path.v = Ext.String.format('m{0},{1}l{2},{1}', Math.round(vml.X * zoom), Math.round(vml.Y * zoom), Math.round(vml.X * zoom) + 1);
  sprite.bbox.plain = null;
  sprite.bbox.transform = null;
  sprite.dirtyFont = false;
}, setText:function(sprite, text) {
  sprite.vml.textpath.string = Ext.htmlDecode(text);
}, hide:function() {
  this.el.hide();
}, show:function() {
  this.el.show();
}, hidePrim:function(sprite) {
  sprite.el.addCls('x-hide-visibility');
}, showPrim:function(sprite) {
  sprite.el.removeCls('x-hide-visibility');
}, setSize:function(width, height) {
  var me = this;
  width = width || me.width;
  height = height || me.height;
  me.width = width;
  me.height = height;
  if (me.el) {
    if (width != undefined) {
      me.el.setWidth(width);
    }
    if (height != undefined) {
      me.el.setHeight(height);
    }
  }
  photoViewer.draw.Surface.prototype.setSize.apply(this, arguments);
}, applyViewBox:function() {
  var me = this, viewBox = me.viewBox, width = me.width, height = me.height, items, iLen, i;
  photoViewer.draw.Surface.prototype.applyViewBox.call(this);
  if (viewBox && (width || height)) {
    items = me.items.items;
    iLen = items.length;
    for (i = 0; i < iLen; i++) {
      me.applyTransformations(items[i]);
    }
  }
}, onAdd:function(item) {
  photoViewer.draw.Surface.prototype.onAdd.apply(this, arguments);
  if (this.el) {
    this.renderItem(item);
  }
}, onRemove:function(sprite) {
  if (sprite.el) {
    sprite.el.destroy();
    delete sprite.el;
  }
  photoViewer.draw.Surface.prototype.onRemove.apply(this, arguments);
}, render:function(container) {
  var me = this, doc = Ext.getDoc().dom, el;
  if (!me.createNode) {
    try {
      if (!doc.namespaces.rvml) {
        doc.namespaces.add('rvml', 'urn:schemas-microsoft-com:vml');
      }
      me.createNode = function(tagName) {
        return doc.createElement('\x3crvml:' + tagName + ' class\x3d"rvml"\x3e');
      };
    } catch (e$13) {
      me.createNode = function(tagName) {
        return doc.createElement('\x3c' + tagName + ' xmlns\x3d"urn:schemas-microsoft.com:vml" class\x3d"rvml"\x3e');
      };
    }
  }
  if (!me.el) {
    el = doc.createElement('div');
    me.el = Ext.get(el);
    me.el.addCls(me.baseVmlCls);
    me.span = doc.createElement('span');
    Ext.get(me.span).addCls(me.measureSpanCls);
    el.appendChild(me.span);
    me.el.setSize(me.width || 0, me.height || 0);
    container.appendChild(el);
    me.el.on({scope:me, mouseup:me.onMouseUp, mousedown:me.onMouseDown, mouseover:me.onMouseOver, mouseout:me.onMouseOut, mousemove:me.onMouseMove, mouseenter:me.onMouseEnter, mouseleave:me.onMouseLeave, click:me.onClick, dblclick:me.onDblClick});
  }
  me.renderAll();
}, renderAll:function() {
  this.items.each(this.renderItem, this);
}, redraw:function(sprite) {
  sprite.dirty = true;
  this.renderItem(sprite);
}, renderItem:function(sprite) {
  if (!this.el) {
    return;
  }
  if (!sprite.el) {
    this.createSpriteElement(sprite);
  }
  if (sprite.dirty) {
    this.applyAttrs(sprite);
    if (sprite.dirtyTransform) {
      this.applyTransformations(sprite);
    }
  }
}, rotationCompensation:function(deg, dx, dy) {
  var matrix = new photoViewer.draw.Matrix;
  matrix.rotate(-deg, 0.5, 0.5);
  return {x:matrix.x(dx, dy), y:matrix.y(dx, dy)};
}, transform:function(sprite, matrixOnly) {
  var me = this, bbox = me.getBBox(sprite, true), matrix = new photoViewer.draw.Matrix, transforms = sprite.transformations, transformsLength = transforms.length, i = 0, deltaDegrees = 0, deltaScaleX = 1, deltaScaleY = 1, el = sprite.el, dom = el.dom, domStyle = dom.style, skew = sprite.skew, shift = me.viewBoxShift, transform, type, offset;
  for (; i < transformsLength; i++) {
    transform = transforms[i];
    type = transform.type;
    if (type == 'translate') {
      matrix.translate(transform.x, transform.y);
    } else {
      if (type == 'rotate') {
        matrix.rotate(transform.degrees, transform.x, transform.y);
        deltaDegrees += transform.degrees;
      } else {
        if (type == 'scale') {
          matrix.scale(transform.x, transform.y, transform.centerX, transform.centerY);
          deltaScaleX *= transform.x;
          deltaScaleY *= transform.y;
        }
      }
    }
  }
  sprite.matrix = matrix.clone();
  if (matrixOnly) {
    return;
  }
  if (shift) {
    matrix.prepend(shift.scale, 0, 0, shift.scale, shift.dx * shift.scale, shift.dy * shift.scale);
  }
  if (sprite.type != 'image' && skew) {
    skew.origin = '0,0';
    skew.matrix = matrix.toString();
    offset = matrix.offset();
    if (offset[0] > 32767) {
      offset[0] = 32767;
    } else {
      if (offset[0] < -32768) {
        offset[0] = -32768;
      }
    }
    if (offset[1] > 32767) {
      offset[1] = 32767;
    } else {
      if (offset[1] < -32768) {
        offset[1] = -32768;
      }
    }
    skew.offset = offset;
  } else {
    domStyle.filter = matrix.toFilter();
    domStyle.left = Math.min(matrix.x(bbox.x, bbox.y), matrix.x(bbox.x + bbox.width, bbox.y), matrix.x(bbox.x, bbox.y + bbox.height), matrix.x(bbox.x + bbox.width, bbox.y + bbox.height)) + 'px';
    domStyle.top = Math.min(matrix.y(bbox.x, bbox.y), matrix.y(bbox.x + bbox.width, bbox.y), matrix.y(bbox.x, bbox.y + bbox.height), matrix.y(bbox.x + bbox.width, bbox.y + bbox.height)) + 'px';
  }
}, createItem:function(config) {
  return Ext.create('photoViewer.draw.Sprite', config);
}, getRegion:function() {
  return this.el.getRegion();
}, addCls:function(sprite, className) {
  if (sprite && sprite.el) {
    sprite.el.addCls(className);
  }
}, removeCls:function(sprite, className) {
  if (sprite && sprite.el) {
    sprite.el.removeCls(className);
  }
}, addGradient:function(gradient) {
  var gradients = this.gradientsColl || (this.gradientsColl = Ext.create('Ext.util.MixedCollection')), colors = [], stops = Ext.create('Ext.util.MixedCollection'), keys, items, iLen, key, item, i;
  stops.addAll(gradient.stops);
  stops.sortByKey('ASC', function(a, b) {
    a = parseInt(a, 10);
    b = parseInt(b, 10);
    return a > b ? 1 : a < b ? -1 : 0;
  });
  keys = stops.keys;
  items = stops.items;
  iLen = keys.length;
  for (i = 0; i < iLen; i++) {
    key = keys[i];
    item = items[i];
    colors.push(key + '% ' + item.color);
  }
  gradients.add(gradient.id, {colors:colors.join(','), angle:gradient.angle});
}, destroy:function() {
  var me = this;
  photoViewer.draw.Surface.prototype.destroy.apply(this, arguments);
  if (me.el) {
    me.el.destroy();
  }
  delete me.el;
}}, 0, 0, 0, 0, 0, 0, [photoViewer.draw.engine, 'Vml'], 0);
Ext.cmd.derive('photoViewer.view.addphotostoalbum.AddPhotosToAlbumController', Ext.app.ViewController, {onExistingAlbumClick:function() {
  var selectedAlbumUIDs = this.getView().getSelectedAlbumUIDs();
  if (selectedAlbumUIDs.length) {
    this.lookupReference('addPhotosToAlbumNextAction').enable();
  } else {
    this.lookupReference('addPhotosToAlbumNextAction').disable();
  }
  this.getViewModel().set('selectedAlbumUIDs', selectedAlbumUIDs);
}, onAddPhotosToAlbumNextActionClick:function() {
  var viewModel = this.getViewModel();
  if (viewModel.get('albumChoice.createNewAlbum')) {
    this.getToolbarActionsController().makeAlbum();
  } else {
    this.savePhotosToAlbums();
  }
}, savePhotosToAlbums:function(photos) {
  var viewModel = this.getViewModel(), view = this.getView(), albumUIDs = viewModel.get('selectedAlbumUIDs');
  if (!photos) {
    this.getToolbarActionsController().savePhotosToAlbums(albumUIDs, view, this.savePhotosToAlbums.bind(this));
    return;
  }
  Ext.getBody().mask();
  view.setLoading(true);
  Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daClientPhotoList.savePhotosToAlbums', params:{ProjectUID:viewModel.get('ProjectUID'), albumUIDs:albumUIDs.join(','), photos:photos.join(',')}, successCallback:function(data) {
    this.afterAddPhotosToAlbum(data);
    Ext.Msg.alert(mvstr['PA_Photos added'], mvstr['PA_The photos were succe']);
    Ext.getBody().unmask();
    view.destroy();
  }, afterFailMessageCallback:function(data) {
    this.afterAddPhotosToAlbum(data);
    Ext.getBody().unmask();
    view.setLoading(false);
  }, scope:this});
}, afterAddPhotosToAlbum:function(data) {
  if (!data) {
    return;
  }
  var interfaceControl = this.getToolbarActionsController().interfaceControl;
  if (!interfaceControl.afterAddPhotosToAlbum) {
    return;
  }
  for (var i = 0; i < data.length; i++) {
    var response = data[i], count = response.data.count ? response.data.count : 0;
    interfaceControl.afterAddPhotosToAlbum(response.AlbumUID, count);
  }
}, getToolbarActionsController:function() {
  return app.getController('photoActions.controller.ToolbarActions');
}}, 0, 0, 0, 0, ['controller.photovieweralbumadd'], 0, [photoViewer.view.addphotostoalbum, 'AddPhotosToAlbumController'], 0);
Ext.cmd.derive('photoViewer.view.addphotostoalbum.AddPhotosToAlbumModel', Ext.app.ViewModel, {data:{albumChoice:{createNewAlbum:false}, lastAlbumUIDChange:null}, formulas:{actionDesc:function(get) {
  return get('albumChoice.createNewAlbum') ? mvstr['PUL_Name New Album'] : mvstr['PUL_Choose Existing Album'];
}, selectedAlbumUIDs:{get:function(get) {
  if (!get('preferencesReady')) {
    return null;
  }
  var lastAlbumUIDChange = get('lastAlbumUIDChange'), defaultAlbumUIDs = mdsPreferences.ProjectPreferences.getAlbumUIDArray(), albumUIDs = [], store = this.getView().store;
  for (var i = 0; i < defaultAlbumUIDs.length; i++) {
    if (store.getById(defaultAlbumUIDs[i])) {
      albumUIDs.push(defaultAlbumUIDs[i]);
    }
  }
  if (albumUIDs.length != defaultAlbumUIDs.length) {
    mdsPreferences.ProjectPreferences.setAlbumUIDArray(albumUIDs);
  }
  return albumUIDs;
}, set:function(value) {
  mdsPreferences.ProjectPreferences.setAlbumUIDArray(value);
  this.set('lastAlbumUIDChange', (new Date).getTime());
}}, nextButtonEnabled:function(get) {
  var creatingAlbum = get('albumChoice.createNewAlbum'), albumUIDs = get('selectedAlbumUIDs');
  return !!(creatingAlbum || albumUIDs.length);
}}}, 0, 0, 0, 0, ['viewmodel.photovieweralbumadd'], 0, [photoViewer.view.addphotostoalbum, 'AddPhotosToAlbumModel'], 0);
Ext.cmd.derive('photoViewer.view.addphotostoalbum.AddPhotosToAlbum', Ext.window.Window, {config:{store:null, loadMaskCls:'light-load-indicator'}, ui:'orange', width:490, height:390, padding:'23 27 23 27', bind:{selectedAlbumUIDs:'{selectedAlbumUIDs}'}, viewModel:{type:'photovieweralbumadd'}, controller:'photovieweralbumadd', localized:{title:'PUL_Add Photos To Album'}, layout:{type:'vbox', align:'stretch'}, modal:true, modalMaskCls:'dark-mask', alwaysOnTop:2, constructor:function(config) {
  var checkBoxes = [], storeEmpty = !config.store.getCount();
  config.store.each(function(rec) {
    checkBoxes.push({xtype:'checkboxfield', ui:'plain-16', boxLabel:rec.get('AlbumName'), listeners:{change:'onExistingAlbumClick'}});
  });
  config.items = [{xtype:'component', cls:'instructions', localized:{html:'PUL_Choose from the field'}, margin:'0 0 23 0'}, {xtype:'radiogroup', layout:'hbox', bind:{value:'{albumChoice}'}, defaults:{name:'createNewAlbum', ui:'plain-radio-16', width:'50%'}, items:[{localized:{boxLabel:'PUL_Add to Existing Album'}, inputValue:false, disabled:storeEmpty}, {localized:{boxLabel:'PUL_Create New Album'}, inputValue:true}]}, {xtype:'component', bind:{html:'{actionDesc}'}, margin:'18 0 7 0'}, {xtype:'checkboxgroup', 
  width:'100%', height:126, columns:2, cls:'album-list', scrollable:true, reference:'existingAlbums', itemId:'existingAlbums', items:checkBoxes, bind:{hidden:'{albumChoice.createNewAlbum}'}}, {xtype:'detailformtextfield', width:436, bind:{hidden:'{!albumChoice.createNewAlbum}'}, id:'newAlbumName', itemId:'albumName', localized:{emptyText:'PUL_Enter new album name', fieldLabel:'PUL_Album Name'}, allowBlank:false, maxLength:255, enforceMaxLength:true}, {xtype:'component', flex:1}, {xtype:'container', 
  layout:{type:'hbox', pack:'middle'}, items:[{xtype:'button', scale:'medium', margin:'0 12 0 12', ui:'grey', localized:{text:'G_Cancel'}, listeners:{click:function() {
    this.up('window').destroy();
  }}}, {xtype:'button', reference:'addPhotosToAlbumNextAction', ui:'green', scale:'medium', margin:'0 12 0 12', localized:{text:'G_Save'}, bind:{disabled:'{!nextButtonEnabled}'}, listeners:{click:'onAddPhotosToAlbumNextActionClick'}}]}];
  Ext.window.Window.prototype.constructor.apply(this, arguments);
  this.getViewModel().set('albumChoice.createNewAlbum', storeEmpty);
}, getSelectedAlbumUIDs:function() {
  var albumView = this.lookupReference('existingAlbums'), albums = this.getStore().getRange(), checkboxes = albumView.query('checkboxfield'), uids = [];
  for (var i = 0; i < checkboxes.length; i++) {
    if (checkboxes[i].getValue()) {
      uids.push(albums[i].get('AlbumUID'));
    }
  }
  return uids;
}, setSelectedAlbumUIDs:function(albumUIDs) {
  var albumView = this.lookupReference('existingAlbums'), albums = this.getStore().getRange(), checkboxes = albumView.query('checkboxfield');
  for (var i = 0; i < checkboxes.length; i++) {
    checkboxes[i].setValue(Ext.Array.contains(albumUIDs, albums[i].get('AlbumUID')));
  }
}}, 1, ['photovieweralbumadd'], ['component', 'box', 'container', 'panel', 'window', 'photovieweralbumadd'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true, 'photovieweralbumadd':true}, ['widget.photovieweralbumadd'], 0, [photoViewer.view.addphotostoalbum, 'AddPhotosToAlbum'], 0);
Ext.cmd.derive('photoViewer.view.annotations.sprites.Line', photoViewer.draw.Sprite, {constructor:function(config) {
  this.initConfig(config);
  photoViewer.draw.Sprite.prototype.constructor.apply(this, arguments);
}, initConfig:function(config) {
  this.x0 = config.x0 - 0;
  this.y0 = config.y0 - 0;
  this.x1 = config.x1 - 0;
  this.y1 = config.y1 - 0;
  config.type = 'path', config.path = this.makePath();
  this.callParent(arguments);
}, makePath:function() {
  path = ['M', this.x0, this.y0, 'L', this.x1, this.y1, 'Z'];
  return path.join(' ');
}, setAttributes:function(attrs, redraw) {
  var changedPath = false;
  if (attrs.x0 !== undefined) {
    this.x0 = attrs.x0;
    delete attrs.x0;
    changedPath = true;
  }
  if (attrs.y0 !== undefined) {
    this.y0 = attrs.y0;
    delete attrs.y0;
    changedPath = true;
  }
  if (attrs.x1 !== undefined) {
    this.x1 = attrs.x1;
    delete attrs.x1;
    changedPath = true;
  }
  if (attrs.y1 !== undefined) {
    this.y1 = attrs.y1;
    delete attrs.y1;
    changedPath = true;
  }
  if (changedPath) {
    attrs.path = this.makePath();
  }
  photoViewer.draw.Sprite.prototype.setAttributes.apply(this, arguments);
}}, 1, 0, 0, 0, 0, 0, [photoViewer.view.annotations.sprites, 'Line'], 0);
Ext.cmd.derive('photoViewer.view.annotations.sprites.Arrow', photoViewer.view.annotations.sprites.Line, {initConfig:function(config) {
  this.strokeWidth = config['stroke-width'];
  photoViewer.view.annotations.sprites.Line.prototype.initConfig.apply(this, arguments);
}, makePath:function() {
  var strokeWidth = this.strokeWidth === undefined ? this.attr['stroke-width'] : this.strokeWidth;
  var theta = Math.getLineAngle([this.x0, this.y0], [this.x1, this.y1]);
  var arrowLength = Math.sqrt(Math.pow(this.y0 - this.y1, 2) + Math.pow(this.x0 - this.x1, 2));
  var arrowHeadLength = strokeWidth * (this.fill ? 5 : 10);
  var arrowHeadWidth = arrowHeadLength / 2;
  var arrowShaftLength = Math.max(0, arrowLength - arrowHeadLength);
  var arrowShaftStartPoint = Math.getRotatedPoint([this.x0, this.y0], [this.x0 + arrowLength - arrowHeadLength - arrowShaftLength, this.y0], theta);
  var arrowHeadBasePoint = Math.getRotatedPoint([this.x0, this.y0], [this.x0 + arrowLength - arrowHeadLength, this.y0], theta);
  var arrowCorner1Point = Math.getRotatedPoint([this.x0, this.y0], [this.x0 + arrowLength - arrowHeadLength, this.y0 - arrowHeadWidth / 2], theta);
  var arrowCorner2Point = Math.getRotatedPoint([this.x0, this.y0], [this.x0 + arrowLength - arrowHeadLength, this.y0 + arrowHeadWidth / 2], theta);
  var path = ['M', arrowShaftStartPoint[0], arrowShaftStartPoint[1], 'L', arrowHeadBasePoint[0], arrowHeadBasePoint[1], 'L', arrowCorner1Point[0], arrowCorner1Point[1], 'L', this.x1, this.y1, 'L', arrowCorner2Point[0], arrowCorner2Point[1], 'L', arrowHeadBasePoint[0], arrowHeadBasePoint[1], 'Z'];
  return path.join(' ');
}, setAttributes:function(attrs, redraw) {
  if (attrs['stroke-width'] != undefined) {
    this.strokeWidth = attrs['stroke-width'];
    if (attrs.x0 === undefined) {
      attrs.x0 = this.x0;
    }
    if (attrs.y0 === undefined) {
      attrs.y0 = this.y0;
    }
    if (attrs.x1 === undefined) {
      attrs.x1 = this.x1;
    }
    if (attrs.y1 === undefined) {
      attrs.y1 = this.y1;
    }
  }
  photoViewer.view.annotations.sprites.Line.prototype.setAttributes.apply(this, arguments);
}}, 0, 0, 0, 0, 0, 0, [photoViewer.view.annotations.sprites, 'Arrow'], 0);
Ext.cmd.derive('photoViewer.view.annotations.sprites.pointHandle', photoViewer.draw.Sprite, {bboxExcluded:true, draggable:true, config:{type:'ellipse', fill:'white', stroke:'black', radiusX:4, radiusY:4}, constructor:function(config) {
  this.initConfig(config);
  photoViewer.draw.Sprite.prototype.constructor.apply(this, arguments);
  this.addListener('mouseover', function() {
    this.setStyle('cursor', 'pointer');
  }, this, {single:true});
}, initConfig:function(config) {
  var scale = config.drawComponent.getScale();
  config.type = 'ellipse';
  config.fill = 'white';
  config.stroke = 'black';
  config.radiusX = Math.max(4 / scale, 4);
  config.radiusY = Math.max(4 / scale, 4);
  this.callParent(arguments);
}}, 1, 0, 0, 0, 0, 0, [photoViewer.view.annotations.sprites, 'pointHandle'], 0);
Ext.cmd.derive('photoViewer.view.annotations.sprites.resizeHandle', photoViewer.draw.Sprite, {draggable:true, bboxExcluded:true, invertX:false, invertY:false, constructor:function(config) {
  this.initConfig(config);
  photoViewer.draw.Sprite.prototype.constructor.apply(this, arguments);
  this.addListener('mouseover', function() {
    var cursorStyles = ['n-resize', 'ne-resize', 'e-resize', 'se-resize', 's-resize', 'sw-resize', 'w-resize', 'nw-resize'];
    this.setStyle('cursor', cursorStyles[this.position]);
  }, this, {single:true});
}, initConfig:function(config) {
  var xy = this.getPositionXY(config.position, config.boundingBox, config.drawComponent), scale = config.drawComponent.getScale(), size = this.getHandleWidth(scale);
  config.x = xy[0];
  config.y = xy[1];
  config.width = size;
  config.height = size;
  delete config.boundingBox;
  config.type = 'rect';
  config.stroke = 'black';
  config.fill = 'white';
  config['stroke-width'] = 1;
  this.callParent(arguments);
}, getPositionXY:function(position, bbox, drawComponent) {
  if (!drawComponent) {
    drawComponent = this.drawComponent;
  }
  var bbx = bbox.x, bby = bbox.y, bbw = bbox.width, bbh = bbox.height, hw = this.getHandleWidth(drawComponent.getScale());
  if (position === 0) {
    return [bbx + bbw / 2 - hw / 2, bby - hw / 2];
  } else {
    if (position == 1) {
      return [bbx + bbw - hw / 2, bby - hw / 2];
    } else {
      if (position == 2) {
        return [bbx + bbw - hw / 2, bby + bbh / 2 - hw / 2];
      } else {
        if (position == 3) {
          return [bbx + bbw - hw / 2, bby + bbh - hw / 2];
        } else {
          if (position == 4) {
            return [bbx + bbw / 2 - hw / 2, bby + bbh - hw / 2];
          } else {
            if (position == 5) {
              return [bbx - hw / 2, bby + bbh - hw / 2];
            } else {
              if (position == 6) {
                return [bbx - hw / 2, bby + bbh / 2 - hw / 2];
              } else {
                return [bbx - hw / 2, bby - hw / 2];
              }
            }
          }
        }
      }
    }
  }
}, refreshPosition:function(bbox) {
  var xy = this.getPositionXY(this.position, bbox), scale = this.drawComponent.getScale(), size = this.getHandleWidth(scale);
  this.setAttributes({width:size, height:size, x:xy[0], y:xy[1]}, true);
  this.show(true);
}, getPosition:function(shape) {
  var oppositeHandle = shape.getByKey('resizeHandle' + (this.position + 4) % 8);
  var handleToRight = shape.getByKey('resizeHandle' + (this.position + 2) % 8);
  var handleToLeft = shape.getByKey('resizeHandle' + (this.position + 6) % 8);
  xPositions = [this.getBBox().x, oppositeHandle.getBBox().x, handleToRight.getBBox().x, handleToLeft.getBBox().x];
  yPositions = [this.getBBox().y, oppositeHandle.getBBox().y, handleToRight.getBBox().y, handleToLeft.getBBox().y];
  if (this.position === 0 || this.position === 4) {
    if (yPositions[0] === yPositions[1]) {
      return this.position;
    }
    if (yPositions[0] < yPositions[1]) {
      return 0;
    }
    return 4;
  }
  if (this.position === 6 || this.position === 2) {
    if (xPositions[0] === xPositions[1]) {
      return this.position;
    }
    if (xPositions[0] < xPositions[1]) {
      return 6;
    }
    return 2;
  }
  for (var i = 1; i < 4; i++) {
    if (xPositions[i] == xPositions[0] && yPositions[i] == yPositions[0]) {
      return this.position;
    }
  }
  var leftmostX = Ext.Array.min(xPositions), rightmostX = Ext.Array.max(xPositions), uppermostY = Ext.Array.min(yPositions), lowermostY = Ext.Array.max(yPositions);
  if (xPositions[0] == rightmostX && yPositions[0] == uppermostY) {
    return 1;
  }
  if (xPositions[0] == rightmostX && yPositions[0] == lowermostY) {
    return 3;
  }
  if (xPositions[0] == leftmostX && yPositions[0] == lowermostY) {
    return 5;
  }
  if (xPositions[0] == leftmostX && yPositions[0] == uppermostY) {
    return 7;
  }
}, getHandleWidth:function(scale) {
  return Math.max(7 / scale, 4);
}}, 1, 0, 0, 0, 0, 0, [photoViewer.view.annotations.sprites, 'resizeHandle'], 0);
Ext.cmd.derive('photoViewer.view.annotations.shapes.Base', photoViewer.draw.CompositeSprite, {statics:{HANDLE_POS:{RHS:[1, 2, 3], LHS:[5, 6, 7], TOP:[0, 1, 7], BOTTOM:[3, 4, 5]}}, shapeAttributes:[], dataAttributes:[], nBaseSprites:1, isSelected:false, constructor:function(config) {
  if (!config && this.myConfig) {
    config = this.myConfig;
  }
  this.drawComponent = config.drawComponent;
  if (typeof config == 'undefined' || config.isNew) {
    config = this.getDefaultConfig();
  }
  this.surface = this.drawComponent.surface;
  photoViewer.draw.CompositeSprite.prototype.constructor.apply(this, arguments);
  if (typeof config.model !== 'undefined') {
    var model = config.model;
    this.record = model;
    config = {};
    for (var i = 0; i < this.shapeAttributes.length; i++) {
      config[this.shapeAttributes[i]] = model.get('Attr' + i);
    }
    this.readOnly = model.get('ReadOnly') || this.drawComponent.getReadOnly();
  }
  this.initConfig(config);
}, initConfig:function(config) {
  if (!config) {
    return;
  }
  this.callParent(arguments);
}, add:function(key, sprite) {
  var me = this;
  photoViewer.draw.CompositeSprite.prototype.add.apply(this, arguments);
  me.surface.add(sprite);
  sprite.show(true);
  if (key.indexOf('base') != -1) {
    if (!this.readOnly) {
      sprite.addListener('click', this.onClick, this);
    }
  }
  if (this.readOnly) {
    return;
  }
  if (sprite.dd && key.indexOf('resizeHandle') != -1) {
    Ext.override(sprite.dd, {onDrag:function(e) {
      me.resizeShapeOnDragHandle(sprite.dd, sprite, e);
    }, onMouseUp:function(e) {
      me.onDragHandleMouseUp(sprite.dd, sprite, e);
    }});
  } else {
    if (sprite.dd && key.indexOf('pointHandle') != -1) {
      Ext.override(sprite.dd, {onDrag:function(e) {
        me.changePointOnDragHandle(sprite.dd, sprite, e);
      }});
    } else {
      if (sprite.dd !== undefined) {
        Ext.override(sprite.dd, {onDrag:function(e) {
          me.spriteGroupMove(sprite.dd, sprite, e);
        }});
      }
    }
  }
  sprite.drawComponent = this.drawComponent;
}, removeByKey:function(key) {
  var sprite = this.getByKey(key);
  if (!sprite) {
    return;
  }
  this.removeAtKey(key);
  this.surface.remove(sprite, true);
}, onRemove:function() {
}, select:function() {
  var vm = this.getViewModel(), drawOff = vm.get('drawMode') == photoViewer.Values.DRAW_OFF;
  if (this.isSelected || vm.get('toolSettings.mode') != 'select') {
    return;
  }
  this.drawComponent.getController().deselectAll(this);
  this.isSelected = true;
  if (!drawOff && !this.readOnly) {
    this.refreshSelectionSprites();
    this.drawComponent.getController().onShapeSelect(this);
  }
}, onClick:function() {
  if (!this.drawComponent.up('photoviewer').lookupController().beforeDrawableSelectionChange(this.record)) {
    return;
  }
  var vm = this.getViewModel(), drawOff = vm.get('drawMode') == photoViewer.Values.DRAW_OFF;
  if (this.isSelected || vm.get('toolSettings.mode') != 'select') {
    return;
  }
  var oldShape = this.drawComponent.getController().getSelectedShape();
  if (!drawOff && !this.readOnly) {
    if (oldShape && !this.disableShapeSync) {
      this.drawComponent.fireEvent('shapesync', this, oldShape);
    }
  }
  this.getViewModel().set('selectedDrawing', this.record);
}, deselect:function() {
  var isDeselectingSomething = this.isSelected;
  this.isSelected = false;
  this.removeSelectionSprites();
  if (isDeselectingSomething) {
    this.drawComponent.getController().onShapeDeselect(this);
  }
  return isDeselectingSomething;
}, refreshSelectionSprites:function() {
  var resizeHandle0 = this.getByKey('resizeHandle0');
  var bbox = this.getBBox();
  if (!resizeHandle0) {
    for (var i = 0; i < 8; i++) {
      var resizeHandle = Ext.create('photoViewer.view.annotations.sprites.resizeHandle', {boundingBox:bbox, position:i, drawComponent:this.drawComponent});
      this.add('resizeHandle' + i, resizeHandle);
    }
  } else {
    for (var j = 0; j < 8; j++) {
      this.getByKey('resizeHandle' + j).refreshPosition(bbox);
    }
  }
}, removeSelectionSprites:function() {
  for (var i = 0; i < 8; i++) {
    var handle = this.getByKey('resizeHandle' + i);
    if (handle) {
      handle.hide(true);
    }
  }
}, spriteGroupMove:function(spriteDD, sprite, event) {
  this.drawComponent.getController().deselectAll(this);
  var xy = event.getXY(), dxDY = [0, 0], dc = this.drawComponent, scale = dc.getScale();
  var prev = spriteDD.prev;
  if (prev) {
    dxDY[0] = xy[0] - prev[0], dxDY[1] = xy[1] - prev[1];
    prev[0] = xy[0];
    prev[1] = xy[1];
  } else {
    var offset = spriteDD.getOffset();
    if (sprite.prevOffset) {
      dxDY[0] = offset[0] - sprite.prevOffset[0], dxDY[1] = offset[1] - sprite.prevOffset[1];
      sprite.prevOffset = offset;
    } else {
      dxDY = offset;
      sprite.prevOffset = offset;
    }
  }
  dxDY[0] = dxDY[0] / scale;
  dxDY[1] = dxDY[1] / scale;
  var shiftPositionLeft = dxDY[0] < 0 ? true : false;
  var shiftPositionUp = dxDY[1] < 0 ? true : false;
  this.adjustdxDYToStayInBounds(dxDY, shiftPositionLeft, shiftPositionUp);
  if (dxDY[0] === 0 && dxDY[1] === 0) {
    return;
  }
  this.translate(dxDY[0], dxDY[1]);
  this.refreshSelectionSprites();
  this.drawComponent.pendingDataChangeShape = this;
}, translate:function(dx, dy) {
  for (var i = 0; i < this.nBaseSprites; i++) {
    var spriteI = this.getAt(i);
    var attributes = {};
    attributes.x = spriteI.attr.x + dx;
    attributes.y = spriteI.attr.y + dy;
    spriteI.setAttributes(attributes, true);
  }
}, resizeShapeOnDragHandle:function(spriteDD, sprite, event) {
  var xy = event.getXY(), scale = this.drawComponent.getScale(), drawRegion = this.drawComponent.getRegion(), scaledXY = [(xy[0] - drawRegion.left) / scale, (xy[1] - drawRegion.top) / scale];
  spriteDD.prev = xy;
  this.resizeShape(scaledXY, sprite.getPosition(this));
}, getChangeWidth:function(direction) {
  return Ext.Array.contains([1, 2, 3, 5, 6, 7], direction) ? true : false;
}, getChangeHeight:function(direction) {
  return Ext.Array.contains([0, 1, 3, 4, 5, 7], direction) ? true : false;
}, getShiftPositionLeft:function(direction) {
  return Ext.Array.contains([0, 4, 5, 6, 7], direction) ? true : false;
}, getShiftPositionUp:function(direction) {
  return Ext.Array.contains([0, 1, 2, 6, 7], direction) ? true : false;
}, getCanResizeFlip:function() {
  return true;
}, resizeShape:function(scaledMouseXY, handlePosition) {
  var handlePos = photoViewer.view.annotations.shapes.Base.HANDLE_POS, newX = this.getRealLeft(), newY = this.getRealTop(), newWidth = this.getRealWidth(), newHeight = this.getRealHeight(), canFlip = this.getCanResizeFlip(), type = this.getType(), resizeCls = 'resize-shape-' + handlePosition;
  if (this.resizeCls != resizeCls) {
    if (this.resizeCls) {
      this.drawComponent.up().el.removeCls(this.resizeCls);
    }
    this.drawComponent.up().el.addCls(resizeCls);
    this.resizeCls = resizeCls;
  }
  if (type == 'text' || type == 'textbox') {
    scaledMouseXY[0] = Math.max(0, Math.min(scaledMouseXY[0], this.drawComponent.getNaturalWidth()));
    scaledMouseXY[1] = Math.max(0, Math.min(scaledMouseXY[1], this.drawComponent.getNaturalHeight()));
  }
  if (this.flipX) {
    handlePosition = {0:0, 1:7, 2:6, 3:5, 4:4, 5:3, 6:2, 7:1}[handlePosition];
  }
  if (this.flipY) {
    handlePosition = {0:4, 1:3, 2:2, 3:1, 4:0, 5:7, 6:6, 7:5}[handlePosition];
  }
  if (!this.anchorX && (Ext.Array.contains(handlePos.RHS, handlePosition) || Ext.Array.contains(handlePos.LHS, handlePosition))) {
    if (Ext.Array.contains(handlePos.RHS, handlePosition)) {
      this.anchorX = this.getRealLeft();
    } else {
      this.anchorX = this.getRealRight();
    }
  }
  if (!this.anchorY && (Ext.Array.contains(handlePos.TOP, handlePosition) || Ext.Array.contains(handlePos.BOTTOM, handlePosition))) {
    if (Ext.Array.contains(handlePos.TOP, handlePosition)) {
      this.anchorY = this.getRealBottom();
    } else {
      this.anchorY = this.getRealTop();
    }
  }
  if (Ext.Array.contains(handlePos.RHS, handlePosition)) {
    newWidth = scaledMouseXY[0] - this.anchorX;
    newX = this.anchorX;
    if (!canFlip) {
      newWidth = Math.max(newWidth, this.getMinWidth());
    }
  } else {
    if (Ext.Array.contains(handlePos.LHS, handlePosition)) {
      newWidth = this.anchorX - scaledMouseXY[0];
      if (!canFlip) {
        newWidth = Math.max(newWidth, this.getMinWidth());
      }
      newX = this.anchorX - newWidth;
    }
  }
  if (Ext.Array.contains(handlePos.BOTTOM, handlePosition)) {
    newHeight = scaledMouseXY[1] - this.anchorY;
    newY = this.anchorY;
    if (!canFlip) {
      newHeight = Math.max(newHeight, this.getMinHeight());
    }
  } else {
    if (Ext.Array.contains(handlePos.TOP, handlePosition)) {
      newHeight = this.anchorY - scaledMouseXY[1];
      if (!canFlip) {
        newHeight = Math.max(newHeight, this.getMinHeight());
      }
      newY = this.anchorY - newHeight;
    }
  }
  if (newWidth < 0 || newHeight < 0) {
    if (newWidth < 0) {
      this.flipX = !this.flipX;
    }
    if (newHeight < 0) {
      this.flipY = !this.flipY;
    }
    return;
  }
  this.resize(newX, newY, newWidth, newHeight, this.getShiftPositionLeft(handlePosition), this.getShiftPositionUp(handlePosition));
  this.refreshSelectionSprites();
  this.drawComponent.pendingDataChangeShape = this;
}, onDragHandleMouseUp:function() {
  delete this.flipX;
  delete this.flipY;
  delete this.anchorX;
  delete this.anchorY;
  this.refreshSelectionSprites();
  if (this.readOnly && this.getType() == 'text') {
    this.afterMove();
  }
  if (this.resizeCls) {
    this.drawComponent.up().el.removeCls(this.resizeCls);
    delete this.resizeCls;
  }
}, getWidth:function() {
  return this.getBaseShape().getBBox().width;
}, getHeight:function() {
  return this.getBaseShape().getBBox().height;
}, getRealWidth:function() {
  if (Ext.Array.contains(this.shapeAttributes, 'width')) {
    return this.getAttribute('width');
  }
  if (Ext.Array.contains(this.shapeAttributes, 'radiusX')) {
    return this.getAttribute('radiusX') * 2;
  }
  if (this.nBaseSprites == 1 && typeof this.getAt(0).attr.width != 'undefined') {
    return this.getAt(0).attr.width;
  }
  return this.getBaseShape().getBBox().width;
}, getRealHeight:function() {
  if (Ext.Array.contains(this.shapeAttributes, 'height')) {
    return this.getAttribute('height');
  }
  if (Ext.Array.contains(this.shapeAttributes, 'radiusY')) {
    return this.getAttribute('radiusY') * 2;
  }
  if (this.nBaseSprites == 1 && typeof this.getAt(0).attr.height != 'undefined') {
    return this.getAt(0).attr.height;
  }
  return this.getBaseShape().getBBox().height;
}, getRealLeft:function() {
  if (Ext.Array.contains(this.shapeAttributes, 'x')) {
    return this.getAttribute('x');
  }
  if (Ext.Array.contains(this.shapeAttributes, 'x0') && Ext.Array.contains(this.shapeAttributes, 'x1')) {
    return Math.min(this.getAttribute('x0'), this.getAttribute('x1'));
  }
  if (this.nBaseSprites == 1 && typeof this.getAt(0).attr.x != 'undefined') {
    return this.getAt(0).attr.x;
  }
  return this.getBaseShape().getBBox().x;
}, getRealRight:function() {
  if (Ext.Array.contains(this.shapeAttributes, 'x0') && Ext.Array.contains(this.shapeAttributes, 'x1')) {
    return Math.max(this.getAttribute('x0'), this.getAttribute('x1'));
  }
  return this.getRealLeft() + this.getRealWidth();
}, getRealTop:function() {
  if (Ext.Array.contains(this.shapeAttributes, 'y')) {
    return this.getAttribute('y');
  }
  if (Ext.Array.contains(this.shapeAttributes, 'y0') && Ext.Array.contains(this.shapeAttributes, 'y1')) {
    return Math.min(this.getAttribute('y0'), this.getAttribute('y1'));
  }
  if (this.nBaseSprites == 1 && typeof this.getAt(0).attr.y != 'undefined') {
    return this.getAt(0).attr.y;
  }
  return this.getBaseShape().getBBox().y;
}, getRealBottom:function() {
  if (Ext.Array.contains(this.shapeAttributes, 'y0') && Ext.Array.contains(this.shapeAttributes, 'y1')) {
    return Math.max(this.getAttribute('y0'), this.getAttribute('y1'));
  }
  return this.getRealTop() + this.getRealHeight();
}, isTooSmall:function() {
  return this.getWidth() <= 10 || this.getHeight() <= 10 ? true : false;
}, setColour:function(colour) {
  for (var i = 0; i < this.nBaseSprites; i++) {
    var sprite = this.getAt(i);
    sprite.setAttributes({stroke:colour}, true);
  }
  this.drawComponent.lookupViewModel().set('toolSettings.strokeColour', colour);
  this.fireEvent('datachanged');
}, getType:function() {
  return this.getAt(0).type;
}, getAttribute:function(shapeAttributeName) {
  var baseShape = this.getAt(0);
  var attr = baseShape.attr;
  if (!attr) {
    attr = baseShape;
  }
  var attribute = attr[shapeAttributeName];
  if (shapeAttributeName == 'width' || shapeAttributeName == 'height' || shapeAttributeName == 'x' || shapeAttributeName == 'y' || shapeAttributeName == 'radiusX' || shapeAttributeName == 'radiusY') {
    attribute = Math.round(attribute);
  } else {
    if (shapeAttributeName == 'style') {
      for (var key in this.drawComponent.self.styleSettings) {
        if (attr['stroke-dasharray'] == this.drawComponent.self.styleSettings[key]) {
          return key;
        }
      }
    }
  }
  return attribute;
}, adjustdxDYToStayInBounds:function(dxDY, shiftPositionLeft, shiftPositionUp) {
  var realTop = this.getRealTop(), realRight = this.getRealRight(), realBottom = this.getRealBottom(), realLeft = this.getRealLeft();
  var maxX = this.getViewModel().get('naturalWidth'), maxY = this.getViewModel().get('naturalHeight');
  var newX = shiftPositionLeft ? realLeft + dxDY[0] : realLeft, newY = shiftPositionUp ? realTop + dxDY[1] : realTop, newRight = !shiftPositionLeft ? realRight + dxDY[0] : realRight, newBottom = !shiftPositionUp ? realBottom + dxDY[1] : realBottom;
  if (newX < 0) {
    dxDY[0] = 0 - realLeft;
    dxDY[0] = Math.ceil(dxDY[0]);
  } else {
    if (newRight > maxX) {
      dxDY[0] = maxX - realRight;
      dxDY[0] = Math.floor(dxDY[0]);
    }
  }
  if (newY < 0) {
    dxDY[1] = 0 - realTop;
    dxDY[1] = Math.ceil(dxDY[1]);
  } else {
    if (newBottom > maxY) {
      dxDY[1] = maxY - realBottom;
      dxDY[1] = Math.floor(dxDY[1]);
    }
  }
}, resize:function(newX, newY, newWidth, newHeight) {
  for (var i = 0; i < this.nBaseSprites; i++) {
    this.getAt(i).setAttributes({x:newX, y:newY, width:newWidth, height:newHeight}, true);
  }
}, handleKeyPress:function(e, shapeIndex) {
  var key = e.getKey();
  if (key == Ext.EventObject.DELETE) {
    e.preventDefault();
    if (this.readOnly) {
      return;
    }
    var store = this.drawComponent.lookupViewModel().get('drawablesStore');
    this.drawComponent.up('photoviewer').lookupController().removeDrawable(store.getAt(shapeIndex));
  }
}, setStrokeWidth:function(newValue) {
  var baseShape = this.getBaseShape();
  if (baseShape) {
    baseShape.setAttributes({'stroke-width':newValue}, true);
  }
  this.drawComponent.lookupViewModel().set('toolSettings.strokeWidth', newValue);
  this.fireEvent('datachanged');
}, setStrokeStyle:function(newValue) {
  var baseShape = this.getBaseShape();
  if (baseShape) {
    baseShape.setAttributes({'stroke-dasharray':this.drawComponent.self.styleSettings[newValue]}, true);
  }
  this.drawComponent.lookupViewModel().set('toolSettings.strokeStyle', newValue);
  this.fireEvent('datachanged');
}, getBaseShape:function() {
  return this.getAt(0);
}, getDrawComponent:function() {
  return this.drawComponent;
}, onCreate:Ext.emptyFn, getViewModel:function() {
  return this.getDrawComponent().lookupViewModel();
}, getMinWidth:function() {
  return 0;
}, getMinHeight:function() {
  return 0;
}, onZoomChange:Ext.emptyFn, onTitleChange:Ext.emptyFn, onIsMetricChange:Ext.emptyFn, getAttrFieldName:function(attrName) {
  return 'Attr' + this.shapeAttributes.indexOf(attrName);
}, getRecordValueByAttrName:function(attrName) {
  return this.record.get(this.getAttrFieldName(attrName));
}}, 1, 0, 0, 0, 0, 0, [photoViewer.view.annotations.shapes, 'Base'], 0);
Ext.cmd.derive('photoViewer.view.annotations.shapes.Line', photoViewer.view.annotations.shapes.Base, {shapeAttributes:['x0', 'y0', 'x1', 'y1', 'stroke', 'stroke-width', 'style'], x1Index:10, initLineConfig:function(config) {
  var lineConfig = {x0:config.x0 - 0, y0:config.y0 - 0, x1:config.x1 - 0, y1:config.y1 - 0, draggable:!this.readOnly, stroke:config.stroke, 'stroke-width':config['stroke-width'], 'stroke-dasharray':this.drawComponent.self.styleSettings[config['style']]};
  return lineConfig;
}, initConfig:function(config) {
  if (!config) {
    return;
  }
  var lineConfig = this.initLineConfig(config);
  var baseShape = Ext.create('photoViewer.view.annotations.sprites.Line', lineConfig);
  this.add('base0', baseShape);
  this.show(true);
}, refreshSelectionSprites:function(staticPoint) {
  var handle0 = this.getByKey('pointHandle' + 0), handle1 = this.getByKey('pointHandle' + 1), x0 = this.getAttribute('x0'), y0 = this.getAttribute('y0'), x1 = this.getAttribute('x1'), y1 = this.getAttribute('y1'), scale = this.drawComponent.getScale(), draggable = this.getBaseShape().draggable;
  if (!handle0) {
    handle0 = Ext.create('photoViewer.view.annotations.sprites.pointHandle', {x:x0, y:y0, pointNumber:0, drawComponent:this.drawComponent, draggable:draggable});
    handle1 = Ext.create('photoViewer.view.annotations.sprites.pointHandle', {x:x1, y:y1, pointNumber:1, drawComponent:this.drawComponent, draggable:draggable});
    this.add('pointHandle0', handle0);
    this.add('pointHandle1', handle1);
  } else {
    var radius = Math.max(4 / scale, 3);
    if (staticPoint !== 0) {
      handle0.setAttributes({x:x0, y:y0, radiusX:radius, radiusY:radius}, true);
      handle0.show(true);
    }
    if (staticPoint !== 1) {
      handle1.setAttributes({x:x1, y:y1, radiusX:radius, radiusY:radius}, true);
      handle1.show(true);
    }
  }
}, removeSelectionSprites:function() {
  for (var i = 0; i < 2; i++) {
    var handle = this.getByKey('pointHandle' + i);
    if (handle) {
      handle.hide(true);
    }
  }
}, getType:function() {
  return 'line';
}, getAttribute:function(shapeAttributeName) {
  var line = this.getAt(0), attr = line.attr;
  if (shapeAttributeName == 'stroke') {
    return attr.stroke;
  }
  if (shapeAttributeName == 'stroke-width') {
    return attr['stroke-width'];
  }
  if (shapeAttributeName == 'style') {
    for (var key in this.drawComponent.self.styleSettings) {
      if (attr['stroke-dasharray'] == this.drawComponent.self.styleSettings[key]) {
        return key;
      }
    }
  }
  return Math.round(line[shapeAttributeName]);
}, changePointOnDragHandle:function(spriteDD, sprite, event) {
  var xy = this.drawComponent.getController().getRelativeDescaledXYFromMouseEvent(event);
  this.movePointHandle(sprite.pointNumber, xy[0], xy[1]);
  this.refreshSelectionSprites(Math.abs(sprite.pointNumber - 1));
}, movePointHandle:function(pointNumber, x, y) {
  var maxX = this.getViewModel().get('naturalWidth');
  var maxY = this.getViewModel().get('naturalHeight');
  if (x < 0) {
    x = 0;
  } else {
    if (x > maxX) {
      x = maxX;
    }
  }
  if (y < 0) {
    y = 0;
  } else {
    if (y > maxY) {
      y = maxY;
    }
  }
  var x0 = this.getAttribute('x0');
  var y0 = this.getAttribute('y0');
  var x1 = this.getAttribute('x1');
  var y1 = this.getAttribute('y1');
  if (pointNumber === 0) {
    x0 = x;
    y0 = y;
  } else {
    x1 = x;
    y1 = y;
  }
  this.getAt(0).setAttributes({x0:x0, y0:y0, x1:x1, y1:y1}, true);
  this.fireEvent('datachanged');
}, isTooSmall:function() {
  var line = this.getAt(0), length = Math.getLineLength([line.x0, line.y0], [line.x1, line.y1]);
  return length > 5 ? false : true;
}, setColour:function(colour) {
  this.getAt(0).setAttributes({stroke:colour}, true);
  this.fireEvent('datachanged');
}, translate:function(dx, dy) {
  var line = this.getAt(0);
  line.setAttributes({x0:line.x0 + dx, y0:line.y0 + dy, x1:line.x1 + dx, y1:line.y1 + dy}, true);
}, getDefaultConfig:function() {
  var xy = this.drawComponent.descaledXY, viewModel = this.getViewModel();
  return {x0:xy[0], x1:xy[0], y0:xy[1], y1:xy[1], stroke:viewModel.get('toolSettings.strokeColour'), 'stroke-width':viewModel.get('toolSettings.strokeWidth'), style:viewModel.get('toolSettings.strokeStyle')};
}}, 0, 0, 0, 0, 0, 0, [photoViewer.view.annotations.shapes, 'Line'], 0);
Ext.cmd.derive('photoViewer.view.annotations.shapes.Arrow', photoViewer.view.annotations.shapes.Line, {initConfig:function(config) {
  if (!config) {
    return;
  }
  var lineConfig = this.initLineConfig(config);
  var baseShape = Ext.create('photoViewer.view.annotations.sprites.Arrow', lineConfig);
  this.add('base0', baseShape);
  this.show(true);
}, getType:function() {
  return 'arrow';
}}, 0, 0, 0, 0, 0, 0, [photoViewer.view.annotations.shapes, 'Arrow'], 0);
Ext.cmd.derive('photoViewer.view.annotations.shapes.Ellipse', photoViewer.view.annotations.shapes.Base, {shapeAttributes:['x', 'y', 'radiusX', 'radiusY', 'stroke', 'stroke-width', 'style'], initConfig:function(config) {
  if (!config) {
    return;
  }
  photoViewer.view.annotations.shapes.Base.prototype.initConfig.apply(this, arguments);
  config.type = 'ellipse';
  config.draggable = !this.readOnly;
  config.fill = 'none';
  config['stroke-dasharray'] = this.drawComponent.self.styleSettings[config['style']];
  var baseShape = Ext.create('photoViewer.draw.Sprite', config);
  this.add('base0', baseShape);
  this.show(true);
}, resize:function(newX, newY, newWidth, newHeight) {
  var ellipse = this.getAt(0), box = ellipse.getBBox();
  var attributes = {x:newX + newWidth / 2, y:newY + newHeight / 2};
  if (box.width != newWidth) {
    attributes.radiusX = newWidth / 2;
  }
  if (box.height != newHeight) {
    attributes.radiusY = newHeight / 2;
  }
  ellipse.setAttributes(attributes, true);
}, getRealLeft:function() {
  return this.getAt(0).getBBox().x;
}, getRealRight:function() {
  return this.getAt(0).getBBox().x + this.getBBox().width;
}, getRealTop:function() {
  return this.getAt(0).getBBox().y;
}, getRealBottom:function() {
  return this.getAt(0).getBBox().y + this.getAt(0).getBBox().height;
}, getDefaultConfig:function() {
  var xy = this.drawComponent.descaledXY, viewModel = this.getViewModel();
  return {x:xy[0], y:xy[1], radiusX:1, radiusY:1, stroke:viewModel.get('toolSettings.strokeColour'), 'stroke-width':viewModel.get('toolSettings.strokeWidth'), style:viewModel.get('toolSettings.strokeStyle')};
}}, 0, 0, 0, 0, 0, 0, [photoViewer.view.annotations.shapes, 'Ellipse'], 0);
Ext.cmd.derive('photoViewer.view.annotations.shapes.Measure', photoViewer.view.annotations.shapes.Line, {disableShapeSync:true, nBaseSprites:1, dataAttributes:['length', 'oScale', 'iX', 'iY', 'stemPosition'], stemLength:15, arrowWidth:1, constructor:function(config) {
  this.shapeAttributes = ['x0', 'y0', 'x1', 'y1', 'stroke', 'stroke-width', 'style', 'length', 'iX', 'iY', 'oScale', 'stemPosition'];
  photoViewer.view.annotations.shapes.Line.prototype.constructor.apply(this, arguments);
}, getType:function() {
  return 'measure';
}, getDefaultConfig:function() {
  var xy = this.drawComponent.descaledXY;
  return {x0:xy[0], x1:xy[0], y0:xy[1], y1:xy[1], stroke:'#FF6600', 'stroke-width':4, style:'normal'};
}, initConfig:function(config) {
  if (!config) {
    return;
  }
  var lineConfig = this.initLineConfig(config), baseShape = Ext.create('photoViewer.view.annotations.sprites.Line', lineConfig), draggable = !this.readOnly;
  this.add('base0', baseShape);
  this.show(true);
  baseShape.addCls('measure');
  var infoAttr = {shape:this, draggable:draggable, renderTo:this.drawComponent.el, contrainTo:this.drawComponent.el, constrain:true, hidden:true};
  this.stemPosition = this.record ? this.getRecordValueByAttrName('stemPosition') : '';
  var iX = this.record ? this.getRecordValueByAttrName('iX') : undefined;
  if (iX === '' || iX === undefined) {
    infoAttr.alignTarget = baseShape.el;
    infoAttr.defaultAlign = 'tc-bc?';
  }
  this.measurementLabel = Ext.create('photoViewer.view.annotations.sprites.Info', infoAttr);
  if (draggable) {
    var dragEl = this.measurementLabel.getDragEl();
    dragEl.addListener('drag', this.onLabelDrag, this);
    dragEl.addListener('dragend', this.onLabelDragEnd, this);
  }
  this.refreshMeasurementLabel(true);
}, initLineConfig:function(config) {
  var scale = this.getScaleFromUnalteredPhoto(), isUnsavedMeasurement = !!(!this.record || !this.record.store || this.record.store.getProxy().type == 'memory'), lineConfig = {x0:(config.x0 - 0) * scale, y0:(config.y0 - 0) * scale, x1:(config.x1 - 0) * scale, y1:(config.y1 - 0) * scale, draggable:isUnsavedMeasurement, stroke:config.stroke, 'stroke-width':config['stroke-width'], 'stroke-dasharray':this.drawComponent.self.styleSettings[config['style']]};
  return lineConfig;
}, getScaleFromUnalteredPhoto:function() {
  var inDrawMode = this.drawComponent.lookupViewModel().get('drawMode') === photoViewer.Values.DRAW_MEASURING;
  return inDrawMode ? 1 : this.getRecordValueByAttrName('oScale');
}, onZoomChange:function() {
  this.refreshMeasurementLabel();
}, destroy:function() {
  this.measurementLabel.destroy();
  photoViewer.view.annotations.shapes.Line.prototype.destroy.apply(this, arguments);
}, refreshMeasurementLabel:function(forceShow, noRepositionInfoBox) {
  if (this.measurementLabel && (forceShow || this.measurementLabel.isVisible()) && this.record && this.record.get('Length')) {
    this.measurementLabel.setData(this.record.getData());
    if (this.measurementLabel.alignTarget) {
      this.measurementLabel.showBy(this.getBaseShape().el);
    } else {
      this.measurementLabel.el.dom.style.visibility = 'hidden';
      if (!this.measurementLabel.isVisible()) {
        this.measurementLabel.show();
      }
      var scale = this.drawComponent.getScale(), scaleFromUnalteredPhoto = this.getScaleFromUnalteredPhoto(), dcBox = this.drawComponent.getBox(), centerX = this.getRecordValueByAttrName('iX') * scale * scaleFromUnalteredPhoto + dcBox.left, centerY = this.getRecordValueByAttrName('iY') * scale * scaleFromUnalteredPhoto + dcBox.top, x = centerX - this.measurementLabel.el.getWidth() / 2, y = centerY - this.measurementLabel.el.getHeight() / 2, strokeWidth = this.getScaledArrowWidth();
      if (!noRepositionInfoBox) {
        this.measurementLabel.setXY([x, y]);
      }
      var labelDimensions = this.getLabelDimensions();
      if (this.stem && this.arrow && labelDimensions.stem) {
        this.stem.setAttributes(this.getUpdatedStemConfig(), true);
        this.arrow.setAttributes(this.getUpdatedArrowConfig(), true);
      } else {
        if (!this.stem && labelDimensions.stem) {
          this.addArrow();
        }
      }
      this.measurementLabel.el.dom.style.visibility = '';
    }
  }
}, getUpdatedStemConfig:function() {
  var labelDimensions = this.getLabelDimensions();
  return {x0:labelDimensions.stem.x, y0:labelDimensions.stem.y, x1:labelDimensions.stem.x1, y1:labelDimensions.stem.y1, 'stroke-width':this.getScaledArrowWidth() * 2};
}, getFullStemConfig:function() {
  var config = this.getUpdatedStemConfig();
  config.draggable = !this.readOnly;
  config.stroke = 'red';
  return config;
}, getUpdatedArrowConfig:function() {
  var labelDimensions = this.getLabelDimensions();
  return {x0:labelDimensions.stem.x1, y0:labelDimensions.stem.y1, 'stroke-width':this.getScaledArrowWidth() * 2};
}, getFullArrowConfig:function() {
  var config = this.getUpdatedArrowConfig(), scaleFromUnalteredPhoto = this.getScaleFromUnalteredPhoto(), measureX0 = Math.round(scaleFromUnalteredPhoto * this.record.get('Attr' + this.shapeAttributes.indexOf('x0'))), measureY0 = Math.round(scaleFromUnalteredPhoto * this.record.get('Attr' + this.shapeAttributes.indexOf('y0'))), measureX1 = Math.round(scaleFromUnalteredPhoto * this.record.get('Attr' + this.shapeAttributes.indexOf('x1'))), measureY1 = Math.round(scaleFromUnalteredPhoto * this.record.get('Attr' + 
  this.shapeAttributes.indexOf('y1')));
  config.draggable = !this.readOnly;
  config.x1 = (measureX0 + measureX1) / 2;
  config.y1 = (measureY0 + measureY1) / 2;
  config.stroke = 'red';
  config.fill = 'red';
  return config;
}, hide:function() {
  photoViewer.view.annotations.shapes.Line.prototype.hide.apply(this, arguments);
  this.measurementLabel.hide();
}, show:function() {
  photoViewer.view.annotations.shapes.Line.prototype.show.apply(this, arguments);
  this.refreshMeasurementLabel(true);
}, changePointOnDragHandle:function() {
  photoViewer.view.annotations.shapes.Line.prototype.changePointOnDragHandle.apply(this, arguments);
  this.onLineMove();
}, translate:function() {
  photoViewer.view.annotations.shapes.Line.prototype.translate.apply(this, arguments);
  this.onLineMove();
}, onLineMove:function() {
  if (this.record) {
    this.record.setAttr('length', undefined);
    this.measurementLabel.hide();
  }
}, select:function() {
  photoViewer.view.annotations.shapes.Line.prototype.select.apply(this, arguments);
  this.measurementLabel.toFront();
}, onTitleChange:function() {
  this.refreshMeasurementLabel(true);
}, onIsMetricChange:function() {
  this.refreshMeasurementLabel(true);
}, onLabelDrag:function() {
  if (this.measurementLabel.alignTarget) {
    this.measurementLabel.alignTarget = null;
    this.measurementLabel.defaultAlign = null;
  }
  var labelDimensions = this.getLabelDimensions(true);
  if (this.arrow) {
    if (!labelDimensions.stem) {
      this.arrow.destroy();
      this.stem.destroy();
      this.arrow = null;
      this.stem = null;
      this.stemPosition = '';
      this.fireEvent('datachanged');
    } else {
      this.fixArrowIntersection();
    }
  }
  this.refreshMeasurementLabel(true, true);
}, onLabelDragEnd:function() {
  var labelDimensions = this.getLabelDimensions(), vm = this.drawComponent.lookupViewModel();
  this.record.setAttrs({'iX':labelDimensions.midX, 'iY':labelDimensions.midY, 'stemPosition':this.stemPosition, 'oScale':(vm.get('activePhoto.OriginalsWidth') / vm.get('unalteredWidth')).toFixed(3)});
}, getLabelDimensions:function(setStemPosition) {
  var scale = this.drawComponent.getScale(), dcBox = this.drawComponent.el.getBox(), labelDimensions = {x:(this.measurementLabel.el.getX() - dcBox.left) / scale, y:(this.measurementLabel.el.getY() - dcBox.top) / scale, width:this.measurementLabel.el.getWidth() / scale, height:this.measurementLabel.el.getHeight() / scale}, stemLength = this.getScaledStemLength();
  labelDimensions.right = labelDimensions.x + labelDimensions.width;
  labelDimensions.bottom = labelDimensions.y + labelDimensions.height;
  labelDimensions.midX = Math.round(labelDimensions.x + labelDimensions.width / 2);
  labelDimensions.midY = Math.round(labelDimensions.y + labelDimensions.height / 2);
  labelDimensions.mid0 = {x:labelDimensions.midX, y:labelDimensions.y, x1:labelDimensions.midX, y1:labelDimensions.y - stemLength};
  labelDimensions.mid1 = {x:labelDimensions.right, y:labelDimensions.midY, x1:labelDimensions.right + stemLength, y1:labelDimensions.midY};
  labelDimensions.mid2 = {x:labelDimensions.midX, y:labelDimensions.bottom, x1:labelDimensions.midX, y1:labelDimensions.bottom + stemLength};
  labelDimensions.mid3 = {x:labelDimensions.x, y:labelDimensions.midY, x1:labelDimensions.x - stemLength, y1:labelDimensions.midY};
  var measureX0 = Math.round(this.record.get('Attr' + this.shapeAttributes.indexOf('x0'))), measureY0 = Math.round(this.record.get('Attr' + this.shapeAttributes.indexOf('y0'))), measureX1 = Math.round(this.record.get('Attr' + this.shapeAttributes.indexOf('x1'))), measureY1 = Math.round(this.record.get('Attr' + this.shapeAttributes.indexOf('y1')));
  if (setStemPosition || this.stemPosition === undefined) {
    var newStemPosition = '';
    if (labelDimensions.y > Math.max(measureY0, measureY1)) {
      newStemPosition = 0;
    } else {
      if (labelDimensions.bottom < Math.min(measureY0, measureY1)) {
        newStemPosition = 2;
      } else {
        if (labelDimensions.x > Math.max(measureX0, measureX1)) {
          newStemPosition = 1;
        } else {
          if (labelDimensions.right < Math.min(measureX0, measureX1)) {
            newStemPosition = 3;
          }
        }
      }
    }
    if (this.stemPosition === undefined || this.stemPosition === '' && newStemPosition !== '' || this.stemPosition !== '' && newStemPosition === '') {
      this.stemPosition = newStemPosition;
    }
  }
  if (Math.segmentsIntersect([labelDimensions.mid0.x, labelDimensions.mid0.y], [labelDimensions.mid0.x1, labelDimensions.mid0.y1], [measureX0, measureY0], [measureX1, measureY1]) || Math.segmentsIntersect([labelDimensions.mid1.x, labelDimensions.mid0.y], [labelDimensions.mid1.x1, labelDimensions.mid1.y1], [measureX0, measureY0], [measureX1, measureY1]) || Math.segmentsIntersect([labelDimensions.mid2.x, labelDimensions.mid0.y], [labelDimensions.mid2.x1, labelDimensions.mid2.y1], [measureX0, measureY0], 
  [measureX1, measureY1]) || Math.segmentsIntersect([labelDimensions.mid3.x, labelDimensions.mid0.y], [labelDimensions.mid3.x1, labelDimensions.mid3.y1], [measureX0, measureY0], [measureX1, measureY1])) {
    this.stemPosition = '';
  }
  if (this.stemPosition !== '') {
    labelDimensions.stem = labelDimensions['mid' + this.stemPosition];
  }
  return labelDimensions;
}, addArrow:function() {
  this.stem = Ext.create('photoViewer.view.annotations.sprites.Line', this.getFullStemConfig());
  this.arrow = Ext.create('photoViewer.view.annotations.sprites.Arrow', this.getFullArrowConfig());
  this.add('arrow', this.arrow);
  this.add('stem', this.stem);
}, fixArrowIntersection:function(silent) {
  var arrow = this.arrow, stem = this.stem, textBounds = this.getLabelDimensions();
  var width = textBounds.width, height = textBounds.height, x = textBounds.x, y = textBounds.y, strokeWidth = arrow.attr['stroke-width'];
  var intersectsTop = this.arrowIntersectsSide(0), intersectsRight = this.arrowIntersectsSide(1), intersectsBottom = this.arrowIntersectsSide(2), intersectsLeft = this.arrowIntersectsSide(3);
  if (intersectsLeft && intersectsTop) {
    if (arrow.x1 <= x) {
      this.moveStemToSide(3, x, y, width, height, strokeWidth, true);
    } else {
      this.moveStemToSide(0, x, y, width, height, strokeWidth, true);
    }
  } else {
    if (intersectsRight && intersectsTop) {
      if (arrow.x1 >= x + width) {
        this.moveStemToSide(1, x, y, width, height, strokeWidth, true);
      } else {
        this.moveStemToSide(0, x, y, width, height, strokeWidth, true);
      }
    } else {
      if (intersectsLeft && intersectsBottom) {
        if (arrow.x1 <= x) {
          this.moveStemToSide(3, x, y, width, height, strokeWidth, true);
        } else {
          this.moveStemToSide(2, x, y, width, height, strokeWidth, true);
        }
      } else {
        if (intersectsRight && intersectsBottom) {
          if (arrow.x1 >= x + width) {
            this.moveStemToSide(1, x, y, width, height, strokeWidth, true);
          } else {
            this.moveStemToSide(2, x, y, width, height, strokeWidth, true);
          }
        } else {
          if (intersectsTop && intersectsBottom) {
            if (arrow.y1 <= y) {
              this.moveStemToSide(0, x, y, width, height, strokeWidth, true);
            } else {
              this.moveStemToSide(2, x, y, width, height, strokeWidth, true);
            }
          } else {
            if (intersectsRight && intersectsLeft) {
              if (arrow.x1 <= x) {
                this.moveStemToSide(3, x, y, width, height, strokeWidth, true);
              } else {
                this.moveStemToSide(1, x, y, width, height, strokeWidth, true);
              }
            }
          }
        }
      }
    }
  }
  arrow.setAttributes({x0:stem.x1, y0:stem.y1, x1:arrow.x1, y1:arrow.y1}, true);
}, arrowIntersectsSide:function(position) {
  var arrow = this.arrow, textBounds = this.getLabelDimensions(), width = textBounds.width, height = textBounds.height, x = textBounds.x, y = textBounds.y, strokeWidth = arrow.attr['stroke-width'];
  var sideXY0 = [x, y], sideXY1 = [x + width, y];
  if (position === 1) {
    sideXY0 = [x + width, y + height];
  }
  if (position === 2) {
    sideXY0 = [x, y + height];
    sideXY1 = [x + width, y + height];
  }
  if (position === 3) {
    sideXY1 = [x, y + height];
  }
  return Math.segmentsIntersect(sideXY0, sideXY1, [arrow.x0, arrow.y0], [arrow.x1, arrow.y1]);
}, moveStemToSide:function(position, x, y, width, height, strokeWidth, moveXY1) {
  this.stemPosition = position;
  var coordinates = this.getStemSideCoordinates(position, x, y, width, height, strokeWidth);
  var attr = {x0:coordinates.x0, y0:coordinates.y0};
  if (moveXY1) {
    attr.x1 = coordinates.x1;
    attr.y1 = coordinates.y1;
  }
  this.stem.setAttributes(attr, true);
}, getScaledStemLength:function() {
  return this.stemLength / this.drawComponent.getScale();
}, getScaledArrowWidth:function() {
  return this.arrowWidth / this.drawComponent.getScale();
}, getStemSideCoordinates:function(position, x, y, width, height, strokeWidth) {
  var offsetStemX = x + width / 2 - strokeWidth / 2;
  var offsetStemY = y + height / 2 + strokeWidth / 2;
  var stemLength = this.getScaledStemLength();
  if (position === 0) {
    return {x0:offsetStemX, y0:y, x1:offsetStemX, y1:y - stemLength};
  }
  if (position === 1) {
    return {x0:x + width, y0:offsetStemY, x1:x + width + stemLength, y1:offsetStemY};
  }
  if (position === 2) {
    return {x0:offsetStemX, y0:y + height, x1:offsetStemX, y1:y + height + stemLength};
  }
  if (position === 3) {
    return {x0:x, y0:offsetStemY, x1:x - stemLength, y1:offsetStemY};
  }
}, getAttribute:function(attrName) {
  if (Ext.Array.contains(['x0', 'y0', 'x1', 'y1'], attrName)) {
    return photoViewer.view.annotations.shapes.Line.prototype.getAttribute.apply(this, arguments) / this.getScaleFromUnalteredPhoto();
  }
  return photoViewer.view.annotations.shapes.Line.prototype.getAttribute.apply(this, arguments);
}, isTooSmall:function() {
  return false;
}}, 1, 0, 0, 0, 0, 0, [photoViewer.view.annotations.shapes, 'Measure'], 0);
Ext.cmd.derive('photoViewer.view.annotations.shapes.Pen', photoViewer.view.annotations.shapes.Base, {shapeAttributes:['translationX', 'translationY', 'unscaledWidth', 'unscaledHeight', 'stroke', 'coordsString', 'stroke-width', 'style', 'scalingX', 'scalingY'], self:{pointAttrIndices:[0], typeLengths:{a:7, c:6, h:1, l:2, m:2, q:4, s:4, t:2, v:1, z:0, A:7, C:6, H:1, L:2, M:2, Q:4, S:4, T:2, V:1, Z:0}, MAX_ANGLE:Math.PI * 0.7, MAX_ERROR:2, MAX_N_ITERATION:4, BOX_SIZE:50, INCREASE_K:0.2, LINE_D:40, N:50, 
MAX_COORDS_LENGTH:1024}, initPenConfig:function(config) {
  for (var i = 0; i < this.shapeAttributes.length; i++) {
    var property = this.shapeAttributes[i];
    if (typeof config[property] === 'undefined') {
      throw "Property '" + property + "' required";
    }
  }
  this.coordsString = config.coordsString;
  this.scalingX = config.scalingX;
  this.scalingY = config.scalingY;
  this.translationX = config.translationX;
  this.translationY = config.translationY;
  var path = '';
  if (config.isUndrawn) {
    var dc = this.getDrawComponent(), dcEl = dc.el, dcWidth = dcEl.getWidth(), dcHeight = dcEl.getHeight(), dcX = dcEl.getX(), dcY = dcEl.getY(), dcRight = dcX + dcWidth, dcBottom = dcY + dcHeight, container = this.drawComponent.up('photoviewer').lookupController().lookupReference('photoContainer'), containerWidth = container.el.getWidth(), containerHeight = container.el.getHeight();
    this.drawingFieldWidth = dcWidth;
    this.drawingFieldHeight = dcHeight;
    this.xOffset = dcX;
    this.yOffset = dcY;
    if (dcX < container.el.getLeft()) {
      this.drawingFieldWidth += dcX;
    }
    if (dcY < container.el.getTop()) {
      this.drawingFieldHeight += dcY;
    }
    if (dcRight > containerWidth) {
      this.drawingFieldWidth -= dcRight - containerWidth;
    }
    if (dcBottom > containerHeight) {
      this.drawingFieldHeight -= dcBottom - containerHeight;
    }
    var ti = [];
    var TRASHOLD_K = 0, TRASHOLD_V = Math.floor(this.self.N * TRASHOLD_K);
    for (var i = 0, maxI = this.self.N; i < maxI; i++) {
      ti.push((i + 1 + TRASHOLD_V) / (this.self.N + 2 * TRASHOLD_V));
    }
    this.ti = ti;
    this.seg = new MVMath.CurveSegment;
    this.iterations = 0;
    this.rasterBorder = {minx:0, miny:0, maxx:0, maxy:0};
    this.breakFlag = false;
    this.curve = {curveSeg:[new MVMath.CurveSegment]};
    this.vectorDistMap = null;
    this.initCurveSegment(dc.pageXY[0] - this.xOffset, dc.pageXY[1] - this.yOffset, this.curve.curveSeg[0]);
    this.clearVectorDistMap(this.drawingFieldWidth, this.drawingFieldHeight);
    this.scale = dc.getScale();
    this.done = false;
    this.pathObj = Ext.create('photoViewer.draw.Path');
  } else {
    this.unscaledWidth = config.unscaledWidth;
    this.unscaledHeight = config.unscaledHeight;
    this.setupAbsCoords(config.coordsString);
    path = this.getTransformedPath();
  }
  var penConfig = {type:'path', path:path, draggable:!this.readOnly, stroke:config.stroke, 'stroke-width':config['stroke-width'], 'stroke-dasharray':this.drawComponent.self.styleSettings[config['style']]};
  return penConfig;
}, getTransformedPath:function() {
  var scx = this.minX + this.unscaledWidth / 2, scy = this.minY + this.unscaledHeight / 2, dx = scx + -scx * this.scalingX + this.translationX, dy = scy + -scy * this.scalingY + this.translationY, path = 'M ' + dx + ',' + dy, coords = Ext.Array.clone(this.absCoords);
  for (var i = 0; i < coords.length; i += 2) {
    coords[i] = coords[i] * this.scalingX + dx;
    coords[i + 1] = coords[i + 1] * this.scalingY + dy;
  }
  for (var i = 0; i < coords.length; i += 6) {
    path += 'C' + +coords[i] + ' ' + +coords[i + 1] + ' ' + +coords[i + 2] + ' ' + coords[i + 3] + ' ' + coords[i + 4] + ' ' + coords[i + 5];
  }
  return path;
}, setupAbsCoords:function(coordsString) {
  var cursor = [0, 0], coords = coordsString.split(','), minX = Number(coords[0]), minY = Number(coords[1]), maxX = minX, maxY = minY;
  for (var i = 0; i < coords.length; i += 6) {
    var nextCursor = [cursor[0] + Number(coords[i + 4]), cursor[1] + Number(coords[i + 5])];
    coords[i] = cursor[0] + Number(coords[i]);
    coords[i + 1] = cursor[1] + Number(coords[i + 1]);
    coords[i + 2] = cursor[0] + Number(coords[i + 2]);
    coords[i + 3] = cursor[1] + Number(coords[i + 3]);
    coords[i + 4] = cursor[0] + Number(coords[i + 4]);
    coords[i + 5] = cursor[1] + Number(coords[i + 5]);
    cursor = nextCursor;
  }
  this.absCoords = Ext.Array.clone(coords);
  for (var i = 0; i < coords.length; i++) {
    if (i % 2 === 0 && coords[i] < minX) {
      minX = coords[i];
    }
    if (i % 2 === 1 && coords[i] < minY) {
      minY = coords[i];
    }
    if (i % 2 === 0 && coords[i] > maxX) {
      maxX = coords[i];
    }
    if (i % 2 === 1 && coords[i] > maxY) {
      maxY = coords[i];
    }
  }
  this.minX = minX;
  this.minY = minY;
}, transformPoint:function(center, scale, translation) {
  return center + -center * scale + translation;
}, initConfig:function(config) {
  if (!config) {
    return;
  }
  var penConfig = this.initPenConfig(config);
  var baseShape = Ext.create('photoViewer.draw.Sprite', penConfig);
  this.add('base0', baseShape);
  this.show(true);
}, getType:function() {
  return 'pen';
}, getAttribute:function(shapeAttributeName) {
  var baseShape = this.getAt(0), attribute = '';
  if (shapeAttributeName == 'coordsString') {
    attribute = this.getCoordsString();
  } else {
    if (this[shapeAttributeName] !== undefined) {
      attribute = this[shapeAttributeName];
    } else {
      attribute = baseShape.attr[shapeAttributeName];
    }
  }
  if (shapeAttributeName == 'unscaledWidth' || shapeAttributeName == 'unscaledHeight' || shapeAttributeName == 'x' || shapeAttributeName == 'y' || shapeAttributeName == 'translationX' || shapeAttributeName == 'translationY') {
    attribute = Math.round(attribute);
  } else {
    if (shapeAttributeName == 'style') {
      for (var key in this.drawComponent.self.styleSettings) {
        if (baseShape.attr['stroke-dasharray'] == this.drawComponent.self.styleSettings[key]) {
          return key;
        }
      }
    }
  }
  return attribute;
}, getCoordsString:function() {
  var coords = this.pathObj ? this.pathObj.coords : null;
  return this.coordsString ? this.coordsString : Ext.Array.slice(coords, 2, coords.length - (coords.length - 2) % 6).join(',');
}, changePointOnDragHandle:function(spriteDD, sprite, event) {
  var xy = this.drawComponent.getController().getRelativeDescaledXYFromMouseEvent(event);
  this.movePointHandle(sprite.pointNumber, xy[0], xy[1]);
  this.refreshSelectionSprites(Math.abs(sprite.pointNumber - 1));
}, movePointHandle:function(pointNumber, x, y) {
  var maxX = this.getViewModel().get('naturalWidth');
  var maxY = this.getViewModel().get('naturalHeight');
  if (x < 0) {
    x = 0;
  } else {
    if (x > maxX) {
      x = maxX;
    }
  }
  if (y < 0) {
    y = 0;
  } else {
    if (y > maxY) {
      y = maxY;
    }
  }
  var x0 = this.getAttribute('x0');
  var y0 = this.getAttribute('y0');
  var x1 = this.getAttribute('x1');
  var y1 = this.getAttribute('y1');
  if (pointNumber === 0) {
    x0 = x;
    y0 = y;
  } else {
    x1 = x;
    y1 = y;
  }
  this.getAt(0).setAttributes({x0:x0, y0:y0, x1:x1, y1:y1}, true);
  this.fireEvent('datachanged');
}, isTooSmall:function() {
  return this.getWidth() > 5 ? false : true;
}, setColour:function(colour) {
  this.getAt(0).setAttributes({stroke:colour}, true);
  this.fireEvent('datachanged');
}, getDefaultConfig:function() {
  var viewModel = this.getViewModel();
  return {translationX:0, translationY:0, unscaledWidth:0, unscaledHeight:0, stroke:viewModel.get('toolSettings.strokeColour'), coordsString:'', 'stroke-width':viewModel.get('toolSettings.strokeWidth'), style:viewModel.get('toolSettings.strokeStyle'), scalingX:1, scalingY:1, isUndrawn:true};
}, translate:function(dx, dy) {
  this.translationX += dx;
  this.translationY += dy;
  this.getBaseShape().setAttributes({path:this.getTransformedPath()}, true);
}, resize:function(newX, newY, newWidth, newHeight, shiftPositionLeft, shiftPositionUp) {
  var pen = this.getBaseShape();
  this.scalingX = newWidth / this.unscaledWidth;
  this.scalingY = newHeight / this.unscaledHeight;
  pen.setAttributes({path:this.getTransformedPath()}, false);
  var newBox = pen.getBBox();
  this.translationX += newX - newBox.x;
  this.translationY += newY - newBox.y;
  pen.setAttributes({path:this.getTransformedPath()}, true);
}, drawPath:function(deltaX, deltaY, e) {
  if (this.done) {
    return;
  }
  var dc = this.getDrawComponent(), x = e.browserEvent.pageX - this.xOffset, y = e.browserEvent.pageY - this.yOffset, curve = this.curve, currentSeg = curve.curveSeg[curve.curveSeg.length - 1], prev = new MVMath.Point(currentSeg.C3), updateResult, nextSeg;
  updateResult = this.updateCurveSegment(x, y, currentSeg);
  if (updateResult !== 'SUCCESS') {
    nextSeg = new MVMath.CurveSegment;
    this.initCurveSegment(prev.x, prev.y, nextSeg, x, y);
    this.clearRaster(this.rasterBorder, this.vectorDistMap);
    if (updateResult === 'FAILURE') {
      nextSeg.constrainted = true;
      nextSeg.tan = new MVMath.Point(currentSeg.C3.x - currentSeg.C2.x, currentSeg.C3.y - currentSeg.C2.y);
      nextSeg.tan.normalize();
      nextSeg.C2.x = nextSeg.C0.x - nextSeg.tan.x;
      nextSeg.C2.y = nextSeg.C0.y - nextSeg.tan.y;
    } else {
      if (updateResult !== 'CORNER') {
        nextSeg.constrained = false;
      }
    }
    this.updateCurveSegment(x, y, nextSeg);
    this.curve.curveSeg.push(nextSeg);
  }
}, updateCurveSegment:function(x, y, seg) {
  var vectorDistMap = this.vectorDistMap, ti = this.ti, prev = new MVMath.Point(seg.C3), error = 0, nIteration = 0, f1, f2, p = new MVMath.Point, dp = new MVMath.Point, d, projection = 0, v = new MVMath.Point((seg.C3.x - seg.C0.x) / 3, (seg.C3.y - seg.C0.y) / 3);
  if (this.testCorner(x, y, seg)) {
    return 'CORNER';
  }
  this.saveControlVertices(seg);
  seg.C3 = new MVMath.Point(x, y);
  seg.C2 = new MVMath.Point(seg.C2.x + (x - prev.x), seg.C2.y + (y - prev.y));
  if (v.getLength() < this.self.LINE_D) {
    seg.C2.x = seg.C3.x - v.x;
    seg.C2.y = seg.C3.y - v.y;
    if (seg.constrainted === true) {
      projection = seg.tan.getScalarMult(v);
      v = new MVMath.Point(projection * seg.tan.x, projection * seg.tan.y);
    }
    seg.C1.x = seg.C0.x + (v.x ? v.x : 0);
    seg.C1.y = seg.C0.y + (v.y ? v.y : 0);
  }
  this.renderLineCell(prev.x, prev.y, x, y, this.self.BOX_SIZE, vectorDistMap);
  this.renderPointCell(prev.x, prev.y, this.self.BOX_SIZE, vectorDistMap);
  do {
    f1 = new MVMath.Point;
    f2 = new MVMath.Point;
    error = 0;
    for (var i = 0, max_i = this.self.N; i < max_i; i += 1) {
      p = this.calc(seg, ti[i]);
      dp = this.interpVectorDist(vectorDistMap, p.x, p.y);
      d = dp.getLength();
      if (d > error) {
        error = d;
      }
      error += d;
      f1.x += 6 * ti[i] * (1 - ti[i]) * (1 - ti[i]) * d * dp.x / this.self.N;
      f1.y += 6 * ti[i] * (1 - ti[i]) * (1 - ti[i]) * d * dp.y / this.self.N;
      f2.x += 6 * ti[i] * ti[i] * (1 - ti[i]) * d * dp.x / this.self.N;
      f2.y += 6 * ti[i] * ti[i] * (1 - ti[i]) * d * dp.y / this.self.N;
    }
    error /= this.self.N;
    if (seg.constrainted === true) {
      projection = seg.tan.getScalarMult(f1);
      f1 = new MVMath.Point(projection * seg.tan.x, projection * seg.tan.y);
    }
    seg.C1.x = seg.C1.x - this.self.INCREASE_K * (f1.x ? f1.x : 0);
    seg.C1.y = seg.C1.y - this.self.INCREASE_K * (f1.y ? f1.y : 0);
    seg.C2.x = seg.C2.x - this.self.INCREASE_K * f2.x;
    seg.C2.y = seg.C2.y - this.self.INCREASE_K * f2.y;
    nIteration++;
  } while (nIteration < this.self.MAX_N_ITERATION);
  if (error < this.self.MAX_ERROR) {
    this.drawCurve(seg);
    this.breakFlag = false;
    return 'SUCCESS';
  } else {
    this.resetControlVertices(seg);
    return 'FAILURE';
  }
}, testCorner:function(x, y, seg) {
  var angle = this.getVectorAngle(new MVMath.Point(seg.C2.x - seg.C3.x, seg.C2.y - seg.C3.y), new MVMath.Point(x - seg.C3.x, y - seg.C3.y));
  if (angle < this.self.MAX_ANGLE) {
    return true;
  } else {
    return false;
  }
}, getVectorAngle:function(v1, v2) {
  var scalarMult = v1.getScalarMult(v2), d1 = v1.getLength(), d2 = v2.getLength();
  return Math.acos(scalarMult / (d1 * d2));
}, adjustdxDYToStayInBounds:Ext.emptyFn, getCanResizeFlip:function() {
  return false;
}, saveControlVertices:function(seg) {
  if (typeof seg.save === 'undefined') {
    seg.save = {};
  }
  seg.save.C1 = seg.C1;
  seg.save.C2 = seg.C2;
  seg.save.C3 = seg.C3;
}, initCurveSegment:function(x, y, seg, nextX, nextY) {
  seg.C0 = MVMath.Point(x, y);
  seg.C1 = MVMath.Point(x, y);
  seg.C2 = MVMath.Point(x, y);
  seg.C3 = MVMath.Point(x, y);
}, clearVectorDistMap:function(w, h) {
  this.vectorDistMap = [];
  this.rasterBorder.minx = Math.floor(w);
  this.rasterBorder.maxx = 0;
  this.rasterBorder.miny = Math.floor(h);
  this.rasterBorder.maxy = 0;
}, renderLineCell:function(xPrev, yPrev, x, y, fieldRadius, vectorDistMap) {
  var edges = [], n = new MVMath.Point(y - yPrev, -(x - xPrev)), nF = new MVMath.Point, points, oV = new MVMath.Point, dV = new MVMath.Point;
  n.normalize();
  nF = new MVMath.Point(n.x * fieldRadius, n.y * fieldRadius);
  edges.push(new MVMath.Edge(new MVMath.Point(x + nF.x, y + nF.y), new MVMath.Point(xPrev + nF.x, yPrev + nF.y)));
  edges.push(new MVMath.Edge(new MVMath.Point(xPrev + nF.x, yPrev + nF.y), new MVMath.Point(xPrev - nF.x, yPrev - nF.y)));
  edges.push(new MVMath.Edge(new MVMath.Point(xPrev - nF.x, yPrev - nF.y), new MVMath.Point(x - nF.x, y - nF.y)));
  edges.push(new MVMath.Edge(new MVMath.Point(x - nF.x, y - nF.y), new MVMath.Point(x + nF.x, y + nF.y)));
  points = this.rasterize(edges);
  if (points.length > 0) {
    dV = this.getDistanceDeffVectorLine(points, x, y, xPrev, yPrev, n);
    oV = this.getDistanceVectorLine(n, points[0], xPrev, yPrev);
    this.processPoints(points, dV, oV, vectorDistMap, n, xPrev, yPrev);
  }
}, renderPointCell:function(xPrev, yPrev, fieldRadius, vectorDistMap) {
  var edges = [], points, oV = new MVMath.Point, dV = new MVMath.Point, vectorDistMap = this.vectorDistMap;
  edges.push(new MVMath.Edge(new MVMath.Point(xPrev - fieldRadius, yPrev + fieldRadius), new MVMath.Point(xPrev + fieldRadius, yPrev + fieldRadius)));
  edges.push(new MVMath.Edge(new MVMath.Point(xPrev + fieldRadius, yPrev + fieldRadius), new MVMath.Point(xPrev + fieldRadius, yPrev - fieldRadius)));
  edges.push(new MVMath.Edge(new MVMath.Point(xPrev + fieldRadius, yPrev - fieldRadius), new MVMath.Point(xPrev - fieldRadius, yPrev - fieldRadius)));
  edges.push(new MVMath.Edge(new MVMath.Point(xPrev - fieldRadius, yPrev - fieldRadius), new MVMath.Point(xPrev - fieldRadius, yPrev + fieldRadius)));
  points = this.rasterize(edges);
  if (points.length > 0) {
    dV = this.getDistanceDeffVectorPoint(points, xPrev, yPrev);
    oV = this.getDistanceVectorPoint(xPrev, yPrev, points[0]);
    this.processPoints(points, dV, oV, vectorDistMap, null, xPrev, yPrev);
  }
}, rasterize:function(edges) {
  var points = [], drawingFieldWidth = this.drawingFieldWidth, drawingFieldHeight = this.drawingFieldHeight, rasterBorder = this.rasterBorder, ymax = 0, ymin = drawingFieldHeight, temp, j, max_j, ET = [], index, edge, SLB = [], activeFlag = false, pixelIterator = 0, SLBIterator = 0;
  for (var i = 0; i < edges.length; i++) {
    edge = edges[i];
    if (edge.p1.y > edge.p2.y) {
      temp = edge.p2;
      edge.p2 = edge.p1;
      edge.p1 = temp;
    }
    if (edge.p1.y < ymin) {
      ymin = edge.p1.y;
    }
    if (edge.p2.y > ymax) {
      ymax = edge.p2.y;
    }
    edge.startY = drawingFieldHeight - Math.floor(drawingFieldHeight - edge.p1.y);
    edge.k = (edge.p2.x - edge.p1.x) / (edge.p2.y - edge.p1.y);
    edge.startX = edge.p1.x + (edge.startY - edge.p1.y) * edge.k;
    edge.stopY = Math.floor(edge.p2.y);
  }
  for (i = edges.length - 1; i >= 0; i -= 1) {
    if (edges[i].p1.y === edges[i].p2.y) {
      edges.splice(i, 1);
    }
  }
  ymax = Math.floor(ymax);
  ymin = drawingFieldHeight - Math.floor(drawingFieldHeight - ymin);
  ET = new Array(Math.max(ymax - ymin + 1, 0));
  for (var i = 0; i < edges.length; i++) {
    index = edges[i].startY - ymin;
    if (typeof ET[index] === 'undefined') {
      ET[index] = [];
    }
    ET[index].push(edges[i]);
  }
  var sortFn = function(a, b) {
    if (a.startX - b.startX !== 0) {
      return a.startX - b.startX;
    } else {
      return a.p2.x - b.p2.x;
    }
  };
  for (i = ymin, max_i = ymax; i <= max_i; i += 1) {
    for (j = SLB.length - 1; j >= 0; j -= 1) {
      SLB[j].startX += SLB[j].k;
    }
    if (typeof ET[i - ymin] !== 'undefined' && ET[i - ymin].length > 0) {
      SLB = SLB.concat(ET[i - ymin]);
      SLB.sort(sortFn);
    }
    for (j = SLB.length - 1; j >= 0; j -= 1) {
      if (SLB[j].stopY === i) {
        SLB.splice(j, 1);
      }
    }
    if (SLB.length > 1) {
      pixelIterator = Math.round(SLB[0].startX);
      activeFlag = true;
      SLBIterator = 1;
      do {
        if (activeFlag) {
          points.push({x:pixelIterator, y:i});
          if (pixelIterator > rasterBorder.maxx) {
            rasterBorder.maxx = pixelIterator;
          }
          if (pixelIterator < rasterBorder.minx) {
            rasterBorder.minx = pixelIterator;
          }
          if (i > rasterBorder.maxy) {
            rasterBorder.maxy = i;
          }
          if (i < rasterBorder.miny) {
            rasterBorder.miny = i;
          }
        }
        pixelIterator++;
        if (activeFlag && pixelIterator > Math.round(SLB[SLBIterator].startX) || !activeFlag && pixelIterator >= Math.round(SLB[SLBIterator].startX)) {
          SLBIterator++;
          activeFlag = !activeFlag;
        }
      } while (SLBIterator < SLB.length);
    }
  }
  return points;
}, getPathObj:function() {
  return this.pathObj;
}, getDistanceDeffVectorPoint:function(points, xPrev, yPrev) {
  var distance, dy, dx;
  if (points.length > 1) {
    distance = this.getDistanceVectorPoint(xPrev, yPrev, points[0]);
    dy = this.getDistanceVectorPoint(xPrev, yPrev, new MVMath.Point(points[0].x, points[0].y + 1));
    dx = this.getDistanceVectorPoint(xPrev, yPrev, new MVMath.Point(points[0].x + 1, points[0].y));
    return {fx:new MVMath.Point(dx.x - distance.x, dy.x - distance.x), fy:new MVMath.Point(dx.y - distance.y, dy.y - distance.y)};
  } else {
    return {fx:new MVMath.Point, fy:new MVMath.Point};
  }
}, getDistanceVectorPoint:function(points, xPrev, yPrev) {
  var distance, dy, dx;
  if (points.length > 1) {
    distance = this.getDistanceVectorPoint(xPrev, yPrev, points[0]);
    dy = this.getDistanceVectorPoint(xPrev, yPrev, new MVMath.Point(points[0].x, points[0].y + 1));
    dx = this.getDistanceVectorPoint(xPrev, yPrev, new MVMath.Point(points[0].x + 1, points[0].y));
    return {fx:new MVMath.Point(dx.x - distance.x, dy.x - distance.x), fy:new MVMath.Point(dx.y - distance.y, dy.y - distance.y)};
  } else {
    return {fx:new MVMath.Point, fy:new MVMath.Point};
  }
}, processPoints:function(points, dV, oV, vectorDistMap, n, xPrev, yPrev) {
  var i, max_i, v = new MVMath.Point, v2, l;
  for (i = 0, max_i = points.length - 1; i < max_i; i += 1) {
    v = new MVMath.Point(oV.x + (points[i + 1].x - points[0].x) * dV.fx.x + (points[i + 1].y - points[0].y) * dV.fx.y, oV.y + (points[i + 1].x - points[0].x) * dV.fy.x + (points[i + 1].y - points[0].y) * dV.fy.y);
    if (!vectorDistMap[points[i + 1].y]) {
      vectorDistMap[points[i + 1].y] = [];
    }
    if (!vectorDistMap[points[i + 1].y][points[i + 1].x]) {
      vectorDistMap[points[i + 1].y][points[i + 1].x] = v;
    } else {
      if (vectorDistMap[points[i + 1].y][points[i + 1].x].getLength() > v.getLength()) {
        vectorDistMap[points[i + 1].y][points[i + 1].x] = v;
      }
    }
  }
}, getDistanceVectorPoint:function(xPrev, yPrev, p) {
  var d = new MVMath.Point(p.x - xPrev, p.y - yPrev);
  return d;
}, calc:function(seg, t) {
  var x, y;
  x = (seg.C0.x ? seg.C0.x : 0) * (1 - t) * (1 - t) * (1 - t) + 3 * (seg.C1.x ? seg.C1.x : 0) * t * (1 - t) * (1 - t) + 3 * (seg.C2.x ? seg.C2.x : 0) * t * t * (1 - t) + (seg.C3.x ? seg.C3.x : 0) * t * t * t;
  y = (seg.C0.y ? seg.C0.y : seg.C0.y) * (1 - t) * (1 - t) * (1 - t) + 3 * (seg.C1.y ? seg.C1.y : 0) * t * (1 - t) * (1 - t) + 3 * seg.C2.y * t * t * (1 - t) + seg.C3.y * t * t * t;
  return new MVMath.Point(x, y);
}, interpVectorDist:function(vectorDistMap, x, y) {
  var x1 = Math.floor(x), y1 = Math.floor(y), x2 = x1 + 1, y2 = y1 + 1, Q11 = vectorDistMap[y1] && vectorDistMap[y1][x1] ? vectorDistMap[y1][x1] : {x:0, y:0}, Q21 = vectorDistMap[y1] && vectorDistMap[y1][x2] ? vectorDistMap[y1][x2] : {x:0, y:0}, Q12 = vectorDistMap[y2] && vectorDistMap[y2][x1] ? vectorDistMap[y2][x1] : {x:0, y:0}, Q22 = vectorDistMap[y2] && vectorDistMap[y2][x2] ? vectorDistMap[y2][x2] : {x:0, y:0};
  return new MVMath.Point(Q11.x * (x2 - x) * (y2 - y) + Q21.x * (x - x1) * (y2 - y) + Q12.x * (x2 - x) * (y - y1) + Q22.x * (x - x1) * (y - y1), Q11.y * (x2 - x) * (y2 - y) + Q21.y * (x - x1) * (y2 - y) + Q12.y * (x2 - x) * (y - y1) + Q22.y * (x - x1) * (y - y1));
}, resetControlVertices:function(seg) {
  if (typeof seg.save !== 'undefined') {
    seg.C1 = seg.save.C1;
    seg.C2 = seg.save.C2;
    seg.C3 = seg.save.C3;
  }
}, clearRaster:function(rasterBorder, vectorDistMap) {
  this.vectorDistMap = [];
  rasterBorder.minx = this.drawingFieldWidth;
  rasterBorder.maxx = 0;
  rasterBorder.miny = this.drawingFieldHeight;
  rasterBorder.maxy = 0;
}, redraw:function() {
  this.setAttributes({path:this.getPathObj().toString()}, true);
}, drawCurve:function(seg, noClear, noRedraw) {
  var path = this.getPathObj(), roundedC0X = Math.round(seg.C0.x / this.scale), roundedC0Y = Math.round(seg.C0.y / this.scale), roundedC1X = Math.round(seg.C1.x / this.scale), roundedC1Y = Math.round(seg.C1.y / this.scale), roundedC2X = Math.round(seg.C2.x / this.scale), roundedC2Y = Math.round(seg.C2.y / this.scale), roundedC3X = Math.round(seg.C3.x / this.scale), roundedC3Y = Math.round(seg.C3.y / this.scale);
  if (noClear !== true) {
    this.doClear();
  }
  if (!path.cursor || path.cursor[0] != roundedC0X || path.cursor[1] != roundedC0Y) {
    path.relativeMoveTo(roundedC0X, roundedC0Y);
  }
  this.coordsLength += path.convertAbsToRelPathBezierCurveTo(roundedC1X, roundedC1Y, roundedC2X, roundedC2Y, roundedC3X, roundedC3Y) + 6;
  if (this.coordsLength >= this.self.MAX_COORDS_LENGTH) {
    this.done = true;
    path.types.pop();
    Ext.Array.erase(path.coords, path.coords.length - this.self.typeLengths.c, this.self.typeLengths.c);
    return;
  }
  if (!noRedraw) {
    this.redraw();
  }
}, getDistanceDeffVectorLine:function(points, x, y, xPrev, yPrev, n) {
  var distance, dy, dx, i;
  if (points.length > 1) {
    distance = this.getDistanceVectorLine(n, points[0], xPrev, yPrev);
    dy = this.getDistanceVectorLine(n, new MVMath.Point(points[0].x, points[0].y + 1), xPrev, yPrev);
    dx = this.getDistanceVectorLine(n, new MVMath.Point(points[0].x + 1, points[0].y), xPrev, yPrev);
    return {fx:new MVMath.Point(dx.x - distance.x, dy.x - distance.x), fy:new MVMath.Point(dx.y - distance.y, dy.y - distance.y)};
  } else {
    return {fx:new MVMath.Point, fy:new MVMath.Point};
  }
}, getDistanceVectorLine:function(n, p, xPrev, yPrev) {
  var distance, returnV;
  distance = n.getScalarMult(new MVMath.Point(p.x - xPrev, p.y - yPrev));
  returnV = new MVMath.Point(n.x * distance, n.y * distance);
  return returnV;
}, doClear:function() {
  var curveSeg = this.curve.curveSeg, path = this.getPathObj();
  path.clear();
  this.coordsLength = -1;
  for (var i = 0; i < curveSeg.length; i++) {
    this.drawCurve(curveSeg[i], true, true);
  }
  this.redraw();
}, getWidth:function() {
  return !this.getBaseShape().attr.path ? 0 : photoViewer.view.annotations.shapes.Base.prototype.getWidth.apply(this, arguments);
}, getHeight:function() {
  return !this.getBaseShape().attr.path ? 0 : photoViewer.view.annotations.shapes.Base.prototype.getHeight.apply(this, arguments);
}, onCreate:function() {
  this.doClear();
  delete this.breakFlag;
  delete this.coordsLength;
  delete this.currentSeg;
  delete this.curve;
  delete this.done;
  delete this.drawingFieldHeight;
  delete this.drawingFieldWidth;
  delete this.iterations;
  delete this.rasterBorder;
  delete this.scale;
  delete this.seg;
  delete this.ti;
  delete this.vectorDistMap;
  delete this.xOffset;
  delete this.yOffset;
  var path = this.pathObj, x = path.coords[0], y = path.coords[1];
  this.translationX = x;
  this.translationY = y;
  this.setupAbsCoords(this.getCoordsString());
  var box = this.getBaseShape().getBBox();
  this.unscaledWidth = box.width;
  this.unscaledHeight = box.height;
  this.fireEvent('datachanged');
}}, 0, 0, 0, 0, 0, 0, [photoViewer.view.annotations.shapes, 'Pen'], 0);
(function() {
  if (typeof MVMath == 'undefined') {
    Ext.namespace('MVMath');
  }
  MVMath.crossProduct2D = function(v, w) {
    return v[0] * w[1] - v[1] * w[0];
  };
  MVMath.roundToNDecimalPlaces = function(x, n) {
    return Number(x.toFixed(n));
  };
  MVMath.Point = function(x, y) {
    if (!(this instanceof MVMath.Point)) {
      return new MVMath.Point(x, y);
    }
    switch(true) {
      case x instanceof MVMath.Point && typeof y === 'undefined':
        this.x = x.x;
        this.y = x.y;
        break;
      case typeof x === 'number' && typeof y === 'number':
        this.x = x;
        this.y = y;
        break;
      default:
        this.x = 0;
        this.y = 0;
    }
  };
  MVMath.Point.prototype.getLength = function getLength() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  };
  MVMath.Point.prototype.getScalarMult = function getScalarMult(v2) {
    return this.x * v2.x + this.y * v2.y;
  };
  MVMath.Point.prototype.normalize = function normalize() {
    var vectorLength = this.getLength();
    this.x /= vectorLength;
    this.y /= vectorLength;
  };
  MVMath.Point.prototype.getRotatedPoint = function(origin, theta) {
    theta = theta * -1;
    return new MVMath.Point(Math.cos(theta) * (this.x - origin.x) - Math.sin(theta) * (this.y - origin.y) + origin.x, origin.y + Math.sin(theta) * (this.x - origin.x) + Math.cos(theta) * (this.y - origin.y));
  };
  MVMath.Edge = function(a, b, c, d) {
    if (!(this instanceof MVMath.Edge)) {
      return new MVMath.Edge(a, b, c, d);
    }
    if (arguments.length === 2) {
      this.p1 = a;
      this.p2 = b;
    }
    if (arguments.length === 4) {
      this.p1 = new MVMath.Point(a, b);
      this.p2 = new MVMath.Point(c, d);
    }
  };
  MVMath.Edge.prototype.getLength = function() {
    return Math.sqrt(Math.pow(this.p1.y - this.p2.y, 2) + Math.pow(this.p1.x - this.p2.x, 2));
  };
  MVMath.Edge.prototype.intersects = function(e2) {
    var r = [this.p2.x - this.p1.x, this.p2.y - this.p1.y], s = [e2.p2.x - e2.p1.x, e2.p2.y - e2.p1.y];
    var rXs = MVMath.crossProduct2D(r, s);
    if (rXs === 0) {
      if (MVMath.crossProduct2D([e2.p1.x - this.p1.x, e2.p1.y - [1]], r) === 0) {
        return true;
      }
      return false;
    }
    var t = MVMath.crossProduct2D([e2.p1.x - this.p1.x, e2.p1.y - this.p1.y], s) / rXs;
    var u = MVMath.crossProduct2D([e2.p1.x - this.p1.x, e2.p1.y - this.p1.y], r) / rXs;
    if (0 <= t && t <= 1 && 0 <= u && u <= 1) {
      return true;
    }
    return false;
  };
  MVMath.Edge.prototype.getAngle = function() {
    var c = (new MVMath.Edge(this.p1.x, this.p1.y, this.p2.x, this.p2.y)).getLength(), theta = c ? Math.asin(Math.abs(this.p1.y - this.p2.y) / c) : 0;
    if (this.p2.x <= this.p1.x && this.p2.y <= this.p1.y) {
      theta = theta - Math.PI;
      theta = theta * -1;
    } else {
      if (this.p2.x <= this.p1.x && this.p2.y >= this.p1.y) {
        theta = theta - Math.PI;
      } else {
        if (this.p2.x >= this.p1.x && this.p2.y >= this.p1.y) {
          theta = theta * -1;
        }
      }
    }
    return theta;
  };
  MVMath.CurveSegment = function(x, y) {
    if (typeof x === 'undefined' || typeof y === 'undefined') {
      this.C0 = new MVMath.Point;
      this.C1 = new MVMath.Point;
      this.C2 = new MVMath.Point;
      this.C3 = new MVMath.Point;
    } else {
      this.C0 = new MVMath.Point(x, y);
      this.C1 = new MVMath.Point(x, y);
      this.C2 = new MVMath.Point(x, y);
      this.C3 = new MVMath.Point(x, y);
    }
  };
})();
Ext.cmd.derive('photoViewer.view.annotations.shapes.Rectangle', photoViewer.view.annotations.shapes.Base, {shapeAttributes:['x', 'y', 'width', 'height', 'stroke', 'stroke-width', 'style'], initConfig:function(config) {
  if (!config) {
    return;
  }
  photoViewer.view.annotations.shapes.Base.prototype.initConfig.apply(this, arguments);
  config.type = 'rect';
  config.draggable = !this.readOnly;
  config.fill = 'none';
  config['stroke-dasharray'] = this.drawComponent.self.styleSettings[config['style']];
  var baseShape = Ext.create('photoViewer.draw.Sprite', config);
  this.add('base0', baseShape);
  this.show(true);
}, getDefaultConfig:function() {
  var xy = this.drawComponent.descaledXY, viewModel = this.getViewModel();
  return {x:xy[0], y:xy[1], width:1, height:1, stroke:viewModel.get('toolSettings.strokeColour'), 'stroke-width':viewModel.get('toolSettings.strokeWidth'), style:viewModel.get('toolSettings.strokeStyle')};
}, getType:function() {
  return 'rectangle';
}}, 0, 0, 0, 0, 0, 0, [photoViewer.view.annotations.shapes, 'Rectangle'], 0);
Ext.cmd.derive('photoViewer.view.annotations.sprites.TextBox', Ext.form.field.TextArea, {fieldCls:'x-form-field annotationsTextBox', style:'position: absolute', setXY:function(xy, force) {
  if (!force && this.unscaledXY && this.unscaledXY[0] == xy[0] && this.unscaledXY[1] == xy[1]) {
    return;
  }
  var dc = this.shape.drawComponent, dcBounds = dc.el.getBox(), scale = dc.getScale();
  this.unscaledXY = [xy[0], xy[1]];
  this.setPagePosition(Math.round(xy[0] * scale + dcBounds.left), Math.round(xy[1] * scale + dcBounds.top));
}, setWidth:function(width, force) {
  if (!force && this.unscaledWidth && this.unscaledWidth == width || !width) {
    return;
  }
  this.unscaledWidth = width;
  Ext.form.field.TextArea.prototype.setWidth.call(this, Math.max(width * this.shape.drawComponent.getScale(), 1));
}, setHeight:function(height, force) {
  if (!force && this.unscaledHeight && this.unscaledHeight == height || !height) {
    return;
  }
  this.unscaledHeight = height;
  var height = Math.max(height * this.shape.drawComponent.getScale(), 1);
  Ext.form.field.TextArea.prototype.setHeight.call(this, height);
  if (this.el.dom) {
    this.getTextArea().style.height = Math.ceil(height) + 'px';
  }
}, setBorderWeight:function(weight) {
  this.borderWeight = weight;
  this.refresh();
}, getBorderWeight:function() {
  return this.borderWeight;
}, setBorderStyle:function(style) {
  this.borderStyle = style == 'normal' ? 'solid' : style;
  this.refresh();
}, getBorderStyle:function() {
  return this.borderStyle == 'solid' ? 'normal' : this.borderStyle;
}, setBorderColour:function(colour) {
  this.borderColour = colour;
  this.refresh();
}, getBorderColour:function() {
  return this.borderColour;
}, setFontSize:function(fontSize) {
  this.fontSize = fontSize;
  this.refresh();
}, getFontSize:function() {
  return this.fontSize;
}, refresh:function() {
  if (!this.el) {
    return;
  }
  var scale = this.shape.drawComponent.getScale();
  this.setWidth(this.unscaledWidth, true);
  this.setHeight(this.unscaledHeight, true);
  if (this.unscaledXY) {
    this.setXY(this.unscaledXY, true);
  }
  var textArea = this.getTextArea();
  textArea.style.border = this.borderWeight * scale + 'px ' + this.borderStyle + ' ' + this.borderColour;
  textArea.style.color = this.borderColour;
  textArea.style.fontSize = '' + (Number(this.fontSize) * scale).toFixed(2) + 'pt';
}, getUnscaledRelativeBox:function() {
  if (!this.unscaledXY) {
    return {0:this.shape.config.x, 1:this.shape.config.y, x:this.shape.config.x, y:this.shape.config.y, width:this.shape.config.width, height:this.shape.config.height, right:this.shape.config.x + this.shape.config.width, bottom:this.shape.config.y + this.shape.config.height};
  }
  return {0:this.unscaledXY[0], 1:this.unscaledXY[1], x:this.unscaledXY[0], y:this.unscaledXY[1], width:this.unscaledWidth, height:this.unscaledHeight, right:this.unscaledXY[0] + this.unscaledWidth, bottom:this.unscaledXY[1] + this.unscaledHeight};
}, getRelativeBox:function() {
  var box = this.el.getBox(), dc = this.shape.drawComponent, dcBounds = dc.el.getBox();
  box[0] -= dcBounds.left;
  box[1] -= dcBounds.top;
  box.x -= dcBounds.left;
  box.y -= dcBounds.top;
  box.left = box.x;
  box.top = box.y;
  box.right -= dcBounds.left;
  box.bottom -= dcBounds.top;
  return box;
}, getTextArea:function() {
  return this.el.dom.getElementsByTagName('textarea')[0];
}, listeners:{afterrender:function(me) {
  var me = this;
  me.el.unselectable();
  var textArea = me.getTextArea();
  textArea.style.overflow = 'hidden';
  this.refresh();
  textArea.style.cursor = 'move';
  this.el.dom.style.zIndex = this.shape.drawComponent.el.dom.style.zIndex - 0 + 1;
  this.el.addListener('mousemove', function(e) {
    this.shape.drawComponent.fireEvent('mousemove', e);
  }, this);
  this.el.addListener('mouseup', function(e) {
    this.shape.drawComponent.fireEvent('mouseup', e);
  }, this);
  this.el.dom.style.zIndex = this.shape.drawComponent.el.dom.style.zIndex;
}, blur:function(me) {
  var textArea = me.getTextArea();
  textArea.style.cursor = 'move';
  this.shape.editingText = false;
  textArea.scrollTop = 0;
  this.dd.disabled = false;
}, el:{click:function() {
  var me = Ext.getCmp(this.getId());
  if (me.shape.readOnly || me.shape.editingText) {
    return;
  }
  if (!me.shape.isSelected) {
    me.shape.onClick();
  } else {
    me.dd.disabled = true;
    var textArea = me.getTextArea();
    textArea.style.cursor = 'text';
    textArea.focus();
    me.shape.editingText = true;
  }
}, scope:'this'}}}, 0, ['annotationstextbox'], ['component', 'box', 'field', 'textfield', 'textareafield', 'textarea', 'annotationstextbox'], {'component':true, 'box':true, 'field':true, 'textfield':true, 'textareafield':true, 'textarea':true, 'annotationstextbox':true}, ['widget.annotationstextbox'], 0, [photoViewer.view.annotations.sprites, 'TextBox'], 0);
Ext.cmd.derive('photoViewer.view.annotations.shapes.Text', photoViewer.view.annotations.shapes.Base, {shapeAttributes:['x', 'y', 'width', 'height', 'stroke', 'text', 'aX0', 'aY0', 'aX1', 'aY1', 'stroke-width', 'style', 'font-size'], nBaseSprites:2, defaultStemLength:80, defaultWidth:460, defaultHeight:90, hasArrow:true, initConfig:function(config) {
  if (!config) {
    return;
  }
  var me = this;
  if (!config['font-size']) {
    config['font-size'] = Math.round(24 + (config['stroke-width'] - 4) * 1.5);
  }
  photoViewer.view.annotations.shapes.Base.prototype.initConfig.apply(this, arguments);
  if (this.hasArrow) {
    var arrowSprite = Ext.create('photoViewer.view.annotations.sprites.Arrow', {draggable:!this.readOnly, x0:config.aX0, y0:config.aY0, x1:config.aX1, y1:config.aY1, 'stroke-width':config['stroke-width'], 'stroke':config.stroke, 'stroke-dasharray':this.drawComponent.self.styleSettings[config['style']]});
    this.add('base0', arrowSprite);
    var sX0 = config.aX0, sY0 = config.aY0;
    if (config.aY0 <= config.y) {
      this.stemPosition = 0;
      sY0 = config.y;
    } else {
      if (config.aX0 >= config.x + config.width) {
        this.stemPosition = 1;
        sX0 = config.x + config.width;
      } else {
        if (config.aY0 >= config.y + config.height) {
          this.stemPosition = 2;
          sY0 = config.y + config.height;
        } else {
          this.stemPosition = 3;
          sX0 = config.x;
        }
      }
    }
    var stemSprite = Ext.create('photoViewer.view.annotations.sprites.Line', {draggable:!this.readOnly, x0:sX0, y0:sY0, x1:config.aX0, y1:config.aY0, 'stroke-width':config['stroke-width'], 'stroke':config.stroke, 'stroke-dasharray':this.drawComponent.self.styleSettings[config['style']]});
    this.add('base1', stemSprite);
  }
  var borderStyle = config.style == 'normal' ? 'solid' : config.style, draggable = !this.readOnly;
  this.textBox = this.drawComponent.up('photoviewer').lookupController().lookupReference('photoContainer').add({xtype:'annotationstextbox', value:config.text, borderStyle:borderStyle, borderWeight:config['stroke-width'], borderColour:config.stroke, shape:this, draggable:draggable, disabled:this.readOnly, left:config.x, top:config.y});
  var onElReady = function() {
    this.textBox.setWidth(config.width);
    this.textBox.setHeight(config.height);
    this.textBox.setXY([config.x, config.y]);
    this.textBox.setFontSize(config['font-size']);
    this.currText = config.text;
    if (this.hasArrow) {
      this.fixArrowIntersection(true);
    }
    var shape = this;
    if (draggable) {
      this.textBox.initDraggable();
      Ext.override(this.textBox.dd, {onDrag:function(e) {
        shape.isSelected = true;
        shape.spriteGroupMove(shape.textBox.dd, shape.textBox, e);
      }, onMouseDown:function(e, target) {
        if (me.editingText) {
          return;
        }
        return this.callParent(arguments);
      }, onMouseUp:function(e) {
        shape.textBox.prevOffset = undefined;
        if (me.editingText) {
          return;
        }
        return this.callParent(arguments);
      }, onMouseMove:function(e, target) {
        if (shape.editingText) {
          return;
        }
        this.callParent(arguments);
      }});
      this.textBox.dd.addListener('mouseup', function(dd, e) {
        if (this.lastXY[0] == this.startXY[0] && this.lastXY[1] == this.startXY[1]) {
          shape.textBox.fireEvent('click', shape.textBox);
        } else {
          shape.afterMove();
        }
      });
    }
    this.drawComponent.addListener('move', shape.textBox.refresh, shape.textBox);
  };
  if (this.textBox.el) {
    onElReady.call(this);
  } else {
    this.textBox.addListener('afterrender', onElReady, this, {single:true});
  }
  this.show(true);
}, getAttribute:function(shapeAttributeName) {
  if (shapeAttributeName == 'text') {
    return this.textBox.value;
  } else {
    if (shapeAttributeName == 'stroke') {
      return this.textBox.getBorderColour();
    } else {
      if (shapeAttributeName == 'stroke-width') {
        return this.textBox.getBorderWeight();
      } else {
        if (shapeAttributeName == 'x' || shapeAttributeName == 'y' || shapeAttributeName == 'width' || shapeAttributeName == 'height') {
          var textBounds = this.textBox.getUnscaledRelativeBox();
          return Math.round(textBounds[shapeAttributeName]);
        } else {
          if (shapeAttributeName == 'style') {
            return this.textBox.getBorderStyle();
          } else {
            if (shapeAttributeName == 'aX0') {
              return this.hasArrow ? Math.round(this.getByKey('base0').x0) : 0;
            } else {
              if (shapeAttributeName == 'aY0') {
                return this.hasArrow ? Math.round(this.getByKey('base0').y0) : 0;
              } else {
                if (shapeAttributeName == 'aX1') {
                  return this.hasArrow ? Math.round(this.getByKey('base0').x1) : 0;
                } else {
                  if (shapeAttributeName == 'aY1') {
                    return this.hasArrow ? Math.round(this.getByKey('base0').y1) : 0;
                  } else {
                    if (shapeAttributeName == 'font-size') {
                      return this.textBox.getFontSize();
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return undefined;
}, resize:function(newX, newY, newWidth, newHeight) {
  this.textBox.setXY([newX, newY]);
  this.textBox.setHeight(newHeight);
  this.textBox.setWidth(newWidth);
  if (this.hasArrow) {
    this.fixStemCoords();
  }
}, deselect:function() {
  if (!this.isSelected) {
    return false;
  }
  this.textBox.blur();
  if (this.textBox.value != this.currText) {
    this.fireEvent('datachanged');
    this.currText = this.textBox.value;
  }
  return photoViewer.view.annotations.shapes.Base.prototype.deselect.apply(this, arguments);
}, getType:function() {
  return 'text';
}, isTooSmall:function() {
  return false;
}, getDefaultConfig:function() {
  var xy = this.drawComponent.descaledXY, viewModel = this.getViewModel(), x = xy[0] - this.defaultWidth / 2, y = xy[1] - this.defaultHeight / 2, strokeWidth = viewModel.get('toolSettings.strokeWidth'), stemCoords = this.getStemSideCoordinates(3, x, y, this.defaultWidth, this.defaultHeight, strokeWidth);
  return {x:x, y:y, width:this.defaultWidth, height:this.defaultHeight, stroke:viewModel.get('toolSettings.strokeColour'), text:'', 'aX1':xy[0], 'aY1':xy[1], 'aX0':stemCoords.x1, 'aY0':stemCoords.y1, 'stroke-width':strokeWidth, 'style':viewModel.get('toolSettings.strokeStyle'), 'font-size':viewModel.get('toolSettings.fontSize')};
}, translate:function(dx, dy) {
  var maxX = this.getViewModel().get('naturalWidth'), maxY = this.getViewModel().get('naturalHeight'), textBounds = this.textBox.getUnscaledRelativeBox(), arrow = this.hasArrow ? this.getByKey('base0') : null, stem = this.hasArrow ? this.getByKey('base1') : null;
  if (textBounds.x + dx < 0 || textBounds.x + dx + textBounds.width > maxX || textBounds.y + dy < 0 || textBounds.y + dy + textBounds.height > maxY) {
    return;
  }
  this.textBox.setXY([textBounds.x + dx, textBounds.y + dy]);
  if (this.hasArrow) {
    stem.setAttributes({x0:Math.min(maxX, Math.max(0, stem.x0 + dx)), y0:Math.min(maxY, Math.max(0, stem.y0 + dy)), x1:Math.min(maxX, Math.max(0, stem.x1 + dx)), y1:Math.min(maxY, Math.max(0, stem.y1 + dy))}, true);
    arrow.setAttributes({x0:stem.x1, y0:stem.y1}, true);
    this.fixArrowIntersection();
  }
}, fixStemCoords:function() {
  var textBounds = this.textBox.getUnscaledRelativeBox(), stem = this.getByKey('base1'), arrow = this.getByKey('base0'), dx = textBounds.x - textBounds.x, dy = textBounds.y - textBounds.y, maxX = this.getViewModel().get('naturalWidth'), maxY = this.getViewModel().get('naturalHeight'), stemAttr = {};
  if ((this.stemPosition == 0 || this.stemPosition == 2) && (stem.x0 < textBounds.x || stem.x0 > textBounds.x + textBounds.width) || (this.stemPosition == 1 || this.stemPosition == 3) && (stem.y0 < textBounds.y || stem.y0 > textBounds.y + textBounds.height)) {
    stemAttr = this.getStemSideCoordinates(this.stemPosition, textBounds.x, textBounds.y, textBounds.width, textBounds.height, stem.attr['stroke-width']);
  } else {
    var stemLength = Math.getLineLength([stem.x0, stem.y0], [stem.x1, stem.y1]);
    if (this.stemPosition === 0) {
      stemAttr.y0 = textBounds.y;
      if (Math.getLineLength([stem.x0, stemAttr.y0], [stem.x1, stem.y1]) < stemLength && stemAttr.y0 - stem.y1 < this.defaultStemLength) {
        stemAttr.y1 = Math.max(0, stemAttr.y0 - this.defaultStemLength);
      }
    } else {
      if (this.stemPosition === 1) {
        stemAttr.x0 = textBounds.right;
        if (Math.getLineLength([stemAttr.x0, stem.y0], [stem.x1, stem.y1]) < stemLength && stem.x1 - stemAttr.x0 < this.defaultStemLength) {
          stemAttr.x1 = Math.min(maxX, stemAttr.x0 + this.defaultStemLength);
        }
      } else {
        if (this.stemPosition === 2) {
          stemAttr.y0 = textBounds.bottom;
          if (Math.getLineLength([stem.x0, stemAttr.y0], [stem.x1, stem.y1]) < stemLength && stem.y1 - stemAttr.y0 < this.defaultStemLength) {
            stemAttr.y1 = Math.min(maxY, stemAttr.y0 + this.defaultStemLength);
          }
        } else {
          if (this.stemPosition === 3) {
            stemAttr.x0 = textBounds.x;
            if (Math.getLineLength([stemAttr.x0, stem.y0], [stem.x1, stem.y1]) < stemLength && stemAttr.x0 - stem.x1 < this.defaultStemLength) {
              stemAttr.x1 = Math.max(0, stemAttr.x0 - this.defaultStemLength);
            }
          }
        }
      }
    }
  }
  stem.setAttributes(stemAttr, true);
  this.fixArrowIntersection();
  this.refreshSelectionSprites();
}, getStemSideCoordinates:function(position, x, y, width, height, strokeWidth) {
  var offsetStemX = x + width / 2 - strokeWidth / 2;
  var offsetStemY = y + height / 2 + strokeWidth / 2;
  if (position === 0) {
    return {x0:offsetStemX, y0:y, x1:offsetStemX, y1:y - this.defaultStemLength};
  }
  if (position === 1) {
    return {x0:x + width, y0:offsetStemY, x1:x + width + this.defaultStemLength, y1:offsetStemY};
  }
  if (position === 2) {
    return {x0:offsetStemX, y0:y + height, x1:offsetStemX, y1:y + height + this.defaultStemLength};
  }
  if (position === 3) {
    return {x0:x, y0:offsetStemY, x1:x - this.defaultStemLength, y1:offsetStemY};
  }
}, moveStemToSide:function(position, x, y, width, height, strokeWidth, moveXY1) {
  this.stemPosition = position;
  var coordinates = this.getStemSideCoordinates(position, x, y, width, height, strokeWidth);
  var attr = {x0:coordinates.x0, y0:coordinates.y0};
  if (moveXY1) {
    attr.x1 = coordinates.x1;
    attr.y1 = coordinates.y1;
  }
  this.getByKey('base1').setAttributes(attr, true);
}, arrowIntersectsSide:function(position) {
  var arrow = this.getByKey('base0'), textBounds = this.textBox.getUnscaledRelativeBox(), width = textBounds.width, height = textBounds.height, x = textBounds.x, y = textBounds.y, strokeWidth = arrow.attr['stroke-width'];
  var sideXY0 = [x, y], sideXY1 = [x + width, y];
  if (position === 1) {
    sideXY0 = [x + width, y + height];
  }
  if (position === 2) {
    sideXY0 = [x, y + height];
    sideXY1 = [x + width, y + height];
  }
  if (position === 3) {
    sideXY1 = [x, y + height];
  }
  return Math.segmentsIntersect(sideXY0, sideXY1, [arrow.x0, arrow.y0], [arrow.x1, arrow.y1]);
}, fixArrowIntersection:function(silent) {
  var arrow = this.getByKey('base0'), stem = this.getByKey('base1'), textBounds = this.textBox.getUnscaledRelativeBox();
  var width = textBounds.width, height = textBounds.height, x = textBounds.x, y = textBounds.y, strokeWidth = arrow.attr['stroke-width'];
  var intersectsTop = this.arrowIntersectsSide(0), intersectsRight = this.arrowIntersectsSide(1), intersectsBottom = this.arrowIntersectsSide(2), intersectsLeft = this.arrowIntersectsSide(3);
  if (intersectsLeft && intersectsTop) {
    if (arrow.x1 <= x) {
      this.moveStemToSide(3, x, y, width, height, strokeWidth, true);
    } else {
      this.moveStemToSide(0, x, y, width, height, strokeWidth, true);
    }
  } else {
    if (intersectsRight && intersectsTop) {
      if (arrow.x1 >= x + width) {
        this.moveStemToSide(1, x, y, width, height, strokeWidth, true);
      } else {
        this.moveStemToSide(0, x, y, width, height, strokeWidth, true);
      }
    } else {
      if (intersectsLeft && intersectsBottom) {
        if (arrow.x1 <= x) {
          this.moveStemToSide(3, x, y, width, height, strokeWidth, true);
        } else {
          this.moveStemToSide(2, x, y, width, height, strokeWidth, true);
        }
      } else {
        if (intersectsRight && intersectsBottom) {
          if (arrow.x1 >= x + width) {
            this.moveStemToSide(1, x, y, width, height, strokeWidth, true);
          } else {
            this.moveStemToSide(2, x, y, width, height, strokeWidth, true);
          }
        } else {
          if (intersectsTop && intersectsBottom) {
            if (arrow.y1 <= y) {
              this.moveStemToSide(0, x, y, width, height, strokeWidth, true);
            } else {
              this.moveStemToSide(2, x, y, width, height, strokeWidth, true);
            }
          } else {
            if (intersectsRight && intersectsLeft) {
              if (arrow.x1 <= x) {
                this.moveStemToSide(3, x, y, width, height, strokeWidth, true);
              } else {
                this.moveStemToSide(1, x, y, width, height, strokeWidth, true);
              }
            }
          }
        }
      }
    }
  }
  arrow.setAttributes({x0:stem.x1, y0:stem.y1, x1:arrow.x1, y1:arrow.y1}, true);
  if (!silent) {
    this.fireEvent('datachanged');
  }
}, afterMove:function() {
  if (!this.hasArrow) {
    return;
  }
  var stem = this.getByKey('base1'), arrow = this.getByKey('base0'), textBounds = this.textBox.getUnscaledRelativeBox();
  if (arrow.x1 >= textBounds.x && arrow.x1 <= textBounds.x + textBounds.width && arrow.y1 >= textBounds.y && arrow.y1 <= textBounds.y + textBounds.height) {
    var leftDiff = arrow.x1 - textBounds.x, rightDiff = textBounds.x + textBounds.width - arrow.x1;
    var dx = leftDiff + this.defaultStemLength;
    if (Math.min(rightDiff, leftDiff) == rightDiff && textBounds.x - (rightDiff + this.defaultStemLength) > 0) {
      dx = 0 - rightDiff - this.defaultStemLength;
    }
    this.translate(dx, 0);
    this.refreshSelectionSprites();
    this.fireEvent('datachanged');
  }
}, refreshSelectionSprites:function(staticPoint) {
  var resizeHandle0 = this.getByKey('resizeHandle0');
  var bbox = this.textBox.getUnscaledRelativeBox();
  var arrow = this.getByKey('base0');
  if (!resizeHandle0) {
    for (var i = 0; i < 8; i++) {
      var resizeHandle = Ext.create('photoViewer.view.annotations.sprites.resizeHandle', {boundingBox:bbox, position:i, drawComponent:this.drawComponent});
      this.add('resizeHandle' + i, resizeHandle);
    }
    if (this.hasArrow) {
      var handle0 = Ext.create('photoViewer.view.annotations.sprites.pointHandle', {x:arrow.x0, y:arrow.y0, pointNumber:0, drawComponent:this.drawComponent});
      this.add('pointHandle0', handle0);
      var handle1 = Ext.create('photoViewer.view.annotations.sprites.pointHandle', {x:arrow.x1, y:arrow.y1, pointNumber:1, drawComponent:this.drawComponent});
      this.add('pointHandle1', handle1);
      var me = this;
      Ext.override(handle1.dd, {onMouseUp:function() {
        me.afterMove();
      }});
    }
  } else {
    for (var j = 0; j < 8; j++) {
      this.getByKey('resizeHandle' + j).refreshPosition(bbox);
    }
    if (this.hasArrow) {
      var handle0 = this.getByKey('pointHandle0'), handle1 = this.getByKey('pointHandle1');
      if (staticPoint !== 0) {
        handle0.setAttributes({x:arrow.x0, y:arrow.y0}, true);
        handle0.show(true);
      }
      if (staticPoint !== 1) {
        handle1.setAttributes({x:arrow.x1, y:arrow.y1}, true);
        handle1.show(true);
      }
    }
  }
}, removeSelectionSprites:function() {
  for (var i = 0; i < 8; i++) {
    var handle = this.getByKey('resizeHandle' + i);
    if (handle) {
      handle.hide(true);
    } else {
      return;
    }
  }
  if (this.hasArrow) {
    for (var i = 0; i < 2; i++) {
      this.getByKey('pointHandle' + i).hide(true);
    }
  }
}, changePointOnDragHandle:function(spriteDD, sprite, event) {
  var xy = this.drawComponent.getController().getRelativeDescaledXYFromMouseEvent(event);
  this.movePointHandle(sprite.pointNumber, xy[0], xy[1]);
  this.refreshSelectionSprites();
}, movePointHandle:function(pointNumber, x, y) {
  var maxX = this.getViewModel().get('naturalWidth');
  var maxY = this.getViewModel().get('naturalHeight');
  if (x < 0) {
    x = 0;
  } else {
    if (x > maxX) {
      x = maxX;
    }
  }
  if (y < 0) {
    y = 0;
  } else {
    if (y > maxY) {
      y = maxY;
    }
  }
  var arrow = this.getByKey('base0');
  var x0 = arrow.x0, y0 = arrow.y0, x1 = arrow.x1, y1 = arrow.y1;
  if (pointNumber === 0) {
    var textBounds = this.textBox.getUnscaledRelativeBox();
    if (this.stemPosition == 0 && y > textBounds.y) {
      y = textBounds.y;
    }
    if (this.stemPosition == 1 && x < textBounds.x + textBounds.width) {
      x = textBounds.x + textBounds.width;
    }
    if (this.stemPosition == 2 && y < textBounds.y + textBounds.height) {
      y = textBounds.y + textBounds.height;
    }
    if (this.stemPosition == 3 && x > textBounds.x) {
      x = textBounds.x;
    }
    if (this.stemPosition === 0 || this.stemPosition == 2) {
      y0 = y;
    } else {
      x0 = x;
    }
  } else {
    x1 = x;
    y1 = y;
  }
  arrow.setAttributes({x0:x0, y0:y0, x1:x1, y1:y1}, true);
  if (pointNumber === 0) {
    this.getByKey('base1').setAttributes({x1:x0, y1:y0}, true);
  }
  this.fixArrowIntersection();
}, setScale:function(scale) {
  this.textBox.refresh();
  this.callParent(arguments);
}, destroy:function() {
  this.drawComponent.removeListener('move', this.textBox.refresh, this.textBox);
  this.textBox.destroy();
  photoViewer.view.annotations.shapes.Base.prototype.destroy.apply(this, arguments);
}, setStrokeWidth:function(newValue) {
  if (this.hasArrow) {
    this.getByKey('base1').setAttributes({'stroke-width':newValue}, true);
  }
  this.textBox.setBorderWeight(newValue);
  photoViewer.view.annotations.shapes.Base.prototype.setStrokeWidth.apply(this, arguments);
}, setStrokeStyle:function(newValue) {
  if (this.hasArrow) {
    this.getByKey('base1').setAttributes({'stroke-dasharray':this.drawComponent.self.styleSettings[newValue]}, true);
  }
  this.textBox.setBorderStyle(newValue);
  photoViewer.view.annotations.shapes.Base.prototype.setStrokeStyle.apply(this, arguments);
}, setColour:function(colour) {
  this.textBox.setBorderColour(colour);
  photoViewer.view.annotations.shapes.Base.prototype.setColour.apply(this, arguments);
}, setFontSize:function(fontSize) {
  var oldFontSize = this.getAttribute('font-size');
  this.textBox.setFontSize(fontSize);
  if (fontSize != oldFontSize) {
    this.drawComponent.lookupViewModel().set('toolSettings.fontSize', fontSize);
    this.fireEvent('datachanged');
  }
}, getCanResizeFlip:function() {
  return false;
}, getMinWidth:function() {
  return Math.max((48 + this.getAttribute('stroke-width') * 2) / this.drawComponent.getScale(), 100);
}, getMinHeight:function() {
  return Math.max((48 + this.getAttribute('stroke-width') * 2) / this.drawComponent.getScale(), 100);
}, onZoomChange:function() {
  if (this.textBox) {
    this.textBox.refresh();
  }
}, hide:function() {
  photoViewer.view.annotations.shapes.Base.prototype.hide.apply(this, arguments);
  this.textBox.hide();
}, show:function() {
  photoViewer.view.annotations.shapes.Base.prototype.show.apply(this, arguments);
  this.textBox.show();
  this.textBox.refresh();
}}, 0, 0, 0, 0, 0, 0, [photoViewer.view.annotations.shapes, 'Text'], 0);
Ext.cmd.derive('photoViewer.view.annotations.shapes.Textbox', photoViewer.view.annotations.shapes.Text, {nBaseSprites:0, hasArrow:false, defaultWidth:100, defaultHeight:75, minWidth:100, minHeight:75, getType:function() {
  return 'textbox';
}}, 0, 0, 0, 0, 0, 0, [photoViewer.view.annotations.shapes, 'Textbox'], 0);
Ext.cmd.derive('photoViewer.view.annotations.sprites.Info', Ext.Component, {cls:'photoviewer-measurement-info', floating:true, shadow:false, tpl:new Ext.Template('\x3cdiv class\x3d"name"\x3e{TitleDisplayName}:\x3c/div\x3e\x3cdiv class\x3d"measurement"\x3e{MeasurementString}\x3c/div\x3e')}, 0, ['annotationsinfo'], ['component', 'box', 'annotationsinfo'], {'component':true, 'box':true, 'annotationsinfo':true}, ['widget.annotationsinfo'], 0, [photoViewer.view.annotations.sprites, 'Info'], 0);
Ext.cmd.derive('photoViewer.view.annotations.sprites.selectionBox', photoViewer.draw.Sprite, {constructor:function(config) {
  this.initConfig(config);
  photoViewer.draw.Sprite.prototype.constructor.apply(this, arguments);
}, bboxExcluded:true, initConfig:function(config) {
  config.x = config.boundingBox.x;
  config.y = config.boundingBox.y;
  config.width = config.boundingBox.width;
  config.height = config.boundingBox.height;
  delete config.boundingBox;
  config.type = 'rect';
  config.stroke = 'white';
  if (typeof config['stroke-width'] === 'undefined') {
    config['stroke-width'] = 1;
  }
  config.draggable = true;
  this.callParent(arguments);
}, resize:function(dx, dy, shiftPositionLeft, shiftPositionUp) {
  var attr = this.attr ? this.attr : this;
  var newX = attr.x;
  var newY = attr.y;
  if (shiftPositionLeft) {
    newX -= dx;
  }
  if (shiftPositionUp) {
    newY -= dy;
  }
  var newWidth = attr.width + dx;
  var newHeight = attr.height + dy;
  this.setAttributes({width:newWidth, height:newHeight, x:newX, y:newY}, true);
}}, 1, 0, 0, 0, 0, 0, [photoViewer.view.annotations.sprites, 'selectionBox'], 0);
Ext.cmd.derive('photoViewer.view.annotations.tools.PhotoViewerToolButton', Ext.button.Button, {enableToggle:true, defaultListenerScope:'this', width:61, height:61, scale:'large', padding:14, ui:'annotationtool', config:{iconAlign:'top'}, listeners:{click:'onButtonClick'}, onButtonClick:function() {
  this.up('photoviewerannotationstoolwindow').doButtonToggle(this);
  this.changeMode(this);
}, changeMode:function(btn) {
  if (btn.controlMode) {
    this.lookupViewModel().set('toolSettings.mode', btn.controlMode);
  }
}}, 0, ['photoviewertoolbutton'], ['component', 'box', 'button', 'photoviewertoolbutton'], {'component':true, 'box':true, 'button':true, 'photoviewertoolbutton':true}, ['widget.photoviewertoolbutton'], 0, [photoViewer.view.annotations.tools, 'PhotoViewerToolButton'], 0);
Ext.cmd.derive('photoViewer.view.annotations.tools.PhotoViewerToolMenuButton', photoViewer.view.annotations.tools.PhotoViewerToolButton, {config:{menuOptions:[], activeButton:null, menuCls:'', iconAlign:'right', menuAlign:'br-tr?'}, initComponent:function() {
  var items = this.getMenuOptions(), icons = [];
  for (var i = 0; i < items.length; i++) {
    items[i].listeners = {click:{fn:this.onMenuButtonClick, scope:this}};
    if (items[i].icon) {
      icons.push(items[i].icon);
    }
  }
  this.setMvPreloadImages(icons);
  this.setIcon(items[0].icon);
  this.setMenu({ui:'annotationtool', cls:this.getMenuCls(), showSeparator:false, items:items, shadow:false});
  photoViewer.view.annotations.tools.PhotoViewerToolButton.prototype.initComponent.apply(this, arguments);
  this.setActiveButton(this.getMenu().items.items[0]);
}, onButtonClick:function() {
  this.up('photoviewerannotationstoolwindow').doButtonToggle(this);
  this.changeMode(this.getActiveButton());
}, onMenuButtonClick:function(btn) {
  this.changeMode(btn);
  this.setIcon(btn.icon);
  this.setActiveButton(btn);
}}, 0, ['photoviewertoolmenubutton'], ['component', 'box', 'button', 'photoviewertoolbutton', 'photoviewertoolmenubutton'], {'component':true, 'box':true, 'button':true, 'photoviewertoolbutton':true, 'photoviewertoolmenubutton':true}, ['widget.photoviewertoolmenubutton'], 0, [photoViewer.view.annotations.tools, 'PhotoViewerToolMenuButton'], 0);
Ext.cmd.derive('photoViewer.view.annotations.tools.PhotoViewerStrokeStyle', photoViewer.view.annotations.tools.PhotoViewerToolMenuButton, {config:{menuOptions:[{icon:'mds/image/component/annotations/style_solid.png', value:'normal'}, {icon:'mds/image/component/annotations/style_dashed.png', value:'dashed'}, {icon:'mds/image/component/annotations/style_dotted.png', value:'dotted'}], activeButton:null, scale:'small', menuCls:'small', localized:{text:'PAT_Style'}, labelAlign:'left', width:60, height:14, 
enableToggle:false, padding:0, menuAlign:'tr-br?'}, onMenuButtonClick:function(btn) {
  this.fireEvent('change', this, btn.value);
  this.setIcon(btn.icon);
  this.setActiveButton(btn);
}, onButtonClick:Ext.emptyFn, setValue:function(value) {
  var menuOptions = this.getMenuOptions(), i;
  for (i = 0; i < menuOptions.length; i++) {
    if (menuOptions[i].value == value) {
      this.fireEvent('change', this, menuOptions[i].value);
      this.setIcon(menuOptions[i].icon);
      var menu = this.getMenu(), menuItems = menu ? menu.items.items : null;
      if (menuItems) {
        this.setActiveButton(menuItems[i]);
      }
    }
  }
}}, 0, ['photoviewerstrokestyle'], ['component', 'box', 'button', 'photoviewertoolbutton', 'photoviewertoolmenubutton', 'photoviewerstrokestyle'], {'component':true, 'box':true, 'button':true, 'photoviewertoolbutton':true, 'photoviewertoolmenubutton':true, 'photoviewerstrokestyle':true}, ['widget.photoviewerstrokestyle'], 0, [photoViewer.view.annotations.tools, 'PhotoViewerStrokeStyle'], 0);
Ext.cmd.derive('photoViewer.view.annotations.tools.ToolWindow', Ext.panel.Panel, {reference:'annotationsTW', closeAction:'hide', draggable:true, resizable:false, defaultType:'button', controller:'toolwindow', hidden:true, floating:true, shadow:false, defaultAlign:'bc-bc?', layout:{type:'hbox', align:'center'}, items:[{reference:'annotationsSelectButton', xtype:'photoviewertoolbutton', icon:'mds/image/icon/annotations/select.png', localized:{tooltip:'PAT_Selection Tool'}, controlMode:'select'}, {xtype:'photoviewertoolbutton', 
icon:'mds/image/icon/annotations/pen.png', controlMode:'pen', localized:{tooltip:'PAT_Pen Tool'}}, {xtype:'photoviewertoolmenubutton', menuOptions:[{icon:'mds/image/icon/annotations/line.png', controlMode:'line', localized:{tooltip:'PAT_Line Tool'}}, {icon:'mds/image/icon/annotations/arrow.png', controlMode:'arrow', localized:{tooltip:'PAT_Arrow Tool'}}]}, {xtype:'photoviewertoolmenubutton', menuOptions:[{icon:'mds/image/icon/annotations/square.png', controlMode:'rectangle', localized:{tooltip:'PAT_Rectangle Tool'}}, 
{icon:'mds/image/icon/annotations/circle.png', controlMode:'ellipse', localized:{tooltip:'PAT_Ellipse Tool'}}]}, {xtype:'photoviewertoolmenubutton', cls:'text-tool', margin:'0 15 0 0', menuOptions:[{icon:'mds/image/icon/annotations/textbox.png', controlMode:'textbox', localized:{tooltip:'PAT_Text Box Tool'}}, {icon:'mds/image/icon/annotations/callout.png', controlMode:'text', localized:{tooltip:'PAT_Callout Tool'}}]}, {xtype:'rangeCombo', ui:'annotationtool', reference:'fontSizePicker', localized:{fieldLabel:'PAT_Font Size'}, 
labelSeparator:'', labelWidth:45, margin:'0 14 0 0', min:12, max:100, pickerAlign:'tl-bl?', pickerOffset:[0, 1], listConfig:{cls:'annotationtool-list', height:100, shadow:false}, bind:{value:'{toolSettings.fontSize}'}, listeners:{change:'onFontSizeChange'}}, {xtype:'simplecolorwidget', popupUi:'dark', popupShadow:false, reference:'strokeColourSample', bind:{value:'{annotationsStrokeColourNoHash}'}, width:33, height:33}, {xtype:'container', layout:'vbox', margin:'0 25 0 18', items:[{xtype:'rangeCombo', 
reference:'strokeWidthPicker', localized:{fieldLabel:'PAT_Width'}, labelSeparator:'', labelWidth:29, ui:'annotationtool', min:1, max:50, pickerAlign:'tl-bl?', pickerOffset:[0, 1], listConfig:{cls:'annotationtool-list', height:100, shadow:false}, listeners:{change:'onStrokeWidthChange'}}, {xtype:'photoviewerstrokestyle', reference:'strokeStylePicker', listeners:{change:'onStrokeStyleChange'}}]}], listeners:{beforeshow:'onBeforeShow', hide:'onHide'}, constructor:function() {
  Ext.panel.Panel.prototype.constructor.apply(this, arguments);
}, doButtonToggle:function(btn) {
  if (!btn.pressed) {
    btn.toggle();
  }
  for (var i = 0; i < this.items.length; i++) {
    var btnI = this.items.getAt(i);
    if (btnI != btn && btnI.pressed) {
      btnI.toggle();
    }
  }
}}, 1, ['photoviewerannotationstoolwindow'], ['component', 'box', 'container', 'panel', 'photoviewerannotationstoolwindow'], {'component':true, 'box':true, 'container':true, 'panel':true, 'photoviewerannotationstoolwindow':true}, ['widget.photoviewerannotationstoolwindow'], 0, [photoViewer.view.annotations.tools, 'ToolWindow'], 0);
Ext.cmd.derive('photoViewer.view.annotations.tools.ToolWindowController', Ext.app.ViewController, {MemberUIDArray:[], statics:{defaultStrokeColour:'#FF6600', defaultStrokeWidth:4, defaultStrokeStyle:'normal', defaultFontSize:24}, onStrokeColourClick:function() {
  this.lookupReference('strokeColourPickerWindow').showBy(this.lookupReference('strokeColourSample'), 'tl-tr', [5, 0]);
}, onBeforeShow:function() {
  this.setDefaults();
  Ext.getDoc().addListener('click', this.checkClick, this);
}, onHide:function() {
  Ext.getDoc().removeListener('click', this.checkClick, this);
}, onStrokeStyleChange:function(selector, newValue) {
  if (!newValue) {
    return;
  }
  this.getViewModel().set('toolSettings.strokeStyle', newValue);
  if (selector.isVisible()) {
    this.getPhotoController().setSelectedShapeStrokeStyle(newValue);
  }
}, onStrokeWidthChange:function(selector, newValue) {
  this.getViewModel().set('toolSettings.strokeWidth', newValue);
  if (selector.isVisible()) {
    this.getPhotoController().setSelectedShapeStrokeWidth(newValue);
  }
}, onFontSizeChange:function(selector, newValue) {
  this.getViewModel().set('toolSettings.fontSize', newValue);
  if (selector.isVisible()) {
    this.getPhotoController().setSelectedShapeFontSize(newValue);
  }
}, onShareTypeChange:function(data) {
  this.getPhotoController().setRecordSelectedShapeShareType(data.selectedShareType, data.selectedMemberList ? data.selectedMemberList.split(',') : []);
}, getControlMode:function() {
  return this.getViewModel().get('toolSettings.mode');
}, getFontSize:function() {
  return this.getViewModel().get('toolSettings.fontSize');
}, checkClick:function(event) {
  var colourWindow = this.lookupReference('strokeColourPickerWindow'), target = event.getTarget();
  if (!target) {
    return;
  }
}, setDefaults:function() {
  var viewModel = this.getViewModel(), selectionBtn = this.lookupReference('annotationsSelectButton');
  viewModel.set('toolSettings.strokeColour', this.self.defaultStrokeColour);
  viewModel.set('toolSettings.strokeWidth', this.self.defaultStrokeWidth);
  viewModel.set('toolSettings.fontSize', this.self.defaultFontSize);
  this.lookupReference('strokeWidthPicker').setValue(this.self.defaultStrokeWidth);
  this.lookupReference('strokeStylePicker').setValue(this.self.defaultStrokeStyle);
  selectionBtn.toggle();
  this.getViewModel().set('toolSettings.mode', selectionBtn.controlMode);
}, resetSelectedButton:function() {
  var controlMode = this.getControlMode(), items = this.items.items;
  if (controlMode) {
    for (var i = 0; i < items.length; i++) {
      if (items[i].controlMode == controlMode) {
        items[i].fireEvent('click', items[i]);
        break;
      }
    }
  }
}, onFontSizePickerShow:function() {
  this.lookupReference('fontSizePicker').setValue(this.getViewModel().get('toolSettings.fontSize'));
}, onStrokeStylePickerShow:function() {
  this.lookupReference('strokeStylePicker').setValue(this.getViewModel().get('toolSettings.strokeStyle'));
}, onStrokeWidthPickerShow:function() {
  this.lookupReference('strokeWidthPicker').setValue(this.getViewModel().get('toolSettings.strokeWidth'));
}, getPhotoController:function() {
  return this.getView().up('photoviewer').lookupController().lookupReference('photoContainer').lookupReference('photo').lookupController();
}}, 0, 0, 0, 0, ['controller.toolwindow'], 0, [photoViewer.view.annotations.tools, 'ToolWindowController'], 0);
Ext.cmd.derive('photoViewer.view.annotations.widget.rangeCombo', Ext.form.field.ComboBox, {constructor:function(config) {
  config.store = Ext.create('Ext.data.Store', {fields:['value', 'display'], idProperty:'value', data:[]});
  var imageCombo = this;
  for (var i = config.min; i <= config.max; i++) {
    var display = i;
    if (config.unit) {
      display += config.unit;
    }
    config.store.add({value:i, display:display});
  }
  Ext.form.field.ComboBox.prototype.constructor.apply(this, arguments);
}, queryMode:'local', valueField:'value', displayField:'display', editable:false, autoSelect:true}, 1, ['rangeCombo'], ['component', 'box', 'field', 'textfield', 'pickerfield', 'combobox', 'combo', 'rangeCombo'], {'component':true, 'box':true, 'field':true, 'textfield':true, 'pickerfield':true, 'combobox':true, 'combo':true, 'rangeCombo':true}, ['widget.rangeCombo'], 0, [photoViewer.view.annotations.widget, 'rangeCombo'], 0);
Ext.cmd.derive('photoViewer.view.exif.Exif', Ext.grid.Panel, {localized:{title:'EXIF_Exif Data'}, width:375, height:300, closable:true, closeAction:'hide', hidden:true, floating:true, resizable:true, draggable:true, controller:'exif', viewModel:{stores:{exifData:{type:'exifdata', listeners:{load:'exifDataStoreLoaded'}}}}, bind:{store:'{exifData}'}, dockedItems:[{xtype:'toolbar', dock:'bottom', items:[{xtype:'checkbox', reference:'exifShowTagsCheckbox', localized:{boxLabel:'EXIF_Show All Tags'}, listeners:{change:'toggleExifShowAllTags'}}], 
padding:'0 0 5 5'}], columns:[{localized:{text:'EXIF_Tag Name'}, dataIndex:'name', width:150}, {localized:{text:'EXIF_Tag Value'}, dataIndex:'description', width:200}]}, 0, ['photoviewerexif'], ['component', 'box', 'container', 'panel', 'tablepanel', 'gridpanel', 'grid', 'photoviewerexif'], {'component':true, 'box':true, 'container':true, 'panel':true, 'tablepanel':true, 'gridpanel':true, 'grid':true, 'photoviewerexif':true}, ['widget.photoviewerexif'], 0, [photoViewer.view.exif, 'Exif'], 0);
Ext.cmd.derive('photoViewer.view.exif.ExifController', Ext.app.ViewController, {exifDataStoreLoaded:function() {
  this.getStore('exifData').filterTags();
  this.lookupReference('exifShowTagsCheckbox').setValue(false);
}, toggleExifShowAllTags:function(comp, newv) {
  var exifStore = this.getStore('exifData');
  if (newv) {
    exifStore.unFilterTags();
  } else {
    exifStore.filterTags();
  }
}, showExifInfo:function() {
  this.getView().show();
  var exifDataStore = this.getStore('exifData'), vm = this.getView().lookupViewModel();
  exifDataStore.getProxy().setExtraParam('id', this.getView().lookupViewModel().get('activePhoto.id'));
  exifDataStore.getProxy().setExtraParam('projectUID', vm.get('ProjectUID'));
  exifDataStore.getProxy().setExtraParam('webcamUID', vm.get('activePhoto.WebcamUID'));
  Ext.getBody().mask('Loading ...');
  exifDataStore.addListener('load', function() {
    Ext.getBody().unmask();
  }, this, {single:true});
  exifDataStore.load();
}}, 0, 0, 0, 0, ['controller.exif'], 0, [photoViewer.view.exif, 'ExifController'], 0);
Ext.cmd.derive('photoViewer.view.webcam.WebcamCustomSlideshow', Ext.window.Window, {modal:true, modalMaskCls:'dark-mask', ui:'orange', closeAction:'hide', height:500, width:500, alwaysOnTop:2, layout:{type:'vbox', align:'stretchmax'}, localized:{title:'WVA_Custom Slideshow Recu'}, items:[{xtype:'container', layout:{type:'vbox', pack:'center', align:'stretchmax'}, height:'100%', padding:15, items:[{xtype:'container', layout:{type:'hbox'}, margin:5, items:[{xtype:'container', layout:{type:'vbox'}, 
defaults:{xtype:'datefield', ui:'detail-form', labelWidth:70, cls:'with-icon', labelSeparator:'', localized:{format:'DATE_Medium'}, width:200}, items:[{reference:'csStartDate', localized:{fieldLabel:'WVA_Start Date'}}, {reference:'csEndDate', localized:{fieldLabel:'WVA_End Date'}}]}, {xtype:'container', layout:{type:'vbox'}, items:[{xtype:'container', layout:{type:'hbox'}, items:[{xtype:'radio', ui:'plain-radio-16', name:'csSelectionType', reference:'csSelectionType', cls:'csSelectionType', localized:{boxLabel:'WVA_Time'}, 
checked:true, margin:'0 5 0 25', inputValue:'time', bind:{value:'{hasTargetTime}'}}, {xtype:'detailformcombo', reference:'csHour', bind:{disabled:'{!hasTargetTime}'}, width:86, store:Ext.create('Ext.data.Store', {fields:['text', 'value'], proxy:'memory', data:[{text:'12 AM', value:0}, {text:'1 AM', value:1}, {text:'2 AM', value:2}, {text:'3 AM', value:3}, {text:'4 AM', value:4}, {text:'5 AM', value:5}, {text:'6 AM', value:6}, {text:'7 AM', value:7}, {text:'8 AM', value:8}, {text:'9 AM', value:9}, 
{text:'10 AM', value:10}, {text:'11 AM', value:11}, {text:'12 PM', value:12}, {text:'1 PM', value:13}, {text:'2 PM', value:14}, {text:'3 PM', value:15}, {text:'4 PM', value:16}, {text:'5 PM', value:17}, {text:'6 PM', value:18}, {text:'7 PM', value:19}, {text:'8 PM', value:20}, {text:'9 PM', value:21}, {text:'10 PM', value:22}, {text:'11 PM', value:23}]}), valueField:'value', editable:false, listeners:{afterrender:function(combo) {
  combo.setValue(12);
}}}, {xtype:'detailformcombo', reference:'csMinute', bind:{disabled:'{!hasTargetTime}'}, width:68, store:Ext.create('Ext.data.Store', {fields:['text', 'value'], proxy:'memory', data:[{text:':00', value:0}, {text:':15', value:15}, {text:':30', value:30}, {text:':45', value:45}]}), valueField:'value', editable:false, listeners:{afterrender:function(combo) {
  combo.setValue(0);
}}}]}, {xtype:'radio', ui:'plain-radio-16', name:'csSelectionType', cls:'csSelectionType', localized:{boxLabel:'WVA_All Photos'}, inputValue:'allPhotos', margin:'10 5 0 25'}, {xtype:'radio', ui:'plain-radio-16', name:'csSelectionType', cls:'csSelectionType', localized:{boxLabel:'WVA_Commented'}, inputValue:'commented', margin:'10 5 0 25'}]}]}, {xtype:'component', flex:1, html:'\x3chr\x3e', margin:'0 0 5 0'}, {xtype:'container', layout:{type:'hbox'}, items:[{xtype:'radiogroup', reference:'csSelectionRadioGroup', 
layout:{type:'vbox'}, defaults:{name:'csRecurrenceType', ui:'plain-radio-16', margin:'0 0 5 5'}, bind:{disabled:'{!hasTargetTime}'}, items:[{localized:{boxLabel:'WVA_Daily'}, inputValue:'daily', checked:true}, {localized:{boxLabel:'WVA_Weekly'}, inputValue:'weekly'}, {localized:{boxLabel:'WVA_Monthly'}, inputValue:'monthly'}], listeners:{change:function(radioGroup, newValue, oldValue) {
  var container = radioGroup.up('webcamcustomslideshow'), cards = container.down('[reference\x3dcsRecurrenceTypeCards]');
  cards.getLayout().setActiveItem(newValue.csRecurrenceType + 'Card');
}}}, {xtype:'component', flex:1}, {xtype:'panel', cls:'cs-panel', reference:'csRecurrenceTypeCards', layout:{type:'card'}, width:300, height:230, defaults:{padding:5}, bind:{disabled:'{!hasTargetTime}'}, items:[{itemId:'dailyCard', xtype:'container', layout:{type:'vbox'}, items:[{xtype:'container', layout:{type:'hbox', align:'middle'}, items:[{xtype:'numberfield', ui:'detail-form', reference:'csRecurrenceX', localized:{fieldLabel:'WVA_Recur every'}, labelWidth:75, labelSeparator:'', width:145, value:1, 
minValue:1}, {xtype:'label', ui:'detail-form', localized:{text:'WVA_day(s)'}, margin:'0 0 0 5'}]}, {flex:1, border:0}]}, {itemId:'weeklyCard', xtype:'container', layout:{type:'vbox'}, items:[{xtype:'container', layout:{type:'hbox', align:'middle'}, items:[{xtype:'numberfield', ui:'detail-form', reference:'csRecurrenceX', localized:{fieldLabel:'WVA_Recur every'}, labelWidth:75, labelSeparator:'', width:145, value:1, minValue:1}, {xtype:'label', ui:'detail-form', localized:{text:'WVA_week(s) on'}, 
margin:'0 0 0 5'}]}, {xtype:'checkboxgroup', reference:'csWeekdays', flex:1, layout:{type:'vbox'}, margin:'5 0 0 0', defaults:{ui:'plain-16', name:'csWeekdays'}, allowBlank:false, items:[{boxLabel:Ext.Date.dayNames[0], inputValue:1}, {boxLabel:Ext.Date.dayNames[1], inputValue:2}, {boxLabel:Ext.Date.dayNames[2], inputValue:3}, {boxLabel:Ext.Date.dayNames[3], inputValue:4}, {boxLabel:Ext.Date.dayNames[4], inputValue:5}, {boxLabel:Ext.Date.dayNames[5], inputValue:6}, {boxLabel:Ext.Date.dayNames[6], 
inputValue:7}]}]}, {itemId:'monthlyCard', xtype:'container', layout:{type:'vbox'}, items:[{xtype:'container', layout:{type:'hbox', align:'middle'}, items:[{xtype:'numberfield', ui:'detail-form', reference:'csDayOfMonth', fieldLabel:'Day', labelWidth:23, labelSeparator:'', width:83, value:15, minValue:1, maxValue:31}, {xtype:'label', ui:'detail-form', text:'of every', margin:'0 5 0 5'}, {xtype:'numberfield', ui:'detail-form', reference:'csRecurrenceX', labelSeparator:'', width:60, value:1, minValue:1}, 
{xtype:'label', ui:'detail-form', text:'month(s)', margin:'0 0 0 5'}]}, {flex:1, border:0}]}]}]}, {xtype:'container', layout:{type:'hbox'}, items:[{flex:1, border:0}, {ui:'orange', xtype:'button', localized:{text:'WVA_Generate'}, margin:'15 2 0 0', handler:function() {
  var container = this.up('window'), vm = container.getViewModel().getParent(), activeWebcam = vm.get('activeWebcam'), webcamPosition = vm.get('selectedWebcamPosition'), archivePositionID = webcamPosition.get('ArchivePositionID') || 0;
  var params = {start:Ext.Date.format(container.down('[reference\x3dcsStartDate]').getValue(), 'Y-m-d'), end:Ext.Date.format(container.down('[reference\x3dcsEndDate]').getValue(), 'Y-m-d'), stype:container.down('[reference\x3dcsSelectionType]').getGroupValue()};
  if (params.stype == 'time') {
    params.rtype = container.down('[reference\x3dcsSelectionRadioGroup]').getValue().csRecurrenceType;
    if (params.rtype == 'weekly') {
      params.wd = container.down('[reference\x3dcsWeekdays]').getValue().csWeekdays;
      if (params.wd === undefined) {
        Ext.Msg.alert('Validation Error', 'At least one day of the week most be chosen.');
        return;
      }
    }
    var card = container.down('[reference\x3dcsRecurrenceTypeCards]').getLayout().getActiveItem();
    params.h = container.down('[reference\x3dcsHour]').getValue();
    params.m = container.down('[reference\x3dcsMinute]').getValue();
    params.x = card.down('[reference\x3dcsRecurrenceX]').getValue();
    if (params.rtype == 'monthly') {
      params.d = container.down('[reference\x3dcsDayOfMonth]').getValue();
    }
  }
  vm.set('photoGroup', Ext.create('floorplanViewer.model.PhotoGroup', {'Identifier':activeWebcam.getId(), 'Type':'C', 'ArchivePositionID':archivePositionID, 'SlideshowDetails':params, 'ParentPhoto':vm.get('activeOrParentPhoto')}));
  vm.set('activePhoto', null);
  container.hide();
}}]}]}], listeners:{afterrender:function(container) {
  var vm = this.getViewModel(), activeWebcam = vm.get('activeWebcam'), selectedWebcamPosition = vm.get('selectedWebcamPosition'), startDateField = container.down('[reference\x3dcsStartDate]'), endDateField = container.down('[reference\x3dcsEndDate]');
  if (!activeWebcam) {
    return;
  }
  var recentPhotoDate = new Date(activeWebcam.get('MostRecentPhotoDate'));
  if (selectedWebcamPosition && selectedWebcamPosition.get('MostRecentPhotoDate')) {
    recentPhotoDate = new Date(selectedWebcamPosition.get('MostRecentPhotoDate'));
  }
  startDateField.setValue(Ext.Date.add(recentPhotoDate, Ext.Date.MONTH, -1));
  endDateField.setValue(recentPhotoDate);
}}}, 0, ['webcamcustomslideshow'], ['component', 'box', 'container', 'panel', 'window', 'webcamcustomslideshow'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true, 'webcamcustomslideshow':true}, ['widget.webcamcustomslideshow'], 0, [photoViewer.view.webcam, 'WebcamCustomSlideshow'], 0);
Ext.cmd.derive('photoViewer.view.mainpanel.PhotoViewerBottomPanel', Ext.Container, {mvPreloadImages:['mds/image/component/expand-up.svg', 'mds/image/icon/slideshow-on.png'], width:'100%', height:131, padding:'0 10 0 20', margin:'14 0 0 0', layout:'vbox', viewModel:{formulas:{shootLockVisible:function(get) {
  return !get('photoThumbsCollapsed') && get('shootLockAvailable');
}, webcamThumbsHeaderVisible:function(get) {
  return !get('photoThumbsCollapsed') && get('activeWebcam');
}, slideshowButtonVisible:function(get) {
  return !get('photoThumbsCollapsed') && get('activePhoto');
}, webcamDatePickerVisible:function(get) {
  return false;
}, gridViewVisible:function(get) {
  return !get('photoThumbsCollapsed') && get('activeStream') && get('webcams.totalCount') > 1;
}}}, items:[{xtype:'container', layout:'hbox', width:'100%', height:31, padding:'6 0 0 0', items:[{xtype:'container', width:200, items:[{xtype:'shootlocktoggle', cls:'transparent', hidden:true, bind:{lockMode:'{lockMode}', hidden:'{!shootLockVisible}'}}, {xtype:'webcamthumbsheader', hidden:true, bind:{hidden:'{!webcamThumbsHeaderVisible}'}}]}, {xtype:'component', flex:1}, {xtype:'container', itemId:'bottomBarExpandTab', layout:{type:'hbox', pack:'center'}, width:100, items:[{xtype:'expandtab', scale:'medium', 
iconAlign:'center', width:11, height:6, margin:'2 0 0 0', listeners:{'click':{fn:function() {
  var vm = this.up('photoviewer').getViewModel();
  vm.set('photoThumbsCollapsed', !vm.get('photoThumbsCollapsed'));
}}}}]}, {xtype:'component', flex:1}, {xtype:'container', width:200, layout:{type:'hbox', pack:'end'}, items:[{xtype:'container', layout:{type:'hbox', align:'middle', pack:'end'}, dock:'right', width:133, items:[{xtype:'button', itemId:'slideshowButton', cls:'slideshow-button', width:22, height:14, ui:'plain', enableToggle:true, hidden:true, listeners:{toggle:'onSlideshowToggle'}, tooltip:{localized:{text:'PV_Toggle Slideshow'}, anchor:'top'}, bind:{hidden:'{!slideshowButtonVisible}'}}, {xtype:'button', 
cls:'customize-ss-button', margin:'0 0 0 10', ui:'plain', width:22, hidden:true, bind:{hidden:'{!webcamDatePickerVisible}'}, tooltip:{localized:{text:'WVA_Customize'}, anchor:'top'}, handler:'onCustomWebcamArchiveClick'}, {xtype:'button', itemId:'gridViewButton', cls:'gridview-button', width:22, ui:'plain', hidden:true, bind:{hidden:'{!gridViewVisible}'}, tooltip:{localized:{text:'WV_Grid View'}, anchor:'top'}, handler:'onGridViewButtonClick'}]}]}]}, {reference:'thumbsContainer', xtype:'photoviewerthumbs', 
padding:'0 10 0 0', hidden:true, bind:{hidden:'{!activePhoto}'}}, {xtype:'webcamviewerthumbs', padding:'0 10 0 0', hidden:true, bind:{hidden:'{!activeStream}'}}]}, 0, ['photoviewerbottompanel'], ['component', 'box', 'container', 'photoviewerbottompanel'], {'component':true, 'box':true, 'container':true, 'photoviewerbottompanel':true}, ['widget.photoviewerbottompanel'], 0, [photoViewer.view.mainpanel, 'PhotoViewerBottomPanel'], 0);
Ext.cmd.derive('photoViewer.view.mainpanel.PhotoViewerFloorplanCloseView', floorplanViewer.view.floorplanViewer.FloorplanViewer, {reference:'largeFloorplanViewer', showMiniMap:false, showHotspotComments:true, showSelectionLayer:false, showZoomControls:false, showHovers:false, showPhotoThumbs:false, showTitle:false, showLegend:false, showMapTools:false, openPins:false, width:'100%', height:'100%', cls:'mv-light-load-mask', animateOptions:{pan:{animate:true, duration:0.5, easeLinearity:0.1}, zoom:{animate:true}}}, 
0, ['photoviewerfloorplanclose'], ['component', 'box', 'container', 'clientFloorplanViewerDisp', 'photoviewerfloorplanclose'], {'component':true, 'box':true, 'container':true, 'clientFloorplanViewerDisp':true, 'photoviewerfloorplanclose':true}, ['widget.photoviewerfloorplanclose'], 0, [photoViewer.view.mainpanel, 'PhotoViewerFloorplanCloseView'], 0);
Ext.cmd.derive('photoViewer.view.mainpanel.PhotoViewerMainPanel', Ext.Container, {flex:1, layout:{type:'vbox'}, items:[{xtype:'container', layout:'hbox', width:'100%', flex:1, items:[{xtype:'photocontainer', reference:'photoContainer', flex:1, height:'100%', listeners:{resize:'onPhotoContainerResize'}}, {xtype:'panel', layout:'fit', height:'100%', width:'50%', hidden:true, cls:'close-floorplan-wrapper', bind:{hidden:'{!largeFloorplanVisible}', style:{visibility:'{largeFloorplanVisible}'}}, resizable:{handles:'w', 
pinned:true, dynamic:true}, items:[{xtype:'photoviewerfloorplanclose'}]}]}, {xtype:'photoviewerbottompanel', reference:'photoViewerThumbs'}]}, 0, ['photoviewermainpanel'], ['component', 'box', 'container', 'photoviewermainpanel'], {'component':true, 'box':true, 'container':true, 'photoviewermainpanel':true}, ['widget.photoviewermainpanel'], 0, [photoViewer.view.mainpanel, 'PhotoViewerMainPanel'], 0);
Ext.cmd.derive('photoViewer.view.mainpanel.PhotoViewerThumbs', Ext.Container, {width:'100%', statics:{leftOffset:42}, height:Ext.isChrome ? 91 : 92, layout:{type:'hbox', align:'middle'}, initComponent:function() {
  this.items = [{xtype:'container', width:7, margin:'0 15 0 0', items:[{xtype:'button', cls:'prev-thumb-button', width:7, height:21, ui:'plain', iconAlign:'left', listeners:{click:function() {
    this.up('photoviewerthumbs').scroll(-1);
  }}, bind:{hidden:'{!prevActive}'}}]}, {xtype:'container', itemId:'thumbWrapper', cls:'thumb-wrapper', flex:1, items:[{xtype:'dataview', bind:'{photoStore}', itemSelector:'.photo', height:Ext.isChrome ? 91 : 92, flex:1, cls:'thumb-container', loadMask:null, selectionModel:false, selectedCls:'', tpl:new Ext.XTemplate('\x3ctpl for\x3d"."\x3e\x3ctpl if\x3d"LoadedImage"\x3e\x3cdiv class\x3d"photo {SelectedCls} {FavouriteCls} {[this.commentCls(values)]} {[this.activeCls(values)]}"', 'style\x3d"background-image: url(\'{LoadedImage}\')"\x3e', 
  '\x3cdiv class\x3d"photo-list-control-button select"\x3e\x3c/div\x3e', '\x3ctpl if\x3d"CommentCount"\x3e\x3cdiv class\x3d"has-comments photo-info tip"\x3e{CommentCount}\x3c/div\x3e\x3c/tpl\x3e', '\x3ctpl if\x3d"HasAnnotations"\x3e\x3cdiv class\x3d"has-annotations photo-info tip"\x3e\x3c/div\x3e\x3c/tpl\x3e', '\x3ctpl if\x3d"IsInteriorPano"\x3e', '\x3cdiv class\x3d"has-pano interior-pano photo-info tip"\x3e\x3c/div\x3e', '\x3c/tpl\x3e', '\x3ctpl if\x3d"IsPano"\x3e', '\x3cdiv class\x3d"has-pano aerial-pano photo-info tip"\x3e\x3c/div\x3e', 
  '\x3c/tpl\x3e', '\x3c/div\x3e\x3ctpl elseif\x3d"LoadedImage\x3d\x3d\x3d0"\x3e\x3cdiv class\x3d"photo error"\x3e\x3cdiv class\x3d"message"\x3emvstr[PT_Failed to load image]\x3c/div\x3e\x3c/div\x3e', '\x3ctpl else\x3e\x3cdiv class\x3d"photo"\x3e\x3c/div\x3e\x3c/tpl\x3e\x3c/tpl\x3e', {commentCls:function(values) {
    return values.CommentCount ? '' : 'no-comments';
  }, activeCls:function(values) {
    return values.Active ? 'is-active' : '';
  }}), listeners:{itemclick:'onThumbClick', resize:{fn:'onThumbsResize', buffer:100}}}], listeners:{afterrender:function(dataview) {
    var parent = this.up('photoviewerthumbs');
    parent.tip1 = Ext.create('Ext.tip.ToolTip', Ext.mergeIf({target:this.getId(), delegate:'.tip', listeners:{beforeshow:{fn:parent.onTooltipBeforeShow, scope:parent}}}, photoViewer.view.photoviewer.PhotoViewer.defaultTooltipConfig));
    parent.tip2 = Ext.create('Ext.tip.ToolTip', Ext.mergeIf({target:this.getId(), delegate:'.photo', listeners:{beforeshow:{fn:parent.onTooltipBeforeShow, scope:parent}}}, photoViewer.view.photoviewer.PhotoViewer.defaultTooltipConfig));
  }}}, {xtype:'container', width:7, margin:'0 0 0 15', items:[{xtype:'button', cls:'next-thumb-button', width:7, height:21, ui:'plain', iconAlign:'right', listeners:{click:function() {
    this.up('photoviewerthumbs').scroll(1);
  }}, bind:{hidden:'{!nextActive}'}}]}];
  Ext.container.Container.prototype.initComponent.apply(this, arguments);
}, getScrollButtonAmount:function() {
  return this.getWidth() - 137;
}, scrollTo:function(x, animate) {
  if (this.deferredScrollTo) {
    this.deferredScrollTo.destroy();
  }
  var dataview = this.down('dataview'), thumbs = this.el.select('.photo').elements, lastThumb = Ext.fly(thumbs[thumbs.length - 1]), lastThumbLeft = lastThumb.getOffsetsTo(dataview)[0], lastThumbRight = lastThumbLeft + lastThumb.getWidth(), minX = (lastThumbRight - dataview.el.getWidth()) * -1;
  if (dataview.el.getWidth() === lastThumbRight && dataview.el.getWidth() > dataview.up('photoviewerthumbs').getWidth()) {
    this.deferredScrollTo = dataview.addListener('resize', this.scrollTo, this, {args:[x, animate], destroyable:true});
    return;
  }
  x = Math.max(minX, x);
  if (thumbs.length < this.getNThumbsPerPage()) {
    x = this.self.leftOffset;
  }
  this.pendingX = x;
  if (animate) {
    var change = Math.abs(x - dataview.el.getX());
    dataview.el.setX(x, {duration:750 * (change / this.getScrollButtonAmount()), stopAnimation:true, scope:this});
  } else {
    dataview.el.setX(x);
  }
  var pageStartX = Math.abs(x - this.self.leftOffset), pageEndX = pageStartX + dataview.el.getWidth(), vm = this.lookupViewModel();
  vm.set('nextActive', lastThumbRight > pageEndX);
  vm.set('prevActive', x < this.self.leftOffset);
  vm.set('firstScrollDone', true);
}, getPageNumber:function(x) {
  x = x === undefined ? this.down('dataview').el.getX() : x;
  return Math.ceil((x - this.self.leftOffset) * -1 / this.getScrollButtonAmount());
}, scroll:function(direction) {
  var dataview = this.down('dataview'), currentX = this.pendingX;
  if (currentX === undefined) {
    currentX = dataview.getX();
  }
  var newX = Math.min(this.self.leftOffset, currentX + this.getScrollButtonAmount() * (direction * -1));
  this.scrollTo(newX, true);
  this.lookupViewModel().set('thumbPage', this.getPageNumber(newX));
}, gotoThumb:function(thumbIndex) {
  if (this.deferredGotoThumb) {
    this.deferredGotoThumb.destroy();
  }
  var vm = this.lookupViewModel(), thumbs = this.el.select('.photo').elements, thumbEl = Ext.fly(thumbs[thumbIndex]), dataview = this.down('dataview');
  if (!thumbEl) {
    this.deferredGotoThumb = dataview.addListener('refresh', this.gotoThumb, this, {args:[thumbIndex], destroyable:true});
    return;
  }
  var thumbLeft = thumbEl.getOffsetsTo(dataview)[0], thumbRight = thumbLeft + thumbEl.getWidth(), currentX = dataview.getX(), pageStartX = Math.abs(currentX - this.self.leftOffset), pageEndX = pageStartX + this.down('dataview').el.getWidth(), newX = (thumbLeft - this.self.leftOffset - 7) * -1;
  if (thumbLeft < pageStartX || thumbRight > pageEndX || !vm.get('firstScrollDone')) {
    this.scrollTo(newX);
  }
}, thumbVisible:function(thumbIndex) {
  var thumbs = this.el.select('.photo').elements, thumbEl = Ext.fly(thumbs[thumbIndex]);
  if (!thumbEl) {
    return false;
  }
  var dataview = this.down('dataview'), thumbLeft = thumbEl.getOffsetsTo(dataview)[0], thumbRight = thumbLeft + thumbEl.getWidth(), currentX = dataview.getX(), pageStartX = Math.abs(currentX - this.self.leftOffset), pageEndX = pageStartX + this.down('dataview').el.getWidth();
  return thumbRight >= pageStartX && thumbLeft <= pageEndX;
}, onTooltipBeforeShow:function(tip) {
  var el = Ext.fly(tip.triggerElement), photoEl, message = '', dataview = this.down('dataview'), photoEls = dataview.el.select('.photo').elements, record = null;
  if (el.hasCls('photo')) {
    photoEl = el;
  } else {
    photoEl = el.up('.photo');
  }
  if (photoEl && photoEl.dom) {
    record = dataview.getStore().getAt(photoEls.indexOf(photoEl.dom));
  }
  if (!record) {
    return false;
  }
  if (el.hasCls('aerial-pano')) {
    message = mvstr['PT_AerialPano'];
  } else {
    if (el.hasCls('interior-pano')) {
      message = mvstr['PT_InteriorPano'];
    } else {
      if (el.hasCls('has-annotations')) {
        message = mvstr['PT_Photo is annotated'];
      } else {
        if (el.hasCls('has-comments')) {
          message = mvstr['PT_{x} comment(s)'].replace('{x}', record.get('CommentCount'));
        } else {
          if (el.hasCls('favourite-btn')) {
            message = record.get('IsFavourite') ? mvstr['PT_Remove this photo fro'] : mvstr['PT_Add this photo to my '];
          } else {
            if (el.hasCls('photo')) {
              message = record.get('title');
            }
          }
        }
      }
    }
  }
  if (tip == this.tip1) {
    this.tip2.hide();
  }
  tip.update(message);
}, getNThumbsPerPage:function() {
  var width = this.down('dataview').el.getWidth(), thumbWidth = 123, selectedThumbWidth = 137, margin = 4;
  return Math.floor((width - (selectedThumbWidth + margin)) / (thumbWidth + margin)) + 1;
}}, 0, ['photoviewerthumbs'], ['component', 'box', 'container', 'photoviewerthumbs'], {'component':true, 'box':true, 'container':true, 'photoviewerthumbs':true}, ['widget.photoviewerthumbs'], 0, [photoViewer.view.mainpanel, 'PhotoViewerThumbs'], 0);
Ext.cmd.derive('photoViewer.view.mainpanel.WebcamThumbsHeader', Ext.container.Container, {layout:{type:'hbox'}, hidden:true, defaults:{margin:'0 5 0 0'}, items:[{xtype:'label', localized:{html:'WV_More Webcams'}, cls:'bottom-panel-label', hidden:true, bind:{hidden:'{!activeStream}'}}, {xtype:'button', cls:'datetime-selector', text:'', arrowCls:'calendar', hidden:true, bind:{hidden:'{!activePhoto}', text:'{activePhoto.PhotoDate:date("DATE_Medium2")}'}, menu:{shadow:false, cls:'webcam-calendar-menu', 
items:[{xtype:'datepicker', reference:'webcamPhotoDatePicker', ui:'mds-dark', width:200, showToday:false, bind:{value:'{activePhoto.PhotoDate}'}, listeners:{select:function(picker, value) {
  var vm = picker.up('photoviewer').getViewModel(), photoGroup = vm.get('photoGroup').getData();
  photoGroup.StartDate = value;
  photoGroup.Type = 'W';
  vm.set('photoGroup', Ext.create('floorplanViewer.model.PhotoGroup', photoGroup));
}}}]}}, {xtype:'combo', reference:'webcamPhotoTimeCombo', ui:'webcam-time', queryMode:'local', editable:false, valueField:'PhotoDate', shadow:false, listConfig:{cls:'webcam-time-boundlist', shadow:false}, hidden:true, bind:{hidden:'{!activePhoto}', value:'{activePhoto}', store:'{photoStore}'}, valuePublishEvent:'', tpl:Ext.create('Ext.XTemplate', '\x3ctpl for\x3d"."\x3e', '\x3cdiv class\x3d"x-boundlist-item"\x3e{PhotoDate:date("g:i A")}\x3c/div\x3e', '\x3c/tpl\x3e'), displayTpl:Ext.create('Ext.XTemplate', 
'\x3ctpl for\x3d"."\x3e', '{PhotoDate:date("g:i A")}', '\x3c/tpl\x3e'), listeners:{select:function(combo, record) {
  combo.up('photoviewer').getViewModel().set('activePhoto', record);
}}}]}, 0, ['webcamthumbsheader'], ['component', 'box', 'container', 'webcamthumbsheader'], {'component':true, 'box':true, 'container':true, 'webcamthumbsheader':true}, ['widget.webcamthumbsheader'], 0, [photoViewer.view.mainpanel, 'WebcamThumbsHeader'], 0);
Ext.cmd.derive('photoViewer.view.mainpanel.WebcamViewerThumbs', Ext.Container, {width:'100%', statics:{leftOffset:42}, height:Ext.isChrome ? 91 : 92, layout:{type:'hbox', align:'middle'}, initComponent:function() {
  this.items = [{xtype:'container', width:7, margin:'0 15 0 0', items:[{xtype:'button', cls:'prev-thumb-button', width:7, height:21, ui:'plain', iconAlign:'left', listeners:{click:function() {
    this.up('webcamviewerthumbs').scroll(-1);
  }}, bind:{hidden:'{!prevActive}'}}]}, {xtype:'container', itemId:'thumbWrapper', cls:'thumb-wrapper', flex:1, items:[{xtype:'dataview', bind:'{webcams}', itemSelector:'.webcam', height:Ext.isChrome ? 91 : 92, flex:1, cls:'thumb-container', loadMask:null, selectionModel:false, selectedCls:'', tpl:new Ext.XTemplate('\x3ctpl for\x3d"."\x3e\x3ctpl if\x3d"ImageURL"\x3e\x3cdiv class\x3d"webcam {[this.activeCls(values)]}"', 'style\x3d"background-image: url(\'{ImageURL}\')"\x3e', '\x3c/div\x3e\x3ctpl elseif\x3d"ImageURL\x3d\x3d\x3d0"\x3e\x3cdiv class\x3d"webcam error"\x3e\x3cdiv class\x3d"message"\x3emvstr[PT_Failed to load image]\x3c/div\x3e\x3c/div\x3e', 
  '\x3ctpl else\x3e\x3cdiv class\x3d"webcam"\x3e\x3c/div\x3e\x3c/tpl\x3e\x3c/tpl\x3e', {activeCls:function(values) {
    return values.Active ? 'is-active' : '';
  }}), listeners:{itemclick:'onWebcamThumbClick', resize:{fn:'onThumbsResize', buffer:100}}}]}, {xtype:'container', width:7, margin:'0 0 0 15', items:[{xtype:'button', cls:'next-thumb-button', width:7, height:21, ui:'plain', iconAlign:'right', listeners:{click:function() {
    this.up('webcamviewerthumbs').scroll(1);
  }}, bind:{hidden:'{!nextActive}'}}]}];
  Ext.container.Container.prototype.initComponent.apply(this, arguments);
}, getScrollButtonAmount:function() {
  return this.getWidth() - 137;
}, scrollTo:function(x, animate) {
  var dataview = this.down('dataview'), thumbs = this.el.select('.webcam').elements, lastThumb = Ext.fly(thumbs[thumbs.length - 1]), lastThumbLeft = lastThumb.getOffsetsTo(dataview)[0], lastThumbRight = lastThumbLeft + lastThumb.getWidth(), minX = (lastThumbRight - dataview.el.getWidth()) * -1;
  x = Math.max(minX, x);
  if (thumbs.length < this.getNThumbsPerPage()) {
    x = this.self.leftOffset;
  }
  this.pendingX = x;
  if (animate) {
    var change = Math.abs(x - dataview.el.getX());
    dataview.el.setX(x, {duration:750 * (change / this.getScrollButtonAmount()), stopAnimation:true, scope:this});
  } else {
    dataview.el.setX(x);
  }
  var pageStartX = Math.abs(x - this.self.leftOffset), pageEndX = pageStartX + dataview.el.getWidth(), vm = this.lookupViewModel();
  vm.set('nextActive', lastThumbRight > pageEndX);
  vm.set('prevActive', x < this.self.leftOffset);
  vm.set('firstScrollDone', true);
}, getPageNumber:function(x) {
  x = x === undefined ? this.down('dataview').el.getX() : x;
  return Math.ceil((x - this.self.leftOffset) * -1 / this.getScrollButtonAmount());
}, scroll:function(direction) {
  var dataview = this.down('dataview'), currentX = this.pendingX;
  if (currentX === undefined) {
    currentX = dataview.getX();
  }
  var newX = Math.min(this.self.leftOffset, currentX + this.getScrollButtonAmount() * (direction * -1));
  this.scrollTo(newX, true);
  this.lookupViewModel().set('thumbPage', this.getPageNumber(newX));
}, gotoThumb:function(thumbIndex) {
  if (this.deferredGotoThumb) {
    this.deferredGotoThumb.destroy();
  }
  var vm = this.lookupViewModel(), thumbs = this.el.select('.webcam').elements, thumbEl = Ext.fly(thumbs[thumbIndex]), dataview = this.down('dataview');
  if (!thumbEl) {
    this.deferredGotoThumb = dataview.addListener('refresh', this.gotoThumb, this, {args:[thumbIndex], destroyable:true});
    return;
  }
  var thumbLeft = thumbEl.getOffsetsTo(dataview)[0], thumbRight = thumbLeft + thumbEl.getWidth(), currentX = dataview.getX(), pageStartX = Math.abs(currentX - this.self.leftOffset), pageEndX = pageStartX + this.down('dataview').el.getWidth(), newX = (thumbLeft - this.self.leftOffset - 7) * -1;
  if (thumbLeft < pageStartX || thumbRight > pageEndX || !vm.get('firstScrollDone')) {
    this.scrollTo(newX);
  }
}, thumbVisible:function(thumbIndex) {
  var thumbs = this.el.select('.webcam').elements, thumbEl = Ext.fly(thumbs[thumbIndex]);
  if (!thumbEl) {
    return false;
  }
  var dataview = this.down('dataview'), thumbLeft = thumbEl.getOffsetsTo(dataview)[0], thumbRight = thumbLeft + thumbEl.getWidth(), currentX = dataview.getX(), pageStartX = Math.abs(currentX - this.self.leftOffset), pageEndX = pageStartX + this.down('dataview').el.getWidth();
  return thumbRight >= pageStartX && thumbLeft <= pageEndX;
}, getNThumbsPerPage:function() {
  var width = this.down('dataview').el.getWidth(), thumbWidth = 123, selectedThumbWidth = 137, margin = 4;
  return Math.floor((width - (selectedThumbWidth + margin)) / (thumbWidth + margin)) + 1;
}}, 0, ['webcamviewerthumbs'], ['component', 'box', 'container', 'webcamviewerthumbs'], {'component':true, 'box':true, 'container':true, 'webcamviewerthumbs':true}, ['widget.webcamviewerthumbs'], 0, [photoViewer.view.mainpanel, 'WebcamViewerThumbs'], 0);
Ext.cmd.derive('photoViewer.view.measurements.PhotoViewerMeasurementTools', Ext.Container, {reference:'measureTW', hidden:true, floating:true, shadow:false, draggable:true, layout:{type:'vbox', align:'middle', pack:'center'}, width:262, height:79, padding:15, defaultAlign:'bc-bc?', alignOffset:[0, -20], viewModel:{formulas:{text:function(get) {
  switch(get('measureStep')) {
    case photoViewer.Values.MSR_ZERO_POINTS:
      return mvstr['PM_Click on the photo to'];
    case photoViewer.Values.MSR_ONE_POINTS:
      return mvstr['PM_Click on the photo to'];
    case photoViewer.Values.MSR_TWO_POINTS:
      return mvstr['PM_Click Calculate to ge'];
    case photoViewer.Values.MSR_CALCULATING:
      return mvstr['PM_Calculating...'];
    case photoViewer.Values.MSR_DONE:
      return mvstr['PM_Measurement'] + ': ' + get('measurementString');
  }
  return '';
}, actionText:function(get) {
  switch(get('measureStep')) {
    case photoViewer.Values.MSR_TWO_POINTS:
    case photoViewer.Values.MSR_CALCULATING:
      return mvstr['PM_Calculate'];
    case photoViewer.Values.MSR_DONE:
      return mvstr['PM_Save'];
  }
  return '';
}, canClear:function(get) {
  return get('measureStep') > photoViewer.Values.MSR_ONE_POINTS;
}, buttonsVisible:function(get) {
  return !!(get('actionText') || get('canClear'));
}}}, bind:{disabled:'{gettingCmiLength}'}, items:[{xtype:'component', cls:'instructions', bind:{html:'{text}'}}, {xtype:'container', layout:{type:'hbox', pack:'middle'}, hidden:true, bind:{hidden:'{!buttonsVisible}'}, defaults:{xtype:'button', width:70, height:25, scale:'small'}, padding:'13 0 0 0', items:[{localized:{text:'PM_Clear'}, ui:'grey', bind:{hidden:'{!canClear}'}, margin:'0 10 0 0', listeners:{click:'clearActiveMeasurement'}}, {ui:'orange', bind:{text:'{actionText}', hidden:'{!actionText}'}, 
listeners:{click:'doMeasurementAction'}}]}]}, 0, ['photoviewermeasurementtools'], ['component', 'box', 'container', 'photoviewermeasurementtools'], {'component':true, 'box':true, 'container':true, 'photoviewermeasurementtools':true}, ['widget.photoviewermeasurementtools'], 0, [photoViewer.view.measurements, 'PhotoViewerMeasurementTools'], 0);
Ext.cmd.derive('photoViewer.view.pannellum.PannellumController', Ext.app.ViewController, {config:{viewerReady:false, listeningForMovement:false, lastPhoto:{hotspotID:0, yaw:0}}, init:function() {
  var vm = this.getViewModel();
  this.getView().up('photocontainer').on('resize', this.onPannellumResize, this);
  vm.bind({floorplanModeOn:'{floorplanModeOn}'}, function(data) {
    this.removeMarkerLayer(true);
    this.checkFloorplanReady();
  }, this);
}, clear:function() {
  if (this.viewer) {
    this.createMarkerLayer();
    this.setViewerReady(false);
    this.viewer.destroy();
  }
}, getViewModel:function() {
  return this.getView().lookupViewModel();
}, setupViewer:function() {
  if (this.viewer) {
    this.clear();
  }
  if (this.pannellumScriptLoaded) {
    return this.setupViewer2();
  }
  Ext.Loader.loadScript({url:'mds/lib/pannellum/pannellum.js', onLoad:function() {
    this.pannellumScriptLoaded = true;
    this.setupViewer();
  }, scope:this});
}, setupViewer2:function() {
  var me = this;
  var view = this.getView();
  var viewModel = this.getViewModel();
  var photo = viewModel.get('activePhoto');
  var initialYaw = 0;
  if (!!me.getLastPhoto().hotspotID && !!photo.get('HotspotID') && photo.get('HotspotID') == me.getLastPhoto().hotspotID) {
    initialYaw = me.getLastPhoto().yaw;
  }
  mdsAjax.doAjaxRequest({url:'index.cfm?fuseaction\x3dpannellumViewer.getBase64Image\x26Identifier\x3d' + photo.get('Identifier') + '\x26FloorplanUID\x3d' + photo.get('FloorplanUID'), successCallback:function(data) {
    var imageURL = photo.get('ImageURL');
    if (typeof data.base64Str !== 'undefined') {
      var binaryString = window.atob(data.base64Str);
      var binaryLen = binaryString.length;
      var fileContent = new Uint8Array(binaryLen);
      for (var i = 0; i < binaryLen; i++) {
        var ascii = binaryString.charCodeAt(i);
        fileContent[i] = ascii;
      }
      var blob = new Blob([fileContent], {type:'application/octet-stream'});
      imageURL = window.URL.createObjectURL(blob);
    }
    me.viewer = pannellum.viewer(view.getId(), {type:'equirectangular', panorama:imageURL, preview:photo.get('ImageURL'), autoLoad:true, showControls:false, compass:false, hfov:180, yaw:initialYaw}).on('load', function() {
      me.getLastPhoto().hotspotID = photo.get('HotspotID') || 0;
      me.checkFloorplanReady();
    }).on('mousedown', function() {
      me.setListeningForMovement(true);
      me.startMovingMarkerFOV();
    }).on('mouseup', function() {
      me.setListeningForMovement(false);
    });
  }, failure:function() {
    Ext.Msg.alert('Error', 'Error loading base64Image data.');
  }, scope:me});
}, startMovingMarkerFOV:function() {
  if (this.getListeningForMovement()) {
    this.updateMarkerFOV();
    setTimeout(this.startMovingMarkerFOV.bind(this), 100);
  }
}, getViewerAngle:function() {
  var hotspot = this.getHotspot();
  if (hotspot && hotspot.properties.hotspotType == '360pano') {
    if (this.viewer !== undefined) {
      var yaw = this.viewer.getYaw();
      var direction = Ext.Number.from(hotspot.properties.media.split('_')[1]);
      if (Ext.isNumber(direction)) {
        this.getLastPhoto().yaw = yaw;
        return direction + yaw;
      }
    }
  }
}, takeScreenShot:function() {
  var viewer = this.viewer;
  if (this.viewer !== undefined) {
    return new Ext.Promise(function(resolve, reject) {
      var pitch = viewer.getPitch() * Math.PI / 180;
      var yaw = viewer.getYaw() * Math.PI / 180;
      var hfov = viewer.getHfov() * Math.PI / 180;
      var shot = viewer.getRenderer().render(pitch, yaw, hfov, {returnImage:true});
      if (shot) {
        resolve(shot);
      } else {
        reject();
      }
    });
  }
  return null;
}, onPannellumResize:function() {
  var viewer = this.viewer;
  if (viewer) {
    try {
      this.viewer.resize();
    } catch (ex) {
      console.log("Couldn't resize pannellum viewer: ", ex.message);
    }
  }
}}, 0, 0, 0, 0, ['controller.pannellum'], [[photoViewer.controller.PanoramaMarkerController.prototype.mixinId || photoViewer.controller.PanoramaMarkerController.$className, photoViewer.controller.PanoramaMarkerController]], [photoViewer.view.pannellum, 'PannellumController'], 0);
Ext.cmd.derive('photoViewer.view.pannellum.Pannellum', Ext.Component, {controller:'pannellum', reference:'pannellum'}, 0, ['pannellum'], ['component', 'box', 'pannellum'], {'component':true, 'box':true, 'pannellum':true}, ['widget.pannellum'], 0, [photoViewer.view.pannellum, 'Pannellum'], 0);
Ext.cmd.derive('photoViewer.view.photo.PhotoController', Ext.app.ViewController, {init:function() {
  app.addListener('photoviewerbeforeloadphoto', this.onBeforeLoadPhoto, this);
  this.addListener('triggerdisplayannotations', this._displayAnnotations, this, {buffer:100});
  Ext.getBody().addListener('keydown', this.onKeyPress, this);
  var vm = this.getViewModel();
  vm.bind('{toolSettings.strokeColour}', this.setSelectedShapeStrokeColour, this);
  vm.bind({drawMode:'{drawMode}'}, function(data) {
    this.onDrawModeChange(data.drawMode != photoViewer.Values.DRAW_OFF);
  }, this);
  vm.bind({drawMode:'{annotating}'}, this.onAnnotatingChange, this, {delay:1});
  vm.bind({annoStoreLoaded:'{annoProps.storeLoaded}', naturalWidth:'{naturalWidth}', naturalHeight:'{naturalHeight}'}, function(data) {
    if (data.naturalWidth && data.naturalHeight && data.annoStoreLoaded && this.getViewModel().get('drawMode') == photoViewer.Values.DRAW_OFF) {
      this.displayAnnotations();
    }
  }, this);
  vm.bind({naturalWidth:'{naturalWidth}', naturalHeight:'{naturalHeight}'}, this.onPhotoSizeChange, this);
  vm.bind('{annoProps.toggledOn}', function(toggledOn) {
    this.updateAnnotationsVisibility(!toggledOn);
  }, this);
  vm.bind('{selectedDrawing}', this.onSelectedDrawingChange, this);
}, onBoxReady:function() {
  var view = this.getView(), cancelFunc = function(e) {
    if (view.shapeInCreation) {
      return;
    }
    this.callParent(arguments);
  };
  Ext.override(view.dd, {onMouseMove:cancelFunc});
}, onBeforeLoadPhoto:function() {
  this.getViewModel().set('annoProps.storeLoaded', !this.getViewModel().get('activePhoto.HasDrawables'));
}, removeAllDrawables:function() {
  var drawablesStore = this.getViewModel().get('drawablesStore');
  if (drawablesStore) {
    drawablesStore.each(function(record) {
      if (record.shape) {
        record.shape.destroy();
      }
    });
  }
}, displayAnnotations:function() {
  this.fireEvent('triggerdisplayannotations');
}, _displayAnnotations:function() {
  var vm = this.getViewModel(), store = vm.get('drawablesStore'), drawMode = vm.get('drawMode');
  if (!store || store.isLoading()) {
    if (this.displayAnnotationsTimeout) {
      clearTimeout(this.displayAnnotationsTimeout);
    }
    this.displayAnnotationsTimeout = setTimeout(Ext.bind(this.displayAnnotations, this), 100);
    return;
  }
  var showMeasurements = !vm.get('annotating'), showAnnotations = !vm.get('measuring');
  this.removeAllDrawables();
  if (vm.get('annoProps.toggledOn') || drawMode != photoViewer.Values.DRAW_OFF) {
    store.each(function(rec) {
      if (showMeasurements && rec.get('Type') == 'measure' || showAnnotations && rec.get('Type') != 'measure') {
        rec.createShape(this.getView());
      }
    }, this);
  }
  vm.set('drawingReady', true);
}, onPhotoSizeChange:function(data) {
  this.removeAllDrawables();
  this.getView().surface.el.dom.setAttribute('viewBox', '0,0,' + data.naturalWidth + ',' + data.naturalHeight);
}, updateAnnotationsVisibility:function(isHidden) {
  if (!this._init_updateAnnotationsVisibility) {
    this._init_updateAnnotationsVisibility = true;
    return;
  }
  if (isHidden) {
    this.removeAllDrawables();
  } else {
    this.displayAnnotations();
  }
}, updateAnnotationVisibility:function(record, isHidden) {
  if (!record.shape) {
    return;
  }
  if (isHidden === undefined) {
    isHidden = !record.get('Visible');
  }
  if (!record.get('Visible')) {
    isHidden = true;
  }
  if (isHidden) {
    record.shape.hide(true);
  } else {
    record.shape.show(true);
  }
}, getStore:function() {
  return this.getViewModel().get('annotationStore');
}, onDrawModeChange:function(annotating) {
  this.getViewModel().set('readOnly', !annotating);
}, onAnnotatingChange:function() {
  if (!this._init_onAnnotatingChange) {
    this._init_onAnnotatingChange = true;
    return;
  }
  this.displayAnnotations();
}, onMouseDown:function(e) {
  var view = this.getView(), mode = this.getViewModel().get('toolSettings.mode'), readOnly = this.getViewModel().get('readOnly');
  if (readOnly || mode == 'select') {
    view.addCls('dragging');
  }
  if (readOnly) {
    return;
  }
  if (this.deselectAll()) {
    return false;
  }
  e.preventDefault();
  var xy = this.getRelativeDescaledXYFromMouseEvent(e);
  view.descaledXY = xy;
  view.pageXY = [e.browserEvent.pageX, e.browserEvent.pageY];
  if (mode == 'select') {
    view.isDragging = true;
    return false;
  } else {
    var uppercaseMode = mode.substring(0, 1).toUpperCase() + mode.substring(1);
    view.shapeInCreation = Ext.create('photoViewer.view.annotations.shapes.' + uppercaseMode, {drawComponent:this.getView(), isNew:true});
    view.shapeInCreationClickXY = xy;
    view.shapeInCreationPrevXY = xy;
  }
  return false;
}, onMouseMove:function(e) {
  var vm = this.getViewModel(), view = this.getView();
  if (vm.get('measuring')) {
    var measureStep = vm.get('measureStep');
    if (measureStep == photoViewer.Values.MSR_ZERO_POINTS) {
      return false;
    }
    if (measureStep == photoViewer.Values.MSR_ONE_POINTS && view.shapeInCreation) {
      var pointHandle = view.shapeInCreation.get('pointHandle1');
      view.shapeInCreation.changePointOnDragHandle(pointHandle.dd, pointHandle, e);
      return false;
    }
  }
  view.pageXY = [e.browserEvent.pageX, e.browserEvent.pageY];
  if (view.isDragging) {
    return false;
  }
  if (view.shapeInCreation) {
    var xy = this.getRelativeDescaledXYFromMouseEvent(e), dx = xy[0] - view.shapeInCreationPrevXY[0], dy = xy[1] - view.shapeInCreationPrevXY[1];
    view.shapeInCreationPrevXY = xy;
    var mode = this.getViewModel().get('toolSettings.mode');
    if (mode == 'ellipse' || mode == 'rectangle' || mode == 'textbox') {
      var clickDX = xy[0] - view.shapeInCreationClickXY[0], clickDY = xy[1] - view.shapeInCreationClickXY[1], handlePosition = view.shapeInCreationHandlePosition;
      if (!view.shapeInCreationHandleDX) {
        view.shapeInCreationHandleDX = clickDX;
      }
      if (!view.shapeInCreationHandleDY) {
        view.shapeInCreationHandleDY = clickDY;
      }
      if (handlePosition === undefined) {
        if (view.shapeInCreationHandleDX < 0) {
          if (view.shapeInCreationHandleDY < 0) {
            handlePosition = 7;
          } else {
            if (view.shapeInCreationHandleDY > 0) {
              handlePosition = 5;
            } else {
              handlePosition = 6;
            }
          }
        } else {
          if (view.shapeInCreationHandleDX > 0) {
            if (view.shapeInCreationHandleDY < 0) {
              handlePosition = 1;
            } else {
              if (view.shapeInCreationHandleDY > 0) {
                handlePosition = 3;
              } else {
                handlePosition = 2;
              }
            }
          } else {
            if (view.shapeInCreationHandleDY < 0) {
              handlePosition = 0;
            } else {
              handlePosition = 4;
            }
          }
        }
        if (view.shapeInCreationHandleDX && view.shapeInCreationHandleDY) {
          view.shapeInCreationHandlePosition = handlePosition;
        }
      }
      view.shapeInCreation.resizeShape(xy, handlePosition);
    } else {
      if (mode == 'line' || mode == 'arrow' || mode == 'measure') {
        view.shapeInCreation.movePointHandle(1, xy[0], xy[1]);
      } else {
        if (mode == 'text') {
          view.shapeInCreation.translate(dx, dy);
        } else {
          if (mode == 'pen') {
            view.shapeInCreation.drawPath(dx, dy, e);
          }
        }
      }
    }
  }
  return false;
}, onMouseUp:function(e) {
  var vm = this.getViewModel(), view = this.getView();
  view.removeCls('dragging');
  if (vm.get('measuring') && vm.get('measureStep') == photoViewer.Values.MSR_ZERO_POINTS) {
    vm.set('measureStep', photoViewer.Values.MSR_ONE_POINTS);
    view.shapeInCreation.refreshSelectionSprites();
    return false;
  }
  if (vm.get('readOnly')) {
    return;
  }
  if (view.pendingDataChangeShape) {
    view.pendingDataChangeShape.fireEvent('datachanged');
    view.pendingDataChangeShape = null;
  }
  if (view.isDragging) {
    view.isDragging = false;
    return false;
  }
  if (view.shapeInCreation) {
    if (view.shapeInCreation.isTooSmall()) {
      view.shapeInCreation.destroy();
    } else {
      var selectButton = this.getView().up('photoviewer').lookupReference('annotationsTW').getController().lookupReference('annotationsSelectButton');
      selectButton.fireEvent('click', selectButton);
      var newAnnotation = Ext.create('photoViewer.model.Annotation', {ShareTypeID:vm.get('defaultShareTypeID'), MemberUIDArray:[], MemberFirstName:vm.get('account.MemberFirstName'), MemberLastName:vm.get('account.MemberLastName'), IsMetric:vm.get('usingMetric')});
      newAnnotation.setShape(view.shapeInCreation);
      view.shapeInCreation.onCreate();
      this.getViewModel().get('writeDrawablesStore').add(newAnnotation);
      vm.set('selectedDrawing', newAnnotation);
      if (newAnnotation.get('Type') == 'measure') {
        this.onAddMeasurement(newAnnotation);
      }
      if (typeof view.shapeInCreation.afterMove == 'function') {
        view.shapeInCreation.afterMove();
      }
      view.shapeInCreation.onDragHandleMouseUp();
    }
    view.shapeInCreation = null;
    view.shapeInCreationHandlePosition = undefined;
    view.shapeInCreationHandleDX = undefined;
    view.shapeInCreationHandleDY = undefined;
  }
  return false;
}, onKeyPress:function(e) {
  var viewModel = this.getViewModel();
  if (!viewModel.get('drawing') || e.getTarget().tagName == 'TEXTAREA') {
    return;
  }
  var i, annotationsStore = viewModel.get('drawablesStore'), count = annotationsStore.count(), annotation, selectedShape = null;
  for (i = 0; i < count; i++) {
    annotation = annotationsStore.getAt(i);
    if (annotation.shape.isSelected) {
      selectedShape = annotation.shape;
      break;
    }
  }
  if (selectedShape === null) {
    return;
  }
  selectedShape.handleKeyPress(e, i);
}, onModeChange:function(mode) {
  if (mode != 'select') {
    this.deselectAll();
  }
}, setSelectedShapeStrokeColour:function(colourValue) {
  var selectedShape = this.getSelectedShape();
  if (selectedShape) {
    selectedShape.setColour(colourValue);
  }
}, setSelectedShapeStrokeWidth:function(newValue) {
  var selectedShape = this.getSelectedShape();
  if (selectedShape && newValue != selectedShape.getAttribute('stroke-width')) {
    selectedShape.setStrokeWidth(newValue);
  }
}, setSelectedShapeStrokeStyle:function(newValue) {
  var selectedShape = this.getSelectedShape();
  if (selectedShape && newValue != selectedShape.getAttribute('style')) {
    selectedShape.setStrokeStyle(newValue);
  }
}, setRecordSelectedShapeShareType:function(ShareTypeID, MemberUIDArray) {
  var model = this.getSelectedModel();
  if (model) {
    if (model.get('ShareTypeID') != ShareTypeID) {
      model.set('ShareTypeID', ShareTypeID);
    }
    if (model.get('MemberUIDArray').join(',') != MemberUIDArray.join(',')) {
      model.set('MemberUIDArray', MemberUIDArray.slice());
    }
  }
}, setSelectedShapeFontSize:function(newValue) {
  var selectedShape = this.getSelectedShape();
  if (selectedShape && Ext.Array.contains(selectedShape.shapeAttributes, 'font-size') && newValue != selectedShape.getAttribute('font-size')) {
    selectedShape.setFontSize(newValue);
  }
}, onShapeSelect:function(shape) {
  if (shape.getType() == 'measure') {
    return;
  }
  var viewModel = this.getViewModel();
  viewModel.set('toolSettings.strokeWidth', shape.getAttribute('stroke-width'));
  viewModel.set('toolSettings.strokeColour', shape.getAttribute('stroke'));
  viewModel.set('toolSettings.strokeStyle', shape.getAttribute('style'));
  if (Ext.Array.contains(shape.shapeAttributes, 'font-size')) {
    viewModel.set('toolSettings.fontSize', shape.getAttribute('font-size'));
  }
  viewModel.set('toolSettings.selectedShapes', [shape]);
}, onShapeDeselect:function(shape) {
  this.getViewModel().set('toolSettings.selectedShapes', []);
}, deselectAll:function(ignoredShape) {
  if (!this.getView().up('photoviewer').lookupController().beforeDrawableSelectionChange()) {
    return false;
  }
  if (!ignoredShape || ignoredShape.record != this.getViewModel().get('selectedDrawing')) {
    this.getViewModel().set('selectedDrawing', null);
  }
  var annotationsStore = this.getViewModel().get('drawablesStore'), count = annotationsStore.count(), deselectedSomething = false;
  for (var i = 0; i < count; i++) {
    var annotation = annotationsStore.getAt(i);
    if (!ignoredShape || annotation.shape != ignoredShape) {
      deselectedSomething = annotation.shape.deselect() || deselectedSomething;
    }
  }
  return deselectedSomething;
}, getRelativeDescaledXYFromMouseEvent:function(e) {
  var bounds = this.getView().el.getBox();
  var xy = [], scale = this.getViewModel().get('scale');
  xy[0] = (e.browserEvent.clientX - bounds.left) / scale;
  xy[1] = (e.browserEvent.clientY - bounds.top) / scale;
  return xy;
}, getSelectedShape:function() {
  var annotationsStore = this.getViewModel().get('drawablesStore');
  if (!annotationsStore) {
    return null;
  }
  var count = annotationsStore.count();
  for (var i = 0; i < count; i++) {
    var annotation = annotationsStore.getAt(i);
    if (annotation.shape.isSelected) {
      return annotation.shape;
    }
  }
  return null;
}, getSelectedModel:function() {
  var annotationsStore = this.getViewModel().get('drawablesStore'), count = annotationsStore.count();
  for (var i = 0; i < count; i++) {
    var annotation = annotationsStore.getAt(i);
    if (annotation.shape.isSelected) {
      return annotation;
    }
  }
  return null;
}, getRelativeRealXYFromMouseEvent:function(e) {
  var bounds = this.getView().el.getBox(), xy = [];
  xy[0] = e.browserEvent.clientX - bounds.left;
  xy[1] = e.browserEvent.clientY - bounds.top;
  return xy;
}, onResetPhotoPosition:function(scale) {
  var store = this.getViewModel().get('activeDrawablesStore');
  if (store && store.getCount()) {
    if (this.getView().surface.items.length) {
      store.each(function(record) {
        if (record.shape) {
          record.shape.onZoomChange(scale);
        }
      });
    } else {
      if (store.isLoaded()) {
        this.displayAnnotations();
      }
    }
  }
  var svg = this.getView().surface.el.dom;
  svg.setAttribute('width', '100%');
  svg.setAttribute('height', '100%');
}, onDoubleClick:function(e) {
  var viewModel = this.getViewModel();
  if (!viewModel.get('photoState.fullImageLoaded') || viewModel.get('drawing')) {
    return;
  }
  var photo = this.getView(), pageBox = photo.el.getBox(), point = e.getPoint(), overPhoto = !(point.y < pageBox.top || point.x > pageBox.right || point.y > pageBox.bottom || point.x < pageBox.left), pointRelativeX = overPhoto ? point.x - pageBox.x : undefined, pointRelativeY = overPhoto ? point.y - pageBox.y : undefined;
  this.getView().up('photoviewer').lookupController().lookupReference('photoContainer').getController().zoom(1, pointRelativeX, pointRelativeY);
}, getAnnotationShareButton:function() {
  return Ext.ComponentQuery.query('photoviewerannotationstoolwindow shareWithButton')[0];
}, onAddMeasurement:function(measure) {
  this.getViewModel().set('measureStep', photoViewer.Values.MSR_TWO_POINTS);
  this.getViewModel().set('toolSettings.mode', 'select');
  this.getViewModel().set('activeMeasurement', measure);
}, onSelectedDrawingChange:function(record) {
  if (record && record.shape) {
    record.shape.select();
  }
}, onPhotoDragStart:function() {
  app.fireEvent('slideshowinterrupt');
}, onPhotoDragEnd:function() {
}}, 0, 0, 0, 0, ['controller.photo'], 0, [photoViewer.view.photo, 'PhotoController'], 0);
Ext.cmd.derive('photoViewer.view.photo.Photo', photoViewer.draw.Component, {controller:'photo', reference:'photo', draggable:{listeners:{dragstart:function() {
  Ext.getCmp(this.dragTarget.getId()).lookupController().onPhotoDragStart();
}, dragend:function() {
  Ext.getCmp(this.dragTarget.getId()).lookupController().onPhotoDragEnd();
}}}, shadow:false, zIndex:0, viewBox:false, pageXY:null, descaledXY:null, shapeInCreation:null, shapeInCreationClickXY:null, shapeInCreationPrevXY:null, statics:{styleSettings:{normal:'', dotted:'5,5', dashed:'10,10'}}, setZIndex:function() {
  return;
}, getScale:function() {
  return this.lookupViewModel().get('scale');
}, getReadOnly:function() {
  return this.lookupViewModel().get('readOnly');
}, getNaturalWidth:function() {
  return this.lookupViewModel().get('naturalWidth');
}, getNaturalHeight:function() {
  return this.lookupViewModel().get('naturalHeight');
}, listeners:{boxready:'onBoxReady', mousedown:'onMouseDown', mousemove:'onMouseMove', mouseup:'onMouseUp', el:{doubletap:'onDoubleClick', scope:'self.controller'}}}, 0, ['viewerphoto'], ['component', 'box', 'viewerphoto'], {'component':true, 'box':true, 'viewerphoto':true}, ['widget.viewerphoto'], 0, [photoViewer.view.photo, 'Photo'], 0);
Ext.cmd.derive('photoViewer.view.photocontainer.PhotoContainerController', Ext.app.ViewController, {statics:{zoomMin:0, zoomMax:20, zoomFactor:1.25}, zoomCount:0, defaultWidth:0, defaultHeight:0, init:function() {
  var vm = this.getViewModel();
  vm.bind({mediumWidth:'{activePhoto.MediumWidth}'}, function() {
    this.resetPhotoDisplay();
  }, this);
  vm.bind({fullImageLoaded:'{photoState.fullImageLoaded}', activePhoto:'{activePhoto}', naturalWidth:'{activePhoto.OriginalsWidth}', naturalHeight:'{activePhoto.OriginalsHeight}'}, function(data) {
    if (data.fullImageLoaded && data.activePhoto && data.naturalWidth && data.naturalHeight) {
      this.resetPhotoDisplay(!data.activePhoto.pvInitialized);
      data.activePhoto.pvInitialized = true;
    }
  }, this);
  app.addListener('photoviewerbeforeloadphoto', this.onBeforeLoadPhoto, this);
  this.sw360 = app.getController('photoViewer.controller.SiteWalk360Controller');
  this.sw360.viewModel = this.getView().up('photoviewer').getViewModel();
  this.sw360.on('showcaseconnected', this.showcaseConnected, this);
}, getMainViewModel:function() {
  return this.getView().up('photoviewer').getViewModel();
}, showcaseConnected:function(on) {
  this.getMainViewModel().set('interiorPanoShowcaseConnected', on);
}, onBeforeLoadPhoto:function(newPhoto) {
  var viewModel = this.getViewModel();
  viewModel.set('photoData.id', newPhoto.get('id'));
  viewModel.set('photoData.photoId', newPhoto.getId());
  viewModel.set('photoData.nComments', newPhoto.get('CommentCount'));
  viewModel.set('annoProps.hasAnnotations', !!newPhoto.get('HasAnnotations'));
  var isPano = !!newPhoto.get('IsPano');
  var isInteriorPano = !!newPhoto.get('IsInteriorPano');
  var is360Pano = newPhoto.get('Is360Pano');
  viewModel.set('photoState.isPano', isPano);
  viewModel.set('photoState.isInteriorPano', isInteriorPano);
  viewModel.set('photoState.is360Pano', is360Pano);
  if (isPano) {
    var rootPath = newPhoto.get('ImageURLThumb');
    var rootPathArray = rootPath.split('/');
    var path = rootPathArray.slice(0, 6).join('/') + '/pano/processed/index.html';
    viewModel.set('photoData.panoHome', path);
  }
  if (is360Pano) {
    this.lookupReference('pannellum').lookupController().setupViewer();
  } else {
    this.lookupReference('pannellum').lookupController().clear();
  }
  this.getMainViewModel().set('photoState.fullImageLoaded', false);
}, onBoxReady:function(photoContainer) {
  photoContainer.body.unselectable();
  var photo = this.lookupReference('photo'), stream = this.lookupReference('webcamLiveStream');
  photo.setWidth(photoContainer.getWidth());
  photo.setHeight(photoContainer.getHeight());
  if (mdsUtil.Browser.isMouseEventSupported('wheel')) {
    photo.el.addListener('wheel', this.onMouseWheel, this);
    stream.el.addListener('wheel', this.onLivestreamMouseWheel, this);
  } else {
    photo.el.addListener('mousewheel', this.onMouseWheel, this);
    stream.el.addListener('mousewheel', this.onLivestreamMouseWheel, this);
  }
  photo.show();
}, onMouseWheel:function(e, t) {
  if (!this.getViewModel().get('photoState.fullImageLoaded')) {
    return;
  }
  app.fireEvent('mouseWheelZoom', this.getView(), e, t);
  var photo = this.lookupReference('photo'), pageBox = photo.el.getBox(), point = e.getPoint(), overPhoto = !(point.y < pageBox.top || point.x > pageBox.right || point.y > pageBox.bottom || point.x < pageBox.left), pointRelativeX = overPhoto ? point.x - pageBox.x : undefined, pointRelativeY = overPhoto ? point.y - pageBox.y : undefined, increment = e.getWheelDelta() >= 0 ? 1 : -1;
  this.zoom(increment, pointRelativeX, pointRelativeY);
}, onLivestreamMouseWheel:function(e, t) {
  var activeStream = this.getMainViewModel().get('activeStream'), stream = this.lookupReference('webcamLiveStream'), pageBox = stream.el.getBox(), point = e.getPoint(), overPhoto = !(point.y < pageBox.top || point.x > pageBox.right || point.y > pageBox.bottom || point.x < pageBox.left), pointRelativeX = overPhoto ? point.x - pageBox.x : undefined, pointRelativeY = overPhoto ? point.y - pageBox.y : undefined, increment = e.getWheelDelta() >= 0 ? 1 : -1;
  if (activeStream && !activeStream.WebcamPTZEnabled) {
    stream.zoom(increment, pointRelativeX, pointRelativeY);
    var zoomPointX = 0, zoomPointY = 0;
    if (increment > 0) {
      zoomPointX = pointRelativeX * this.self.zoomFactor;
      zoomPointY = pointRelativeY * this.self.zoomFactor;
    } else {
      if (stream.localScale <= 100) {
        return;
      }
      zoomPointX = pointRelativeX / this.self.zoomFactor;
      zoomPointY = pointRelativeY / this.self.zoomFactor;
    }
    stream.setXY([pageBox.x - (zoomPointX - pointRelativeX), pageBox.y - (zoomPointY - pointRelativeY)]);
  }
}, onContextMenu:function(e) {
  e.preventDefault();
  if (!this.getViewModel().get('drawing') && this.getViewModel().get('activePhoto')) {
    this.getView().up('photoviewer').getController().showContextMenu(e);
  }
  return false;
}, zoom:function(increment, pointRelativeX, pointRelativeY) {
  if (!this.getViewModel().get('photoState.fullImageLoaded')) {
    return;
  }
  app.fireEvent('slideshowinterrupt');
  var photo = this.lookupReference('photo'), pageBox = photo.el.getBox(), zoomPointX = 0, zoomPointY = 0;
  if (pointRelativeX === undefined) {
    pointRelativeX = pageBox.width / 2;
  }
  if (pointRelativeY === undefined) {
    pointRelativeY = pageBox.height / 2;
  }
  if (increment > 0) {
    if (this.zoomCount == this.self.zoomMax) {
      return;
    }
    zoomPointX = pointRelativeX * this.self.zoomFactor;
    zoomPointY = pointRelativeY * this.self.zoomFactor;
  } else {
    if (this.zoomCount == this.self.zoomMin) {
      this.resetPhotoDisplay(false, true);
      return;
    }
    zoomPointX = pointRelativeX / this.self.zoomFactor;
    zoomPointY = pointRelativeY / this.self.zoomFactor;
  }
  this.zoomCount += increment;
  var newZoomFactor = this.zoomCount >= 0 ? Math.pow(this.self.zoomFactor, this.zoomCount) : Math.pow(1 / this.self.zoomFactor, this.zoomCount), newWidth = this.defaultWidth * newZoomFactor, newHeight = this.defaultHeight * newZoomFactor;
  var scale = newWidth / this.getViewModel().get('naturalWidth');
  this.getViewModel().set('scale', scale);
  photo.setWidth(newWidth);
  photo.setHeight(newHeight);
  photo.setXY([pageBox.x - (zoomPointX - pointRelativeX), pageBox.y - (zoomPointY - pointRelativeY)]);
  photo.getController().onResetPhotoPosition(scale);
}, zoomIn:function() {
  if (this.getMainViewModel().get('activeStream')) {
    this.lookupReference('webcamLiveStream').zoom(1);
  } else {
    this.zoom(1);
  }
}, zoomOut:function() {
  if (this.getMainViewModel().get('activeStream')) {
    this.lookupReference('webcamLiveStream').zoom(-1);
  } else {
    this.zoom(-1);
  }
}, getDefaultPhotoDimenstions:function() {
  var activePhotoMediumWidth = this.getMainViewModel().get('activePhoto.MediumWidth'), activePhotoMediumHeight = this.getMainViewModel().get('activePhoto.MediumHeight'), photoContainer = this.getView(), containerWidth = photoContainer.body.getWidth(), containerHeight = photoContainer.body.getHeight(), fullSizedMediumWidth = containerWidth, fullSizedMediumHeight = containerHeight;
  if (activePhotoMediumWidth && fullSizedMediumHeight) {
    fullSizedMediumHeight = containerHeight;
    fullSizedMediumWidth = Math.round(activePhotoMediumWidth * (fullSizedMediumHeight / activePhotoMediumHeight));
    if (fullSizedMediumWidth > containerWidth) {
      fullSizedMediumWidth = containerWidth;
      fullSizedMediumHeight = Math.round(activePhotoMediumHeight * (fullSizedMediumWidth / activePhotoMediumWidth));
    }
  }
  return {width:fullSizedMediumWidth, height:fullSizedMediumHeight};
}, resetPhotoDisplay:function(initial, noPositionChange) {
  var photo = this.lookupReference('photo'), naturalWidth = this.getMainViewModel().get('naturalWidth'), photoContainer = this.getView(), containerWidth = photoContainer.body.getWidth(), containerHeight = photoContainer.body.getHeight(), photoContainerXY = photoContainer.body.getXY(), defaultDimensions = this.getDefaultPhotoDimenstions(), scale = naturalWidth ? defaultDimensions.width / naturalWidth : 1;
  if (this.getMainViewModel().get('activeStream')) {
    var livestream = this.lookupReference('webcamLiveStream');
    livestream.localZoom(100);
    livestream.setXY([Math.round((containerWidth - livestream.getWidth()) / 2 + photoContainerXY[0]), Math.round((containerHeight - livestream.getHeight()) / 2 + photoContainerXY[1])]);
    return;
  }
  photo.setWidth(defaultDimensions.width);
  photo.setHeight(defaultDimensions.height);
  this.getMainViewModel().set('scale', scale);
  if (!noPositionChange) {
    photo.setXY([Math.round((containerWidth - defaultDimensions.width) / 2 + photoContainerXY[0]), Math.round((containerHeight - defaultDimensions.height) / 2 + photoContainerXY[1])]);
  }
  if (!initial) {
    photo.getController().onResetPhotoPosition(scale);
  }
  this.zoomCount = 0;
  this.defaultWidth = defaultDimensions.width;
  this.defaultHeight = defaultDimensions.height;
}, centerPhoto:function() {
  if (this.zoomCount == 0) {
    this.resetPhotoDisplay();
  } else {
    var photo = this.lookupReference('photo'), photoWidth = photo.el.getWidth(), photoHeight = photo.el.getHeight(), photoContainer = this.getView(), containerWidth = photoContainer.body.getWidth(), containerHeight = photoContainer.body.getHeight(), photoContainerXY = photoContainer.body.getXY();
    photo.setXY([photoWidth > containerWidth ? photo.el.getX() : Math.round((containerWidth - photoWidth) / 2 + photoContainerXY[0]), photoHeight > containerHeight ? photo.el.getY() : Math.round((containerHeight - photoHeight) / 2 + photoContainerXY[1])]);
  }
}, switchImageSize:function(newWidth, newHeight) {
  var vm = this.getViewModel(), photo = this.lookupReference('photo'), photoContainer = this.getView(), containerWidth = photoContainer.body.getWidth(), containerHeight = photoContainer.body.getHeight(), defaultScale = newWidth ? Math.min(containerWidth / newWidth, containerHeight / newHeight) : 1, defaultWidth = newWidth ? newWidth * defaultScale : containerWidth, defaultHeight = newHeight ? newHeight * defaultScale : containerHeight, scale = photo.el.getWidth() / newWidth;
  vm.set('scale', scale);
  Ext.defer(function() {
    photo.lookupController().onResetPhotoPosition();
  }, 1);
  this.defaultWidth = defaultWidth;
  this.defaultHeight = defaultHeight;
  this.zoomCount = Math.round(Math.log(scale / defaultScale) / Math.log(this.self.zoomFactor));
}, onShapeSelect:function(shapes) {
}, syncShapes:function(newShape, oldShape) {
  newShape.setColour(oldShape.getAttribute('stroke'));
  newShape.setStrokeWidth(oldShape.getAttribute('stroke-width'));
  newShape.setStrokeStyle(oldShape.getAttribute('style'));
  if (Ext.Array.contains(oldShape.shapeAttributes, 'font-size') && Ext.Array.contains(newShape.shapeAttributes, 'font-size')) {
    newShape.setFontSize(oldShape.getAttribute('font-size'));
  }
}, siteWalkTakeScreenShot:function(resolution) {
  return this.sw360.takeScreenShot(resolution);
}, pannellumTakeScreenshot:function() {
  return this.lookupReference('pannellum').lookupController().takeScreenShot();
}, siteWalkGetPose:function() {
  return this.sw360.getPose();
}, getPannellumViewerAngle:function() {
  return this.lookupReference('pannellum').lookupController().getViewerAngle();
}, nextPhoto:function() {
  this.getView().up('photoviewer').getController().nextPhoto();
}, prevPhoto:function() {
  this.getView().up('photoviewer').getController().prevPhoto();
}, onResize:function() {
  var vm = this.getViewModel();
  if (vm.get('photoState.fullImageLoaded') && vm.get('activePhoto') && vm.get('naturalWidth') && vm.get('naturalHeight')) {
    this.centerPhoto();
  }
  if (vm.get('activeStream')) {
    this.lookupReference('webcamLiveStream').resize();
    var streampositioncontrols = this.lookupReference('streampositioncontrols');
    if (streampositioncontrols) {
      streampositioncontrols.controller.handleResize();
    }
  }
}, onFullscreenClick:function() {
  var fullscreen = this.getViewModel().get('fullscreen');
  if (this.getViewModel().get('activeStream')) {
    if (fullscreen) {
      document.exitFullscreen();
    } else {
      var element = this.getView().body.dom;
      var requestMethod = element.requestFullScreen || element.webkitRequestFullScreen || element.mozRequestFullScreen || element.msRequestFullScreen;
      if (requestMethod) {
        requestMethod.call(element);
      }
    }
  }
}, pvWebcamPositionSelected:function(combo, record) {
  this.getView().up('photoviewer').getController().onSelectedWebcamPositionChange(record);
}, webcamLiveStreamDragStart:function() {
  var vm = this.getMainViewModel();
  return vm.get('activeStream') && !vm.get('activeStream').WebcamPTZEnabled;
}, onUAVPanoLoadOrError:function() {
  if (this.getViewModel().get('photoState.isPano')) {
    analytics.Ctrl.log('Viewed Photo', {}, ['Photo ID', 'Photo Type', 'Photo ID with Prefix']);
  }
}}, 0, 0, 0, 0, ['controller.photocontainer'], 0, [photoViewer.view.photocontainer, 'PhotoContainerController'], 0);
Ext.cmd.derive('photoViewer.view.positioncontrols.WebcamPositionSelector', Ext.form.field.ComboBox, {height:29, width:120, alwaysOnTop:2, style:{zIndex:2}, displayField:'Name', editable:false, cls:'camera-presets', listConfig:{cls:'photo-viewer-camera-presets', shadow:false}, bind:{store:'{webcamPositions}', value:'{_selectedArchivePosition}'}, listeners:{select:'pvWebcamPositionSelected'}}, 0, ['webcampositionselector'], ['component', 'box', 'field', 'textfield', 'pickerfield', 'combobox', 'combo', 
'webcampositionselector'], {'component':true, 'box':true, 'field':true, 'textfield':true, 'pickerfield':true, 'combobox':true, 'combo':true, 'webcampositionselector':true}, ['widget.webcampositionselector'], 0, [photoViewer.view.positioncontrols, 'WebcamPositionSelector'], 0);
Ext.cmd.derive('photoViewer.view.photocontainer.PhotoContainer', Ext.panel.Panel, {config:{loadMaskCls:'dark-load-indicator'}, controller:'photocontainer', layout:'absolute', bind:{disabled:'{viewerDisabled}'}, items:[{xtype:'viewerphoto', reference:'photo', bind:{hidden:'{isPhotoHidden}'}, listeners:{shapesync:'syncShapes', shapeSelect:'onShapeSelect'}}, {xtype:'uxiframe', id:'panophoto', bind:{visible:'{photoState.isPano}', src:'{photoData.panoHome}'}, renderTpl:['\x3ciframe src\x3d"{src}" id\x3d"{id}-iframeEl" data-ref\x3d"iframeEl" name\x3d"{frameName}" width\x3d"100%" height\x3d"100%" frameborder\x3d"0" allowFullScreen\x3d"true"\x3e\x3c/iframe\x3e'], 
width:'100%', height:'100%', setSrc:function(url) {
  this.load(url);
}, listeners:{error:'onUAVPanoLoadOrError', load:'onUAVPanoLoadOrError'}}, {id:'interiorPanoFrame', xtype:'uxiframe', loadMask:null, bind:{visible:'{interiorPanoFrameVisible}', src:'{interiorPanoUrl}'}, renderTpl:['\x3ciframe src\x3d"{src}" id\x3d"{id}-iframeEl" data-ref\x3d"iframeEl" name\x3d"{frameName}" width\x3d"100%" height\x3d"100%" frameborder\x3d"0" allowFullScreen\x3d"true" allow\x3d"vr"\x3e\x3c/iframe\x3e'], width:'100%', height:'100%', setSrc:function(url) {
  this.load(url);
}}, {xtype:'component', id:'truViewComponent', bind:{visible:'{truViewComponentVisible}'}, width:'100%', height:'100%'}, {xtype:'pannellum', loadMask:null, bind:{visible:'{photoState.is360Pano}'}, width:'100%', height:'100%'}, {xtype:'container', layout:{type:'hbox', align:'center', pack:'center'}, bind:{visible:'{activeStream}'}, items:[{xtype:'webcamlivestream', layout:{type:'vbox', pack:'center'}, reference:'webcamLiveStream', draggable:{listeners:{mousedown:function(draggable) {
  return draggable.comp.lookupController().webcamLiveStreamDragStart();
}}}, showFullscreenButton:false}]}, {xtype:'component', cls:'photo-viewer-video', reference:'webcamTimelapse', height:'100%', bind:{hidden:'{!activeTimelapse}'}}, {xtype:'container', cls:'nextprev-button-container', height:'100%', width:49, items:[{xtype:'button', cls:'prev-photo-button', ui:'plain', iconAlign:'right', width:49, height:64, padding:20, margin:'-32 0 0 0', style:{position:'absolute', top:'50%', zIndex:2}, listeners:{click:function(button) {
  button.up('photoviewer').lookupController().logNextPrevEvent('prev', 'click');
  button.up('photoviewer').lookupController().prevPhoto();
}}, bind:{hidden:'{!nextPrevButtonsVisible}'}}]}, {xtype:'container', cls:'nextprev-button-container', width:49, height:'100%', style:{top:0, right:0}, items:[{xtype:'button', cls:'next-photo-button', ui:'plain', iconAlign:'left', width:49, height:64, padding:20, margin:'-32 0 0 0', style:{position:'absolute', top:'50%', zIndex:2}, listeners:{click:function(button) {
  button.up('photoviewer').lookupController().logNextPrevEvent('next', 'click');
  button.up('photoviewer').lookupController().nextPhoto();
}}, bind:{hidden:'{!nextPrevButtonsVisible}'}}]}, {xtype:'streampositioncontrols', reference:'streampositioncontrols', hidden:true, bind:{hidden:'{ptzControlsHidden}'}}, {xtype:'container', x:17, y:20, layout:{type:'vbox', align:'center'}, width:120, bind:{width:'{positionControlsWidth}'}, viewModel:{formulas:{positionControlsWidth:function(get) {
  return get('showWebcamPositionSelector') ? 120 : 36;
}}}, defaults:{hidden:true}, items:[{xtype:'photopositioncontrols', bind:{hidden:'{!showPhotoPositionControls}'}}, {xtype:'webcampositionselector', bind:{hidden:'{!showWebcamPositionSelector}'}}]}, {xtype:'photoviewerfullscreentoggle', bind:{pressed:'{fullscreen}', hidden:'{!overlayVisible}'}, listeners:{click:'onFullscreenClick'}}], listeners:{boxready:'onBoxReady', el:{contextmenu:'onContextMenu', scope:'self.controller'}, resize:'onResize'}, getStaticHSpace:function() {
  return 0;
}, getStaticVSpace:function() {
  return 0;
}, onEnable:function() {
  Ext.panel.Panel.prototype.onEnable.apply(this, arguments);
  this.unmask();
}}, 0, ['photocontainer'], ['component', 'box', 'container', 'panel', 'photocontainer'], {'component':true, 'box':true, 'container':true, 'panel':true, 'photocontainer':true}, ['widget.photocontainer'], 0, [photoViewer.view.photocontainer, 'PhotoContainer'], 0);
Ext.cmd.derive('photoViewer.view.photocontainer.PhotoViewerFullscreenToggle', Ext.button.Button, {cls:'full-image-button', width:28, height:20, config:{enableToggle:true}, ui:'plain', icon:'mds/image/icon/fullscreen-enter.png', mvPreloadImages:['mds/image/icon/fullscreen-enter.png'], style:{bottom:'6px', right:'6px'}, tooltip:{localized:{text:'PV_Toggle Fullscreen'}, anchor:'top'}}, 0, ['photoviewerfullscreentoggle'], ['component', 'box', 'button', 'photoviewerfullscreentoggle'], {'component':true, 
'box':true, 'button':true, 'photoviewerfullscreentoggle':true}, ['widget.photoviewerfullscreentoggle'], 0, [photoViewer.view.photocontainer, 'PhotoViewerFullscreenToggle'], 0);
Ext.cmd.derive('photoViewer.view.photomenu.ContextMenu', Ext.menu.Menu, {ui:'dark2', cls:'photo-actions-menu', floating:true, showSeparator:false, shadow:false, defaultMinWidth:103, width:102, defaults:{height:21}, items:[{localized:{text:'PV_Save Photo'}, listeners:{click:'downloadCurrentImage'}}, {localized:{text:'PV_Show Exif Info'}, listeners:{click:'showExifInfo'}}], listeners:{mouseleave:function() {
  this.hide();
}}}, 0, ['photoviewercontextmenu'], ['component', 'box', 'container', 'panel', 'menu', 'photoviewercontextmenu'], {'component':true, 'box':true, 'container':true, 'panel':true, 'menu':true, 'photoviewercontextmenu':true}, ['widget.photoviewercontextmenu'], 0, [photoViewer.view.photomenu, 'ContextMenu'], 0);
Ext.cmd.derive('photoViewer.view.photoviewer.PhotoViewerController', Ext.app.ViewController, {config:{storeSession:null}, slideInterval:4000, canSnapshot:true, flowplayer:null, activeTypes:['activePhoto', 'activeStream', 'activeTimelapse'], init:function() {
  Ext.on('resize', this.onViewerResize, this);
  var toolbarActionsController = window.app.getController('photoActions.controller.ToolbarActions');
  this.oldInterfaceControl = toolbarActionsController.interfaceControl;
  toolbarActionsController.interfaceControl = this;
  this.oldToolbarActionsMainView = toolbarActionsController.mainView;
  toolbarActionsController.mainView = this.getView();
  this.oldExtMsg = Ext.Msg;
  Ext.Msg = Ext.MessageBox = MDS.Msg;
  var vm = this.getViewModel();
  vm.bind('{annotating}', this.onAnnotatingToggle, this);
  vm.bind({activePhoto:'{activePhoto}', photoStore:'{photoStore}', photoStoreLoaded:'{photoStoreLoaded}'}, this.onActivePhotoChange, this);
  vm.bind({FloorplanUID:'{FloorplanUID}'}, function(data) {
    if (data.FloorplanUID) {
      if (data.floorplanModeOn) {
        this.loadFloorplan(this.lookupReference('largeFloorplanViewer').down('fvFloorplanViewer'), data.FloorplanUID);
      } else {
        this.loadFloorplan(this.lookupReference('smallFloorplanView').down('fvFloorplanViewer'), data.FloorplanUID);
      }
    }
  }, this);
  vm.bind({floorplanModeOn:'{floorplanModeOn}'}, function(data) {
    if (!this.floorplanModeOnInitialized) {
      this.floorplanModeOnInitialized = true;
      return;
    }
    if (this.getViewModel().get('FloorplanUID')) {
      var sw360Controller = app.getController('photoViewer.controller.SiteWalk360Controller');
      if (data.floorplanModeOn) {
        this.loadFloorplan(this.lookupReference('largeFloorplanViewer').down('fvFloorplanViewer'), this.getViewModel().get('FloorplanUID'));
      } else {
        this.loadFloorplan(this.lookupReference('smallFloorplanView').down('fvFloorplanViewer'), this.getViewModel().get('FloorplanUID'));
      }
      if (this.getViewModel().get('activePhoto.IsInteriorPano')) {
        sw360Controller.displayPanoMarkersOnFloorplan();
      } else {
        app.getController('photoViewer.controller.SiteWalk360Controller').removePanoLayer();
      }
    }
  }, this);
  vm.bind({largeFloorplanReady:'{largeFloorplanReady}', activePhoto:'{activePhoto}', floorplanModeOn:'{floorplanModeOn}'}, function(data) {
    if (data.largeFloorplanReady && data.activePhoto && data.floorplanModeOn && !this.getViewModel().get('activePhoto.IsInteriorPano')) {
      this.lookupReference('largeFloorplanViewer').down('fvFloorplanViewer').highlight2(data.activePhoto.get('HotspotID'), data.activePhoto.get('PushpinUID'), true);
    }
  }, this);
  vm.bind({smallFloorplanReady:'{smallFloorplanReady}', activePhoto:'{activePhoto}', floorplanModeOn:'{floorplanModeOn}'}, function(data) {
    if (data.smallFloorplanReady && data.activePhoto && !data.floorplanModeOn && !this.getViewModel().get('activePhoto.IsInteriorPano')) {
      this.lookupReference('smallFloorplanView').down('fvFloorplanViewer').highlight2(data.activePhoto.get('HotspotID'), data.activePhoto.get('PushpinUID'), true);
    }
  }, this);
  vm.bind({isInteriorPano:'{activePhoto.IsInteriorPano}', smallFloorplanReady:'{smallFloorplanReady}'}, function(data) {
    if (data.smallFloorplanReady) {
      this.lookupReference('smallFloorplanView').down('fvFloorplanViewer').setPanoHotspotLayerVisible(true);
    }
  }, this);
  vm.bind({isInteriorPano:'{activePhoto.IsInteriorPano}', largeFloorplanReady:'{largeFloorplanReady}'}, function(data) {
    if (data.largeFloorplanReady) {
      this.lookupReference('largeFloorplanViewer').down('fvFloorplanViewer').setPanoHotspotLayerVisible(true);
    }
  }, this);
  var b1 = vm.bind({albumStoreLoaded:'{albumStoreLoaded}', photoGroup:'{photoGroup}', albumStore:'{albumStore}'}, function(data) {
    if (!data.albumStore || !data.albumStoreLoaded || !data.photoGroup) {
      return;
    }
    b1.destroy();
    this.onAlbumStoreLoaded(data.albumStore, data.photoGroup);
  }, this);
  vm.bind({PushpinUID:'{PushpinUID}'}, this.onPushpinChange, this);
  vm.bind({photoGroup:'{photoGroup}'}, this.onPhotoGroupChange, this);
  vm.bind({floorplan:'{lockMode}'}, this.onLockModeChange, this);
  vm.bind({lockMode:'{lockMode}'}, this.onLockModeChange, this);
  vm.bind('{measuring}', this.onMeasuringToggle, this);
  vm.bind({measureStep:'{measureStep}', measuring:'{measuring}'}, this.onMeasuringStepChange, this);
  vm.bind({cachedCmiPhotoID:'{cachedCmiPhotoID}', unalteredImagePhotoID:'{unalteredImagePhotoID}', activePhotoID:'{activePhoto.Identifier}'}, function(data) {
    if (data.cachedCmiPhotoID && data.cachedCmiPhotoID == data.activePhotoID && data.unalteredImagePhotoID && data.unalteredImagePhotoID == data.activePhotoID) {
      this.onMeasuringReady();
    }
  }, this);
  vm.bind('{gettingCmiLength}', this.onGettingCmiLengthChange, this);
  vm.bind('{sidePanelCollapsed}', this.onSidePanelCollapseChange, this);
  vm.bind('{photoThumbsCollapsed}', this.onPhotoThumbsCollapseChange, this);
  vm.bind('{activeMeasurement.Length}', this.onActiveMeasurementLengthChange, this);
  vm.bind('{usingMetric}', this.usingMetricChange, this);
  vm.bind('{thumbPage}', this.onThumbPageChange, this);
  vm.bind('{viewMode}', this.onViewModeChange, this);
  vm.bind('{viewModeButtonValue}', this.onViewModeToggle, this);
  vm.bind('{FloorplanUID}', function(floorplanUID) {
    analytics.Ctrl.setOptionalDefaultEventProperties({'Floorplan UID':floorplanUID});
  }, this);
  vm.bind('{permissionsLoaded}', this.onPermissionsLoaded, this);
  vm.bind({webcamPlaybackReady:'{webcamPlaybackReady}', activeStream:'{activeStream}'}, Ext.bind(function(data) {
    this.getLivestreamWeather();
    if (data.activeStream) {
      if (data.webcamPlaybackReady) {
        this.initStream(data.activeStream);
      } else {
        this.initWebcamPlayback(data.activeStream);
      }
    }
  }, this));
  vm.bind({flowplayerLoaded:'{flowplayerLoaded}', activeTimelapse:'{activeTimelapse}'}, Ext.bind(function(data) {
    if (data.activeTimelapse) {
      if (data.flowplayerLoaded) {
        this.initTimelapsePlayback(data.activeTimelapse);
      } else {
        this.loadFlowplayer();
      }
    }
  }, this));
  vm.bind('{activeWebcam}', function(activeWebcam) {
    if (activeWebcam) {
      this.loadWebcamArchivePositions(activeWebcam);
    }
  }, this);
  vm.bind('{selectedWebcamPosition}', this.loadWebcamPhotoDates, this);
  var view = this.getView();
  if (view.activePhoto) {
    vm.set('activePhoto', view.activePhoto);
  }
  if (view.photoGroup) {
    vm.set('photoGroup', view.photoGroup);
  }
  if (view.standalone !== undefined) {
    vm.set('standalone', view.standalone);
  }
  if (view.standalone !== undefined) {
    vm.set('standalone', view.standalone);
  }
  if (view.ListTypeID !== undefined) {
    vm.set('ListTypeID', view.ListTypeID);
  }
  var webcams = view.webcams;
  if (!webcams) {
    webcams = Ext.create('photoViewer.store.Webcams', {proxy:{extraParams:{ProjectUID:vm.get('ProjectUID')}}, listeners:{load:function() {
      vm.set('_webcamsLoaded', true);
    }}});
  } else {
    vm.set('_webcamsLoaded', true);
  }
  vm.set('webcams', webcams);
  if (!webcams.isLoaded() && !webcams.isLoading()) {
    if (view.WebcamUID) {
      webcams.load();
    } else {
      vm.bind('{photoStoreLoaded}', function(photoStoreLoaded) {
        if (photoStoreLoaded && !vm.get('webcams').isLoaded() && !vm.get('webcams').isLoading()) {
          var photoStore = vm.get('photoStore');
          if (photoStore.query('Type', 'W').length > 0) {
            webcams.load();
          }
        }
      }, this);
    }
  }
  if (!view.photoGroup && view.WebcamUID) {
    Ext.defer(function() {
      this.launchWebcamView(view.WebcamUID);
    }, 1, this);
  }
  this.setStoreSession(view.storeSession || Ext.create('Ext.data.Session'));
  this.pendingPhotoID = view.photoId;
  this.keyNavArrows = new Ext.util.KeyNav({target:Ext.getBody(), left:function(e) {
    this.thumbsArrowKeys(e);
    return true;
  }, right:function(e) {
    this.thumbsArrowKeys(e);
    return true;
  }, scope:this});
  this.lookupReference('measureTW').alignTarget = this.lookupReference('photoContainer');
  this.lookupReference('annotationsTW').alignTarget = this.lookupReference('photoContainer');
  this.control({'fvFloorplanViewer':{'hotspot_click':function(feature, floorplanView) {
    var vm = this.getViewModel(), photoStore = vm.get('photoStore');
    this.mapHotspotID = feature.id;
    vm.set('PushpinUID', null);
    if (!this.mapHotspotID || !photoStore.isLoaded()) {
      return;
    }
    var photo = photoStore.findRecord('HotspotID', this.mapHotspotID);
    if (!photo) {
      this.loadPhotosFromHotspot(this.mapHotspotID);
    } else {
      vm.set('activePhoto', photo);
    }
  }, 'pushpin_click':function(e, feature) {
    var vm = this.getViewModel();
    this.mapHotspotID = feature.id;
    vm.set('PushpinUID', feature.id);
  }, 'map_ready':function(floorplanView) {
    if (floorplanView.up('clientFloorplanViewerDisp').xtype == 'photoviewerfloorplanclose') {
      var minimapFloorplanView = this.lookupReference('minimapFloorplanView');
      if (minimapFloorplanView._mainMap != floorplanView.map) {
        minimapFloorplanView.reinit();
        minimapFloorplanView._mainMap = floorplanView.map;
        floorplanView.addSeparateMiniMap(minimapFloorplanView.map);
      }
      this.getViewModel().set('largeFloorplanReady', true);
    } else {
      this.getViewModel().set('pvFloorplan', floorplanView.lookupViewModel().get('floorplan'));
      this.getViewModel().set('smallFloorplanReady', true);
    }
  }}, 'comments':{commentcountchange:function(info) {
    var photoStore = this.getViewModel().get('photoStore'), photo = photoStore.getAt(photoStore.find('id', info.Identifier));
    if (photo) {
      photo.set('CommentCount', info.nComments);
    }
  }}});
  Ext.tip.QuickTipManager.destroy();
  Ext.tip.QuickTipManager.init(true, {className:'photoViewer.view.photoviewer.PhotoViewerToolTip'});
}, closePhotoViewer:function() {
  if (this.getViewModel().get('standalone')) {
    var referrerQSO = {};
    var photoViewerPages = ['aClientPhotoViewer.view'];
    var split = document.referrer.split('index.cfm');
    if (split.length > 1) {
      referrerQSO = Ext.Object.fromQueryString(split[1]);
    }
    var backFromSwitch = Ext.Object.fromQueryString(document.location.search).backOK == '1';
    if (this.getViewModel().get('activeWebcam') && referrerQSO.fuseaction == 'aClientWebcam.grid') {
      window.location.href = mdslink.clientWebcamOverview + 'ProjectUID\x3d' + this.getViewModel().get('ProjectUID');
      return;
    }
    if (document.referrer && !Ext.Array.contains(photoViewerPages, referrerQSO.fuseaction) || backFromSwitch) {
      if (window.history.length > 1) {
        window.history.back();
      } else {
        window.location.href = document.referrer;
      }
    } else {
      window.location.href = archiverConfig.GATEWAY + '?ProjectUID\x3d' + this.getViewModel().get('ProjectUID');
    }
  } else {
    this.onDestroy();
    this.getView().destroy();
    if (window.app) {
      window.app.fireEvent('photoviewerdestroy');
    }
  }
}, getPhotoComponent:function() {
  return this.lookupReference('photoContainer').lookupController().lookupReference('photo');
}, loadSelectedImage:function() {
  var vm = this.getViewModel(), record = vm.get('activePhoto'), med = '', src = '', imageObjectMed = new Image, imageObject = new Image;
  vm.set('photoState.fullImageLoaded', false);
  vm.set('src', 'mds/image/transparent.png');
  app.fireEvent('photoviewerbeforeloadphoto', record);
  if (!record.get('isPano')) {
    var photoContainerController = this.lookupReference('photoContainer').getController();
    med = record.get('ImageURLMedium');
    src = record.get('ImageURL');
    imageObjectMed.onload = function() {
      if (typeof vm.isDestroyed !== 'undefined' && vm.isDestroyed) {
        return;
      }
      vm.set('src', imageObjectMed.src);
      imageObject.src = src;
      record.set({'MediumWidth':imageObjectMed.naturalWidth, 'MediumHeight':imageObjectMed.naturalHeight});
      var defaultDimensions = photoContainerController.getDefaultPhotoDimenstions();
      imageObject.style.width = defaultDimensions.width + 'px';
      imageObject.style.height = defaultDimensions.height + 'px';
      imageObject.style.width = defaultDimensions.width + 'px';
      imageObject.style.height = defaultDimensions.height + 'px';
      imageObject.style.position = 'fixed';
      imageObject.style.left = '-99999px';
      imageObject.style.top = '-99999px';
      document.body.appendChild(imageObject);
      imageObject.onload = function() {
        if (typeof vm.isDestroyed !== 'undefined' && vm.isDestroyed) {
          return;
        }
        vm.set('src', src);
        record.set('OriginalsWidth', imageObject.naturalWidth);
        record.set('OriginalsHeight', imageObject.naturalHeight);
        vm.set('photoState.fullImageLoaded', true);
        imageObject.parentNode.removeChild(imageObject);
        if (!vm.get('hasSpecialViewer')) {
          analytics.Ctrl.log('Viewed Photo', {}, ['Photo ID', 'Photo Type', 'Photo ID with Prefix']);
        }
      };
      imageObject.src = src;
    };
    imageObjectMed.src = med;
  }
}, onAnnotationsStoreLoad:function(store) {
  if (store.getProxy().getExtraParams().photo == this.getViewModel().get('activePhoto.id')) {
    this.getViewModel().set('annoProps.storeLoaded', true);
  }
}, onAnnotatingToggle:function(annotating) {
  this.toggleToolWindow(annotating, this.lookupReference('annotationsTW'));
}, onMeasuringToggle:function(measuring) {
  this.clearActiveMeasurement();
  var vm = this.getViewModel(), unalteredImage = new Image, photoID = vm.get('activePhoto.Identifier'), photoContainer = this.lookupReference('photoContainer');
  if (measuring) {
    analytics.Ctrl.log('Toggled on Measurement Tools', {}, ['Photo ID', 'Photo Type', 'Photo ID with Prefix']);
    var failFn = Ext.bind(function() {
      Ext.Msg.alert(mvstr['G_Failure'], mvstr['PVM_Could not initialize ']);
      vm.set('measuring', false);
      unalteredImage.onerror = null;
      unalteredImage.src = '';
    }, this);
    photoContainer.setLoading(true);
    this.cacheCmi({success:function(args) {
      vm.set('cachedCmiPhotoID', args.photoID);
    }, failure:failFn, scope:this, photoID:vm.get('activePhoto.Identifier'), cmiName:vm.get('activePhoto.CmiName')});
    photoContainer.getController().lookupReference('photo').getController().removeAllDrawables();
    unalteredImage.onload = function() {
      vm.set('unalteredWidth', unalteredImage.width);
      vm.set('unalteredHeight', unalteredImage.height);
      vm.set('unalteredImagePhotoID', photoID);
      Ext.defer(function() {
        photoContainer.lookupController().switchImageSize(unalteredImage.width, unalteredImage.height);
      }, 1);
    };
    unalteredImage.onerror = failFn;
    unalteredImage.src = vm.get('activePhoto.ImageURLUnaltered');
    vm.set('measureStep', photoViewer.Values.MSR_ZERO_POINTS);
  } else {
    var leavingMeasureMode = !!vm.get('unalteredImagePhotoID');
    vm.set('cachedCmiPhotoID', 0);
    vm.set('unalteredImagePhotoID', 0);
    vm.set('unalteredWidth', 0);
    vm.set('unalteredHeight', 0);
    if (leavingMeasureMode) {
      Ext.defer(function() {
        photoContainer.lookupController().switchImageSize(vm.get('activePhoto.OriginalsWidth'), vm.get('activePhoto.OriginalsHeight'));
      }, 1);
    }
    this.toggleToolWindow(measuring, this.lookupReference('measureTW'));
    photoContainer.setLoading(false);
  }
}, cacheCmi:function(args) {
  var vm = this.getViewModel(), tries = args.tries || 0, success = args.success || Ext.emptyFn, failure = args.failure || Ext.emptyFn, scope = args.scope || this;
  if (vm.get('activePhoto.Identifier') != args.photoID) {
    return;
  }
  if (tries >= 50) {
    failure.call(scope);
    return;
  }
  Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daArgos.isCmiCached', params:{photoID:args.photoID, cmiName:args.cmiName}, successCallback:function(data) {
    if (data.cached) {
      success.call(scope, args);
    } else {
      args.tries = tries + 1;
      Ext.defer(this.cacheCmi, 500, this, [args]);
    }
  }, noAlert:true, afterFailMessageCallback:args.failure, scope:this});
}, onMeasuringReady:function() {
  var vm = this.getViewModel();
  this.lookupReference('photoContainer').setLoading(false);
  this.toggleToolWindow(true, this.lookupReference('measureTW'));
  vm.set('src', vm.get('activePhoto.ImageURLUnaltered'));
}, onMeasuringStepChange:function(data) {
  if (!data.measuring) {
    return;
  }
  if (data.measureStep <= photoViewer.Values.MSR_ZERO_POINTS) {
    this.clearActiveMeasurement();
  }
  this.getViewModel().set('toolSettings.mode', data.measureStep == photoViewer.Values.MSR_ZERO_POINTS ? 'measure' : 'select');
}, clearActiveMeasurement:function() {
  var vm = this.getViewModel(), activeMeasurement = vm.get('activeMeasurement');
  vm.set('measurementString', '');
  if (vm.get('measureStep') > photoViewer.Values.MSR_ZERO_POINTS) {
    vm.set('measureStep', photoViewer.Values.MSR_ZERO_POINTS);
  }
  if (activeMeasurement) {
    vm.get('measurementsStore').remove(activeMeasurement);
    activeMeasurement.destroy();
  }
  vm.set('activeMeasurement', null);
}, doMeasurementAction:function() {
  var vm = this.getViewModel(), activeMeasurement = vm.get('activeMeasurement');
  if (vm.get('measureStep') == photoViewer.Values.MSR_TWO_POINTS) {
    vm.set('measureStep', photoViewer.Values.MSR_CALCULATING);
    Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daArgos.getCmiLength', jsonData:{lines:[{start:{x:activeMeasurement.getRecordValueByAttrName('x0'), y:activeMeasurement.getRecordValueByAttrName('y0')}, end:{x:activeMeasurement.getRecordValueByAttrName('x1'), y:activeMeasurement.getRecordValueByAttrName('y1')}}], numberOfLines:1, id:'0', cmiName:vm.get('activePhoto.CmiName'), photoID:vm.get('activePhoto.Identifier')}, successCallback:function(data) {
      var currentActiveMeasurement = vm.get('activeMeasurement');
      if (currentActiveMeasurement != activeMeasurement) {
        return;
      }
      vm.set('measureStep', photoViewer.Values.MSR_TWO_POINTS);
      if (data.length === '0' || data.message == 'No Measurement') {
        Ext.Msg.alert(mvstr['PVM_Calculation Failed'], mvstr['PVM_Could not use these t']);
        return;
      }
      if (!data.length) {
        Ext.Msg.alert(mvstr['PVM_Calculation Failed'], mvstr["PVM_Please try to 'Calcul"]);
        return;
      }
      activeMeasurement.setAttrs({'length':Number(data.length), 'oScale':(vm.get('activePhoto.OriginalsWidth') / vm.get('unalteredWidth')).toFixed(3)});
      vm.set('measureStep', photoViewer.Values.MSR_DONE);
      vm.set('measurementString', activeMeasurement.get('MeasurementString'));
      activeMeasurement.shape.refreshMeasurementLabel(true);
    }, scope:this, noAlert:true, afterFailMessageCallback:function(data, message) {
      vm.set('measureStep', photoViewer.Values.MSR_TWO_POINTS);
      if (data && data.message == 'Buzy') {
        Ext.Msg.alert(mvstr['G_Error'], mvstr['PVM_Unable to measure at ']);
      } else {
        if (data && data.message == 'CMI Not Found') {
          vm.set('measureStep', photoViewer.Values.MSR_TWO_POINTS);
          this.cacheCmi({success:this.doMeasurementAction, failure:function() {
            Ext.Msg.alert(mvstr['G_Error'], mvstr['PVM_Could not reinitializ']);
          }, scope:this, photoID:vm.get('activePhoto.Identifier'), cmiName:vm.get('activePhoto.CmiName')});
        } else {
          Ext.Msg.alert(mvstr.G_Error, mvstr.G_UnexpectedError);
        }
      }
    }});
  } else {
    vm.get('drawablesStore').add(activeMeasurement);
    vm.set('activeMeasurement', null);
    vm.set('measureStep', photoViewer.Values.MSR_ZERO_POINTS);
    activeMeasurement.redraw();
  }
}, onGettingCmiLengthChange:function(gettingCmiLength) {
  if (gettingCmiLength) {
    this.lookupReference('photoContainer').setLoading(true);
  } else {
    this.lookupReference('photoContainer').setLoading(false);
  }
}, onActiveMeasurementLengthChange:function(length) {
  var vm = this.getViewModel(), measureStep = this.getViewModel().get('measureStep');
  if (!length && measureStep > photoViewer.Values.MSR_TWO_POINTS) {
    vm.set('measureStep', photoViewer.Values.MSR_TWO_POINTS);
  }
}, toggleToolWindow:function(toggleToolsOn, toolWindow) {
  if (toggleToolsOn) {
    toolWindow.showBy(toolWindow.alignTarget);
  } else {
    toolWindow.hide();
  }
}, onThumbClick:function(view, record, item, index, e) {
  var vm = this.getViewModel(), target = Ext.fly(e.getTarget()), targetIsSelectIcon = target.hasCls('select'), ProjectUID = vm.get('ProjectUID'), favouritesAlbumUID = vm.get('favouritesAlbumUID');
  if (targetIsSelectIcon) {
    var didSelect = !record.get('Selected');
    record.set('Selected', didSelect);
    vm.set('lastSelectionChange', (new Date).getTime());
  } else {
    if (target.hasCls('favourite-btn')) {
      var isFavourited = !record.get('IsFavourite');
      record.set('IsFavourite', isFavourited);
      if (isFavourited) {
        Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daClientPhotoList.updateAlbum', params:{ProjectUID:ProjectUID, AlbumUID:favouritesAlbumUID, photos:record.get('id')}, afterFailMessageCallback:function() {
          record.set('IsFavourite', !record.get('IsFavourite'));
        }, scope:this});
      } else {
        Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daClientPhotoList.removeMultipleFromAlbum', params:{ProjectUID:ProjectUID, data:Ext.encode([{AlbumUID:favouritesAlbumUID, mixedPhotoArray:[record.get('id')]}])}, afterFailMessageCallback:function() {
          record.set('IsFavourite', !record.get('IsFavourite'));
        }, scope:this});
      }
    } else {
      vm.set('activePhoto', record);
    }
  }
}, onWebcamThumbClick:function(view, record) {
  this.launchWebcamView(record.get('WebcamUID'));
}, getPhotoEventProperties:function(record) {
  var properties = record.getPhotoEventProperties(), activePhoto = this.getActivePhoto();
  if (activePhoto && activePhoto.getId() == record.getId()) {
    var viewMode = this.getViewModel().get('viewMode');
    if (viewMode == photoViewer.Values.VIEW_TRUVIEW) {
      properties['Photo Type'] = 'TruView';
    } else {
      if (viewMode == photoViewer.Values.VIEW_SITEWALK360) {
        properties['Photo Type'] = 'SW360';
      }
    }
  }
  return properties;
}, onActivePhotoChange:function(data) {
  if (!data.photoStore || !data.activePhoto || !data.photoStoreLoaded) {
    return;
  }
  this.loadSelectedImage(data.activePhoto);
  var vm = this.getViewModel();
  vm.set('commentViewData', {CommentType:'photo', CommentCount:vm.get('photoData.nComments'), Identifier:vm.get('photoData.id'), BufferLoad:true});
  if (vm.get('FloorplanUID') != data.activePhoto.get('FloorplanUID')) {
    vm.set('smallFloorplanReady', false);
    vm.set('largeFloorplanReady', false);
    vm.set('FloorplanUID', data.activePhoto.get('FloorplanUID'));
  }
  vm.set('annotating', false);
  if (data.photoStore.isLoaded()) {
    var thumbIndex = data.photoStore.indexOf(data.activePhoto);
    this.lookupReference('thumbsContainer').gotoThumb(thumbIndex);
    this.loadThumbs(thumbIndex);
  }
}, loadThumbs:function(index) {
  var photoStore = this.getViewModel().get('photoStore'), thumbsContainer = this.lookupReference('thumbsContainer'), maxIndex = photoStore.getCount() - 1, nonVisibleIndices = [];
  index = Math.max(0, Math.min(maxIndex, index));
  this.loadThumb(photoStore.getAt(index));
  var bufferSize = this.getViewModel().get('bufferSize');
  for (var i = 0; i < bufferSize; i++) {
    var index1 = index + i, index2 = index - i;
    if (index1 <= maxIndex) {
      if (thumbsContainer.thumbVisible(index1)) {
        this.loadThumb(photoStore.getAt(index1));
      } else {
        nonVisibleIndices.push(index1);
      }
    }
    if (index2 >= 0) {
      if (thumbsContainer.thumbVisible(index2)) {
        this.loadThumb(photoStore.getAt(index2));
      } else {
        nonVisibleIndices.push(index2);
      }
    }
  }
  for (var i = 0; i < nonVisibleIndices.length; i++) {
    this.loadThumb(photoStore.getAt(nonVisibleIndices[i]));
  }
}, loadThumb:function(record) {
  if (!record || record.get('LoadedImage') || record.loadingMediumImage) {
    return;
  }
  record.loadingMediumImage = true;
  var image = new Image;
  image.onload = function() {
    record.set('LoadedImage', this.src);
    record.set({'MediumWidth':image.naturalWidth, 'MediumHeight':image.naturalHeight});
  };
  image.onerror = function() {
    image.onerror = function() {
      record.set('LoadedImage', 0);
    };
    image.src = record.get('ImageURLThumb');
  };
  image.src = record.get('ImageURLMedium');
}, onThumbPageChange:function(page) {
  this.loadThumbs(page * this.getViewModel().get('nThumbsPerPage'));
}, onAlbumStoreLoaded:function(store, photoGroup) {
  if (photoGroup.get('Type') == 'A') {
    var album = store.getById(photoGroup.get('Identifier'));
    if (!album) {
      photoGroup.set('IsMine', false);
    } else {
      photoGroup.set('IsMine', album.get('IsUserAlbum'));
    }
  }
  var favouriteAlbum = store.queryBy(function(record) {
    return record.get('IsFavouritesAlbum');
  }).getAt(0);
  if (favouriteAlbum) {
    this.getViewModel().set('favouritesAlbumUID', favouriteAlbum.get('AlbumUID'));
  }
}, nextPhoto:function(increment) {
  var vm = this.getViewModel(), increment = increment || 1;
  if (vm.get('activeStream')) {
    return this.nextStream(increment);
  }
  var activePhoto = vm.get('activePhoto'), photoStore = vm.get('photoStore'), photoIndex = photoStore.indexOf(activePhoto), newIndex = photoIndex + increment;
  if (newIndex >= photoStore.getCount()) {
    newIndex = 0;
  }
  if (newIndex <= -1) {
    newIndex = photoStore.getCount() - 1;
  }
  var nextPhoto = photoStore.getAt(newIndex);
  if (newIndex != photoIndex) {
    vm.set('activePhoto', nextPhoto);
  }
  return nextPhoto;
}, prevPhoto:function() {
  this.nextPhoto(-1);
}, nextStream:function(increment) {
  var vm = this.getViewModel(), activeWebcam = vm.get('activeWebcam'), webcamStore = vm.get('webcams'), webcamIndex = webcamStore.indexOf(activeWebcam), newIndex = webcamIndex + increment;
  if (newIndex >= webcamStore.getCount()) {
    newIndex = 0;
  }
  if (newIndex <= -1) {
    newIndex = webcamStore.getCount() - 1;
  }
  var nextWebcam = webcamStore.getAt(newIndex);
  if (newIndex != webcamIndex) {
    this.launchWebcamView(nextWebcam.get('WebcamUID'));
  }
  return nextWebcam;
}, loadFloorplan:function(fpViewer, floorplanUID) {
  this.floorplanLoadPhoto = this.getViewModel().get('activePhoto');
  var isInteriorPano = this.floorplanLoadPhoto.get('IsInteriorPano');
  fpViewer.setHighlightInteriorPanoHotspots(isInteriorPano);
  fpViewer.setZoomOutInteriorPanoHotspots(true);
  fpViewer.setShowInteriorPanoHotspots(true);
  var viewModel = fpViewer.lookupViewModel();
  if (!viewModel.get('_recordfloorplan') || viewModel.get('_recordfloorplan.FloorplanUID') != floorplanUID) {
    fpViewer.mask('');
    viewModel.set('_recordfloorplan', null);
    viewModel.set('FloorplanUID', null);
    viewModel.set('ListTypeID', this.getViewModel().get('ListTypeID'));
    viewModel.notify();
    viewModel.set('FloorplanUID', floorplanUID);
    viewModel.set('ProjectUID', this.getViewModel().get('ProjectUID'));
  }
}, gotoFloorplan:function() {
  var vm = this.getViewModel();
  var params = {ProjectUID:vm.get('ProjectUID'), FloorplanUID:vm.get('FloorplanUID')}, hotspotID = vm.get('activePhoto.HotspotID'), pushpinUID = vm.get('PushpinUID'), ListTypeID = vm.get('ListTypeID');
  if (hotspotID) {
    params.hotspotID = hotspotID;
  }
  if (pushpinUID) {
    params.pushpinUID = pushpinUID;
  }
  if (ListTypeID) {
    params.ListTypeID = ListTypeID;
  }
  document.location = vm.get('floorplanViewerLink') + Ext.Object.toQueryString(params);
}, onPushpinChange:function(data) {
  if (!data.PushpinUID) {
    return;
  }
  var vm = this.getViewModel();
  vm.set('photoGroup', Ext.create('floorplanViewer.model.PhotoGroup', {'Identifier':data.PushpinUID, 'Type':'N'}));
}, onPhotoGroupChange:function(data) {
  if (!data.photoGroup) {
    return;
  }
  var vm = this.getViewModel(), store = data.photoGroup.getPhotoStore(this.getViewModel().get('ProjectUID'), this.getStoreSession(), null, {load:{fn:function(store) {
  }, scope:this}});
  if (data.photoGroup.get('Type') == 'A') {
    store.sort('PhotoDate', 'DESC');
  } else {
    if (data.photoGroup.get('Type') == 'H') {
      store.sort('PhotoDate', 'ASC');
      store.proxy.extraParams.LookupDate = '';
      if (!vm.get('lockMode')) {
        vm.set('lockMode', 'lockToHotspot');
      }
    }
  }
  vm.set('photoStore', store);
  if (store.isLoaded()) {
    this.onPhotoStoreLoad(store);
  } else {
    vm.set('nPhotos', 0);
    vm.set('photoStoreLoaded', 0);
    vm.set('firstScrollDone', false);
    vm.set('nextActive', false);
    vm.set('prevActive', false);
    store.addListener('load', this.onPhotoStoreLoad, this, {single:true});
    store.load();
  }
}, onPhotoStoreLoad:function(store) {
  if (!store.isLoaded()) {
    Ext.Msg.alert(mvstr['G_Error'], mvstr['PV_Photos do not exist o']);
    this.getView().destroy();
    return;
  }
  var vm = this.getViewModel(), count = store.getCount();
  vm.set('nPhotos', store.getCount());
  vm.set('photoStoreLoaded', true);
  this.lookupReference('photoContainer').setLoading(false);
  if (count) {
    var range = store.getRange();
    for (var i = 0; i < range.length; i++) {
      if (!range[i].get('PhotoNumber')) {
        range[i].set('PhotoNumber', i + 1);
      }
    }
    var index = 0;
    if (this.pendingPhotoID) {
      index = store.find('id', this.pendingPhotoID);
    } else {
      if (store.record.get('Type') == 'W') {
        index = count - 1;
      } else {
        index = store.find('HotspotID', this.mapHotspotID);
      }
    }
    this.pendingPhotoID = 0;
    if (index == -1) {
      index = 0;
    }
    vm.set('activePhoto', store.getAt(index));
  } else {
    var type = vm.get('photoGroup').get('Type');
    if (type == 'N') {
      MDS.Msg.alert('', mvstr['PV_There are no photos p']);
    }
    if (type == 'C') {
      MDS.Msg.alert('', mvstr['PV_Custom Slideshow Error']);
    }
    vm.set('src', '');
  }
}, loadPhotosFromHotspot:function(hotspotID) {
  var vm = this.getViewModel(), photo = vm.get('activePhoto'), lockMode = vm.get('lockMode'), floorplan = vm.get('pvFloorplan'), photoContainer = this.lookupReference('photoContainer'), projectUID = vm.get('ProjectUID'), ctrl = this;
  hotspotID = hotspotID || photo.get('HotspotID');
  if (photo.get('HotspotID') != hotspotID) {
    photo = ctrl.floorplanLoadPhoto;
  }
  photoContainer.setLoading(true);
  mdsAjax.doAjaxRequest({url:'/index.cfm?fuseaction\x3daClientPhotoViewer.getHotspotClickData\x26HotspotID\x3d' + hotspotID + '\x26ProjectUID\x3d' + projectUID, scope:ctrl, successCallback:function(data) {
    ctrl.pendingPhotoID = 'P' + data[0].PhotoID;
    ctrl.getViewModel().set('photoGroup', Ext.create('floorplanViewer.model.PhotoGroup', {'Identifier':lockMode == 'lockToHotspot' ? hotspotID : data[0].ProjectShootTypeUID, 'Type':lockMode == 'lockToHotspot' ? 'H' : 'D', 'StartDate':customData.fields.tzadate.convertFn(data[0].ShootDate), 'Locations':[floorplan.get('floorplanTitle')]}));
  }, afterFailMessageCallback:function() {
    photoContainer.setLoading(false);
  }});
}, onLockModeChange:function(data) {
  var vm = this.getViewModel();
  if (!vm.get('pvFloorplan')) {
    vm.bind('{pvFloorplan}', function() {
      this.onLockModeChange(data);
    }, this, {single:true});
    return;
  }
  if (data.lockMode) {
    this.loadPhotosFromHotspot();
  }
}, onThumbsResize:function(thumbContainer, width) {
  if (!width) {
    return;
  }
  var thumbWidth = 123, selectedThumbWidth = 137, margin = 4, nThumbsPerPage = Math.floor((width - (selectedThumbWidth + margin)) / (thumbWidth + margin)) + 1;
  this.getViewModel().set('nThumbsPerPage', nThumbsPerPage);
  this.getViewModel().set('bufferSize', nThumbsPerPage * 2);
}, onAnnotationsDataChanged:function(store) {
  var photoId = store.getProxy().getExtraParams().photo, photoStore = this.getViewModel().get('photoStore'), photoRecord = photoStore.getAt(photoStore.find('id', photoId));
  if (photoRecord) {
    photoRecord.set('HasAnnotations', store.getCount() > 0);
  }
  if (photoId == this.getViewModel().get('activePhoto.id')) {
    this.getViewModel().set('drawablesDataChange', (new Date).getTime());
  }
}, getFloorplan:function() {
  if (this.getViewModel().get('floorplanModeOn')) {
    return this.lookupReference('largeFloorplanViewer').down('fvFloorplanViewer');
  } else {
    return this.lookupReference('smallFloorplanView').down('fvFloorplanViewer');
  }
}, onDestroy:function() {
  Ext.un('resize', this.onViewerResize, this);
  this.disableSlideshow();
  window.app.getController('photoViewer.controller.SiteWalk360Controller').clearAll();
  var toolbarActionsController = window.app.getController('photoActions.controller.ToolbarActions');
  toolbarActionsController.interfaceControl = this.oldInterfaceControl;
  toolbarActionsController.mainView = this.oldToolbarActionsMainView;
  Ext.Msg = Ext.MessageBox = this.oldExtMsg;
  this.keyNavArrows.destroy(false);
  Ext.tip.QuickTipManager.destroy();
  Ext.tip.QuickTipManager.init();
}, getSelectedPhotoIDs:function(callback) {
  var photos = this.getSelectedPhotos(), ids = [];
  for (var i = 0; i < photos.length; i++) {
    ids.push(photos[i].get('id'));
  }
  if (callback) {
    callback(ids);
  }
  return ids;
}, getSelectedPhotos:function() {
  return this.getViewModel().get('selectedPhotos').getRange();
}, onBatchAddComments:function(changedPhotos) {
  var vm = this.getViewModel(), activePhotoId = vm.get('activePhoto').get('id');
  for (var i = 0; i < changedPhotos.length; i++) {
    if (activePhotoId == changedPhotos[i].get('id')) {
      this.lookupReference('comments').lookupController().loadComments();
      return;
    }
  }
}, onPhotosDeleted:function(data) {
  var recs = [], photos = this.getViewModel().get('photoStore'), vm = this.getViewModel();
  for (var i = 0; i < data.UDEFPhotoUIDs.length; i++) {
    recs.push(photos.getById(data.UDEFPhotoUIDs[i]));
  }
  photos.remove(recs);
  vm.set('lastSelectionChange', (new Date).getTime());
  vm.set('nPhotos', photos.getCount());
}, getOpenAlbum:function() {
  return this.albumStore.getById(this.getViewModel().get('photoGroup').get('Identifier'));
}, toggleAnnotationsVisible:function() {
  var viewModel = this.getViewModel();
  viewModel.set('annoProps.toggledOn', !viewModel.get('annoProps.toggledOn'));
}, onSlideshowToggle:function() {
  var vm = this.getViewModel(), slideshowOn = !vm.get('slideshowOn');
  vm.set('slideshowOn', slideshowOn);
  if (slideshowOn) {
    Ext.asap(function() {
      if (this.slideshowClickListener) {
        this.slideshowClickListener.destroy();
      }
      this.slideshowClickListener = this.getView().el.addListener('click', this.disableSlideshow, this, {destroyable:true});
    }, this);
    var keepAliveInterval = 5 * 60 * 1000, timestamp, doInterval = Ext.bind(function() {
      clearInterval(this.intervalTimeout);
      var nowTimestamp = (new Date).getTime();
      if (!timestamp || nowTimestamp - timestamp >= keepAliveInterval) {
        timestamp = nowTimestamp;
      }
      var record = this.nextPhoto(), interval = this.slideInterval;
      if (record && record.get('isInteriorPano')) {
        interval *= 2;
      }
      this.intervalTimeout = window.setTimeout(doInterval, interval);
    }, this);
    this.intervalTimeout = window.setTimeout(doInterval, this.slideInterval);
  } else {
    this.disableSlideshow();
  }
}, disableSlideshow:function() {
  if (this.slideshowClickListener) {
    this.slideshowClickListener.destroy();
  }
  this.getViewModel().set('slideshowOn', false);
  if (!this.intervalTimeout) {
    return;
  }
  clearInterval(this.intervalTimeout);
  delete this['intervalTimeout'];
}, keepAlive:function() {
  Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daClientPhotoViewer.keepAlive'});
}, showContextMenu:function(eventObj) {
  var photoContainerEl = this.lookupReference('photoContainer').getEl();
  this.lookupReference('contextMenu').showAt([eventObj.getX() - photoContainerEl.getX(), eventObj.getY() - photoContainerEl.getY()]);
}, savePhoto:function() {
  window.app.getController('photoActions.controller.ToolbarActions').saveSinglePhoto(this.getViewModel().get('activePhoto.id'));
}, showExifInfo:function() {
  this.lookupReference('exifDisplay').lookupController().showExifInfo();
}, saveInteriorPanoSnapshotToComputer:function(saveToServerCallback, photos) {
  this.saveSnapshotToComputer('InteriorPano', saveToServerCallback, photos);
}, save360PanoSnapshotToComputer:function(saveToServerCallback) {
  this.saveSnapshotToComputer('360Pano', saveToServerCallback);
}, saveWebcamStreamSnapshot:function(callback, forPunchlist) {
  var vm = this.getViewModel(), activeWebcam = vm.get('activeWebcam'), currentPosition = vm.get('selectedWebcamPosition'), photoContainer = this.lookupReference('photoContainer');
  if (currentPosition) {
    currentPosition = Ext.Array.findBy(activeWebcam.get('ArchivePositions'), function(rec) {
      return rec.ArchivePositionID === currentPosition.get('ArchivePositionID');
    });
  }
  photoContainer.setLoading(true);
  Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daClientWebcam.doSnapshot', timeout:60000, params:{WebcamUID:activeWebcam.get('WebcamUID'), ProjectUID:vm.get('ProjectUID'), ArchivePositionID:currentPosition ? currentPosition.ArchivePositionID : 0}, successCallback:function(data) {
    photoContainer.setLoading(false);
    if (forPunchlist) {
      var photo = Ext.create('mdsData.model.Photo', {Identifier:data.WebcamPhotoUID, WebcamPhotoUID:data.WebcamPhotoUID, Type:'W', ImageURL:data.ImageURLs.webcam_original, ImageURLThumb:data.ImageURLs.webcam_thumb, ImageURLMedium:data.ImageURLs.webcam_medium});
      callback(photo);
    } else {
      callback(['W' + data.WebcamPhotoUID]);
    }
  }, afterFailMessageCallback:function() {
    photoContainer.setLoading(false);
  }, noResponseCallback:function() {
    photoContainer.setLoading(false);
    Ext.Msg.alert(mvstr.G_Error, mvstr.G_UnexpectedError);
  }});
}, takeInteriorPanoSnapshot:function(includePose) {
  var resolution = window.hasOwnProperty('iwResolutionOptions') ? window.iwResolutionOptions : {width:4000, height:2667};
  var photoController = this.lookupReference('photoContainer').lookupController();
  var snapshotPromise = photoController.siteWalkTakeScreenShot(resolution);
  if (includePose) {
    var posePromise = photoController.siteWalkGetPose();
    return Promise.all([snapshotPromise, posePromise]);
  }
  return snapshotPromise;
}, take360PanoSnapshot:function() {
  var photoController = this.lookupReference('photoContainer').lookupController();
  return photoController.pannellumTakeScreenshot();
}, saveSnapshotToComputer:function(type, saveToServerCallback, photos) {
  var me = this;
  this['take' + type + 'Snapshot']().then(function(base64) {
    var len = base64 ? base64.length : -1;
    if (len > 0) {
      var downloaded = false;
      if (Ext.isChrome || Ext.isGecko || Ext.isWebKit) {
        try {
          me.downloadBase64Blob(base64);
          downloaded = true;
        } catch (ex) {
          console.log('Failed to save image blob', ex);
        }
      }
      if (!downloaded) {
        var photos = photos || me.getSelectedPhotoIDs();
        saveToServerCallback(photos, base64);
      }
    } else {
      Ext.Msg.alert(mvstr['G_Error'], mvstr['PA_Unable to take snapsh']);
    }
  }, function(error) {
    if (error) {
      console.error(error);
    }
    Ext.Msg.alert(mvstr['G_Error'], type == 'InteriorPano' ? mvstr['PA_UnableSnapshotLong'] : mvstr['PA_Unable to take snapsh']);
  });
}, onViewerResize:function(newWidth, newHeight) {
  this.lookupReference('mainContainer').setSize(newHeight - this.lookupReference('topToolbar').el.getHeight(), this.getView().getWidth());
}, onPhotoContainerResize:function() {
  var measureTW = this.lookupReference('measureTW');
  if (measureTW.isVisible()) {
    measureTW.showBy(measureTW.alignTarget);
  }
}, openNewAlbumInViewer:function(AlbumUID) {
  this.getViewModel().set('photoGroup', Ext.create('floorplanViewer.model.PhotoGroup', {'Identifier':AlbumUID, 'Type':'A'}));
}, isInteriorPano:function() {
  return this.getViewModel().get('photoState.isInteriorPano');
}, is360Pano:function() {
  return this.getViewModel().get('photoState.is360Pano');
}, saveInteriorPanoSnapshotToUDEF:function(AlbumUID, callback) {
  var includePose = this.getViewModel().get('viewMode') != photoViewer.Values.VIEW_TRUVIEW;
  var jsonData = {mpPhotoID:this.getViewModel().get('photoData.photoId'), AlbumUID:AlbumUID || ''};
  this.takeInteriorPanoSnapshot(includePose).then(function(data) {
    if (includePose) {
      if (data.length == 2) {
        var base64 = data[0];
        if (base64 && base64.length) {
          var pose = data[1];
          jsonData.base64Photo = base64;
          jsonData.PanoUUID = pose ? pose.sweep : '';
          this.saveBase64ToUDEFPhoto(jsonData, callback);
        } else {
          callback(false, 'Unable to take snapshot');
        }
      } else {
        console.error('No data returned for snapshot');
        callback(false, 'Unable to take snapshot');
      }
    } else {
      jsonData.base64Photo = data;
      jsonData.PanoUUID = app.getController('photoViewer.controller.SiteWalk360Controller').getActivePano().uuid || '';
      this.saveBase64ToUDEFPhoto(jsonData, callback);
    }
  }.bind(this), function(error) {
    console.log('Failed to take snapshot', error);
    callback(false, 'Failed to take snapshot');
  });
}, getPannellumViewerAngle:function() {
  var photoController = this.lookupReference('photoContainer').lookupController();
  var angle = photoController.getPannellumViewerAngle();
  return angle;
}, save360PanoSnapshotToUDEF:function(AlbumUID, callback) {
  this.take360PanoSnapshot().then(function(base64) {
    var jsonData = {base64Photo:base64, AlbumUID:AlbumUID || ''};
    this.saveBase64ToUDEFPhoto(jsonData, callback);
  }.bind(this));
}, saveBase64ToUDEFPhoto:function(jsonData, callback) {
  jsonData.ProjectUID = this.getViewModel().get('ProjectUID');
  var errorHandler = function() {
    console.error('Failed to save base 64 photo', arguments);
    callback(false, 'Failed to save snapshot');
  };
  Ext.Ajax.request({url:mdslink.server + '/index.cfm?fuseaction\x3daClientPhotoList.saveBase64UDEFPhoto', method:'POST', jsonData:jsonData, successCallback:function(data) {
    callback(true, data);
  }, afterFailMessageCallback:errorHandler, noResponseCallback:errorHandler});
}, takeInteriorPanoSnapshotForPunchlist:function(callback) {
  var includePose = this.getViewModel().get('viewMode') != photoViewer.Values.VIEW_TRUVIEW;
  this.takeInteriorPanoSnapshot(includePose).then(function(data) {
    if (includePose) {
      if (data.length == 2) {
        var base64 = data[0];
        if (base64 && base64.length) {
          var pose = data[1];
          callback(true, base64, pose ? pose.sweep : '');
        } else {
          callback(false, 'Unable to take snapshot');
        }
      } else {
        console.error('No data returned for snapshot');
        callback(false, 'Unable to take snapshot');
      }
    } else {
      var base64 = data;
      callback(true, base64, '');
    }
  }.bind(this), function(error) {
    console.log('Failed to take snapshot', error);
    callback(false, 'Failed to take snapshot');
  });
}, take360PanoSnapshotForPunchlist:function(callback) {
  this.take360PanoSnapshot().then(function(data) {
    var base64 = data;
    callback(true, base64, '');
  }, function() {
    console.error('No data returned for snapshot');
    console.log('Failed to take snapshot', error);
    callback(false, 'Failed to take snapshot');
  });
}, print:function(type, photos, maxDirectExportPhotos) {
  var zoomInfo = '{}', vm = this.getViewModel(), pushpin = vm.get('PushpinUID'), ProjectUID = vm.get('ProjectUID');
  if (vm.get('photoGroup').get('Type') === 'N') {
    pushpin = vm.get('photoGroup').get('Identifier');
  }
  if (photos.length == 1) {
    if (photos[0] == vm.get('activePhoto').get('id')) {
      zoomInfo = JSON.stringify(this.getPrintZoomInformation());
    }
  }
  if (type == '4view') {
    var data = {photos:photos, zoomInfo:zoomInfo, PushpinUID:pushpin};
    var hiddenDrawables = vm.get('drawablesStore').query('Visible', false), hiddenDrawablesIDs = [];
    hiddenDrawables.each(function(rec) {
      hiddenDrawablesIDs.push(rec.getId());
    });
    if (hiddenDrawables.length) {
      data.hiddenAnnotations = hiddenDrawablesIDs.join(',');
    }
    if (vm.get('activePhoto.Is360Pano')) {
      var angle = this.getPannellumViewerAngle();
      data.Photo360ID = vm.get('activePhoto.Identifier') || 0;
      if (Ext.isNumber(angle)) {
        data.FOVAngle = angle;
      }
    }
    if (photos.length <= maxDirectExportPhotos) {
      Ext.Ajax.postFormData(mdslink.server + '/index.cfm?fuseaction\x3daClientPhotoList.4ViewPDF\x26ProjectUID\x3d' + ProjectUID, data, {target:'_blank'});
    } else {
      photoActions.controller.ToolbarActions.doEmailPDF(mdslink.server + '/index.cfm?fuseaction\x3daClientPhotoList.4ViewPDF\x26ProjectUID\x3d' + ProjectUID, data);
    }
  } else {
    if (photos.length <= maxDirectExportPhotos) {
      Ext.Ajax.postFormData(mdslink.server + '/index.cfm?fuseaction\x3daClientPhotoList.4ViewPDF\x26ProjectUID\x3d' + ProjectUID + '\x26forcePhotoOnly\x3dtrue', {photos:photos, zoomInfo:zoomInfo}, {target:'_blank'});
    } else {
      photoActions.controller.ToolbarActions.doEmailPDF(mdslink.server + '/index.cfm?fuseaction\x3daClientPhotoList.4ViewPDF\x26ProjectUID\x3d' + ProjectUID + '\x26forcePhotoOnly\x3dtrue', {photos:photos, zoomInfo:zoomInfo});
    }
  }
}, getPrintZoomInformation:function() {
  var view = this.lookupReference('photoContainer'), viewWidth = view.getWidth(), viewHeight = view.getHeight(), vm = this.getViewModel(), originalHeight = vm.get('activePhoto.OriginalsHeight'), photo = this.lookupReference('photoContainer').getController().lookupReference('photo'), photoCurrentWidth = photo.getWidth(), photoCurrentHeight = photo.getHeight(), info = {};
  if (photoCurrentWidth <= viewWidth && photoCurrentHeight <= viewHeight) {
    return {};
  }
  info.realWidth = photoCurrentWidth;
  info.realWidth = photoCurrentHeight;
  info.viewWidth = viewWidth;
  info.viewHeight = viewHeight;
  var viewPosition = view.getPosition(), photoPosition = photo.getPosition(), photoRight = photoPosition[0] + photoCurrentWidth, viewRight = viewPosition[0] + viewWidth, photoBottom = photoPosition[1] + photoCurrentHeight, viewBottom = viewPosition[1] + viewHeight, viewerToReal = originalHeight / photoCurrentHeight;
  if (photoPosition[0] > viewPosition[0]) {
    info.viewWidth -= photoPosition[0] - viewPosition[0];
  }
  if (photoRight < viewRight) {
    info.viewWidth -= viewRight - photoRight;
  }
  if (photoPosition[1] > viewPosition[1]) {
    info.viewHeight -= photoPosition[1] - viewPosition[1];
  }
  if (viewBottom > photoBottom) {
    info.viewHeight -= viewBottom - photoBottom;
  }
  info.realWidth = info.viewWidth * viewerToReal;
  info.realHeight = info.viewHeight * viewerToReal;
  info.x = Math.round(Math.max(0, (photoPosition[0] - viewPosition[0]) * -1 * viewerToReal));
  info.y = Math.round(Math.max(0, (photoPosition[1] - viewPosition[1]) * -1 * viewerToReal));
  info.viewWidth = Math.round(info.viewWidth);
  info.viewHeight = Math.round(info.viewHeight);
  info.realWidth = Math.round(info.realWidth);
  info.realHeight = Math.round(info.realHeight);
  return info;
}, thumbsArrowKeys:function(eventObject) {
  var el = Ext.get(eventObject.getTarget()), keyCode = eventObject.getKey();
  if (eventObject.isNavKeyPress() && !el.hasCls('x-form-text')) {
    if (keyCode == 37) {
      this.prevPhoto();
    } else {
      if (keyCode == 39) {
        this.nextPhoto();
      }
    }
  }
  return true;
}, logNextPrevEvent:function(direction, source) {
  analytics.Ctrl.log('Clicked Next/Prev', {'Direction':direction, 'Source':source}, ['Photo ID', 'Photo Type', 'Photo ID with Prefix']);
}, onSidePanelCollapseChange:function(collapsed) {
  var photoviewerSidepanel = this.lookupReference('photoViewerSidePanel');
  if (collapsed) {
    photoviewerSidepanel.animate({to:{width:11}, duration:250, dynamic:true});
  } else {
    photoviewerSidepanel.animate({to:{width:371}, duration:250, dynamic:true});
  }
}, onPhotoThumbsCollapseChange:function(collapsed) {
  var thumbsContainer = this.lookupReference('photoViewerThumbs');
  if (collapsed) {
    thumbsContainer.animate({to:{height:13}, duration:100, dynamic:true, callback:function() {
      Ext.asap(function() {
        thumbsContainer.setWidth('100%');
      });
    }});
  } else {
    thumbsContainer.animate({to:{height:145}, duration:100, dynamic:true, callback:function() {
      Ext.asap(function() {
        thumbsContainer.setWidth('100%');
      });
    }});
  }
}, usingMetricChange:function(usingMetric) {
  var drawablesStore = this.getViewModel().get('drawablesStore'), activeMeasurement = this.getViewModel().get('activeMeasurement');
  if (drawablesStore) {
    drawablesStore.usingMetric = usingMetric;
    drawablesStore.each(function(rec) {
      rec.set('IsMetric', usingMetric);
    }, this);
  }
  if (activeMeasurement) {
    activeMeasurement.set('IsMetric', usingMetric);
  }
}, removeDrawable:function(drawable) {
  var vm = this.getViewModel(), store = vm.get('drawablesStore');
  if (store.isSyncing) {
    store.addListener('datachanged', this.removeDrawable, this, {args:[drawable], single:true});
    return;
  }
  if (drawable) {
    if (vm.get('activeMeasurement') == drawable) {
      this.clearActiveMeasurement();
      return;
    }
    store.remove(drawable);
    drawable.destroy();
  }
}, beforeDrawableSelectionChange:function(drawable) {
  var vm = this.getViewModel(), activeMeasurement = vm.get('activeMeasurement');
  if (!vm.get('account.canWrite')) {
    return false;
  }
  return !(activeMeasurement && activeMeasurement != drawable);
}, gotoWebcamStream:function(activeWebcam) {
  var vm = this.getViewModel(), activeWebcam = activeWebcam && activeWebcam.isModel ? activeWebcam : vm.get('activeWebcam'), photoContainer = this.lookupReference('photoContainer');
  vm.set('activeWebcam', activeWebcam);
  vm.set('fullscreen', false);
  photoContainer.setLoading(true);
  activeWebcam.getFullWebcamData(vm.get('ProjectUID')).then(Ext.bind(function(fullWebcamData) {
    this.switchToObjectType('activeStream', fullWebcamData);
    photoContainer.setLoading(false);
  }, this));
}, gotoWebcamArchive:function(activeWebcam) {
  var vm = this.getViewModel(), activeWebcam = activeWebcam && activeWebcam.isModel ? activeWebcam : vm.get('activeWebcam'), currentPosition = vm.get('selectedWebcamPosition'), positions = vm.get('webcamPositions');
  if (!activeWebcam || !activeWebcam.get('ArchivePositions')) {
    Ext.defer(function() {
      this.gotoWebcamArchive();
    }, 1000, this);
  }
  if (positions && (!currentPosition || !currentPosition.get('ArchivePositionID'))) {
    var index = positions.findBy(function(record) {
      return !!record.get('ArchivePositionID');
    });
    if (index > -1) {
      currentPosition = positions.getAt(index);
      vm.set('selectedWebcamPosition', currentPosition);
    } else {
      currentPosition = null;
    }
  }
  if (currentPosition) {
    vm.set('_selectedArchivePosition', currentPosition);
  }
  this.switchToObjectType('activePhoto', null);
  this.getViewModel().set('photoGroup', Ext.create('floorplanViewer.model.PhotoGroup', {'Identifier':activeWebcam.getId(), 'Type':'W', 'StartDate':currentPosition ? currentPosition.get('MostRecentPhotoDate') : activeWebcam.get('MostRecentPhotoDate'), 'ArchivePositionID':currentPosition ? currentPosition.get('ArchivePositionID') : 0}));
}, gotoWebcamTimelapseOLD:function(activeWebcam) {
  var vm = this.getViewModel(), activeWebcam = activeWebcam && activeWebcam.isModel ? activeWebcam : vm.get('activeWebcam'), currentPosition = vm.get('selectedWebcamPosition');
  if (!currentPosition || !currentPosition.get('TimelapseURL')) {
    var positions = vm.get('webcamPositions'), index = positions.findBy(function(record) {
      return !!record.get('TimelapseURL');
    });
    if (index > -1) {
      currentPosition = positions.getAt(index);
      vm.set('selectedWebcamPosition', currentPosition);
    } else {
      Ext.Msg.alert(mvstr.G_Error, mvstr.G_UnexpectedError);
      return;
    }
  }
  this.switchToObjectType('activeTimelapse', Ext.create('photoViewer.model.Timelapse', {'WebcamUID':activeWebcam.get('WebcamUID'), 'ArchivePositionID':currentPosition.get('ArchivePositionID'), 'TimelapseURL':currentPosition.get('TimelapseURL')}));
}, gotoWebcamTimelapse:function(activeWebcam) {
  var vm = this.getViewModel(), activeWebcam = activeWebcam && activeWebcam.isModel ? activeWebcam : vm.get('activeWebcam'), currentPosition = vm.get('selectedWebcamPosition');
  var timelapseObj = {'WebcamUID':activeWebcam.get('WebcamUID')};
  if (!currentPosition || !currentPosition.get('TimelapseURL')) {
    var positions = vm.get('webcamPositions'), index = positions.findBy(function(record) {
      return !!record.get('TimelapseURL');
    });
    if (index > -1) {
      currentPosition = positions.getAt(index);
      timelapseObj.ArchivePositionID = currentPosition.get('ArchivePositionID');
      timelapseObj.TimelapseURL = currentPosition.get('TimelapseURL');
      vm.set('selectedWebcamPosition', currentPosition);
    } else {
      var archivePositions = activeWebcam.get('ArchivePositions');
      if (archivePositions && archivePositions.length) {
        var archivePositionID = this.getView().ArchivePositionID || 1;
        currentPosition = Ext.Array.findBy(archivePositions, function(record) {
          return record.ArchivePositionID === archivePositionID;
        });
        if (!currentPosition) {
          currentPosition = archivePositions[0];
        }
        timelapseObj.ArchivePositionID = currentPosition.ArchivePositionID;
        timelapseObj.TimelapseURL = currentPosition.TimelapseURL;
        vm.set('_selectedArchivePosition', Ext.data.Record.create(currentPosition));
      }
    }
  } else {
    timelapseObj.ArchivePositionID = currentPosition.get('ArchivePositionID');
    timelapseObj.TimelapseURL = currentPosition.get('TimelapseURL');
    vm.set('_selectedArchivePosition', currentPosition);
  }
  this.switchToObjectType('activeTimelapse', Ext.create('photoViewer.model.Timelapse', timelapseObj));
}, switchToObjectType:function(type, objectRecord) {
  var vm = this.getViewModel(), photo = vm.get('activePhoto');
  if (photo) {
    vm.set('photoBeforeObjectTypeSwitch', photo);
  }
  vm.set(type, objectRecord);
  for (var i = 0; i < this.activeTypes.length; i++) {
    if (type != this.activeTypes[i]) {
      vm.set(this.activeTypes[i], null);
    }
  }
}, onViewModeChange:function(viewMode) {
  this.getViewModel().set('viewModeButtonValue', viewMode);
  app.getController('photoViewer.controller.SiteWalk360Controller').switchViewer(viewMode == photoViewer.Values.VIEW_TRUVIEW);
}, onViewModeToggle:function(value) {
  if (value === '') {
    return;
  }
  if (!this.viewModeToggleInitialized) {
    this.viewModeToggleInitialized = true;
    return;
  }
  this.getViewModel().set('photoState.isTruView', value == photoViewer.Values.VIEW_TRUVIEW);
}, onPermissionsLoaded:function() {
  var view = this.getView(), vm = this.getViewModel(), albumStore = view.albumStore;
  if (!albumStore) {
    albumStore = Ext.create('photoActions.store.Albums');
    if (vm.get('account.canWrite')) {
      albumStore.getProxy().setExtraParams({ProjectUID:vm.get('ProjectUID')});
      albumStore.load();
    }
  }
  this.albumStore = albumStore;
  albumStore.addListener('load', function(store) {
    this.getViewModel().set('albumStore', store);
    this.getViewModel().set('albumStoreLoaded', true);
  }, this);
  if (albumStore.isLoaded()) {
    this.getViewModel().set('albumStore', albumStore);
    this.getViewModel().set('albumStoreLoaded', true);
  }
}, getActivePhoto:function() {
  return this.getViewModel().get('activePhoto');
}, showWelcome:function() {
  var greetings = this.getViewModel().get('greetings');
  if (!greetings.isLoaded()) {
    greetings.addListener('loaded', this.showWelcome, this, {single:true});
    return;
  }
  var photoViewerGreeting = greetings.getAt(greetings.findExact('Name', 'photoViewer2019'));
  if (photoViewerGreeting && !photoViewerGreeting.get('seen')) {
    var bodyHeight = Ext.getBody().getHeight(), welcomeWidth = 490, welcomeHeight = 418, startY = (bodyHeight - welcomeHeight) / 2 - 200, welcome = Ext.create('photoViewer.view.photoviewer.PhotoViewerWelcome', {x:(Ext.getBody().getWidth() - welcomeWidth) / 2, y:startY, width:welcomeWidth, height:welcomeHeight, style:{opacity:0}});
    Ext.create('Ext.fx.Anim', {target:welcome, duration:1200, from:{opacity:0}, to:{opacity:1}});
    Ext.create('Ext.fx.Anim', {target:welcome, duration:750, easing:'bounceOut', from:{y:startY}, to:{y:startY + 100}});
    this.getView().add(welcome).show();
    var GreetingID = photoViewerGreeting.get('GreetingID');
    if (GreetingID) {
      Ext.Ajax.request({url:'/index.cfm', params:{fuseaction:'aClientNavigation.updateGreeting', GreetingID:GreetingID}, method:'GET'});
      photoViewerGreeting.set('seen', true);
      if (window.localStorage.getItem('Multivista_ClientSession')) {
        window.localStorage.removeItem('Multivista_ClientSession');
      }
    }
  }
}, showTour:function() {
  var welcome = this.lookupReference('photoViewerWelcome');
  if (welcome) {
    welcome.destroy();
  }
  if (this.getViewModel().get('activeTimelapse')) {
    return;
  } else {
    if (this.getViewModel().get('activeStream')) {
      Ext.create('clientHelp.view.helpsequences.WebcamViewerHelpSequence', {parentView:this.getView()});
    } else {
      Ext.create('clientHelp.view.helpsequences.PhotoViewerHelpSequence', {parentView:this.getView()});
    }
  }
}, onPhotoViewerBoxReady:function() {
  this.showWelcome();
}, switchPhotoViewer:function() {
  var vm = this.getViewModel(), photoGroup = vm.get('photoGroup'), type = photoGroup.get('Type'), photo = vm.get('activePhoto'), photoType = photo.get('Type'), photoId = photo.getId(), photoGroupIdentifier = photoGroup.get('Identifier'), params = {ProjectUID:vm.get('ProjectUID'), switchToOld:1};
  if (type == 'A') {
    params.AlbumUID = photoGroupIdentifier;
  } else {
    if (type == 'D' || type == 'L') {
      type = 'S';
      params.ShootUID = photoGroup.get('ShootUID') || vm.get('activePhoto').get('ShootUID');
    } else {
      if (type == 'U') {
        params.MemberUID = photoGroupIdentifier;
        params.PhotoGroupDate = Ext.Date.format(photoGroup.get('StartDate'), 'Y-m-d');
      } else {
        if (type == 'Q') {
          params.PunchItemID = photoGroupIdentifier;
          params.ListTypeID = vm.get('ListTypeID');
        } else {
          if (type == 'M') {
            params.SNID1 = photoGroupIdentifier.split('-')[0];
            params.SNID2 = photoGroupIdentifier.split('-')[1];
          } else {
            if (type == 'N') {
              type = 'P';
              params.PushpinUID = photoGroupIdentifier;
              var ListTypeID = vm.get('ListTypeID');
              if (ListTypeID) {
                params.ListTypeID = ListTypeID;
              }
            } else {
              if (type == 'I') {
                type = 'X';
              }
            }
          }
        }
      }
    }
  }
  params.PhotoGroupType = type;
  if (photoType == 'W') {
    params.SelectedWebcamPhotoUID = photoId;
  } else {
    if (photoType == 'U') {
      params.SelectedUDEFPhotoUID = photoId;
    } else {
      params.SelectedPhotoID = photoId;
    }
  }
  if (window.localStorage.getItem('Multivista_ClientSession')) {
    window.localStorage.removeItem('Multivista_ClientSession');
  }
  Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daClientPhotoViewer.setFeatureEnabled', params:{featureEnabled:0}, callback:function() {
    var url = mdslink.clientPhotoViewer + Ext.Object.toQueryString(params);
    if (this.getViewModel().get('standalone')) {
      window.location.replace(url);
    } else {
      if (type == 'X') {
        var photoStore = vm.get('photoStore'), photoIds = [];
        photoStore.each(function(photo) {
          photoIds.push(photo.get('Identifier'));
        });
        Ext.Ajax.postFormData(mdslink.clientPhotoViewer + Ext.Object.toQueryString(params), {PhotoIDs:photoIds.join(','), UDEFPhotoUIDs:'', WebcamPhotoUIDs:''});
      } else {
        document.location = url;
      }
    }
  }, scope:this});
}, downloadCurrentImage:function() {
  var vm = this.getViewModel();
  Ext.Ajax.postFormData('/index.cfm?fuseaction\x3daClientPhotoViewer.downloadCurrentImage', {id:vm.get('activePhoto.id'), projectUID:vm.get('ProjectUID'), webcamUID:vm.get('activePhoto.WebcamUID')});
}, initWebcamPlayback:function(stream) {
  if (stream.ForceFlashStream) {
    this.loadFlowplayer();
  } else {
    Ext.Loader.loadScript({url:'mds/lib/nanocosmos/js/nanoplayer/nanoplayer.3.17.1.min.js', onLoad:function() {
      this.getViewModel().set('h5LivePlayerLoaded', true);
    }, scope:this});
  }
}, loadFlowplayer:function(stream) {
  if (!this.getViewModel().get('flowplayerLoaded')) {
    Ext.Loader.loadScript({url:'mds/lib/flowplayer-6.0.5/skin/functional.css', scope:this});
    Ext.Loader.loadScript({url:'mds/lib/flowplayer-6.0.5/flowplayer.min.js', onLoad:function() {
      this.getViewModel().set('flowplayerLoaded', true);
    }, scope:this});
  }
}, initStream:function(stream) {
  var vm = this.getViewModel(), streamComponent = this.lookupReference('photoContainer').lookupController().lookupReference('webcamLiveStream');
  streamComponent.load(stream, {ProjectUID:vm.get('ProjectUID'), WebcamUID:vm.get('activeWebcam').getId()}, this.getView().lookupReference('photoContainer'));
}, launchWebcamView:function(WebcamUID) {
  var vm = this.getViewModel(), webcamsLoaded = vm.get('_webcamsLoaded');
  if (!webcamsLoaded) {
    vm.bind('{_webcamsLoaded}', function() {
      this.launchWebcamView(WebcamUID);
    }, this, {single:true});
    return;
  }
  vm.set('_selectedPTZPosition', null);
  vm.set('_selectedArchivePosition', null);
  var activeWebcam = vm.get('webcams').getById(WebcamUID);
  if (activeWebcam.get('WebcamIsStreaming')) {
    this.gotoWebcamStream(activeWebcam);
  } else {
    if (activeWebcam.get('MostRecentPhotoDate')) {
      this.gotoWebcamArchive(activeWebcam);
    }
  }
}, initTimelapsePlayback:function(timelapse) {
  var container = this.lookupReference('photoContainer').lookupController().lookupReference('webcamTimelapse');
  var key = '$131119724416338';
  if (location.href.indexOf('localhost') != -1) {
    key = '$863732616083910';
  }
  var clip = {preload:true, scaling:'orig', sources:[{type:'video/mp4', src:timelapse.get('TimelapseURL')}]};
  if (this.flowplayer) {
    this.flowplayer.load(clip, function(a, api) {
      api.pause();
    });
    return;
  }
  this.flowplayer = flowplayer('#' + container.id, {key:key, autoplay:false, clip:clip, embed:false, adaptiveRatio:true, controls:false}).on('error', function(e, api, err) {
    console.log('Error loading video');
    console.log(err);
  });
}, loadWebcamArchivePositions:function(activeWebcam) {
  var vm = this.getViewModel();
  activeWebcam = activeWebcam || vm.get('activeWebcam');
  if (!activeWebcam || activeWebcam.get('ArchivePositions')) {
    return;
  }
  var ProjectUID = vm.get('ProjectUID');
  var WebcamUID = activeWebcam.get('WebcamUID');
  mdsAjax.doAjaxRequest({url:'index.cfm?fuseaction\x3daClientPhotoViewer.getArchivePositions\x26ProjectUID\x3d' + ProjectUID + '\x26WebcamUID\x3d' + WebcamUID, successCallback:function(data) {
    activeWebcam.set('ArchivePositions', data);
    if (data.length > 0) {
      if (data[0].TimelapseURL == '') {
        activeWebcam.set('TimelapseIsAvailable', 0);
      }
    }
  }});
}, loadWebcamPhotoDates:function() {
  var vm = this.getViewModel(), activeWebcam = vm.get('activeWebcam'), currentPosition = vm.get('selectedWebcamPosition'), calendar = this.lookupReference('webcamPhotoDatePicker');
  if (!activeWebcam || !activeWebcam.get('ArchivePositions') || !activeWebcam.get('MostRecentPhotoDate')) {
    return;
  }
  if (currentPosition) {
    currentPosition = Ext.Array.findBy(activeWebcam.get('ArchivePositions'), function(rec) {
      return rec.ArchivePositionID === currentPosition.get('ArchivePositionID');
    });
  } else {
    currentPosition = activeWebcam.get('ArchivePositions')[0];
  }
  if (currentPosition && currentPosition.FirstPhotoDate) {
    if (currentPosition.NoPhotoDates.length) {
      calendar.setDisabledDates(currentPosition.NoPhotoDates);
    }
    calendar.setMinDate(new Date(currentPosition.FirstPhotoDate));
    calendar.setMaxDate(new Date(currentPosition.MostRecentPhotoDate));
    return;
  }
  var ProjectUID = vm.get('ProjectUID');
  var WebcamUID = activeWebcam.get('WebcamUID');
  calendar.setLoading();
  mdsAjax.doAjaxRequest({url:'index.cfm?fuseaction\x3daClientPhotoViewer.getWebcamPhotoDates\x26ProjectUID\x3d' + ProjectUID + '\x26WebcamUID\x3d' + WebcamUID, successCallback:function(data) {
    if (Ext.Object.isEmpty(data)) {
      return;
    }
    if (currentPosition) {
      Ext.Object.merge(currentPosition, data);
    }
    if (data.NoPhotoDates.length) {
      calendar.setDisabledDates(data.NoPhotoDates);
    }
    calendar.setMinDate(new Date(data.FirstPhotoDate));
    calendar.setMaxDate(new Date(data.MostRecentPhotoDate));
    calendar.setLoading(false);
  }});
}, onCustomWebcamArchiveClick:function() {
  if (!this.webcamCSWindow) {
    this.webcamCSWindow = Ext.create('photoViewer.view.webcam.WebcamCustomSlideshow', {viewModel:{parent:this.getViewModel()}});
  }
  this.webcamCSWindow.show();
}, onGridViewButtonClick:function() {
  var vm = this.getViewModel(), params = {ProjectUID:vm.get('ProjectUID')};
  window.location.href = mdslink.clientWebcamGridView + Ext.Object.toQueryString(params);
}, onSelectedWebcamPositionChange:function(record) {
  var vm = this.getViewModel();
  var b1 = vm.bind('{selectedWebcamPosition}', function(data) {
    b1.destroy();
    if (vm.get('activeTimelapse')) {
      this.gotoWebcamTimelapse();
    } else {
      if (vm.get('activePhoto')) {
        this.gotoWebcamArchive();
      }
    }
  }, this);
  vm.set('selectedWebcamPosition', record);
}, getLivestreamWeather:function() {
  var stream = this.getViewModel().get('activeStream');
  clearTimeout(this.weatherUpdateInterval);
  if (!stream) {
    this.getViewModel().set('streamWeather', null);
    return;
  }
  Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daClientWebcam.getWebcamWeather', params:{ProjectUID:stream.ProjectUID, WebcamUID:stream.WebcamUID}, scope:this, successCallback:function(data) {
    this.getViewModel().set('streamWeather', data);
    this.weatherUpdateInterval = setTimeout(this.getLivestreamWeather.bind(this), 3 * 60 * 1000);
  }});
}, logDrawablesEvent:function(photoIdentifier, event) {
  var record = this.getViewModel().get('photoStore').getById(photoIdentifier.substr(1));
}}, 0, 0, 0, 0, ['controller.photoviewer'], 0, [photoViewer.view.photoviewer, 'PhotoViewerController'], 0);
Ext.cmd.derive('photoViewer.view.photoviewer.PhotoViewerModel', Ext.app.ViewModel, {data:{nThumbsPerPage:0, photoData:{id:0, photoId:0, nComments:0, panoHome:''}, annoProps:{drawn:false, storeLoaded:false, toggledOn:true, annotating:false, saving:false, hasAnnotations:false, checkedForSave:false}, photoActions:{nThumbsSelected:0}, photoState:{fullImageLoaded:false, hasHotspot:false, isPano:false, isInteriorPano:false, isTruView:false, is360Pano:false}, topNavBarHeight:29, imgToolbarHeight:33, imgToolbarDisabled:true, 
dateLocationToggleActiveItem:0, PushpinUID:null, ListTypeID:null, pinDescription:'Photo', thumbnailsLoading:false, interiorPanoUrl:'', interiorPanoShowcaseConnected:false, hasMatterportAndTruView:false, selectedAnnotation:null, toolSettings:{mode:'select', strokeColour:undefined, strokeWidth:undefined, strokeStyle:'normal', fontSize:undefined, strokeStylePickerVisible:false, selectedShapes:[]}, src:'mds/image/transparent.png', unalteredWidth:0, unalteredHeight:0, scale:1, readOnly:true, nPhotos:0, 
favouritesAlbumUID:null, _selectedPhotosStore:Ext.create('Ext.data.Store', {model:'mdsData.model.Photo', proxy:'memory'}), photoStore:Ext.create('Ext.data.Store'), lastSelectionChange:0, _selectedPhoto:null, commentViewData:null, FloorplanUID:null, layoutMode:'default', largeFloorplanReady:false, smallFloorplanReady:false, _photoGroup:null, lastPhotoGroup:null, standalone:false, selectedPhotoCount:1, onlyOwnedPhotosSelected:false, oneOwnedPhotoSelected:false, photoStoreLoaded:false, albumStore:null, 
slideshowOn:false, measureStep:photoViewer.Values.MSR_ZERO_POINTS, cachedCmiPhotoID:0, unalteredImagePhotoID:0, _measurementsStore:Ext.create('Ext.data.Store', {proxy:'memory', model:'photoViewer.model.Annotation', filters:[{filterFn:function(rec) {
  return rec.get('Type') == 'measure';
}}]}), _annotationStore:Ext.create('Ext.data.Store', {proxy:'memory', model:'photoViewer.model.Annotation', filters:[{filterFn:function(rec) {
  return rec.get('Type') != 'measure';
}}]}), drawMode:photoViewer.Values.DRAW_OFF, drawingReady:false, drawablesDataChange:0, activeMeasurement:null, measurementString:'', sidePanelCollapsed:false, photoThumbsCollapsed:false, selectedDrawing:null, _usingMetric:null, nextActive:false, prevActive:false, firstScrollDone:false, bufferSize:30, lockMode:'', forceHideInteriorPano:false, viewModeButtonValue:'', photoBeforeObjectTypeSwitch:null, activeStream:null, activeTimelapse:null, flowplayerLoaded:false, h5LivePlayerLoaded:false, pvFloorplan:null, 
_webcamsLoaded:false, webcams:null, PTZPresets:Ext.create('Ext.data.Store', {proxy:'memory'}), PTZPosition:null, _selectedPTZPreset:null, _selectedArchivePosition:null, webcamStreamSnapshot:null}, formulas:{viewButtonEnabled:function(get) {
  if (get('photoState.isInteriorPano')) {
    return false;
  }
  return !!(get('photoActions.nThumbsSelected') && !get('annotating'));
}, saveButtonDisabled:function(get) {
  if (get('photoState.isInteriorPano')) {
    return !get('interiorPanoShowcaseConnected');
  }
  return get('annotating');
}, dateLocationToggleDisabled:function(get) {
  var isAnnotating = get('annotating'), photo = get('activePhoto'), hasFloorplan = photo ? !!photo.get('FloorplanUID') : false, hasHotspot = get('photoState.hasHotspot'), toolbarDisabled = get('imgToolbarDisabled');
  return isAnnotating || !hasFloorplan || !hasHotspot || toolbarDisabled;
}, annotationBtnText:function(get) {
  return get('annotating') ? 'Annotation Mode is ON' : 'Annotation Mode is OFF';
}, defaultShareTypeID:function(get) {
  return get('account.canShare') ? 1 : 2;
}, permsCls:function(get) {
  var permCls = '';
  if (get('account.canRead')) {
    permCls += 'perms-canread';
  } else {
    permCls += 'perms-noread';
  }
  permCls += ' ';
  if (get('account.canWrite')) {
    permCls += 'perms-canwrite';
  } else {
    permCls += 'perms-nowrite';
  }
  return permCls;
}, printAndEmailDisabled:function(get) {
  if (get('photoState.isInteriorPano')) {
    return !get('interiorPanoShowcaseConnected');
  }
  if (get('photoState.isPano')) {
    return true;
  }
  return !get('photoState.fullImageLoaded') || get('annotating');
}, floorplanViewerLink:function(get) {
  return get('ListTypeID') ? mdslink.clientFloorplanViewer_punchlistPlan : mdslink.clientFloorplanViewer;
}, isPhotoHidden:function(get) {
  return !!(!get('activePhoto') || get('photoState.isPano'));
}, isOverlayHidden:function(get) {
  return get('annotating') || get('thumbnailsLoading');
}, commentsHidden:function(get) {
  return false;
}, helpHidden:function(get) {
  return get('photoState.isInteriorPano');
}, integrationsDisabled:function(get) {
  return get('annotating') || get('photoState.isTruView') || get('photoState.isPano');
}, canToggleAnnotations:function(get) {
  return !!(get('annoProps.hasAnnotations') && get('account.canRead') && !get('annotating') && !Ext.isIE8);
}, triggerOnShapeSelect:function(get) {
  var shapes = get('toolSettings.selectedShapes');
  if (shapes.length) {
    this.getView().lookupController().lookupReference('photoContainer').getController().onShapeSelect(shapes);
  }
}, backgroundStyle:{bind:{backroundCSS:'url({src})'}, get:function(data) {
  var view = this.getView().getController().getPhotoComponent();
  if (view && view.el && view.el.dom) {
    view.el.dom.style.backgroundImage = data.backroundCSS;
  }
  return data.backroundCSS;
}}, naturalWidth:function(get) {
  return (get('drawMode') == photoViewer.Values.DRAW_MEASURING ? get('unalteredWidth') : get('activePhoto.OriginalsWidth')) || 0;
}, naturalHeight:function(get) {
  return (get('drawMode') == photoViewer.Values.DRAW_MEASURING ? get('unalteredHeight') : get('activePhoto.OriginalsHeight')) || 0;
}, onModeChange:function(get) {
  var mode = get('toolSettings.mode'), annotating = get('drawing'), view = this.getView().getController().getPhotoComponent();
  if (annotating && mode == 'select') {
    view.el.addCls('mode-select');
  } else {
    view.el.removeCls('mode-select');
  }
  if (annotating && mode == 'pen') {
    view.el.addCls('mode-pen');
  } else {
    view.el.removeCls('mode-pen');
  }
  if (annotating && (mode != 'select' && mode != 'pen')) {
    view.el.addCls('mode-draw');
  } else {
    view.el.removeCls('mode-draw');
  }
  this.getView().getController().getPhotoComponent().lookupController().onModeChange(mode);
}, defaultShareTypeID:function(get) {
  return get('account.canShare') ? 1 : 2;
}, annotationsStrokeColourNoHash:{get:function(get) {
  var strokeColor = get('toolSettings.strokeColour');
  if (!strokeColor) {
    return strokeColor;
  }
  return strokeColor.charAt(0) == '#' ? strokeColor.substr(1) : strokeColor;
}, set:function(value) {
  if (!value || value.charAt(0) == '#') {
    this.set('toolSettings.strokeColour', value);
  } else {
    this.set('toolSettings.strokeColour', '#' + value);
  }
}}, activePhoto:{get:function(get) {
  return get('_selectedPhoto');
}, set:function(record) {
  var photoStore = this.get('photoStore');
  if (photoStore) {
    photoStore.each(function(rec) {
      rec.set('Active', rec == record);
    });
  }
  this.set('_selectedPhoto', record);
}}, floorplanModeOn:function(get) {
  return get('layoutMode') == 'floorplan';
}, floorplanWidgetCard:function(get) {
  return this.getView().lookupController().lookupReference('floorplanWidget').items.getAt(get('floorplanModeOn') ? 1 : 0);
}, largeFloorplanVisible:function(get) {
  return get('activePhoto.FloorplanUID') ? 'visible' : 'hidden';
}, photoGroup:{get:function(get) {
  return get('_photoGroup');
}, set:function(newPhotoGroup) {
  this.set('lastPhotoGroup', this.get('_photoGroup'));
  if (newPhotoGroup.get('Type') == 'B') {
    newPhotoGroup.set('Type', 'A');
  }
  this.set('_photoGroup', newPhotoGroup);
}}, canReadAnnotations:function(get) {
  return get('account.canRead') && !Ext.isIE8;
}, drawablesStore:function(get) {
  var activePhoto = get('activePhoto'), oldStore = this.get('_drawablesStore');
  if (!activePhoto) {
    return null;
  }
  if (oldStore) {
    oldStore.destroyShapes();
    oldStore.clearListeners();
    if (oldStore.isSyncing) {
      oldStore.addListener('datachanged', function() {
        oldStore.destroy();
      }, this, {buffer:10000});
    } else {
      oldStore.destroy();
    }
  }
  var controller = this.getView().lookupController(), store = Ext.create('photoViewer.store.Annotations', {proxy:{extraParams:{ProjectUID:this.get('ProjectUID'), photo:activePhoto.get('id')}}, listeners:{load:{fn:'onAnnotationsStoreLoad', scope:controller}, datachanged:{fn:'onAnnotationsDataChanged', scope:controller}, logevent:{fn:'logDrawablesEvent', scope:controller}}, usingMetric:this.get('usingMetric')});
  this.set('_drawablesStore', store);
  if (!activePhoto.get('HasDrawables') || !get('canReadAnnotations')) {
    this.set('drawingReady', true);
  } else {
    this.set('drawingReady', false);
    console.log('loading ' + store.getId());
    store.load();
  }
  return store;
}, writeDrawablesStore:function(get) {
  var drawMode = get('drawMode');
  if (drawMode == photoViewer.Values.DRAW_MEASURING) {
    return get('measurementsStore');
  }
  return get('drawablesStore');
}, measurementsStore:function(get) {
  var drawablesStore = get('drawablesStore'), drawablesDataChange = get('drawablesDataChange'), measurementsStore = get('_measurementsStore'), annosLoaded = get('annoProps.storeLoaded');
  if (drawablesStore && annosLoaded) {
    measurementsStore.setData(drawablesStore.getRange());
  } else {
    measurementsStore.removeAll();
  }
  return measurementsStore;
}, annotationStore:function(get) {
  var drawablesStore = get('drawablesStore'), drawablesDataChange = get('drawablesDataChange'), annotationStore = get('_annotationStore'), annosLoaded = get('annoProps.storeLoaded');
  if (drawablesStore && annosLoaded) {
    annotationStore.setData(drawablesStore.getRange());
  } else {
    annotationStore.removeAll();
  }
  return annotationStore;
}, activeDrawablesStore:function(get) {
  switch(get('drawMode')) {
    case photoViewer.Values.DRAW_ANNOTATING:
      return get('annotationStore');
    case photoViewer.Values.DRAW_MEASURING:
      return get('measurementsStore');
  }
  return get('drawablesStore');
}, selectedPhotos:function(get) {
  var store = get('photoStore'), selectedPhotoStore = this.get('_selectedPhotosStore'), photos = [], activePhoto = get('activePhoto'), lastSelectionChange = get('lastSelectionChange'), onlyOwnedPhotosSelected = store.getCount() ? true : false, oneOwnedPhotoSelected = false;
  if (store && lastSelectionChange) {
    store.each(function(rec) {
      if (rec.get('Selected')) {
        photos.push(rec);
      }
    });
  }
  if (!photos.length && activePhoto) {
    photos.push(activePhoto);
  }
  selectedPhotoStore.removeAll();
  selectedPhotoStore.add(photos);
  selectedPhotoStore.each(function(rec) {
    if (rec.get('IsOwnedByUser')) {
      oneOwnedPhotoSelected = true;
    } else {
      onlyOwnedPhotosSelected = false;
    }
  });
  var count = selectedPhotoStore.getCount();
  this.set('selectedPhotoCount', count);
  this.set('oneOwnedPhotoSelected', count ? oneOwnedPhotoSelected : false);
  this.set('onlyOwnedPhotosSelected', count ? onlyOwnedPhotosSelected : false);
  return selectedPhotoStore;
}, pageHasSettings:function(get) {
  var openAlbum = get('openAlbum');
  return openAlbum && !openAlbum.get('IsSystemAlbum') && openAlbum.get('IsUserAlbum');
}, followersMenuVisible:function(get) {
  return false;
  var openAlbum = get('openAlbum');
  return openAlbum && !openAlbum.get('IsSystemAlbum') && get('project.pushpinAlbumFollowEnabled') && get('openAlbum.ShareTypeID') != 2;
}, openAlbum:function(get) {
  if (!get('activePhoto')) {
    return null;
  }
  var store = get('albumStore'), photoGroup = get('photoGroup');
  if (!store || !photoGroup || photoGroup.get('Type') != 'A') {
    return null;
  }
  return store.getById(photoGroup.get('Identifier'));
}, shootLockAvailable:function(get) {
  var activePhoto = get('activePhoto');
  if (!activePhoto) {
    return false;
  }
  return activePhoto.get('HotspotID') && get('pvFloorplan') && !get('activeWebcam');
}, floorplanVisible:function(get) {
  return !!(get('activePhoto.FloorplanUID') || get('activePhoto.HotspotID') || get('activePhoto.PushpinUID'));
}, largeFloorplanVisible:function(get) {
  return get('floorplanVisible') && get('floorplanModeOn');
}, hasSpecialViewer:function(get) {
  return !!(get('photoState.isPano') || get('photoState.is360Pano'));
}, overlayVisible:function(get) {
  return !get('hasSpecialViewer');
}, annotationsAvailable:function(get) {
  return !get('hasSpecialViewer');
}, integrationsMenuVisible:function(get) {
  return get('activePhoto') && get('account.features.integrationsVisible') && (get('account.procoreEnabled') || get('account.planGridEnabled') || get('account.aconexEnabled') || get('account.bluebeamEnabled'));
}, writeableListsAndReports:function(get) {
  if (true) {
    return [];
  }
  if (!get('_listsAndReportsLoaded')) {
    return [];
  }
  return get('listsAndReports').getRange();
}, addCommentActionVisible:function(get) {
  return false;
}, drawing:function(get) {
  return get('drawMode') != photoViewer.Values.DRAW_OFF;
}, annotating:{get:function(get) {
  return get('drawMode') == photoViewer.Values.DRAW_ANNOTATING;
}, set:function(annotating) {
  this.set('drawMode', annotating ? photoViewer.Values.DRAW_ANNOTATING : photoViewer.Values.DRAW_OFF);
}}, measuring:{get:function(get) {
  return get('drawMode') == photoViewer.Values.DRAW_MEASURING;
}, set:function(measuring) {
  this.set('drawMode', measuring ? photoViewer.Values.DRAW_MEASURING : photoViewer.Values.DRAW_OFF);
}}, fullscreen:{get:function(get) {
  return get('sidePanelCollapsed') && get('photoThumbsCollapsed');
}, set:function(fullscreenOn) {
  this.set('sidePanelCollapsed', fullscreenOn);
  this.set('photoThumbsCollapsed', fullscreenOn);
}}, usingMetric:function(get) {
  return get('account.MeasurePreferenceID') == mdsData.PreferenceValues.MEASURE_PREFERENCE_METRIC;
}, gettingCmiLength:function(get) {
  return get('measureStep') == photoViewer.Values.MSR_CALCULATING;
}, photoIsWebcamPhoto:function(get) {
  return get('activePhoto.Type') == 'W';
}, viewMode:{get:function(get) {
  return get('photoState.isTruView') ? photoViewer.Values.VIEW_TRUVIEW : photoViewer.Values.VIEW_SITEWALK360;
}, set:function(value) {
  this.set('photoState.isTruView', value == photoViewer.Values.VIEW_TRUVIEW);
}}, measureInfoLink:function(get) {
  return get('usingMetric') ? 'https://info.multivista.com/measurable-3d-image-met' : 'https://info.multivista.com/measurable-3d-images';
}, truViewComponentVisible:function(get) {
  return get('photoState.isTruView') && !get('forceHideInteriorPano');
}, interiorPanoFrameVisible:function(get) {
  return get('photoState.isInteriorPano') && !get('photoState.isTruView') && !get('forceHideInteriorPano');
}, activeOrParentPhoto:function(get) {
  var photoGroup = get('photoGroup');
  return get('activePhoto') || (photoGroup ? photoGroup.get('ParentPhoto') : null);
}, activeWebcam:{get:function(get) {
  if (get('_webcamsLoaded')) {
    var activePhoto = get('activeOrParentPhoto'), activeStream = get('activeStream'), activeTimelapse = get('activeTimelapse'), webcams = get('webcams'), activeWebcam, webcamUID;
    if (activePhoto && activePhoto.get('WebcamUID')) {
      webcamUID = activePhoto.get('WebcamUID');
    }
    if (activeStream && activeStream.WebcamUID) {
      webcamUID = activeStream.WebcamUID;
    }
    if (activeTimelapse) {
      webcamUID = activeTimelapse.get('WebcamUID');
    }
    activeWebcam = webcams.getById(webcamUID);
    if (webcams) {
      webcams.each(function(rec) {
        rec.set('Active', rec == activeWebcam);
      });
    }
    return activeWebcam;
  }
  return null;
}, set:function(value) {
  var webcams = this.get('webcams');
  if (webcams) {
    webcams.each(function(rec) {
      rec.set('Active', rec == value);
    });
  }
}}, canSwitchToStream:function(get) {
  return get('activeWebcam') && get('activeWebcam.WebcamIsStreaming');
}, canSwitchToArchive:function(get) {
  return get('activeWebcam') && get('activeWebcam.MostRecentPhotoDate');
}, canSwitchToTimelapse:function(get) {
  return get('activeWebcam') && get('activeWebcam.TimelapseIsAvailable');
}, activeStreamSelected:function(get) {
  return !!get('activeStream');
}, activeTimelapseSelected:function(get) {
  return !!get('activeTimelapse');
}, activeArchiveSelected:function(get) {
  return !!(get('activePhoto') && get('activeWebcam'));
}, webcamPlaybackReady:function(get) {
  var activeStream = get('activeStream');
  if (activeStream) {
    if (activeStream.ForceFlashStream) {
      return get('flowplayerLoaded');
    } else {
      return get('h5LivePlayerLoaded');
    }
  }
  return false;
}, viewerDisabled:function(get) {
  return !get('activePhoto') && !get('activeStream') && !get('activeTimelapse');
}, showStreamZoomControls:function(get) {
  return get('overlayVisible') && (!get('activeStream.WebcamPTZEnabled') || get('PTZPosition'));
}, showStreamPanTiltControls:function(get) {
  return get('overlayVisible') && get('activeStream.WebcamPTZEnabled') && get('PTZPosition');
}, _activeWebcamRecord:function(get) {
  if (get('activeWebcam')) {
    return get('activeWebcam');
  }
  return Ext.create('photoViewer.model.Webcam', {PTZPresets:null, ArchivePositions:null});
}, webcamPositions:function(get) {
  var activeWebcam = get('activeWebcam'), activeStream = get('activeStream'), store = Ext.create('Ext.data.Store', {proxy:'memory'});
  if (!activeWebcam) {
    return store;
  }
  if (activeStream && get('_activeWebcamRecord.PTZPresets')) {
    return Ext.create('Ext.data.Store', {proxy:'memory', data:get('_activeWebcamRecord.PTZPresets')});
  }
  if (get('_activeWebcamRecord.ArchivePositions')) {
    store = Ext.create('Ext.data.Store', {proxy:'memory', data:get('_activeWebcamRecord.ArchivePositions')});
  }
  if (get('activeTimelapse')) {
    store.filterBy(function(record) {
      return !!record.get('TimelapseURL');
    });
  }
  return store;
}, selectedWebcamPosition:{get:function(get) {
  var activeWebcam = get('activeWebcam'), activeStream = get('activeStream');
  if (!activeWebcam) {
    return null;
  }
  if (activeStream) {
    if (get('_selectedPTZPreset')) {
      return get('_selectedPTZPreset');
    }
  } else {
    if (get('_selectedArchivePosition')) {
      return get('_selectedArchivePosition');
    } else {
      return get('webcamPositions').getAt(0);
    }
  }
}, set:function(value) {
  if (Ext.isObject(value)) {
    var activeStream = this.get('activeStream');
    if (activeStream) {
      this.set('_selectedPTZPreset', value);
      if (value && value.get('ArchivePositionID')) {
        this.set('_selectedArchivePosition', value);
      }
    } else {
      this.set('_selectedArchivePosition', value);
    }
  }
}}, showWebcamPositionSelector:function(get) {
  var activeWebcam = get('activeWebcam'), activePhoto = get('activePhoto'), activeTimelapse = get('activeTimelapse');
  if (!activeWebcam) {
    return false;
  }
  return get('webcamPositions').getCount() > 1 && (activePhoto || activeTimelapse);
}, nextPrevButtonsVisible:function(get) {
  if (get('activeTimelapse') || get('activeStream') && (get('fullscreen') || get('webcams').count() == 1)) {
    return false;
  }
  return true;
}, showPhotoPositionControls:function(get) {
  var activePhoto = get('activePhoto'), activeStream = get('activeStream');
  if (activePhoto) {
    return true;
  }
  if (activeStream && !activeStream.WebcamPTZEnabled) {
    return true;
  }
  return false;
}, photoCanBeSaved:function(get) {
  return !!(get('selectedPhotoCount') || get('activeStream'));
}, ptzPresetCanBeDeleted:function(get) {
  return get('account.canEditPTZ') && !get('selectedWebcamPosition.ArchivePositionID');
}, ptzControlsHidden:function(get) {
  return !(get('account.canUsePTZ') && get('activeStream') && get('activeStream.WebcamPTZEnabled'));
}}}, 0, 0, 0, 0, ['viewmodel.photoviewer'], 0, [photoViewer.view.photoviewer, 'PhotoViewerModel'], 0);
Ext.cmd.derive('photoViewer.view.photoviewer.PhotoViewerToolTip', Ext.tip.QuickTip, {anchorToTarget:true, cls:'x-tip-dark', anchorSize:[0, 12], shadow:false}, 0, ['photoviewertooltip'], ['component', 'box', 'container', 'panel', 'tip', 'tooltip', 'quicktip', 'photoviewertooltip'], {'component':true, 'box':true, 'container':true, 'panel':true, 'tip':true, 'tooltip':true, 'quicktip':true, 'photoviewertooltip':true}, ['widget.photoviewertooltip'], 0, [photoViewer.view.photoviewer, 'PhotoViewerToolTip'], 
0);
Ext.cmd.derive('photoViewer.view.photoviewer.PhotoViewerWelcome', Ext.window.Window, {modal:true, ui:'orange', cls:'photo-actions-window', title:'Welcome to our new Photoviewer!', padding:'40 45 30 45', reference:'photoViewerWelcome', items:[{xtype:'component', html:'\x3ch1\x3eWelcome to the NEW Multivista Photoviewer!\x3c/h1\x3e\x3cp\x3eMultivista’s lighting fast new photoviewer has been redesigned to provide a larger viewing area, split-screen capabilities for easier floor plan navigation, a simplified user interface for more efficient workflows, and the ability to capture in-image measurements on Multivista 3D Images.\x3c/p\x3e\x3cp\x3eClick "Check it Out" to have a look around!\x3c/p\x3e\x3cbr/\x3e\x3cp class\x3d\'note\'\x3e*If you prefer to use the last-generation photoviewer, which will be available only through September 20th, click \x3ca\x3ehere.\x3c/a\x3e\x3c/p\x3e'}], 
modalMaskCls:'modal-transparent', dockedItems:[{xtype:'container', dock:'bottom', width:'100%', padding:'40 0 0 0', layout:{type:'hbox', pack:'middle'}, defaults:{xtype:'button', scale:'medium', margin:'0 12 0 12'}, items:[{ui:'grey-smallerfont', text:'Review Later', listeners:{click:function() {
  this.up('photoviewerwelcome').destroy();
}}}, {ui:'green-smallerfont', text:'Check it Out', listeners:{click:'showTour'}}]}], listeners:{render:function(component) {
  component.el.select('a').elements[0].onclick = Ext.bind(function() {
    this.lookupController().switchPhotoViewer();
  }, this);
}}}, 0, ['photoviewerwelcome'], ['component', 'box', 'container', 'panel', 'window', 'photoviewerwelcome'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true, 'photoviewerwelcome':true}, ['widget.photoviewerwelcome'], 0, [photoViewer.view.photoviewer, 'PhotoViewerWelcome'], 0);
Ext.cmd.derive('photoViewer.view.positioncontrols.CreatePresetWindow', Ext.window.Window, {modal:true, modalMaskCls:'dark-mask', ui:'orange', width:370, height:216, alwaysOnTop:1, localized:{title:'WV_Create Preset'}, padding:'25 25 25 25', layout:{type:'vbox', align:'middle'}, items:[{xtype:'detailformtextfield', localized:{fieldLabel:'WV_Preset Name'}, reference:'newPresetName', width:312, validator:function(value) {
  var vm = this.lookupViewModel(), positions = vm.get('webcamPositions'), exists = positions.findExact('Name', value) > -1;
  if (value.length > 31) {
    return mvstr['WV_Preset name length mu'];
  }
  if (value.match(/(["<>~:#&=,])+/g)) {
    return mvstr['WV_Preset name cannot co'] + ': " , \x3c \x3e ~ : # \x26 \x3d';
  }
  if (exists) {
    return mvstr['WV_Preset with this name exists'];
  }
  return true;
}}], modalMaskCls:'modal-transparent', dockedItems:[{xtype:'container', dock:'bottom', width:'100%', padding:'10 0 0 0', layout:{type:'hbox', pack:'middle'}, defaults:{xtype:'button', scale:'medium', margin:'0 12 0 12', padding:'0 5', height:30}, items:[{ui:'grey', localized:{text:'G_Cancel'}, listeners:{click:function(btn) {
  btn.up('window').destroy();
}}}, {ui:'orange', localized:{text:'G_Done'}, listeners:{click:function(btn) {
  var container = btn.up('window'), field = container.down('textfield'), name = field.getValue(), vm = container.getViewModel(), stream = vm.get('activeStream');
  if (!field.isValid()) {
    return;
  }
  if (name) {
    Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daClientWebcam.savePreset', params:{WebcamUID:stream.WebcamUID, ProjectUID:stream.ProjectUID, name:name}, successCallback:function(data) {
      app.fireEvent('reloadwebcampositions');
      btn.up('window').destroy();
    }});
  } else {
    btn.up('window').destroy();
  }
}}}]}]}, 0, ['createpresetwindow'], ['component', 'box', 'container', 'panel', 'window', 'createpresetwindow'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true, 'createpresetwindow':true}, ['widget.createpresetwindow'], 0, [photoViewer.view.positioncontrols, 'CreatePresetWindow'], 0);
Ext.cmd.derive('photoViewer.view.positioncontrols.PhotoPositionControls', Ext.Container, {layout:'vbox', width:36, defaults:{width:36, height:36, style:{zIndex:2}, hidden:true, margin:'0 0 6 0'}, items:[{xtype:'button', text:'+', cls:'zoom-in-button', bind:{hidden:'{!overlayVisible}'}, listeners:{click:'zoomIn'}, tooltip:{localized:{text:'ZC_Zoom in'}, anchor:'top'}}, {xtype:'button', itemId:'photoViewerZoomOutButton', text:'-', cls:'zoom-out-button', bind:{hidden:'{!overlayVisible}'}, listeners:{click:'zoomOut'}, 
tooltip:{localized:{text:'ZC_Zoom out'}, anchor:'top'}}, {xtype:'button', icon:'mds/image/icon/reset.png', cls:'reset-button', bind:{hidden:'{!overlayVisible}'}, listeners:{click:function() {
  this.lookupController().resetPhotoDisplay(false);
}}, tooltip:{localized:{text:'PV_Reset Display'}, anchor:'top'}}]}, 0, ['photopositioncontrols'], ['component', 'box', 'container', 'photopositioncontrols'], {'component':true, 'box':true, 'container':true, 'photopositioncontrols':true}, ['widget.photopositioncontrols'], 0, [photoViewer.view.positioncontrols, 'PhotoPositionControls'], 0);
Ext.cmd.derive('photoViewer.view.positioncontrols.StreamPositionControls', Ext.Container, {controller:'streampositioncontrols', layout:{type:'vbox', align:'middle'}, width:152, defaults:{style:{zIndex:2}, hidden:true}, items:[{xtype:'streampositionslider', reference:'zoomSlider', cls:'webcam-control-slider', vertical:true, padding:2, height:149, listeners:{changecomplete:'zoomValueChanged'}, bind:{hidden:'{!showStreamZoomControls}'}}, {xtype:'container', width:152, height:140, margin:'6 0 0 0', layout:{type:'vbox', 
align:'middle'}, bind:{hidden:'{!showStreamPanTiltControls}'}, reference:'panCircle', items:[{xtype:'draw', activeCounter:1, plugins:['spriteevents'], width:136, height:136, cls:'pan-circle', anchor:'0 0', sprites:[{type:'rect', x:0, y:0, height:136, width:136, fillOpacity:1.0E-5, fillStyle:'#777777'}, {type:'circle', cx:68, cy:68, r:60, fillStyle:'#000000', strokeStyle:'#4e4e4e', lineWidth:1, fillOpacity:0.6}, {type:'arc', reference:'panTrack', cx:68, cy:68, r:60, strokeStyle:'#a8a8a8', lineWidth:2, 
rotation:-90}, {type:'line', reference:'minPanLine', fromX:68, fromY:2, toX:68, toY:14, lineWidth:2, rotationCenterX:68, rotationCenterY:68}, {type:'line', reference:'maxPanLine', fromX:68, fromY:2, toX:68, toY:14, lineWidth:2, rotationCenterX:68, rotationCenterY:68}, {type:'arc', reference:'panMarkerOutline', cx:68, cy:9, r:8, rotationCenterX:68, rotationCenterY:68, strokeOpacity:1, strokeStyle:'#F0F0F0', lineWidth:2}, {type:'circle', reference:'panMarker', cx:68, cy:9, r:6, rotationCenterX:68, 
rotationCenterY:68, rotation:0, fillStyle:'#F0F0F0', strokeStyle:'#4e4e4e', lineWidth:2}], listeners:{spritemousedown:'panSpriteMouseDown', spritemousemove:'panSpriteMouseMove', spritemouseout:{buffer:250, fn:'panSpriteMouseOut'}, spritemouseup:'panSpriteMouseUp', spriteclick:'panSpriteClick'}}, {xtype:'streampositionslider', reference:'tiltSlider', buttonType:'arrow', vertical:true, height:90, listeners:{changecomplete:'tiltValueChanged'}, margin:'-113 0 0 0', style:{position:'absolute', zIndex:3}}, 
{xtype:'container', layout:'hbox', width:'100%', margin:'-8 0 0 0', style:{position:'absolute'}, items:[{xtype:'button', cls:'ptz-reset-button', handler:'resetPTZPosition', style:{zIndex:3}}, {xtype:'container', flex:1}, {xtype:'button', cls:'ptz-add-button', text:'+', handler:'createPTZPresetPressed', bind:{disabled:'{!account.canEditPTZ}'}, style:{zIndex:3}}]}]}, {xtype:'container', layout:'hbox', width:152, cls:'ptz-container', padding:'2 1', height:32, margin:'0 0 6 0', bind:{hidden:'{!showStreamPanTiltControls}'}, 
defaults:{xtype:'numberfield', cls:'ptz-input-field', labelSeparator:'', labelWidth:7, width:40, margin:'3 0', hideTrigger:true}, items:[{fieldLabel:'P', reference:'panNumberField', listeners:{change:{fn:function(field, value) {
  analytics.Ctrl.setOptionalDefaultEventProperties({'Method':'Slider', 'Sub Method':'Text Input'});
  this.lookupController().panValueChanged(field, value);
}, buffer:1000}}}, {xtype:'label', cls:'ptz-input-field degree', width:6, margin:'3 0 3 1', text:'°'}, {fieldLabel:'T', reference:'tiltNumberField', listeners:{change:{fn:function(field, value) {
  analytics.Ctrl.setOptionalDefaultEventProperties({'Method':'Slider', 'Sub Method':'Text Input'});
  this.lookupController().tiltValueChanged(field, value);
}, buffer:1000}}}, {xtype:'label', cls:'ptz-input-field percent', width:6, margin:'3 3 3 1', text:'%'}, {fieldLabel:'Z', reference:'zoomNumberField', listeners:{change:{fn:function(field, value) {
  analytics.Ctrl.setOptionalDefaultEventProperties({'Method':'Slider', 'Sub Method':'Text Input'});
  this.lookupController().zoomValueChanged(field, value);
}, buffer:1000}}}, {xtype:'label', cls:'ptz-input-field percent', width:6, margin:'3 1 3 1', text:'%'}]}, {xtype:'container', layout:{type:'hbox', align:'middle', pack:'center'}, width:152, height:32, cls:'ptz-container', bind:{hidden:'{!showStreamPanTiltControls}'}, items:[{xtype:'combobox', displayField:'Name', flex:1, height:'100%', editable:false, cls:'ptz-presets', listConfig:{cls:'photo-viewer-ptz-presets', shadow:false}, bind:{store:'{webcamPositions}', value:'{selectedWebcamPosition}'}, listeners:{select:'presetSelected'}}, 
{xtype:'button', ui:'more-options', scale:'small', width:20, menuAlign:'r', bind:{disabled:'{!_selectedPTZPreset}'}, menu:{cls:'photo-viewer-ptz-menu', minWidth:60, showSeparator:false, shadow:false, items:[{localized:{text:'PTZ_Create'}, scale:'small', handler:'createPTZPresetPressed', bind:{disabled:'{!account.canEditPTZ}'}}, {localized:{text:'PTZ_Delete'}, scale:'small', disabled:true, bind:{disabled:'{!ptzPresetCanBeDeleted}'}, handler:'deletePTZPresetPressed'}]}}]}], listeners:{show:'handleResize'}}, 
0, ['streampositioncontrols'], ['component', 'box', 'container', 'streampositioncontrols'], {'component':true, 'box':true, 'container':true, 'streampositioncontrols':true}, ['widget.streampositioncontrols'], 0, [photoViewer.view.positioncontrols, 'StreamPositionControls'], 0);
Ext.cmd.derive('photoViewer.view.positioncontrols.StreamPositionControlsController', Ext.app.ViewController, {updatePositionTimeout:null, PTZPositionRequest:null, PTZLimitsRequest:null, PTZPresetRequest:null, PanMovementActive:false, PanMovementTimestamp:null, PanMovementStartAngle:null, init:function() {
  var vm = this.getViewModel();
  vm.bind({activeStream:'{activeStream}'}, this.onStreamChange, this);
  vm.bind('{activeWebcam}', this.onWebcamChange, this);
  vm.bind({PTZPosition:'{PTZPosition}'}, function(data) {
    var ptz = data.PTZPosition, livestream = this.getView().up('photocontainer').lookupReference('webcamLiveStream');
    if (!ptz) {
      livestream.setPTZMaskVisibility(false);
      return;
    }
    livestream.setPTZMaskVisibility(true);
    if (ptz.pan) {
      this.setPanMarkerPosition(ptz.pan);
      this.lookupReference('panNumberField').setRawValue(Math.round(ptz.pan));
    }
    if (ptz.tilt) {
      this.lookupReference('tiltSlider').setValue(ptz.tilt);
      var convertedTilt = this.convertTiltValue(ptz.tilt, true);
      this.lookupReference('tiltNumberField').setRawValue(convertedTilt);
    }
    if (ptz.zoom) {
      this.lookupReference('zoomSlider').setValue(ptz.zoom);
      var convertedZoom = this.convertZoomValue(ptz.zoom, true);
      this.lookupReference('zoomNumberField').setRawValue(convertedZoom);
    }
  }, this);
  app.addListener('reloadwebcampositions', this.getPTZPresets, this);
  app.addListener('forceupdateptzposition', function() {
    this.updatePosition(true);
  }, this);
  this.getView().up('photocontainer').lookupReference('webcamLiveStream').on('resize', this.handleResize, this);
}, getWebcam:function() {
  return this.getViewModel().get('activeWebcam');
}, onWebcamChange:function(activeWebcam) {
  if (!activeWebcam) {
    return;
  }
  var vm = this.getViewModel();
  vm.set('PTZPosition', null);
  var presets = activeWebcam.get('PTZPresets'), selectedPreset = vm.get('_selectedPTZPreset');
  if (!(presets && selectedPreset && Ext.Array.contains(presets, selectedPreset.data))) {
    vm.set('_selectedPTZPreset', null);
  }
  var archivePositions = activeWebcam.get('ArchivePositions'), selectedAP = vm.get('_selectedArchivePosition');
  if (!(archivePositions && selectedAP && Ext.Array.findBy(archivePositions, function(rec) {
    return rec.ArchivePositionID == selectedAP.get('ArchivePositionID');
  }))) {
    vm.set('_selectedArchivePosition', null);
  }
}, onStreamChange:function(data) {
  clearTimeout(this.updatePositionTimeout);
  if (this.PTZPositionRequest) {
    Ext.Ajax.abort(this.PTZPositionRequest);
  }
  if (this.PTZLimitsRequest) {
    Ext.Ajax.abort(this.PTZLimitsRequest);
  }
  if (this.PTZPresetRequest) {
    Ext.Ajax.abort(this.PTZPresetRequest);
  }
  if (!data.activeStream || !data.activeStream.WebcamPTZEnabled) {
    return;
  }
  if (this.getWebcam().PTZLimits) {
    if (!this.getWebcam().PTZPresets) {
      this.getPTZPresets();
    }
    this.updatePosition();
    this.updatePanSliderLimits();
  } else {
    this.getPTZLimits();
  }
}, getPTZLimits:function() {
  var viewModel = this.getViewModel(), activeStream = viewModel.get('activeStream'), controller = this;
  this.PTZLimitsRequest = Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daClientWebcam.getPTZSettings', params:{WebcamUID:activeStream.WebcamUID, ProjectUID:activeStream.ProjectUID}, successCallback:function(data) {
    if (!data.PTZPosition || Ext.Object.isEmpty(data.PTZPosition)) {
      Ext.Msg.alert('', mvstr['WV_Camera position contr']);
      return;
    }
    for (var key in data.PTZPosition) {
      if (data.PTZPosition.hasOwnProperty(key) && !isNaN(data.PTZPosition[key])) {
        data.PTZPosition[key] = data.PTZPosition[key] - 0;
      }
    }
    for (var key in data.PTZLimits) {
      if (data.PTZLimits.hasOwnProperty(key) && !isNaN(data.PTZLimits[key])) {
        data.PTZLimits[key] = data.PTZLimits[key] - 0;
      }
    }
    viewModel.set('PTZPosition', data.PTZPosition);
    controller.getWebcam().PTZLimits = data.PTZLimits;
    controller.updatePanSliderLimits(data.PTZLimits);
    setTimeout(Ext.bind(controller.updatePosition, controller), 10 * 1000);
    controller.getPTZPresets();
  }, noResponseCallback:function() {
    if (controller.PTZLimitsRequest && controller.PTZLimitsRequest.aborted) {
      return;
    }
    Ext.Msg.alert('', mvstr['WV_Camera position contr']);
  }});
}, updatePosition:function(logAnalytics) {
  if (this.PTZPositionRequest) {
    Ext.Ajax.abort(this.PTZPositionRequest);
  }
  if (this.updatePositionTimeout) {
    clearTimeout(this.updatePositionTimeout);
  }
  var viewModel = this.getViewModel(), activeStream = viewModel.get('activeStream'), controller = this;
  if (!activeStream || !activeStream.WebcamPTZEnabled) {
    return;
  }
  this.PTZPositionRequest = Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daClientWebcam.getPTZPosition', params:{WebcamUID:activeStream.WebcamUID, ProjectUID:activeStream.ProjectUID}, successCallback:function(data) {
    if (Ext.Object.isEmpty(data)) {
      if (viewModel.get('PTZPosition')) {
        Ext.Msg.alert('', mvstr['WV_Camera position contr']);
        viewModel.set('PTZPosition', null);
      }
      return;
    }
    for (var key in data) {
      if (data.hasOwnProperty(key) && !isNaN(data[key])) {
        data[key] = data[key] - 0;
      }
    }
    if (logAnalytics) {
      var eventProperties = {};
      if (data.hasOwnProperty('pan')) {
        eventProperties.Pan = data.pan;
      }
      if (data.hasOwnProperty('tilt')) {
        eventProperties.Tilt = data.tilt;
      }
      if (data.hasOwnProperty('zoom')) {
        eventProperties.Zoom = data.zoom;
      }
      analytics.Ctrl.log('PTZ Control', eventProperties, ['Webcam UID', 'Method', 'Sub Method']);
    }
    viewModel.set('PTZPosition', data);
    controller.matchCurrentPositionToPreset();
    controller.updatePositionTimeout = setTimeout(Ext.bind(controller.updatePosition, controller), 30 * 1000);
  }, noResponseCallback:function() {
    if (!controller.PTZPositionRequest.aborted) {
      viewModel.set('PTZPosition', null);
    }
  }});
}, getPTZPresets:function() {
  var viewModel = this.getViewModel(), activeStream = viewModel.get('activeStream');
  this.PTZPresetRequest = Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daClientWebcam.getPTZPresets', params:{WebcamUID:activeStream.WebcamUID, ProjectUID:activeStream.ProjectUID, force:true}, scope:this, successCallback:function(data) {
    viewModel.set('activeWebcam.PTZPresets', data);
    this.matchCurrentPositionToPreset();
  }});
}, matchCurrentPositionToPreset:function() {
  var viewModel = this.getViewModel(), presetStore = viewModel.get('webcamPositions'), ptzPosition = viewModel.get('PTZPosition');
  if (!ptzPosition) {
    return;
  }
  presetStore.each(function(record) {
    var match = true;
    var keys = ['pan', 'tilt', 'zoom'];
    for (var i in keys) {
      var multiplier = ptzPosition[keys[i]] < 0 ? -1 : 1, current = multiplier * ptzPosition[keys[i]], preset = multiplier * record.get(keys[i]);
      match = match && (preset + -1 <= current && current <= preset + 1);
      if (match) {
        viewModel.set('selectedWebcamPosition', record);
        return;
      }
    }
  });
  if (!viewModel.get('selectedWebcamPosition')) {
    var home = presetStore.findRecord('isHome', true);
    if (!home) {
      return;
    }
    viewModel.set('selectedWebcamPosition', home);
  }
}, presetSelected:function(combobox, record) {
  var id = record.get('id');
  if (!id) {
    return;
  }
  this.moveToPreset(id);
  this.getViewModel().set('selectedWebcamPosition', record);
  analytics.Ctrl.log('Selected Camera Position', {'Webcam View':'Live Stream', 'Position Name':record.get('Name')}, ['Webcam UID']);
}, ptzValueChange:function(type, value) {
  if (!Ext.isNumber(value)) {
    return;
  }
  var vm = this.getViewModel(), activeStream = vm.get('activeStream'), ptzPosition = JSON.parse(JSON.stringify(vm.get('PTZPosition')));
  if (this.PTZPositionRequest) {
    Ext.Ajax.abort(this.PTZPositionRequest);
  }
  if (this.updatePositionTimeout) {
    clearTimeout(this.updatePositionTimeout);
  }
  ptzPosition[type] = value;
  vm.set('PTZPosition', ptzPosition);
  Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daClientWebcam.move\x26' + type + '\x3d' + value, params:{WebcamUID:activeStream.WebcamUID, ProjectUID:activeStream.ProjectUID}, successCallback:Ext.callback(this.updatePosition, this, [true], 3000)});
}, moveToPreset:function(id) {
  var vm = this.getViewModel(), activeStream = vm.get('activeStream');
  if (activeStream.WebcamPTZEnabled) {
    Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daClientWebcam.setPreset', params:{WebcamUID:activeStream.WebcamUID, ProjectUID:activeStream.ProjectUID, id:id}, successCallback:Ext.bind(this.updatePosition, this)});
  }
}, panSpriteMouseDown:function(item, event) {
  var sprite = item.sprite;
  if (sprite.reference == 'panMarker') {
    this.PanMovementActive = true;
    this.PanMovementStartAngle = this.getPanMarkerPosition();
  }
}, panSpriteMouseMove:function(item, event) {
  if (this.PanMovementActive) {
    this.PanMovementTimestamp = event.getTime();
    var limits = this.getWebcam().PTZLimits;
    var angle = this.getPanMouseEventAngle(event);
    if (angle >= limits.MinPan && angle <= limits.MaxPan) {
      this.setPanMarkerPosition(angle, false);
    }
  }
  var container = this.lookupReference('panCircle');
  if (this.checkSpriteClickOnPanTrack(event)) {
    container.setStyle({'cursor':'pointer'});
  } else {
    container.setStyle({'cursor':'default'});
  }
}, panSpriteMouseUp:function(item, event) {
  if (this.PanMovementActive) {
    this.PanMovementActive = false;
    this.ptzValueChange('pan', this.getPanMarkerPosition());
  }
}, panSpriteMouseOut:function(item, event) {
  var cancel = this.PanMovementActive && Ext.Date.now() - this.PanMovementTimestamp > 250;
  if (cancel) {
    this.PanMovementActive = false;
    this.PanMovementTimestamp = null;
    if (this.PanMovementStartAngle) {
      this.setPanMarkerPosition(this.PanMovementStartAngle);
    }
  }
}, panSpriteClick:function(item, event) {
  if (this.checkSpriteClickOnPanTrack(event)) {
    var angle = this.getPanMouseEventAngle(event);
    this.setPanMarkerPosition(angle, true);
    this.ptzValueChange('pan', angle);
  }
}, checkSpriteClickOnPanTrack:function(event) {
  var container = this.lookupReference('panCircle'), x = event.pageX - container.getX() - container.getWidth() / 2, y = -1 * (event.pageY - container.getY() - container.getHeight() / 2);
  sprites = container.down('draw').getSprites(), track = Ext.Array.findBy(sprites, function(sprite) {
    return sprite.reference == 'panTrack';
  }), clickDistanceFromCenter = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
  var returnVal = track.r - 10 < clickDistanceFromCenter && track.r + 10 > clickDistanceFromCenter;
  var limits = this.getWebcam().PTZLimits;
  var angle = this.getPanMouseEventAngle(event);
  return angle >= limits.MinPan && angle <= limits.MaxPan && returnVal;
}, getPanMouseEventAngle:function(event) {
  var container = this.lookupReference('panCircle'), x = event.pageX - container.getX() - container.getWidth() / 2, y = -1 * (event.pageY - container.getY() - container.getHeight() / 2);
  var angle = -1 * (Math.atan2(y, x) * (180 / Math.PI) - 90);
  if (angle > 180) {
    angle -= 360;
  }
  return angle;
}, getPanMarkerPosition:function() {
  var container = this.lookupReference('panCircle'), drawContainer = container.down('draw'), sprites = drawContainer.getSprites(), marker = Ext.Array.findBy(sprites, function(sprite) {
    return sprite.reference == 'panMarker';
  });
  return marker.attr.rotationRads * 180 / Math.PI;
}, setPanMarkerPosition:function(degrees, animate) {
  var container = this.lookupReference('panCircle'), drawContainer = container.down('draw'), sprites = drawContainer.getSprites(), surface = drawContainer.getSurface(), marker = Ext.Array.findBy(sprites, function(sprite) {
    return sprite.reference == 'panMarker';
  }), markerOutline = Ext.Array.findBy(sprites, function(sprite) {
    return sprite.reference == 'panMarkerOutline';
  });
  if (animate) {
    markerOutline.setAnimation({duration:500, easing:'easeInOut'});
    marker.setAnimation({duration:500, easing:'easeInOut'});
  } else {
    markerOutline.setAnimation({duration:0});
    marker.setAnimation({duration:0});
  }
  markerOutline.setAttributes({rotation:degrees});
  marker.setAttributes({rotation:degrees});
  surface.renderFrame();
}, updatePanSliderLimits:function(limits) {
  var limits = limits || this.getWebcam().PTZLimits, tiltLimits = {MinValue:limits.MinTilt, MaxValue:limits.MaxTilt}, zoomLimits = {MinValue:limits.MinZoom, MaxValue:limits.MaxZoom}, panLimits = {MinValue:limits.MinPan, MaxValue:limits.MaxPan};
  this.lookupReference('tiltSlider').setConfig(tiltLimits);
  this.lookupReference('tiltNumberField').setConfig({MinValue:0, MaxValue:100});
  this.lookupReference('zoomSlider').setConfig(zoomLimits);
  this.lookupReference('zoomNumberField').setConfig({MinValue:0, MaxValue:100});
  this.lookupReference('panNumberField').setConfig(panLimits);
  var container = this.lookupReference('panCircle'), drawContainer = container.down('draw'), sprites = drawContainer.getSprites(), surface = drawContainer.getSurface(), track = Ext.Array.findBy(sprites, function(sprite) {
    return sprite.reference == 'panTrack';
  }), minPanLine = Ext.Array.findBy(sprites, function(sprite) {
    return sprite.reference == 'minPanLine';
  }), maxPanLine = Ext.Array.findBy(sprites, function(sprite) {
    return sprite.reference == 'maxPanLine';
  });
  var minRadians = limits.MinPan * Math.PI / 180;
  var maxRadians = limits.MaxPan * Math.PI / 180;
  if (limits.MaxPan != 180 || limits.MinPan != -180) {
    minPanLine.setAttributes({rotation:limits.MinPan, strokeStyle:'#a8a8a8'});
    maxPanLine.setAttributes({rotation:limits.MaxPan, strokeStyle:'#a8a8a8'});
  } else {
    minPanLine.setAttributes({strokeStyle:'none'});
    maxPanLine.setAttributes({strokeStyle:'none'});
  }
  track.setAttributes({startAngle:minRadians, endAngle:maxRadians}, true);
  surface.renderFrame();
}, panValueChanged:function(field, value) {
  var enforceBounds = field.minValue && field.maxValue;
  if (enforceBounds && (value < field.minValue || value > field.maxValue)) {
    return;
  }
  this.ptzValueChange('pan', value);
}, tiltValueChanged:function(field, value) {
  var enforceBounds = field.minValue && field.maxValue;
  if (enforceBounds && (value < field.minValue || value > field.maxValue)) {
    return;
  }
  if (field.reference == 'tiltNumberField') {
    value = this.convertTiltValue(value, false);
  }
  this.ptzValueChange('tilt', value);
}, zoomValueChanged:function(field, value) {
  var enforceBounds = field.minValue && field.maxValue;
  if (enforceBounds && (value < field.minValue || value > field.maxValue)) {
    return;
  }
  if (field.reference == 'zoomNumberField') {
    value = this.convertZoomValue(value, false);
  }
  this.ptzValueChange('zoom', value);
}, resetPTZPosition:function() {
  var vm = this.getViewModel(), pos = vm.get('selectedWebcamPosition');
  if (pos && pos.get('id') && Ext.isNumeric(pos.get('id'))) {
    this.moveToPreset(pos.get('id'));
  }
}, createPTZPresetPressed:function() {
  var viewModel = this.getViewModel();
  Ext.create('photoViewer.view.positioncontrols.CreatePresetWindow', {viewModel:{parent:viewModel}}).show();
}, deletePTZPresetPressed:function() {
  var controller = this, record = this.getViewModel().get('selectedWebcamPosition'), presets = this.getViewModel().get('webcamPositions'), activeStream = this.getViewModel().get('activeStream');
  if (record.get('ArchivePositionID')) {
    return;
  }
  analytics.Ctrl.log('Clicked Delete Preset Button', {}, ['Webcam UID']);
  MDS.Msg.show({xtype:'mmvmsgbox', title:mvstr['PTZ_Delete Preset'], message:mvstr["PTZ_Are you sure you'd li"], buttonText:{action:mvstr['G_Yes'], cancel:mvstr['G_Cancel']}, maxWidth:400, fn:function(btn) {
    if (btn == 'action') {
      Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daClientWebcam.removePreset', params:{WebcamUID:activeStream.WebcamUID, ProjectUID:activeStream.ProjectUID, name:record.get('Name')}, successCallback:function() {
        presets.remove(record);
        controller.matchCurrentPositionToPreset();
      }});
    }
  }, scope:this, transparentModal:true});
}, convertZoomValue:function(value, convertToPercentage) {
  var limits = this.getWebcam().PTZLimits;
  if (convertToPercentage) {
    return Math.round(100 * value / (limits.MaxZoom - limits.MinZoom));
  } else {
    return value / 100 * (limits.MaxZoom - limits.MinZoom);
  }
}, convertTiltValue:function(value, convertToPercentage) {
  var limits = this.getWebcam().PTZLimits, min = limits.MinTilt, max = limits.MaxTilt, offset = 0 - min, offsetMax = max + offset;
  if (convertToPercentage) {
    return Math.round(Math.min(Math.max((value + offset) / offsetMax * 100, 0), 100));
  } else {
    return min + (max - min) * value / 100;
  }
}, handleResize:function() {
  var view = this.getView(), photoContainer = view.up('photocontainer'), streamContainer = photoContainer.lookupReference('webcamLiveStream').down('#wcLiveStreamContainer'), prevButtonWidth = photoContainer.down('button[cls\x3dprev-photo-button]').getWidth();
  var requiredSpace = view.getWidth() + prevButtonWidth;
  var givenSpace = (photoContainer.getWidth() - streamContainer.getWidth()) / 2;
  if (givenSpace < requiredSpace) {
    var x = givenSpace < prevButtonWidth ? prevButtonWidth - givenSpace : 15;
    view.alignTo(streamContainer.getId(), 'tl?', [x, 15]);
  } else {
    view.alignTo(photoContainer.getId(), 'tl?', [prevButtonWidth, 15]);
  }
}}, 0, 0, 0, 0, ['controller.streampositioncontrols'], 0, [photoViewer.view.positioncontrols, 'StreamPositionControlsController'], 0);
Ext.cmd.derive('photoViewer.view.positioncontrols.StreamPositionSlider', Ext.container.Container, {constructor:function(config) {
  config = config || {};
  var vertical = !!config.vertical;
  var incrementButtonCls = 'plus', decrementButtonCls = 'minus';
  var slider = {xtype:'slider', cls:'control-slider', vertical:vertical, flex:1, listeners:{changecomplete:function(slider, newValue) {
    analytics.Ctrl.setOptionalDefaultEventProperties({'Method':'Slider', 'Sub Method':'Slider Drag'});
    var container = slider.up('streampositionslider');
    container.fireEvent('changecomplete', slider, newValue);
  }}};
  if (vertical) {
    config.cls = config.cls + ' vertical';
    config.layout = {type:'vbox', align:'middle'};
    if (config.buttonType == 'arrow') {
      incrementButtonCls = 'up';
      decrementButtonCls = 'down';
    }
  } else {
    config.layout = 'hbox';
    if (config.buttonType == 'arrow') {
      incrementButtonCls = 'right';
      decrementButtonCls = 'left';
    }
  }
  config.items = [{xtype:'button', text:config.buttonType == 'arrow' ? '' : '+', cls:'control-slider-button ' + incrementButtonCls, handler:function(button) {
    button.up('streampositionslider').nudgeSlider(1);
  }}, slider, {xtype:'button', text:config.buttonType == 'arrow' ? '' : '−', cls:'control-slider-button ' + decrementButtonCls, handler:function(button) {
    button.up('streampositionslider').nudgeSlider(-1);
  }}];
  if (!config.vertical) {
    config.items.reverse();
  }
  Ext.container.Container.prototype.constructor.call(this, config);
}, getValue:function(value) {
  return this.down('slider').getValue();
}, setValue:function(value) {
  this.down('slider').setValue(value);
}, setMaxValue:function(value) {
  this.down('slider').setMaxValue(value);
}, setMinValue:function(value) {
  this.down('slider').setMinValue(value);
}, nudgeSlider:function(multiplier) {
  var slider = this.down('slider'), maxValue = slider.maxValue, minValue = slider.minValue, oldValue = slider.getValue(), range = maxValue - minValue, change = multiplier * (range / 30);
  newValue = oldValue + change;
  newValue = Math.min(maxValue, newValue);
  newValue = Math.max(minValue, newValue);
  analytics.Ctrl.setOptionalDefaultEventProperties({'Method':'Slider', 'Sub Method':'Arrow Click'});
  slider.setValue(newValue);
  this.fireEvent('changecomplete', slider, newValue);
}}, 1, ['streampositionslider'], ['component', 'box', 'container', 'streampositionslider'], {'component':true, 'box':true, 'container':true, 'streampositionslider':true}, ['widget.streampositionslider'], 0, [photoViewer.view.positioncontrols, 'StreamPositionSlider'], 0);
Ext.cmd.derive('photoViewer.view.sidepanel.PhotoViewerCommentsPane', Ext.panel.Panel, {height:'100%', layout:'fit', padding:'10 15 10 15', items:[{xtype:'comments', reference:'comments'}]}, 0, ['photoviewercommentspane'], ['component', 'box', 'container', 'panel', 'photoviewercommentspane'], {'component':true, 'box':true, 'container':true, 'panel':true, 'photoviewercommentspane':true}, ['widget.photoviewercommentspane'], 0, [photoViewer.view.sidepanel, 'PhotoViewerCommentsPane'], 0);
Ext.cmd.derive('photoViewer.view.sidepanel.PhotoViewerFloorplanMinimap', Ext.Component, {reinit:function() {
  if (this.map) {
    this.map.remove();
  }
  this.map = MVLeaflet.map(this.getId(), {zoomControl:false, boxZoom:false, touchZoom:false, keyboard:false, attributionControl:false, fadeAnimation:false});
}}, 0, ['photoviewerfloorplanminimap'], ['component', 'box', 'photoviewerfloorplanminimap'], {'component':true, 'box':true, 'photoviewerfloorplanminimap':true}, ['widget.photoviewerfloorplanminimap'], 0, [photoViewer.view.sidepanel, 'PhotoViewerFloorplanMinimap'], 0);
Ext.cmd.derive('photoViewer.view.sidepanel.PhotoViewerFloorplanView', Ext.panel.Panel, {ui:'dark', reference:'floorplanWidget', layout:'card', width:360, height:339, margin:'20 0 0 0', bind:{activeItem:'{floorplanWidgetCard}'}, tbar:{height:46, items:[{xtype:'label', localized:{text:'PV_Floorplan'}, margin:'0 0 0 14'}, {xtype:'component', flex:1}, {xtype:'button', ui:'more-options', width:24, height:16, margin:'0 10 0 0', cls:'on-orange', menu:{cls:'photo-viewer-floorplan-widget-menu', showSeparator:false, 
shadow:false, width:145, items:[{localized:{text:'PV_Go to Floorplan'}, height:20, margin:'0 1 0 1', listeners:{click:'gotoFloorplan'}}, {localized:{text:'PV_Enable Splitscreen Mo'}, height:20, margin:'0 1 0 1', bind:{disabled:'{floorplanModeOn}'}, listeners:{click:function() {
  this.lookupViewModel().set('layoutMode', 'floorplan');
}}}]}, tooltip:{localized:{text:'PV_Menu'}, anchor:'top'}}]}, items:[{xtype:'clientFloorplanViewerDisp', cls:'mv-light-load-mask', reference:'smallFloorplanView', itemId:'defaultFloorplanView', showMiniMap:false, showHotspotComments:false, showSelectionLayer:false, showZoomControls:false, showHovers:false, showPhotoThumbs:false, showTitle:false, showLegend:false, showMapTools:false, openPins:false, width:'100%', height:'100%', animateOptions:{pan:{animate:true, duration:0.5, easeLinearity:0.1}, zoom:{animate:true}}, 
bind:{style:{visibility:'{largeFloorplanVisible}'}}}, {xtype:'photoviewerfloorplanminimap', cls:'mv-light-load-mask', reference:'minimapFloorplanView', itemId:'minimapFloorplanView', width:'100%', height:'100%', bind:{style:{visibility:'{largeFloorplanVisible}'}}}]}, 0, ['photoviewerflooplanview'], ['component', 'box', 'container', 'panel', 'photoviewerflooplanview'], {'component':true, 'box':true, 'container':true, 'panel':true, 'photoviewerflooplanview':true}, ['widget.photoviewerflooplanview'], 
0, [photoViewer.view.sidepanel, 'PhotoViewerFloorplanView'], 0);
Ext.cmd.derive('photoViewer.view.sidepanel.PhotoViewerSideControls', Ext.tab.Panel, {layout:'card', width:360, flex:1, ui:'orange2', config:{mvPreloadImages:['mds/image/icon/comments-tab-icon-deselected.svg', 'mds/image/icon/annotations-tab-icon-deselected.svg', 'mds/image/icon/measurements-tab-icon-deselected.png', 'mds/image/icon/comments-tab-icon-selected.svg', 'mds/image/icon/annotations-tab-icon-selected.svg', 'mds/image/icon/measurements-tab-icon-selected.png'], measurementsAvailable:false}, 
items:[{xtype:'photoviewercommentspane', localized:{title:'GC_Comments'}, iconCls:'comments-tab', icon:'mds/image/icon/comments-tab-icon-deselected.svg'}, {xtype:'photoviewerannotationspane', localized:{title:'PV_Annotate'}, iconCls:'annotations-tab', icon:'mds/image/icon/annotations-tab-icon-deselected.svg'}, {xtype:'photoviewermeasurementspane', itemId:'measureTab', localized:{title:'PV_Measure'}, iconCls:'measurements-tab', icon:'mds/image/icon/measurements-tab-icon-deselected.png'}]}, 0, ['photoviewersidecontrols'], 
['component', 'box', 'container', 'panel', 'tabpanel', 'photoviewersidecontrols'], {'component':true, 'box':true, 'container':true, 'panel':true, 'tabpanel':true, 'photoviewersidecontrols':true}, ['widget.photoviewersidecontrols'], 0, [photoViewer.view.sidepanel, 'PhotoViewerSideControls'], 0);
Ext.cmd.derive('photoViewer.view.sidepanel.PhotoViewerSidePanel', Ext.Container, {mvPreloadImages:['mds/image/icon/expand-sidebar-arrow.svg'], width:371, height:'100%', layout:{type:'hbox'}, margin:'0 0 0 9', items:[{xtype:'expandtab', width:7, height:11, margin:'3 5 0 0', padding:1, listeners:{'click':{fn:function() {
  this.lookupViewModel().set('sidePanelCollapsed', !this.lookupViewModel().get('sidePanelCollapsed'));
}}}}, {xtype:'container', itemId:'sidePanelContent', layout:{type:'vbox', pack:'end'}, width:360, height:'100%', items:[{xtype:'photoviewersidecontrols', hidden:true, bind:{hidden:'{!account.canRead}'}}, {xtype:'container', layout:'fit', width:360, height:339, items:[{xtype:'photoviewerflooplanview', hidden:true, bind:{hidden:'{!floorplanVisible}'}}]}]}]}, 0, ['photoviewersidepanel'], ['component', 'box', 'container', 'photoviewersidepanel'], {'component':true, 'box':true, 'container':true, 'photoviewersidepanel':true}, 
['widget.photoviewersidepanel'], 0, [photoViewer.view.sidepanel, 'PhotoViewerSidePanel'], 0);
Ext.cmd.derive('photoViewer.view.sidepanel.photoviewerannotationspane.PhotoViewerAnnotationsPane', Ext.panel.Panel, {controller:'photoviewerannotationspane', layout:'fit', config:{mvPreloadImages:['mds/image/component/annotations-toggle-on.png', 'mds/image/component/annotations-toggle-off.png']}, viewModel:{data:{allAnnotationsHidden:false}, formulas:{projectMapEditable:function(get) {
  return get('account.canWrite');
}, copyAnnotationBtnDisabled:function(get) {
  var selectedDrawing = get('selectedDrawing'), store = get('annotationStore');
  return !(selectedDrawing && store && get('annoProps.storeLoaded') && store.contains(selectedDrawing) && get('drawMode') == photoViewer.Values.DRAW_ANNOTATING);
}, deleteAnnotationBtnDisabled:function(get) {
  var selectedDrawing = get('selectedDrawing'), store = get('annotationStore');
  return !(selectedDrawing && store && get('annoProps.storeLoaded') && store.contains(selectedDrawing) && selectedDrawing.get('CanEdit'));
}}}, dockedItems:[{xtype:'container', layout:{type:'hbox', pack:'middle', align:'center'}, dock:'top', height:38, width:'100%', items:[{xtype:'container', layout:{type:'hbox', pack:'middle', align:'center'}, dock:'top', height:38, width:'100%', items:[{xtype:'label', cls:'annotations-toggle-label', localized:{text:'PV_Annotations Mode'}, margin:'0 12 0 0'}, {xtype:'button', ui:'plain', width:45, height:19, cls:'annotation-button', enableToggle:true, tooltip:{localized:{text:'PV_Enable/Disable Drawin'}, 
anchor:'top'}, bind:{pressed:'{annotating}', disabled:'{!drawingReady}'}}], bind:{hidden:'{!annotationsAvailable}'}}, {xtype:'container', layout:{type:'hbox', pack:'middle', align:'center'}, dock:'top', height:46, width:'100%', items:[{xtype:'component', dock:'top', localized:{html:'PV_Annotating is not ava'}}], bind:{hidden:'{annotationsAvailable}'}}], bind:{hidden:'{!account.canWrite}'}}], constructor:function(config) {
  config = config || [];
  config.items = [{xtype:'annotationsgrid', localized:{emptyText:'PV_There are no annotati'}, padding:0, typeHidden:true, removeImportExport:true, showVisibilityHeaderToggle:true, tooltipConfig:photoViewer.view.photoviewer.PhotoViewer.defaultTooltipConfig, bind:{selection:'{selectedDrawing}', hidden:'{!annotationsAvailable}'}}];
  Ext.panel.Panel.prototype.constructor.call(this, config);
}}, 1, ['photoviewerannotationspane'], ['component', 'box', 'container', 'panel', 'photoviewerannotationspane'], {'component':true, 'box':true, 'container':true, 'panel':true, 'photoviewerannotationspane':true}, ['widget.photoviewerannotationspane'], 0, [photoViewer.view.sidepanel.photoviewerannotationspane, 'PhotoViewerAnnotationsPane'], 0);
Ext.cmd.derive('photoViewer.view.sidepanel.photoviewerannotationspane.PhotoViewerAnnotationsPaneController', Ext.app.ViewController, {init:function() {
  var vm = this.getViewModel();
  vm.bind('{activePhoto}', this.onActivePhotoChange, this);
}, annotationColorButtonChange:function(colorString, record) {
  if (record.shape) {
    record.shape.setColour(colorString);
  }
}, annotationGridBeforeSelectionChanged:function(grid, record) {
  return this.getView().up('photoviewer').getController().beforeDrawableSelectionChange(record);
}, annotationGridCellEdit:function(cmp, td, cellIndex, record, tr, rowIndex, e, eOpts) {
  return record.get('CanEdit');
}, annotationVisibilityChanged:function(record) {
  var photoController = this.getView().up('photoviewer').getController().lookupReference('photoContainer').getController().lookupReference('photo').getController(), allVisible = true, allHidden = true, toggleAllVisibilityButton = Ext.getCmp(this.getView().down('annotationsgrid').el.select('.x-btn.annotation-visible-icon').elements[0].id);
  photoController.updateAnnotationVisibility(record);
  this.getView().down('annotationsgrid').getStore().each(function(rec) {
    if (rec.get('Visible')) {
      allHidden = false;
    } else {
      allVisible = false;
    }
  }, this);
  if (allVisible) {
    toggleAllVisibilityButton.setPressed(false);
  } else {
    if (allHidden) {
      toggleAllVisibilityButton.setPressed(true);
    }
  }
}, removeButtonClick:function() {
  this.getView().up('photoviewer').lookupController().removeDrawable(this.getViewModel().get('selectedDrawing'));
}, copyButtonClick:function() {
  var record = this.getViewModel().get('selectedDrawing'), copy = record.copy(null);
  copy.set('Title', record.get('Title') + ' (copy)');
  copy.createShape(this.getView().up('photoviewer').getController().getPhotoComponent());
  this.getView().up('photoviewer').getViewModel().get('drawablesStore').add(copy);
  this.getView().up('photoviewer').getViewModel().set('selectedDrawing', copy);
}, onToggleAllVisibilityClick:function(button) {
  this.getView().down('annotationsgrid').getStore().each(function(rec) {
    rec.set('Visible', !button.pressed);
    this.annotationVisibilityChanged(rec);
  }, this);
}, onActivePhotoChange:function() {
  var button = this.getView().down('grid').visibilityToggle;
  if (button) {
    button.setPressed(false);
  }
}, viewMeasurementsInfo:function() {
  window.open(this.getViewModel().get('usingMetric') ? 'https://info.multivista.com/measurable-3d-image-met' : 'https://info.multivista.com/measurable-3d-images', '_blank');
}, annotationGridSelectionChanged:Ext.emptyFn, annotationShareTypeChanged:Ext.emptyFn, annotationGridEdit:Ext.emptyFn, annotationGridRowClick:Ext.emptyFn, annotationGridBeforeRowClick:Ext.emptyFn}, 0, 0, 0, 0, ['controller.photoviewerannotationspane'], 0, [photoViewer.view.sidepanel.photoviewerannotationspane, 'PhotoViewerAnnotationsPaneController'], 0);
Ext.cmd.derive('photoViewer.view.sidepanel.photoviewermeasurementspane.PhotoViewerMeasurementsPane', Ext.panel.Panel, {controller:'photoviewerannotationspane', layout:'fit', config:{mvPreloadImages:['mds/image/component/annotations-toggle-on.png']}, viewModel:{formulas:{projectMapEditable:function(get) {
  return get('account.canWrite');
}, deleteAnnotationBtnDisabled:function(get) {
  var selectedDrawing = get('selectedDrawing'), store = get('measurementsStore');
  return !(selectedDrawing && store && get('annoProps.storeLoaded') && store.contains(selectedDrawing) && selectedDrawing.get('CanEdit'));
}}}, bind:{disabled:'{gettingCmiLength}'}, dockedItems:[{xtype:'photoviewernomeasurementspane'}], constructor:function(config) {
  config = config || [];
  config.items = [{xtype:'annotationsgrid', localized:{emptyText:'PV_There are no measurem', titleHeaderLabel:'PV_Measurements'}, padding:0, typeHidden:true, removeImportExport:true, removeCopy:true, tooltipConfig:photoViewer.view.photoviewer.PhotoViewer.defaultTooltipConfig, showVisibilityHeaderToggle:true, bind:{hidden:'{!activePhoto.CmiName}', store:'{measurementsStore}', selection:'{selectedDrawing}'}}];
  Ext.panel.Panel.prototype.constructor.call(this, config);
}}, 1, ['photoviewermeasurementspane'], ['component', 'box', 'container', 'panel', 'photoviewermeasurementspane'], {'component':true, 'box':true, 'container':true, 'panel':true, 'photoviewermeasurementspane':true}, ['widget.photoviewermeasurementspane'], 0, [photoViewer.view.sidepanel.photoviewermeasurementspane, 'PhotoViewerMeasurementsPane'], 0);
Ext.cmd.derive('photoViewer.view.sidepanel.photoviewermeasurementspane.PhotoViewerNoMeasurementsPane', Ext.Container, {layout:{type:'hbox', pack:'middle', align:'center'}, dock:'top', height:46, margin:'12 0 0 0', width:'100%', config:{measureInfoLink:''}, items:[{xtype:'component', cls:'unmeasurable-text', dock:'top', localized:{html:'mvstr[PV_This is not a measura]\x3cbr/\x3emvstr[PV_To learn more about 3]'}}], bind:{hidden:'{activePhoto.CmiName}', measureInfoLink:'{measureInfoLink}'}, setMeasureInfoLink:function(measureInfoLink) {
  if (this.el) {
    this.el.select('a').elements[0].href = measureInfoLink;
  }
}}, 0, ['photoviewernomeasurementspane'], ['component', 'box', 'container', 'photoviewernomeasurementspane'], {'component':true, 'box':true, 'container':true, 'photoviewernomeasurementspane':true}, ['widget.photoviewernomeasurementspane'], 0, [photoViewer.view.sidepanel.photoviewermeasurementspane, 'PhotoViewerNoMeasurementsPane'], 0);
Ext.cmd.derive('photoViewer.view.topbar.PhotoActionsMenu', Ext.button.Button, {ui:'more-options', reference:'listMenuButton', scale:'medium', menuAlign:'tr-br?', mvPreloadImages:['mds/image/component/submenu.png'], menu:{ui:'dark2', width:155, showSeparator:false, shadow:false, cls:'photo-actions-menu', items:[{xtype:'photosavemenuitemdark', bind:{disabled:'{!photoCanBeSaved}', hidden:'{activeTimelapse}'}}, {itemId:'saveTimelapseAction', localized:{text:'PUL_Save'}, hidden:true, bind:{hidden:'{!activeTimelapse}'}}, 
{xtype:'integrationmenuitemdark', hidden:true, bind:{hidden:'{!integrationsMenuVisible}', disabled:'{!selectedPhotoCount}'}}, {itemId:'printPhotosAction', localized:{text:'PUL_Print'}, hidden:true, cls:'print-button', bind:{disabled:'{!selectedPhotoCount}', hidden:'{!photoactions_showPrintEmailButtons}'}}, {localized:{text:'PUL_Email'}, hidden:true, itemId:'emailPhotosAction', cls:'email-button', bind:{disabled:'{!selectedPhotoCount}', hidden:'{!photoactions_showPrintEmailButtons}'}}, {localized:{text:'PUL_Add a Comment'}, 
itemId:'addCommentAction', cls:'add-comment-button', hidden:true, bind:{disabled:'{!selectedPhotoCount}', hidden:'{!addCommentActionVisible}'}}, {localized:{text:'PUL_Edit Date and Sharing'}, itemId:'editDateAndSharingAction', cls:'edit-date-and-sharing-button', hidden:true, bind:{hidden:'{!onlyOwnedPhotosSelected}'}}, {localized:{text:'PUL_Delete'}, itemId:'deleteAction', hidden:true, bind:{hidden:'{!oneOwnedPhotoSelected}'}}, {localized:{text:'PUL_Settings'}, itemId:'photoListSettings', hidden:true, 
bind:{hidden:'{!pageHasSettings}'}}, {localized:{text:'PUL_Followers'}, itemId:'albumFollowersAction', hidden:true, bind:{hidden:'{!followersMenuVisible}'}}]}, viewModel:{formulas:{photoactions_showPrintEmailButtons:function(get) {
  var stream = get('activeStream'), timelapse = get('activeTimelapse');
  return !(stream || timelapse);
}}}, constructor:function(config) {
  config = config || {};
  config.tooltip = {text:mvstr.PUL_Menu, anchor:'top'};
  Ext.button.Button.prototype.constructor.call(this, config);
}}, 1, ['photoactionsmenu'], ['component', 'box', 'button', 'photoactionsmenu'], {'component':true, 'box':true, 'button':true, 'photoactionsmenu':true}, ['widget.photoactionsmenu'], 0, [photoViewer.view.topbar, 'PhotoActionsMenu'], 0);
Ext.cmd.derive('photoViewer.view.topbar.PhotoViewerActionsMenu', photoViewer.view.topbar.PhotoActionsMenu, {constructor:function() {
  photoViewer.view.topbar.PhotoActionsMenu.prototype.constructor.apply(this, arguments);
  var menu = this.getMenu();
  menu.add([{localized:{text:'PV_Help'}, listeners:{click:'showTour'}}, {text:'Switch to Old Viewer', hidden:true, bind:{hidden:'{!account.features.photoviewerHasOptOut}'}, listeners:{click:'switchPhotoViewer'}}]);
}}, 1, ['photovieweractionsmenu'], ['component', 'box', 'button', 'photoactionsmenu', 'photovieweractionsmenu'], {'component':true, 'box':true, 'button':true, 'photoactionsmenu':true, 'photovieweractionsmenu':true}, ['widget.photovieweractionsmenu'], 0, [photoViewer.view.topbar, 'PhotoViewerActionsMenu'], 0);
Ext.cmd.derive('photoViewer.view.topbar.PhotoViewerLayoutMenu', Ext.button.Button, {ui:'dark', width:43, height:35, padding:7, config:{menuOptions:[{icon:'mds/image/icon/photoviewer-view-default.svg', viewMode:'default', tooltip:{text:'PV_Default Mode', anchor:'top'}}, {icon:'mds/image/icon/floorplan-splitscreen-toggle.svg', viewMode:'floorplan', tooltip:{text:'PV_Floorplan Mode', anchor:'top'}}], activeButton:null, viewMode:'default', mvPreloadImages:['mds/image/icon/floorplan-splitscreen-toggle.svg'], 
menuCls:'photo-viewer-layout-menu'}, publishes:'viewMode', bind:{viewMode:'{layoutMode}'}, tooltip:{localized:{text:'PV_View Mode'}, anchor:'top', anchorSize:[12, 5]}, initComponent:function() {
  var items = this.getMenuOptions(), viewMode = this.getViewMode();
  for (var i = 0; i < items.length; i++) {
    items[i].tooltip.text = mvstr[items[i].tooltip.text];
    items[i].listeners = {click:{fn:this.onMenuButtonClick, scope:this}};
    items[i].hidden = viewMode == items[i].viewMode;
  }
  this.setIcon(items[0].icon);
  this.setMenu({items:items, ui:'dark', cls:this.getMenuCls(), width:43, padding:7, minWidth:43, shadow:false});
  Ext.button.Button.prototype.initComponent.apply(this, arguments);
  var menuItems = this.getMenu().items.items;
  for (var i = 0; i < menuItems.length; i++) {
    if (viewMode && menuItems[i].viewMode == viewMode) {
      this.activeButton = menuItems[i];
    }
  }
  this.getMenu().addListener('show', this.onMenuFirstShow, this, {single:true, delay:1});
}, onButtonClick:function() {
  this.changeMode(this.getActiveButton());
}, onMenuButtonClick:function(btn) {
  this.changeMode(btn);
  this.setIcon(btn.icon);
  this.setActiveButton(btn);
}, changeMode:function(btn) {
  this.setViewMode(btn.viewMode);
}, updateActiveButton:function(newBtn, oldBtn) {
  newBtn.hide();
  if (oldBtn) {
    oldBtn.show();
  }
}, updateViewMode:function(viewMode) {
  if (this.isConfiguring) {
    return;
  }
  var buttons = this.getMenu().items.items;
  for (var i = 0; i < buttons.length; i++) {
    if (buttons[i].viewMode == viewMode) {
      this.onMenuButtonClick(buttons[i]);
    }
  }
}, onMenuFirstShow:function() {
  var menuButtons = this.getMenu().items.items, viewMode = this.getViewMode();
  for (var i = 0; i < menuButtons.length; i++) {
    if (menuButtons[i].viewMode != viewMode) {
      menuButtons[i].hide();
      menuButtons[i].show();
    }
  }
}}, 0, ['photoviewerlayoutmenu'], ['component', 'box', 'button', 'photoviewerlayoutmenu'], {'component':true, 'box':true, 'button':true, 'photoviewerlayoutmenu':true}, ['widget.photoviewerlayoutmenu'], 0, [photoViewer.view.topbar, 'PhotoViewerLayoutMenu'], 0);
Ext.cmd.derive('photoViewer.view.topbar.PhotoViewerTitle', Ext.Component, {viewModel:{formulas:{titleData:function(get) {
  var data = {imageURL:get('project.ImageURL64'), title1:'', title2:'', title3:'', weatherData:''};
  var activePhoto = get('activePhoto');
  if (activePhoto) {
    data.title1 = activePhoto.get('Type') == 'U' ? mvstr['PV_User-Uploaded Photo'] : activePhoto.get('DescLine2') ? activePhoto.get('DescLine2') : activePhoto.get('DescLine1');
    data.title2 = activePhoto.get('DescLine3');
    data.title3 = activePhoto.get('PhotoLatitude') !== '' && activePhoto.get('PhotoLatitude') !== undefined ? 'Lat: ' + activePhoto.get('PhotoLatitude') + ' Long: ' + activePhoto.get('PhotoLongitude') + ' Elev: ' + activePhoto.get('PhotoAltitude') + ' ASL' : '';
  }
  if (activePhoto && activePhoto.get('Weather')) {
    data.weatherData = {Weather:activePhoto.get('Weather') || '', WindDirection:activePhoto.get('WindDirection') || '', WindMPH:activePhoto.get('WindMPH') || '', TemperatureF:activePhoto.get('TemperatureF') || '', PhotoDate:activePhoto.get('PhotoDate')};
  }
  var activeWebcam = get('activeWebcam');
  if (activeWebcam) {
    data.title1 = activeWebcam.get('WebcamLabel');
    if (get('activeStream')) {
      data.title2 = mvstr['WV_Live View'];
    }
    if (get('activeTimelapse')) {
      data.title2 = mvstr['WV_Timelapse'];
    }
  }
  return data;
}}}, bind:{data:'{titleData}'}, tpl:'\x3cimg src\x3d"{imageURL}"\x3e\x3cdiv class\x3d"photo-viewer-title"\x3e\x3cdiv class\x3d"title1"\x3e{title1}\x3c/div\x3e\x3ctpl if\x3d"weatherData.Weather!\x3d\x3d\'\'"\x3e\x3cdiv class\x3d"title2"\x3e{weatherData.Weather}\x3c/div\x3e\x3c/tpl\x3e\x3cdiv class\x3d"title2"\x3e{title2}\x3c/div\x3e\x3ctpl if\x3d"title3!\x3d\x3d\'\'"\x3e\x3cdiv class\x3d"title3"\x3e{title3}\x3c/div\x3e\x3c/tpl\x3e\x3c/div\x3e', listeners:{afterrender:function(dataview) {
  dataview.tip1 = Ext.create('Ext.tip.ToolTip', Ext.mergeIf({target:this.getId(), cls:'x-tip-dark multiline', delegate:'.photo-viewer-weather', listeners:{beforeshow:{fn:dataview.onTooltipBeforeShow, scope:dataview}}}, photoViewer.view.photoviewer.PhotoViewer.defaultTooltipConfig));
}}, onTooltipBeforeShow:function(tip) {
  var vm = this.getViewModel(), data = vm.get('weatherDisplayData');
  if (Ext.Object.isEmpty(data)) {
    return false;
  }
  tip.update(data.desc + (data.desc ? '\x3cbr\x3e' : '') + data.temperature + (data.temperature ? '\x3cbr\x3e' : '') + data.windDirection + (data.windDirection ? ' ' + data.windSpeed : ''));
}}, 0, ['photoviewertitle'], ['component', 'box', 'photoviewertitle'], {'component':true, 'box':true, 'photoviewertitle':true}, ['widget.photoviewertitle'], 0, [photoViewer.view.topbar, 'PhotoViewerTitle'], 0);
Ext.cmd.derive('photoViewer.view.topbar.PhotoViewerTopToolbar', Ext.Container, {padding:'12 20 12 20', margin:'0 0 12 0', height:90, layout:{type:'hbox', align:'center'}, items:[{xtype:'photoviewertitle'}, {xtype:'component', flex:1}, {xtype:'photoviewerlayoutmenu', cls:'photoviewer-view-menu', width:45, height:31, padding:'0 7 0 7', margin:'0 14 0 0', menuOptions:[{icon:'mds/image/icon/sitewalk360.png', viewMode:photoViewer.Values.VIEW_SITEWALK360, tooltip:{text:'PV_Sitewalk 360', anchor:'top'}}, 
{icon:'mds/image/icon/truview.png', viewMode:photoViewer.Values.VIEW_TRUVIEW, tooltip:{text:'PV_TruView', anchor:'top'}}], menuCls:'photo-viewer-layout-menu photoviewer-view-menu', mvPreloadImages:['mds/image/icon/truview.png', 'mds/image/icon/sitewalk360.png'], hidden:true, bind:{viewMode:'{viewModeButtonValue}', hidden:'{!hasMatterportAndTruView}'}}, {xtype:'button', cls:'photo-viewer-webcam-button', ui:'dark', margin:'0 24 0 0', iconCls:'photo-viewer-livestream-btn', hidden:true, toggleGroup:'webcam-view-btn', 
allowDepress:false, bind:{hidden:'{!canSwitchToStream}', pressed:'{activeStreamSelected}'}, listeners:{toggle:function(btn, pressed) {
  if (pressed) {
    analytics.Ctrl.log('Clicked Webcam Navigation Button', {'Webcam View':'Live Stream'}, ['Webcam UID']);
    this.lookupController().gotoWebcamStream();
  }
}}, tooltip:{localized:{text:'WV_Live View'}, anchor:'top'}}, {xtype:'button', cls:'photo-viewer-webcam-button', itemId:'photoViewerWebcamModeToggle', margin:'0 22 0 0', iconCls:'photo-viewer-archive-btn', ui:'dark', hidden:true, toggleGroup:'webcam-view-btn', allowDepress:false, bind:{hidden:'{!canSwitchToArchive}', pressed:'{activeArchiveSelected}'}, listeners:{click:function() {
  analytics.Ctrl.log('Clicked Webcam Navigation Button', {'Webcam View':'Archive'}, ['Webcam UID']);
  this.lookupController().gotoWebcamArchive();
}}, tooltip:{localized:{text:'WV_Archives'}, anchor:'top'}}, {xtype:'button', cls:'photo-viewer-webcam-button', iconCls:'photo-viewer-timelapse-btn', ui:'dark', hidden:true, toggleGroup:'webcam-view-btn', allowDepress:false, bind:{hidden:'{!canSwitchToTimelapse}', pressed:'{activeTimelapseSelected}'}, listeners:{toggle:function(btn, pressed) {
  if (pressed) {
    analytics.Ctrl.log('Clicked Webcam Navigation Button', {'Webcam View':'Timelapse'}, ['Webcam UID']);
    this.lookupController().gotoWebcamTimelapse();
  }
}}, tooltip:{localized:{text:'WV_Timelapse'}, anchor:'top'}}, {xtype:'photoviewerlayoutmenu', itemId:'photoViewerLayoutModeToggle', hidden:true, bind:{hidden:'{activeWebcam}'}}, {xtype:'photovieweractionsmenu', margin:'0 10 0 30', hidden:true}, {xtype:'container', width:35, items:[{xtype:'button', itemId:'photoViewerCloseButton', cls:'close-button', ui:'plain', text:'X', margin:'0 0 0 20', listeners:{click:{fn:'closePhotoViewer', delay:1}}, tooltip:{localized:{text:'G_Close'}, anchor:'top'}}]}]}, 
0, ['photoviewertoptoolbar'], ['component', 'box', 'container', 'photoviewertoptoolbar'], {'component':true, 'box':true, 'container':true, 'photoviewertoptoolbar':true}, ['widget.photoviewertoptoolbar'], 0, [photoViewer.view.topbar, 'PhotoViewerTopToolbar'], 0);
Ext.cmd.derive('photoViewer.view.photoviewer.PhotoViewer', Ext.panel.Panel, {viewModel:{type:'photoviewer'}, controller:'photoviewer', statics:{defaultTooltipConfig:{anchor:'top', anchorToTarget:true, cls:'x-tip-dark', anchorSize:[0, 12], shadow:false}, launchWithProjectWrapper:function(viewport, ProjectUID, config, oldPVURL) {
  if (viewport.lookupViewModel().get('account.features.photoviewerVisible') && Ext.versions.ext.major == 6 && Ext.versions.ext.minor == 2) {
    this.launchWithProjectWrapper2(viewport, ProjectUID, config);
  } else {
    document.location = oldPVURL;
  }
}, launchWithProjectWrapper2:function(viewport, ProjectUID, config) {
  var projectWrapper = viewport.add({xtype:'projectwrapper'}).show();
  projectWrapper.getViewModel().set('ProjectUID', ProjectUID);
  Ext.asap(function() {
    projectWrapper.initWrapper(function() {
      var photoViewer = projectWrapper.add(config).show();
      projectWrapper.el.addListener('resize', function(projectWrapper, width, height) {
        photoViewer.setSize(width, height);
      }, this);
      photoViewer.addListener('destroy', function() {
        projectWrapper.destroy();
      });
    });
  });
}}, width:'100%', height:'100%', floating:true, alwaysOnTop:true, layout:{type:'fit'}, config:{loadMaskCls:'dark-load-indicator'}, dockedItems:[{dock:'top', xtype:'photoviewertoptoolbar', reference:'topToolbar'}], items:[{xtype:'container', reference:'mainContainer', layout:{type:'hbox', align:'stretch'}, items:[{xtype:'photoviewermainpanel'}, {xtype:'photoviewersidepanel', reference:'photoViewerSidePanel', bind:{hidden:'{!activePhoto}'}}]}, {xtype:'photoviewerannotationstoolwindow'}, {xtype:'photoviewermeasurementtools'}, 
{xtype:'photoviewercontextmenu', reference:'contextMenu'}, {xtype:'photoviewerexif', reference:'exifDisplay'}], listeners:{boxready:{fn:'onPhotoViewerBoxReady', delay:1000}}}, 0, ['photoviewer'], ['component', 'box', 'container', 'panel', 'photoviewer'], {'component':true, 'box':true, 'container':true, 'panel':true, 'photoviewer':true}, ['widget.photoviewer'], 0, [photoViewer.view.photoviewer, 'PhotoViewer'], 0);
Ext.cmd.derive('accountShared.model.Member', Ext.data.Model, {fields:[{name:'MemberID', convert:function(v, r) {
  return v || r.get('MemberUID');
}}, {name:'MemberUsername', type:'string'}, {name:'Password', type:'string'}, {name:'MemberRole', type:'string', allowBlank:false}, {name:'TerritoryID', type:'int', allowBlank:false}, {name:'MemberFirstName', type:'string'}, {name:'MemberLastName', type:'string'}, {name:'MemberName', calculate:function(data) {
  return Ext.String.trim(data.MemberFirstName + ' ' + data.MemberLastName);
}}, {name:'MemberEmail', type:'string'}, {name:'MemberPhone', type:'string'}, {name:'MemberCell', type:'string'}, {name:'MemberDashboardPreference', type:'string', defaultValue:'globalfeed'}, {name:'MemberProjectPreference', type:'string', defaultValue:'floorplans'}, {name:'EmailFrequency', type:'string', defaultValue:'r'}, {name:'EmailWeekday', type:'int', defaultValue:1}, {name:'EmailTimeOfDay', type:'int'}, {name:'MemberTimezone', type:'string'}, {name:'MemberOverlayInt', type:'boolean'}, {name:'MemberCommentIcon', 
type:'boolean', 'default':true}, {name:'EmailAsUsername', type:'boolean', persist:false}, {name:'NotificationCategorySettings', type:'auto'}, {name:'MeasurePreferenceID', type:'int', defaultValue:1}, {name:'ProjectRoleID'}, {name:'MemberCompanyName'}, {name:'EmailValidating', persist:false, 'default':false}, {name:'EmailExists', persist:false, 'default':false}, {name:'IsClientUserAdd', persist:false, 'default':false}, {name:'IsAdminUserAdd', persist:false, 'default':false}, {name:'EmailIsOtherRealm', 
persist:false, 'default':false}, {name:'EmailExistsAsUsername', persist:false, 'default':false}, {name:'UsernameExists', persist:false, 'default':false}, {name:'UsernameValidating', persist:false, 'default':false}], idProperty:'id', clientIdProperty:'MemberID', proxy:{type:'ajax', writer:{type:'json', writeAllFields:false}, reader:{type:'json', rootProperty:'data'}, api:{read:'/index.cfm?fuseaction\x3daMember.getMemberSettings', create:'/index.cfm?fuseaction\x3daMember.createMember', update:'/index.cfm?fuseaction\x3daMember.saveMemberSettings'}}, 
validators:{MemberUsername:{fn:function(value, record) {
  if (record.get('UsernameValidating')) {
    return mvstr['G_Validating'];
  }
  if (record.get('UsernameExists')) {
    return mvstr['UAF_Username taken'];
  }
  var v = value ? value.trim() : '', validChars = v.match(/[a-zA-Z0-9\u00C0-\u00D6\u00D8-\u00f6\u00f8-\u00ff\-!#$%&'*+\/=?\^_`{|}~@.]/g);
  if (v.length && (!validChars || v.length != validChars.length)) {
    return mvstr['G_InvalidCharacters'].replace('{x}', "a-z 0-9 . - _ @ ! $ % \x26 ' * + / \x3d ? ^ ` { } | ~");
  }
  if (v.length < 3) {
    return mvstr['G_MinimumFieldLength'].replace('{x}', 3);
  }
  if (v.length > 60) {
    return mvstr['G_MaximumFieldLength'].replace('{x}', 60);
  }
  return true;
}}, MemberFirstName:{fn:function(value) {
  var v = value ? value.trim() : '', hasEmail = v.match(/.*[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+.*/g);
  if (v.length < 1) {
    return mvstr['G_RequiredField'];
  }
  if (hasEmail) {
    return mvstr['UAF_Name cannot contain e'];
  }
  if (v.length > 60) {
    return mvstr['G_MaximumFieldLength'].replace('{x}', 60);
  }
  return true;
}}, MemberLastName:{fn:function(value) {
  var v = value ? value.trim() : '', hasEmail = v.match(/.*[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+.*/g);
  if (v.length > 60) {
    return mvstr['G_MaximumFieldLength'].replace('{x}', 60);
  }
  if (hasEmail) {
    return mvstr['UAF_Name cannot contain e'];
  }
  return true;
}}, MemberEmail:{type:'email', matcher:/^(?:[^\.])(?:(?:[\.])?(?:[\w\u00C0-\u00D6\u00D8-\u00f6\u00f8-\u00ff\-!#$%&'*+\/=?\^_`{|}~]))*\1@(\w[\-\w]*\.){1,5}([A-Za-z]){2,20}$/, fn:function(value, record) {
  if (record.get('EmailValidating')) {
    return mvstr['G_Validating'];
  }
  if (record.get('EmailExists') && !record.get('IsClientUserAdd') && (!record.get('IsAdminUserAdd') || !record.get('EmailIsOtherRealm'))) {
    return mvstr['UAF_Account exists with t'];
  }
  if (record.get('IsClientUserAdd') && !record.get('EmailExists') && record.get('EmailExistsAsUsername')) {
    return mvstr['UAF_Email is unavailable'];
  }
  if (!value) {
    return mvstr['G_RequiredField'];
  }
  var matcher = /^(?:[^\.])(?:(?:[\.])?(?:[\w\u00C0-\u00D6\u00D8-\u00f6\u00f8-\u00ff\-!#$%&'*+\/=?\^_`{|}~]))*\1@(\w[\-\w]*\.){1,5}([A-Za-z]){2,20}$/;
  if (value.match(matcher)) {
    return true;
  }
  return mvstr['UAF_Email not of proper f'];
}}, MemberPhone:{fn:function(value, record) {
  var v = value ? value.trim() : '', validChars = v.match(/[0-9 \+\-EeXxTt\.]+/g);
  if (!v.length) {
    return true;
  }
  if (!validChars || validChars[0] != v) {
    return mvstr['UAF_Phone number can only'];
  }
  if (v.length < 9) {
    return mvstr['G_MinimumFieldLength'].replace('{x}', 9);
  }
  if (v.length > 60) {
    return mvstr['G_MaximumFieldLength'].replace('{x}', 60);
  }
  return true;
}}, MemberCell:{fn:function(value, record) {
  var v = value ? value.trim() : '', validChars = v.match(/[0-9 \+\-EeXxTt\.]+/g);
  if (!v.length) {
    return true;
  }
  if (!validChars || validChars[0] != v) {
    return mvstr['UAF_Phone number can only'];
  }
  if (v.length < 9) {
    return mvstr['G_MinimumFieldLength'].replace('{x}', 9);
  }
  if (v.length > 60) {
    return mvstr['G_MaximumFieldLength'].replace('{x}', 60);
  }
  return true;
}}, MemberCompanyName:{fn:function(v) {
  var minLength = 3, maxLength = 80;
  if (v && v.length < minLength) {
    return mvstr['G_MinimumFieldLength'].replace('{x}', minLength);
  }
  if (v && v.length > maxLength) {
    return mvstr['G_MaximumFieldLength'].replace('{x}', maxLength);
  }
  return true;
}}}}, 0, 0, 0, 0, 0, 0, [accountShared.model, 'Member'], 0);
Ext.cmd.derive('accountShared.model.MemberAdmin', accountShared.model.Member, {fields:[{name:'MemberRole', type:'string', defaultValue:'client'}, {name:'MemberID', type:'string', defaultValue:0}, {name:'TerritoryID', type:'int'}, {name:'MemberIsActive', type:'boolean', defaultValue:true}, {name:'MemberGetsNotifications', type:'boolean', defaultValue:true}, {name:'MemberCommentIcon', type:'boolean', defaultValue:true}, {name:'MemberOverlayInt', type:'boolean', defaultValue:true}, {name:'LanguageID', 
type:'string', defaultValue:'en'}, {name:'MemberCompanyName', type:'string'}, {name:'ProjectRoleID', type:'int'}, {name:'MemberCompanyConfirmed', type:'int', defaultValue:0}], idProperty:'MemberID', clientIdProperty:'MemberID', validators:{MemberRole:{fn:function(value) {
  if (!value) {
    return 'Member Role required';
  }
  return true;
}}, TerritoryID:{fn:function(value) {
  if (!value) {
    return 'Default Territory required';
  }
  return true;
}}}}, 0, 0, 0, 0, 0, 0, [accountShared.model, 'MemberAdmin'], 0);
Ext.cmd.derive('accountShared.model.MemberCompany', Ext.data.Model, {fields:[{name:'MemberCompanyName', type:'string'}], idProperty:'MemberCompanyName'}, 0, 0, 0, 0, 0, 0, [accountShared.model, 'MemberCompany'], 0);
Ext.cmd.derive('accountShared.model.ProjectRole', Ext.data.Model, {fields:[{name:'ProjectRoleID', type:'int'}, {name:'ProjectRoleLabel', type:'string', convert:function(v, rec) {
  var label = mvstr['ProjectRole_' + rec.get('ProjectRoleID')];
  return label || v;
}}], idProperty:'ProjectRoleID'}, 0, 0, 0, 0, 0, 0, [accountShared.model, 'ProjectRole'], 0);
Ext.cmd.derive('accountShared.view.MemberCompany', formShared.view.components.Combo, {reference:'memberCompany', allowBlank:true, hideTrigger:true, localized:{fieldLabel:'UAF_Company'}, editable:true, queryMode:'remote', minChars:3, displayField:'MemberCompanyName', valueField:'MemberCompanyName', anyMatch:true, typeAhead:true, setValue:function(value) {
  if (!this.lastValue) {
    this.lastValue = value;
  }
  return formShared.view.components.Combo.prototype.setValue.apply(this, arguments);
}, getValue:function() {
  var value = formShared.view.components.Combo.prototype.getValue.apply(this, arguments);
  return value || '';
}}, 0, ['membercompany'], ['component', 'box', 'field', 'textfield', 'pickerfield', 'combobox', 'combo', 'detailformcombo', 'membercompany'], {'component':true, 'box':true, 'field':true, 'textfield':true, 'pickerfield':true, 'combobox':true, 'combo':true, 'detailformcombo':true, 'membercompany':true}, ['widget.membercompany'], 0, [accountShared.view, 'MemberCompany'], 0);
Ext.cmd.derive('accountShared.view.field.ProjectRole', formShared.view.components.Combo, {localized:{fieldLabel:'UAF_Role'}, msgTarget:'side', bind:{store:'{projectRoles}'}, displayField:'ProjectRoleLabel', valueField:'ProjectRoleID', viewModel:{stores:{projectRoles:{model:'accountShared.model.ProjectRole', autoLoad:true, proxy:{url:'/index.cfm?fuseaction\x3daMember.getProjectRoles'}}}}}, 0, ['projectrole'], ['component', 'box', 'field', 'textfield', 'pickerfield', 'combobox', 'combo', 'detailformcombo', 
'projectrole'], {'component':true, 'box':true, 'field':true, 'textfield':true, 'pickerfield':true, 'combobox':true, 'combo':true, 'detailformcombo':true, 'projectrole':true}, ['widget.projectrole'], 0, [accountShared.view.field, 'ProjectRole'], 0);
Ext.cmd.derive('clientNavigation.model.FileUpload', Ext.data.Model, {idProperty:'id', fields:[{name:'id', type:'int'}, {name:'name', type:'string'}, {name:'type', type:'string'}, {name:'status', type:'string'}, {name:'time', type:'int'}, {name:'target', type:'string', defaultValue:''}, {name:'message', type:'string', defaultValue:''}, {name:'fileExt', type:'string', defaultValue:''}, {name:'thumbUrl', type:'string', defaultValue:''}, {name:'retries', type:'int', defaultValue:0}, {name:'canRetry', 
type:'boolean', defaultValue:true}, {name:'statusLabel', calculate:function(data) {
  var type = data.type;
  var status = data.status;
  var msg = data.message;
  var target = data.target || '';
  var lbl = status;
  if (status === 'error') {
    lbl = msg || Ext.String.capitalize(type) + ' error';
  } else {
    if (status === 'processing') {
      if (type) {
        lbl = Ext.String.capitalize(type) + 'ing' + (target ? ' to ' + target : '') + '...';
      } else {
        lbl = msg || 'Uploading...';
      }
    } else {
      if (status) {
        lbl = Ext.String.capitalize(status);
      }
    }
  }
  return Ext.String.htmlEncode(lbl);
}}, {name:'removeCss', calculate:function(data) {
  var status = data.status;
  var retries = data.retries;
  var canRetry = !!data.canRetry;
  if (status === 'error' || status === 'failed') {
    return retries > 0 ? canRetry ? 'remove withRetry' : 'remove' : '';
  }
  if (status === 'completed' || status === 'cancelled') {
    return 'remove';
  }
  return '';
}}, {name:'buttonCss', calculate:function(data) {
  var status = data.status;
  var retries = data.retries;
  var canRetry = !!data.canRetry;
  if (status === 'error' || status === 'failed') {
    return canRetry ? 'retry' + (retries > 0 ? ' withRemove' : '') : '';
  }
  if (status === 'processing' || status === 'queued') {
    return 'cancel';
  }
  if (status === 'completed') {
    return 'removeOnly';
  }
  return '';
}}, {name:'buttonLabel', calculate:function(data) {
  var status = data.status;
  if (status === 'error' || status === 'failed') {
    return 'Retry';
  }
  if (status === 'processing' || status === 'queued') {
    return 'Cancel';
  }
  return '';
}}, {name:'imageStyle', calculate:function(data) {
  var cssUrl = mdslink.server + '/mds/image/transparent.png';
  var bgSize = '';
  var ext = (data.fileExt || '').toLowerCase();
  if (ext) {
    if (ext === 'jpeg') {
      ext = 'jpg';
    } else {
      if (ext === 'mpeg') {
        ext = 'mpg';
      } else {
        if (ext === 'tif') {
          ext = 'tiff';
        } else {
          if (ext === 'docx' || ext === 'xlsx' || ext === 'pptx') {
            ext = ext.substr(0, 3);
          }
        }
      }
    }
    var allowedExts = ['jpg', 'jpeg', 'png', 'gif', 'tiff', 'pdf', 'zip', 'avi', 'mov', 'mpg', 'doc', 'xls', 'ppt', 'rvt', 'ifc'];
    if (allowedExts.indexOf(ext) !== -1) {
      cssUrl = mdslink.server + '/mds/image/clientFileManager/icons/large/' + ext + '.png';
      bgSize = 'background-size: 37px 50px';
    }
  }
  if (data.thumbUrl) {
    cssUrl = data.thumbUrl;
    bgSize = 'background-size: 80px 50px;';
  }
  var bgImage = "background-image: url('" + cssUrl + "');";
  return bgImage + bgSize;
}}, {name:'imageCss', calculate:function(data) {
  var ext = (data.fileExt || '').toLowerCase();
  if (data.thumbUrl && ext === 'pdf') {
    return 'pdf-overlay';
  }
  return '';
}}, {name:'titleAttr', calculate:function(data) {
  var status = data.statusLabel;
  if (status.length > 30) {
    return 'title\x3d"' + status + '"';
  }
  return '';
}}, {name:'statusLabelSimple', calculate:function(data) {
  var label = mvstr['GFU_' + data.status];
  return label || data.status;
}}]}, 0, 0, 0, 0, 0, 0, [clientNavigation.model, 'FileUpload'], 0);
Ext.cmd.derive('clientNavigation.model.MegamenuChild', Ext.data.Model, {fields:[{name:'text'}, {name:'href'}]}, 0, 0, 0, 0, 0, 0, [clientNavigation.model, 'MegamenuChild'], 0);
Ext.cmd.derive('clientNavigation.model.MegamenuParent', Ext.data.Model, {hasMany:{model:'clientNavigation.model.MegamenuChild', name:'shoots'}, fields:[{name:'text'}, {name:'list', convert:function(v, rec) {
  for (var i = 0; i < v.length; i++) {
    var url = v[i].url;
    var ProjectUID = Ext.Object.fromQueryString(rec.data.list[i].url).ProjectUID, FloorplanUID = Ext.Object.fromQueryString(rec.data.list[i].url).FloorplanUID;
    v[i].url = mdslink.clientFloorplanViewer + 'ProjectUID\x3d' + ProjectUID + '\x26FloorplanUID\x3d' + FloorplanUID;
  }
  return v;
}}]}, 0, 0, 0, 0, 0, 0, [clientNavigation.model, 'MegamenuParent'], 0);
Ext.cmd.derive('clientNavigation.model.Member', Ext.data.Model, {fields:[{name:'MemberUID', type:'string'}, {name:'MemberFirstName', type:'string'}, {name:'MemberLastName', type:'string'}, {name:'MemberDisplayName', convert:function(v, record) {
  return record.get('MemberFirstName') + ' ' + record.get('MemberLastName');
}}, {name:'isChecked', type:'boolean', defaultValue:'false'}], idProperty:'MemberUID'}, 0, 0, 0, 0, 0, 0, [clientNavigation.model, 'Member'], 0);
Ext.cmd.derive('clientNavigation.view.GlobalMyAccountMenu', Ext.menu.Menu, {ui:'topnavmenu', plain:true, showSeparator:false, shadow:false, renderTo:Ext.getBody(), items:[{localized:{text:'G_My Account'}, href:mdslink.clientAccount, handler:function() {
  analytics.Ctrl.log('Clicked User My Account', {});
  if (app.getName() === 'clientDashboard') {
    app.getController('clientDashboard.controller.Manager4Dashboard').getNavigationBar4Dashboard().selectNone();
    app.getMainView().query('clientAccountDisp')[0].show();
  }
}}, {localized:{text:'G_Logout'}, itemId:'topNavLogout', href:''}], listeners:{click:function(cmp, item) {
  if (item.getItemId() == 'topNavLogout') {
    analytics.Ctrl.log('Clicked User Log Out', {});
    if (window.localStorage.getItem('Multivista_ClientSession')) {
      window.localStorage.removeItem('Multivista_ClientSession');
    }
    mdsPreferences.GlobalPreferences.removeLang();
    window.location.replace(mdslink.logout);
  }
}}}, 0, ['globalmyaccountmenu'], ['component', 'box', 'container', 'panel', 'menu', 'globalmyaccountmenu'], {'component':true, 'box':true, 'container':true, 'panel':true, 'menu':true, 'globalmyaccountmenu':true}, ['widget.globalmyaccountmenu'], 0, [clientNavigation.view, 'GlobalMyAccountMenu'], 0);
Ext.cmd.derive('clientNavigation.view.HelpMenu', Ext.menu.Menu, {reference:'helpMenu', ui:'topnavmenu', plain:true, showSeparator:false, shadow:false, items:[{localized:{text:'G_Support Center'}, href:'http://support.multivista.com', hrefTarget:'_blank', handler:'supportCenterHelpClicked'}, {localized:{text:'G_Inline Help'}, handler:'openInlineHelp'}, {localized:{text:'G_Suggest an Idea'}, handler:'openSuggestIdeaWindow', hidden:true, bind:{hidden:'{!account.features.ideasVisible}'}}]}, 0, ['helpmenu'], 
['component', 'box', 'container', 'panel', 'menu', 'helpmenu'], {'component':true, 'box':true, 'container':true, 'panel':true, 'menu':true, 'helpmenu':true}, ['widget.helpmenu'], 0, [clientNavigation.view, 'HelpMenu'], 0);
Ext.cmd.derive('clientNavigation.view.fileUploads.FileUploadsView', Ext.view.View, {cls:'file-uploads-view', tpl:new Ext.XTemplate('\x3ctpl for\x3d"."\x3e', '\x3cdiv class\x3d"file-uploads-item" id\x3d"fileUploadItem_{id}"\x3e', '\x3cdiv class\x3d"file-upload-img {imageCss}" style\x3d"{imageStyle}"\x3e\x3c/div\x3e', '\x3cdiv class\x3d"file-upload-name {buttonCss}"\x3e{name}\x3c/div\x3e', '\x3cdiv class\x3d"file-upload-status {buttonCss}" {titleAttr}\x3e{statusLabel}\x3c/div\x3e', '\x3cspan class\x3d"file-upload-btn {buttonCss}"\x3e{buttonLabel}\x3c/span\x3e', 
'\x3cspan class\x3d"file-upload-btn {removeCss}" title\x3d"Remove"\x3eX\x3c/span\x3e', '\x3c/div\x3e', '\x3c/tpl\x3e'), itemSelector:'div.file-uploads-item', emptyText:'', store:'fileUploads', loadMask:false, listeners:{itemclick:function(view, record, htmlElement, index, ev) {
  view.handleItemClick(record, ev.target, htmlElement);
}, itemremove:function(records, index, hemlElements, view) {
  this.removeAllStatusAnimations(view);
}, refresh:function(view) {
  this.removeAllStatusAnimations(view);
  if (view.store) {
    view.store.each(function(record) {
      if (record.get('status') === 'processing') {
        this.animateItemStatus(view, record);
      }
    }, this);
  }
}}, handleItemClick:function(record, target, htmlElement) {
  var cls = target ? target.getAttribute('class') : '';
  if (cls.indexOf('file-upload-btn') !== -1 && cls.indexOf('disabled') === -1) {
    var action = null;
    if (cls.indexOf('retry') !== -1) {
      action = 'retryBackgroundProcess';
    } else {
      if (cls.indexOf('cancel') !== -1) {
        action = 'cancelBackgroundProcess';
      } else {
        if (cls.indexOf('remove') !== -1) {
          action = 'removeBackgroundProcess';
          this.animateRemoveItem(record, htmlElement);
        }
      }
    }
    if (action) {
      Ext.Ajax.request({url:'/index.cfm?fuseaction\x3daClientNavigation.' + action + '\x26id\x3d' + record.id, noAlert:true, successCallback:function(data) {
        app.fireEvent('reloadfileuploads');
      }});
      target.setAttribute('class', cls + ' disabled');
      if (cls.indexOf('withRetry') !== -1 && target.querySelector && target.classList) {
        target.parentNode.querySelector('.file-upload-btn.retry').classList.add('disabled');
      } else {
        if (cls.indexOf('withRemove') !== -1 && target.querySelector && target.classList) {
          target.parentNode.querySelector('.file-upload-btn.remove').classList.add('disabled');
        }
      }
    }
  }
}, animateRemoveItem:function(record, htmlElement) {
  Ext.create('Ext.fx.Anim', {target:htmlElement, duration:750, dynamic:true, to:{height:0, opacity:0}, callback:function() {
    if (record.store) {
      record.store.remove(record);
    }
  }});
}, removeAllStatusAnimations:function(view) {
  if (view.statusAnimationItems) {
    view.oldStatusAnimationItems = {};
    for (var i = 0; i < view.statusAnimationItems.length; i++) {
      var item = view.statusAnimationItems[i];
      clearInterval(item.intervalId);
      delete item.node;
      view.oldStatusAnimationItems['' + item.id] = item;
    }
    delete view.statusAnimationItems;
  }
}, animateItemStatus:function(view, record) {
  var label = record.get('statusLabel').replace('...', '');
  var node = view.getNode(record);
  if (node) {
    node = Ext.dom.Query.selectNode('.file-upload-status', node);
  }
  if (node) {
    if (!view.statusAnimationItems) {
      view.statusAnimationItems = [];
    }
    var item = null;
    if (view.oldStatusAnimationItems && view.oldStatusAnimationItems.hasOwnProperty('' + record.id)) {
      item = view.oldStatusAnimationItems['' + record.id];
      item.node = node;
      item.label = label;
      item.updateDots();
    } else {
      item = {id:record.id, intervalId:0, count:0, label:label, node:node, updateDots:function() {
        this.count = (this.count + 1) % 4;
        var dots = '';
        for (var i = 0; i < this.count % 4; i++) {
          dots += '.';
        }
        if (this.node && this.node.parentNode) {
          this.node.innerHTML = this.label + dots;
        } else {
          clearInterval(this.intervalId);
          delete this.node;
        }
      }};
    }
    item.intervalId = setInterval(item.updateDots.bind(item), 400);
    view.statusAnimationItems.push(item);
  }
}}, 0, ['fileuploadsview'], ['component', 'box', 'dataview', 'fileuploadsview'], {'component':true, 'box':true, 'dataview':true, 'fileuploadsview':true}, ['widget.fileuploadsview'], 0, [clientNavigation.view.fileUploads, 'FileUploadsView'], 0);
Ext.cmd.derive('clientNavigation.view.fileUploads.FileUploadsMenu', Ext.menu.Menu, {reference:'fileUploadsMenu', ui:'topnavmenu', plain:true, showSeparator:false, shadow:false, width:355, items:[{xtype:'component', html:'Active Uploads\x3ca class\x3d"file-clear-uploads-link"\x3eClear\x3c/a\x3e', cls:'file-active-uploads-label', listeners:{render:function() {
  var anchor = this.getEl().child('a');
  anchor.on('click', function() {
    Ext.Ajax.request({url:mdslink.server + '/index.cfm?fuseaction\x3daClientNavigation.clearCompletedBackgroundProcesses', successCallback:function(data) {
      store.reload();
    }});
  });
  var changeHandler = function(store) {
    var index = store.findExact('status', 'completed');
    if (index === -1) {
      anchor.removeCls('shown');
    } else {
      anchor.addCls('shown');
    }
  };
  var store = Ext.getStore('fileUploads');
  store.on('load', changeHandler);
  changeHandler(store);
}}}, {xtype:'fileuploadsview', scrollable:'y', maxHeight:285}]}, 0, ['fileuploadsmenu'], ['component', 'box', 'container', 'panel', 'menu', 'fileuploadsmenu'], {'component':true, 'box':true, 'container':true, 'panel':true, 'menu':true, 'fileuploadsmenu':true}, ['widget.fileuploadsmenu'], 0, [clientNavigation.view.fileUploads, 'FileUploadsMenu'], 0);
Ext.cmd.derive('clientNavigation.view.SuggestIdeaWindow', Ext.window.Window, {width:428, height:495, title:'Suggest an Idea', plain:true, layout:'fit', ui:'suggestideawindow', border:false, bodyBorder:false, items:[{xtype:'form', fieldDefaults:{width:368, labelAlign:'top', labelSeparator:'', labelPad:7, labelClsExtra:'label-plain'}, layout:{type:'vbox', align:'stretch'}, bodyPadding:20, border:false, items:[{xtype:'textfield', fieldLabel:'Idea Title', ui:'detail-form', itemId:'ideaTitle', allowBlank:false, 
minLength:2}, {xtype:'combobox', fieldLabel:'Category', ui:'detail-form', itemId:'ideaCategory', displayField:'categoryName', valueField:'categoryName', queryMode:'local', forceSelection:true, emptyText:'Select a category', allowBlank:false, cls:'suggest-idea-field-pad', store:Ext.create('Ext.data.Store', {idProperty:'categoryName', data:[{categoryName:'Photographic Documentation'}, {categoryName:'Webcams'}, {categoryName:'Owner Equipment Training Videos'}, {categoryName:'UAV – Drone Services'}, 
{categoryName:'UAV – Mapping'}, {categoryName:'Immersive \x26 3D'}, {categoryName:'Task Manager'}, {categoryName:'Field Services \x26 Operations'}, {categoryName:'Other'}]})}, {xtype:'textarea', fieldLabel:'Idea Details', ui:'detail-form', itemId:'ideaDetails', cls:'suggest-idea-field-pad', flex:1}]}], dockedItems:{xtype:'toolbar', dock:'bottom', ui:'footer', height:68, layout:{type:'hbox', align:'middle', pack:'center'}, items:[{text:'Cancel', ui:'grey', scale:'medium', minWidth:70, handler:function() {
  this.up('window').close();
}}, {xtype:'tbspacer', width:5}, {xtype:'savebutton', text:'Submit Idea', ui:'green', width:110, scale:'medium', listeners:{click:function(btn) {
  var wind = this.up('window');
  var form = wind.down('form');
  if (form.isValid()) {
    btn.setDisabled(true);
    btn.setDone(false);
    btn.setProcessing(true);
    var title = wind.down('#ideaTitle').getValue().trim();
    var category = wind.down('#ideaCategory').getValue();
    var details = wind.down('#ideaDetails').getValue().trim();
    wind.fireEvent('submitidea', title, category, details, function(success) {
      btn.setProcessing(false);
      if (success) {
        btn.setDone(true);
        setTimeout(function() {
          wind.close();
          Ext.create('clientNavigation.view.SuggestIdeaThanksWindow').show();
        }, 250);
      } else {
        btn.setDisabled(false);
      }
    });
  }
}}}]}}, 0, 0, ['component', 'box', 'container', 'panel', 'window'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true}, 0, 0, [clientNavigation.view, 'SuggestIdeaWindow'], 0);
Ext.cmd.derive('clientNavigation.view.SuggestIdeaThanksWindow', Ext.window.Window, {width:350, height:180, title:'Suggest an Idea', plain:true, layout:'fit', ui:'suggestideawindow', border:false, bodyBorder:false, items:[{xtype:'component', html:'Thanks for submitting your idea!', cls:'suggest-idea-thanks', flex:1}], dockedItems:{xtype:'toolbar', dock:'bottom', ui:'footer', height:58, layout:{type:'hbox', align:'middle', pack:'center'}, items:[{xtype:'button', text:'Done', ui:'green', width:'80px', 
scale:'medium', listeners:{click:function(btn) {
  this.up('window').close();
}}}]}}, 0, 0, ['component', 'box', 'container', 'panel', 'window'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true}, 0, 0, [clientNavigation.view, 'SuggestIdeaThanksWindow'], 0);
Ext.cmd.derive('clientNavigation.view.companyandrole.CompanyAndRoleModel', Ext.app.ViewModel, {data:{User:null, saving:false, saveDone:false}, stores:{memberCompanies:{proxy:{api:{read:'/index.cfm?fuseaction\x3daMember.getMemberMemberCompanyNames'}}, autoLoad:false}}}, 0, 0, 0, 0, ['viewmodel.companyandrole'], 0, [clientNavigation.view.companyandrole, 'CompanyAndRoleModel'], 0);
Ext.cmd.derive('clientNavigation.view.companyandrole.CompanyAndRoleController', Ext.app.ViewController, {init:function() {
  var view = this.getView(), ProjectRoleID = view.getProjectRoleID(), MemberCompanyName = view.getMemberCompanyName(), data = {};
  if (ProjectRoleID) {
    data.ProjectRoleID = ProjectRoleID;
  }
  if (MemberCompanyName) {
    data.MemberCompanyName = MemberCompanyName;
  }
  data.MemberUID = this.getViewModel().get('account.MemberUID');
  data.id = data.MemberUID;
  this.getViewModel().set('User', Ext.create('accountShared.model.Member', data));
}, save:function() {
  this.getView().mask();
  var vm = this.getViewModel();
  vm.set('saving', true);
  vm.set('Member');
  vm.get('User').set('MemberCompanyConfirmed', 1);
  vm.get('User').save({success:function() {
    vm.set('saveDone', true);
    Ext.defer(function() {
      var view = this.getView();
      if (view) {
        view.destroy();
      }
    }, 1000, this);
  }, scope:this});
}}, 0, 0, 0, 0, ['controller.companyandrole'], 0, [clientNavigation.view.companyandrole, 'CompanyAndRoleController'], 0);
Ext.cmd.derive('clientNavigation.view.companyandrole.CompanyAndRole', Ext.window.Window, {viewModel:{type:'companyandrole'}, controller:'companyandrole', config:{ProjectRoleID:null, MemberCompanyName:null}, alwaysOnTop:3, modal:true, ui:'orange', cls:'unsaved', localized:{title:'PU_Update Your Informati'}, layout:'fit', items:[{xtype:'form', ui:'detail-form', layout:{type:'vbox', align:'stretch'}, width:488, padding:26, items:[{xtype:'component', cls:'instructions', margin:'0 0 30 0', localized:{html:'PU_We are adding Company'}}, 
{xtype:'membercompany', bind:{value:'{User.MemberCompanyName}', store:'{memberCompanies}'}, width:440}, {xtype:'projectrole', showRequiredText:true, margin:'0 0 70 0', width:440, bind:{value:'{User.ProjectRoleID}'}}, {xtype:'container', dock:'bottom', layout:{type:'hbox', pack:'center'}, items:[{xtype:'button', scale:'medium', ui:'grey', localized:{text:'G_Cancel'}, margin:'0 12 0 12', listeners:{click:function() {
  this.up('window').destroy();
}}}, {xtype:'savebutton', reference:'saveButton', localized:{text:'G_Save'}, bind:{processing:'{saving}', done:'{saveDone}', disabled:'{!User.ProjectRoleID}'}, margin:'0 12 0 12', listeners:{click:'save'}}]}]}]}, 0, ['companyandrole'], ['component', 'box', 'container', 'panel', 'window', 'companyandrole'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true, 'companyandrole':true}, ['widget.companyandrole'], 0, [clientNavigation.view.companyandrole, 'CompanyAndRole'], 0);
Ext.cmd.derive('clientNavigation.view.SharedViewController', Ext.app.ViewController, {init:function() {
  this.getViewModel().bind('{account.aconexEnabled}', this.aconexChanged, this);
  this.getViewModel().bind('{account.planGridEnabled}', this.plangridChanged, this);
  this.getViewModel().bind('{account.procoreEnabled}', this.procoreChanged, this);
  this.getViewModel().bind('{account.bim360Enabled}', this.bim360Changed, this);
  this.getViewModel().bind('{account.bluebeamEnabled}', this.bluebeamChanged, this);
  this.getViewModel().bind({permissionsLoaded:'{projectAccountLoaded}', globalAccountLoaded:'{globalAccountLoaded}'}, function(data) {
    if (data.permissionsLoaded && data.globalAccountLoaded) {
      this.onAccountAndPermissionsReady();
    }
  }, this);
  return Ext.app.ViewController.prototype.init.apply(this, arguments);
}, aconexChanged:function(value) {
  this.accountFeatureChanged('aconexEnabled', value);
}, plangridChanged:function(value) {
  this.accountFeatureChanged('planGridEnabled', value);
}, procoreChanged:function(value) {
  this.accountFeatureChanged('procoreEnabled', value);
}, bim360Changed:function(value) {
  this.accountFeatureChanged('bim360Enabled', value);
}, bluebeamChanged:function(value) {
  this.accountFeatureChanged('bluebeamEnabled', value);
}, accountFeatureChanged:function(feature, value) {
  console.log('Account feature changed', arguments);
  if (window.localStorage.getItem('Multivista_ClientSession')) {
    var session = JSON.parse(window.localStorage.getItem('Multivista_ClientSession'));
    session.account[feature] = value;
    window.localStorage.setItem('Multivista_ClientSession', JSON.stringify(session));
  }
}, loadAccount:function() {
  var ctrl = this;
  var viewModel = ctrl.getViewModel(), account = {};
  account.IsPublic = 0;
  account.MemberRole = 'superadmin';
  account.MemberUsername = 'Client';
  account.MemberFirstName = 'Client';
  account.MemberLastName = 'User';
  account.MemberUID = 0;
  account.MeasurePreferenceID = 1;
  account.canShare = false;
  account.procoreEnabled = false;
  account.aconexEnabled = false;
  account.planGridEnabled = false;
  account.bim360Enabled = false;
  account.bluebeamEnabled = false;
  account.features = {'pushpinalbumfollowVisible':true, 'megaviewerfloorplanoverlaysVisible':true, 'photoviewerHasOptOut':0, 'plangridVisible':true, 'clientUserAddVisible':false, 'ideasVisible':true, 'webrtcVisible':true, 'commentmentionsVisible':true, 'userDetailsPromptVisible':true, 'bluebeamVisible':true, 'amplitudeVisible':false, 'procoreVisible':true, 'uploadscenterVisible':true, 'badgesVisible':true, 'photos360Visible':true, 'photoviewerVisible':true, 'integrationsVisible':true, 'photolistVisible':true, 
  'bim360Visible':true, 'aconexVisible':true};
  account.newFeatureNotifications = [];
  account.sessionDataID = 0;
  account.ampProfile = {};
  account.subDomains = [];
  viewModel.set('account', account);
  viewModel.set('globalAccountLoaded', true);
  return;
  if (window.localStorage.getItem('Multivista_ClientSession')) {
    var session = JSON.parse(window.localStorage.getItem('Multivista_ClientSession'));
    var viewModel = ctrl.getViewModel();
    var account = session.account;
    var greeting = session.greeting;
    viewModel.set('account', account);
    viewModel.get('greetings').loadData(greeting);
    if (ctrl.htmlHelpHelper.greetingId != 0) {
      Ext.Ajax.request({url:'/index.cfm', params:{fuseaction:'aClientNavigation.updateGreeting', GreetingID:ctrl.htmlHelpHelper.greetingId}, method:'GET'});
    }
    viewModel.set('globalAccountLoaded', true);
    ctrl.notifyNewFeatures(account.newFeatureNotifications);
    if (account.features.uploadscenterVisible) {
      ctrl.initFileUploads();
    }
  } else {
    mdsAjax.doAjaxRequest({url:'index.cfm?fuseaction\x3daClientNavigation.getGlobalMyAccount', successCallback:function(data) {
      var viewModel = ctrl.getViewModel(), oldAccount = viewModel.get('account'), account = {};
      Ext.Object.merge(account, oldAccount);
      account.IsPublic = data[0].IsPublic;
      account.MemberRole = data[0].MemberRole;
      account.MemberUsername = data[0].MemberUsername;
      account.MemberFirstName = data[0].MemberFirstName;
      account.MemberLastName = data[0].MemberLastName;
      account.MemberUID = data[0].MemberUID;
      account.MeasurePreferenceID = data[0].MeasurePreferenceID;
      account.canShare = data[0].canShare;
      account.procoreEnabled = data[0].procoreEnabled;
      account.aconexEnabled = data[0].aconexEnabled;
      account.planGridEnabled = data[0].planGridEnabled;
      account.bim360Enabled = data[0].bim360Enabled;
      account.bluebeamEnabled = data[0].bluebeamEnabled;
      account.features = data[0].features;
      account.newFeatureNotifications = data[0].newFeatureNotifications;
      account.sessionDataID = data[0].sessionDataID;
      account.ampProfile = data[0].ampProfile;
      account.subDomains = data[0].memberRealms;
      if (account.subDomains.length > 1) {
        account.hasSubdomains = true;
      }
      viewModel.set('account', account);
      var sessionItem = {account:account, greeting:data[0].Greeting};
      window.localStorage.setItem('Multivista_ClientSession', JSON.stringify(sessionItem));
      viewModel.get('greetings').loadData(data[0].Greeting);
      if (ctrl.htmlHelpHelper.greetingId != 0) {
        Ext.Ajax.request({url:'/index.cfm', params:{fuseaction:'aClientNavigation.updateGreeting', GreetingID:ctrl.htmlHelpHelper.greetingId}, method:'GET'});
      }
      viewModel.set('globalAccountLoaded', true);
      ctrl.notifyNewFeatures(account.newFeatureNotifications);
      if (account.features.uploadscenterVisible) {
        ctrl.initFileUploads();
      }
      if (data[0].showUpdateDetailsPrompt) {
        ctrl.promptForCompanyAndRole(data[0].MemberCompanyName, data[0].ProjectRoleID);
      }
    }, scope:ctrl});
  }
}, loadMainProjectData:function(callback) {
  var ctrl = this;
  var viewModel = this.getViewModel(), projectUID = viewModel.get('ProjectUID');
  mdsAjax.doAjaxRequest({url:'index.cfm?fuseaction\x3daClientPhotoViewer.getProject\x26ProjectUID\x3d' + projectUID, successCallback:function(data) {
    var ampProject = {};
    if (data) {
      if (data[0].projectTitle) {
        viewModel.set('project.ProjectTitle', data[0].projectTitle);
      }
      if (data[0].projectAddress) {
        viewModel.set('project.ProjectAddress', data[0].projectAddress);
      }
      viewModel.set('project.CompanyUID', data[0].CompanyUID);
      viewModel.set('project.CompanyName', data[0].projectCompany);
      if (data[0].projectTitle) {
        ampProject.projectTitle = data[0].projectTitle;
      }
      if (data[0].territory) {
        ampProject.projectTerritory = data[0].territory;
      }
      if (data[0].ampProject) {
        ampProject.ampProject = data[0].ampProject;
      }
      if (data[0].commentMentionsEnabled) {
        viewModel.set('project.commentMentionsEnabled', data[0].commentMentionsEnabled);
      }
      if (data[0].pushpinAlbumFollowEnabled) {
        viewModel.set('project.pushpinAlbumFollowEnabled', data[0].pushpinAlbumFollowEnabled);
      }
      if (data[0].isPhotos360Enabled) {
        viewModel.set('project.isPhotos360Enabled', data[0].isPhotos360Enabled);
      }
      viewModel.set('project.ampProject', ampProject);
      viewModel.set('project.ImageURL32', data[0].projectImg32 ? data[0].projectImg32 : 'mds/image/project_icon32.jpg');
      viewModel.set('project.ImageURL64', data[0].projectImg ? data[0].projectImg : 'mds/image/project_icon64.jpg');
    }
    if (callback) {
      callback();
    }
  }, scope:ctrl});
}, initHelp:function() {
  this.htmlHelpHelper = null;
}, onProjectAdminEdit:function(ProjectID) {
  window.location.href = mdslink.projectEditJump + 'ProjectID\x3d' + ProjectID;
}, onProjectAdminView:function(ProjectID) {
  window.location.href = mdslink.projectView + 'ProjectID\x3d' + ProjectID;
}, onProjectTagSearch:function(SearchString) {
  var projectUID = this.getViewModel().get('ProjectUID');
  window.location.href = mdslink.clientTagSearch + 'ProjectUID\x3d' + projectUID + '\x26SearchString\x3d' + SearchString;
}, onProjectsLoad:Ext.emptyFn, onBeforeProjectsLoad:Ext.emptyFn, initFileUploads:function() {
}, pollFileUploads:function(delay) {
  var fileUploadsBtn = this.lookup('fileUploadsButton');
  if (!fileUploadsBtn) {
    console.log('File uploads UI unavailable on this page');
    return;
  }
  var store = this.getStore('fileUploads');
  if (store.pollTimeoutId) {
    clearTimeout(store.pollTimeoutId);
  }
  store.pollTimeoutId = Ext.defer(function() {
    store.load({scope:this, callback:function(records, op, success) {
      var delay = 30000;
      var recordCount = 0;
      var activeCount = 0;
      var errorCount = 0;
      if (success && records.length > 0) {
        recordCount = records.length;
        delay = 15000;
        for (var i = 0; i < records.length; i++) {
          var record = records[i];
          var status = record.get('status');
          if (status === 'processing') {
            activeCount++;
          } else {
            if (status === 'error') {
              errorCount++;
            }
          }
        }
      }
      fileUploadsBtn.updateFileUploads(recordCount, activeCount, errorCount);
      if (recordCount === 0 && this.uploadsMenu && this.uploadsMenu.isVisible()) {
        this.uploadsMenu.hide();
      }
      this.pollFileUploads(delay);
    }});
  }, delay, this);
}, showFileUploads:function(comp, ev) {
  if (!this.uploadsMenu) {
    this.uploadsMenu = this.getView().add(Ext.create('clientNavigation.view.fileUploads.FileUploadsMenu'));
  }
  this.showTopNavMenu(this.uploadsMenu, comp, [3, -2]);
  if (ev && ev.ctrlKey) {
  }
}, showHelp:function(comp) {
  if (!this.helpMenu) {
    this.helpMenu = this.getView().add(Ext.create('clientNavigation.view.HelpMenu'));
  }
  this.showTopNavMenu(this.helpMenu, comp);
  if (this.newFeaturePopupWindow) {
    this.newFeaturePopupWindow.close();
  }
}, showTopNavMenu:function(menu, comp, offsets) {
  if (menu.skipNextShowEvent) {
    delete menu.skipNextShowEvent;
    return;
  }
  if (!offsets) {
    offsets = [10, -5];
  }
  if (location.href.toLowerCase().indexOf('clientdashboard') != -1) {
    offsets[1] -= 15;
  }
  menu.showBy(comp, 'tr-br', offsets);
  if (comp.el) {
    comp.el.on('mousedown', function() {
      var menu = this;
      if (menu.isVisible()) {
        menu.skipNextShowEvent = true;
      }
    }, menu, {single:true});
  }
}, onUserClick:function(comp) {
  if (!this.accountMenu) {
    this.accountMenu = Ext.create('clientNavigation.view.GlobalMyAccountMenu');
    var account = comp.account;
    if (account && account.hasSubdomains) {
      var subdomains = account.subDomains;
      var sep = Ext.create('Ext.menu.Separator', {text:'Switch subdomains'});
      this.accountMenu.add(sep);
      for (var i = 0; i < subdomains.length; i++) {
        var item = subdomains[i];
        var menuItem = Ext.create('Ext.menu.Item', {text:item.RealmName, href:'?fuseaction\x3daAuthentication.realmRelocate\x26realmID\x3d' + item.RealmID, hrefTarget:'_blank'});
        this.accountMenu.add(menuItem);
      }
    }
  }
  this.showTopNavMenu(this.accountMenu, comp, [5, -5]);
}, logHelpClick:function(hlp) {
  var eventName = 'Clicked Help Button';
  var eventArgs = {'Help':hlp};
}, openInlineHelp:function() {
  this.logHelpClick('Inline Help');
  this.htmlHelpHelper.handleHtmlHelpHelper();
}, supportCenterHelpClicked:function() {
  this.logHelpClick('Support Center');
}, openSuggestIdeaWindow:function() {
  if (this.suggestIdeaWindow != null) {
    return;
  }
  this.logHelpClick('Suggest Idea');
  var wind = Ext.create('clientNavigation.view.SuggestIdeaWindow');
  wind.show();
  wind.on('submitidea', this.submitIdeaHandler, this);
  wind.on('close', function() {
    delete this.suggestIdeaWindow;
  }, this);
  this.suggestIdeaWindow = wind;
}, notifyNewFeatures:function(newFeatures) {
  if (!newFeatures) {
    return;
  }
  var vm = this.getViewModel(), projectUID = vm.get('ProjectUID');
  if (projectUID && !vm.get('readyToShowNotificationPopup')) {
    vm.bind('{readyToShowNotificationPopup}', function(readyToShowNotificationPopup) {
      if (readyToShowNotificationPopup) {
        Ext.defer(function() {
          this.notifyNewFeatures(newFeatures);
        }, 1, this);
      }
    }, this);
    return;
  }
  for (var i = 0; i < newFeatures.length; i++) {
    var feature = newFeatures[i], classPath = 'clientHelp.view.newfeatures.' + feature;
    var featureClass = eval(classPath);
    if (!featureClass) {
      continue;
    }
    if (!featureClass.isVisibleNotification || featureClass.isVisibleNotification(vm.get('account'))) {
      Ext.create(classPath, {parentView:this.getView()});
      return;
    }
  }
}, submitIdeaHandler:function(title, category, details, callback) {
  var errorHandler = function() {
    var subject = encodeURIComponent('Idea submission - Category ' + category);
    var body = 'Title \x3d ' + title + '\nCategory \x3d ' + category + '\nDetails \x3d ' + details;
    body = encodeURIComponent(body);
    if (body.length > 256) {
      body = body.substr(0, 252) + '...';
    }
    var emailAddress = 'ideas@multivista.com?subject\x3d' + subject + '\x26body\x3d' + body;
    Ext.Msg.error('There was an error submitting your idea.\x3cbr\x3ePlease email \x3ca href\x3d"mailto:' + emailAddress + '"\x3eideas@multivista.com\x3c/a\x3e with your idea.\x3cbr\x3eSorry for the inconvenience.');
  };
  mdsAjax.doAjaxRequest({url:'index.cfm?fuseaction\x3daClientNavigation.submitIdea', method:'POST', scope:this, jsonData:{title:title, category:category, details:details}, success:function(resp) {
    var response = JSON.parse(resp.responseText);
    if (response.success) {
      callback(true);
    } else {
      console.log('Error submitting idea', response.message);
      errorHandler();
      callback(false);
    }
  }, failure:function(resp) {
    console.error('Failed to submit idea', resp);
    errorHandler();
    callback(false);
  }});
}, loadPermissions:function(callback) {
  var viewModel = this.getViewModel(), ProjectUID = viewModel.get('ProjectUID');
  mdsAjax.doAjaxRequest({url:'index.cfm?fuseaction\x3daPermission.getUserPermissions\x26ProjectUID\x3d' + ProjectUID, successCallback:function(data) {
    var canRead = data.comment.read, canWrite = data.comment['write'], canShare = data.userCanShare;
    viewModel.set('account.canShare', canShare);
    viewModel.set('account.canRead', canRead);
    viewModel.set('account.canWrite', canWrite);
    viewModel.set('account.canViewArchive', data.userHasArchivePermission);
    viewModel.set('account.canViewLivestream', data.userHasLivestreamPermission);
    viewModel.set('account.canViewTimelapse', data.userHasTimelapsePermission);
    viewModel.set('account.canUsePTZ', data.userHasPTZPermission);
    viewModel.set('account.canEditPTZ', data.userHasPTZPresetPermission);
    viewModel.set('account.TaskListItemStatusPermission', data.TaskListItemStatusPermission);
    viewModel.set('permissionsLoaded', true);
    if (callback) {
      callback(canRead, canWrite, canShare);
    }
  }});
}, promptForCompanyAndRole:function(MemberCompanyName, ProjectRoleID) {
  this.getView().add({xtype:'companyandrole', MemberCompanyName:MemberCompanyName, ProjectRoleID:ProjectRoleID}).show();
}, onAccountAndPermissionsReady:function() {
  if (this.htmlHelpHelper) {
    var session = JSON.parse(window.localStorage.getItem('Multivista_ClientSession'));
    this.htmlHelpHelper.account = this.getViewModel().get('account');
    this.htmlHelpHelper.handleGreetings(session.greeting);
  }
}}, 0, 0, 0, 0, ['controller.sharedviewcontroller'], 0, [clientNavigation.view, 'SharedViewController'], 0);
Ext.cmd.derive('clientNavigation.view.ProjectViewModel', Ext.app.ViewModel, {data:{ProjectUID:'', project:{ProjectTitle:'', ProjectAddress:'', ImageURL32:'', ImageURL64:'', ampProject:{}, commentMentionsEnabled:false, pushpinAlbumFollowEnabled:false}, permissionsLoaded:false, private_ShareTypeID:null, private_ShareMemberUIDList:null}, formulas:{preferencesReady:function(get) {
  var ProjectUID = get('ProjectUID'), MemberUID = get('account.MemberUID');
  if (!ProjectUID || !MemberUID) {
    return false;
  }
  mdsPreferences.ProjectPreferences.setIdentification(ProjectUID, MemberUID);
  mdsPreferences.MemberPreferences.setIdentification(MemberUID);
  return true;
}, selectedShareTypeID:{get:function(get) {
  var shareTypeID = get('private_ShareTypeID');
  if (shareTypeID !== null) {
    return shareTypeID;
  }
  if (!get('preferencesReady')) {
    return null;
  }
  shareTypeID = mdsPreferences.ProjectPreferences.getShareTypeID();
  return shareTypeID ? shareTypeID : get('account.canShare') ? 1 : 2;
}, set:function(value) {
  this.set('private_ShareTypeID', value);
  mdsPreferences.ProjectPreferences.setShareTypeID(value);
}}, selectedShareMemberUIDList:{get:function(get) {
  var memberList = get('private_ShareMemberUIDList'), peopleStore = get('people'), peopleStoreReady = get('_peopleLoaded');
  if (memberList === null) {
    if (!get('preferencesReady')) {
      return null;
    }
    memberList = mdsPreferences.ProjectPreferences.getShareMembersList();
  }
  if (peopleStoreReady) {
    var memberArray = memberList ? memberList.split(',') : [], adjustedMemberArray = [];
    for (var i = 0; i < memberArray.length; i++) {
      if (peopleStore.getById(memberArray[i])) {
        adjustedMemberArray.push(memberArray[i]);
      }
    }
    memberList = adjustedMemberArray.join(',');
    if (memberArray.length != adjustedMemberArray.length) {
      this.set('private_ShareMemberUIDList', memberList);
      mdsPreferences.ProjectPreferences.setShareMembersList(memberList);
    }
  }
  return memberList ? memberList : '';
}, set:function(value) {
  this.set('private_ShareMemberUIDList', value);
  mdsPreferences.ProjectPreferences.setShareMembersList(value);
}}}, stores:{listsAndReports:{type:'listreports', proxy:{extraParams:{ProjectUID:'{ProjectUID}'}}, autoLoad:false, mvAutoLoadVars:false}, people:{model:'clientNavigation.model.Member', proxy:{type:'jsonp', url:'index.cfm?fuseaction\x3daClientPeopleOverview.getPeopleBasic'}, autoLoad:false, mvAutoLoadVars:false}}}, 0, 0, 0, 0, ['viewmodel.projectviewmodel'], 0, [clientNavigation.view, 'ProjectViewModel'], 0);
Ext.cmd.derive('clientNavigation.view.SharedViewModel', clientNavigation.view.ProjectViewModel, {data:{globalAccountLoaded:false, mainNavBarReady:true, navSettings:{companyLogoURL:''}, navButtonSettings:{dashboard:{visible:false, ui:'client-navigation'}, photos:{visible:false}, floorplans:{visible:false}, files:{visible:false}, webcams:{visible:false}, videos:{visible:false}, people:{visible:false}, externallink:{text:'', visible:false}, '3dimmersive':{text:'3D Immersive', visible:false}, projectedit:{visible:false}, 
workingplans:{visible:false}, 'map':{visible:false}}}, formulas:{isStaff:function(get) {
  var memberRole = get('account.MemberRole');
  return !!(memberRole && memberRole != 'client');
}, projectSelectorText:function(get) {
  var projectTitle = get('project.ProjectTitle');
  return projectTitle ? projectTitle : mvstr['G_Select A Project'];
}, globalPreferencesReady:function(get) {
  var MemberUID = get('account.MemberUID');
  if (!MemberUID) {
    return false;
  }
  mdsPreferences.MemberPreferences.setIdentification(MemberUID);
  return true;
}, readyToShowNotificationPopup:function(get) {
  return get('projectAccountLoaded') && get('mainNavBarReady');
}}, stores:{projects:{extend:'Ext.data.Store', model:'sharedLookup.model.ProjectSelector', storeId:'projects', proxy:{type:'jsonp', reader:{type:'json', root:'data'}, url:'index.cfm?fuseaction\x3daClientNavigation.ProjectNavigation'}, sorters:[{property:'projectTitle', direction:'ASC'}], autoLoad:false, listeners:{load:'onProjectsLoad', beforeload:'onBeforeProjectsLoad'}}, greetings:{fields:[{name:'GreetingID', type:'int'}, {name:'Name', type:'string'}, {name:'seen', type:'boolean', defaultValue:false}]}, 
fileUploads:{storeId:'fileUploads', model:'clientNavigation.model.FileUpload', proxy:{type:'jsonp', reader:{type:'json', root:'data'}, url:'index.cfm?fuseaction\x3daClientNavigation.getBackgroundProcesses'}, autoLoad:false}}}, 0, 0, 0, 0, 0, 0, [clientNavigation.view, 'SharedViewModel'], 0);
Ext.cmd.derive('clientNavigation.view.clientViewport.ClientViewportController', clientNavigation.view.SharedViewController, {init:function() {
  var ctrl = this;
  var viewModel = ctrl.getViewModel(), projectUID = viewModel.get('ProjectUID');
  ctrl.initHelp();
  ctrl.loadAccount();
  mdsAjax.doAjaxRequest({url:'index.cfm?fuseaction\x3daClientNavigation.getNavigationPreference4Project\x26ProjectUID\x3d' + projectUID, successCallback:function(data) {
    if (!data.length) {
      data = [data];
    }
    var viewModel = ctrl.getViewModel();
    viewModel.set('navSettings', {companyLogoURL:data[0].companyLogoURL, projectLogoURL:data[0].projectLogoURL});
    viewModel.set('account.canRead', 1);
    viewModel.set('account.canWrite', 0);
    viewModel.set('account.JoinedWithAddUserPermission', 0);
    viewModel.set('account.MultivistaContentPermission', 0);
    var navButtonSettings = viewModel.get('navButtonSettings');
    var buttons = data[0].navigationBar4Project;
    var pageAlias = ctrl.getPageAlias();
    for (var i = 0; i < buttons.length; i++) {
      var ui = 'client-navigation';
      var cls = '';
      var btn = buttons[i];
      if (btn.alias.substr(0, 9) == 'tasklist-') {
        var ListTypeID = btn.alias.split('-')[1], pageListTypeID = Ext.Object.fromQueryString(document.location.search).ListTypeID;
        ctrl.lookupReference('taskListButtonContainer').add({xtype:'button', ui:ui, localized:{text:'MN_' + btn.DisplayLabel}, height:37, hrefTarget:'', bind:{href:'{mdslink_clientPunchlistOverview_Base}ProjectUID\x3d{ProjectUID}\x26ListTypeID\x3d' + ListTypeID}, cls:pageAlias == 'punchlist' && pageListTypeID == ListTypeID ? 'client-navigation-current-button' : undefined});
        continue;
      }
      if (pageAlias == btn.alias) {
        cls = 'client-navigation-current-button';
      }
      if (btn.alias == 'externallink') {
        if (btn.CSSClass) {
          ui = btn.CSSClass;
        }
        viewModel.set('navButtonSettings.' + btn.alias + '.href', btn.LinkURL);
        var externalLinkBtn = ctrl.lookupReference('externalLinkButton');
        externalLinkBtn.el.dom.target = btn.NewWindow == 1 ? '_blank' : '_self';
        externalLinkBtn.setHref(btn.LinkURL);
      }
      if (mvstr['MN_' + btn.alias]) {
        viewModel.set('navButtonSettings.' + btn.alias + '.text', mvstr['MN_' + btn.alias]);
      }
      viewModel.set('navButtonSettings.' + btn.alias + '.ui', ui);
      viewModel.set('navButtonSettings.' + btn.alias + '.cls', cls);
      if (btn.DisplayLabel) {
        viewModel.set('navButtonSettings.' + btn.alias + '.text', btn.DisplayLabel);
      }
      viewModel.set('navButtonSettings.' + btn.alias + '.visible', btn.visible);
    }
    viewModel.set('projectAccountLoaded', true);
  }, scope:ctrl});
  ctrl.loadMainProjectData();
  return ctrl.callParent(arguments);
}, getPage:function() {
  return this.getView().down('#activePage');
}, getPageName:function() {
  var name = this.getPage().xtype, params = Ext.Object.fromQueryString(document.location.search);
  if (name == 'clientFloorplanOverview' && params.ListTypeID) {
    return 'clientFloorplanOverview_punchlistPlans';
  }
  return name;
}, getPageAlias:function() {
  return {clientPhotoList:'photos', clientFloorplanOverview:'floorplans', clientFileManager:'files', clientWebcamOverview:'webcams', client3DImmersive:'3dimmersive', clientVideo:'videos'}[this.getPageName()];
}, listeners:{updateProjectPreference:function() {
  var me = this;
  var search = Ext.Object.fromQueryString(document.location.search);
  if (me.htmlHelpHelper.greetingIdProjectPreference != 0) {
    mdsAjax.doAjaxRequest({url:'index.cfm?fuseaction\x3daClientNavigation.updateGreeting\x26GreetingID\x3d' + me.htmlHelpHelper.greetingIdProjectPreference + '\x26projectpreference\x3d' + me.htmlHelpHelper.projectpreference, method:'GET', success:function(response) {
      if (me.htmlHelpHelper.projectpreference == 'photos' && search.fuseaction == 'aClientFloorplanOverview.home' || me.htmlHelpHelper.projectpreference == 'floorplans' && search.fuseaction == 'aClientPhotoList.home') {
        window.location.href = '/index.cfm?fuseaction\x3daClientNavigation.ProjectGateway\x26ProjectUID\x3d' + search.ProjectUID;
      }
    }});
  }
}}}, 0, 0, 0, 0, ['controller.clientNavigation'], 0, [clientNavigation.view.clientViewport, 'ClientViewportController'], 0);
Ext.cmd.derive('clientNavigation.view.clientViewport.ClientViewportModel', clientNavigation.view.SharedViewModel, {data:{validatedCompanyLogo:'', validatedProjectLogo:'', validatedProjectLogo:false, mainNavBarReady:false}, stores:{breadcrumbs:{fields:[{name:'display', type:'string', convert:function(txt) {
  return '\x26nbsp;' + txt;
}}, {name:'homepageIcon32', type:'string', convert:function(path) {
  return '\x3cimg src\x3d"' + path + '" style\x3d"vertical-align:middle" width\x3d"32" height\x3d"32" border\x3d"1"\x3e';
}}, {name:'url', type:'string', convert:function(v) {
  var temp = {url:v};
  var ProjectUID = Ext.Object.fromQueryString(temp.url).ProjectUID, FloorplanUID = Ext.Object.fromQueryString(temp.url).FloorplanUID;
  temp.url = mdslink.clientFloorplanViewer + 'ProjectUID\x3d' + ProjectUID + '\x26FloorplanUID\x3d' + FloorplanUID;
  return temp.url;
}}], proxy:{type:'jsonp', reader:{type:'json', root:'data'}, url:'index.cfm?fuseaction\x3daClientNavigation.getProjectBreadcrumb\x26ProjectUID\x3d{ProjectUID}'}, autoLoad:true}, floorplans:{model:'clientNavigation.model.MegamenuParent', proxy:{type:'jsonp', reader:{type:'json', root:'data'}, url:'index.cfm?fuseaction\x3daClientNavigation.ProjectMegamenu\x26ProjectUID\x3d{ProjectUID}'}, autoLoad:true}, workingPlans:{model:'clientNavigation.model.MegamenuParent', proxy:{type:'jsonp', reader:{type:'json', 
root:'data'}, url:'index.cfm?fuseaction\x3daClientNavigation.getWorkingPlansMenu\x26ProjectUID\x3d{ProjectUID}'}, autoLoad:false}}, formulas:{accountReady:function(get) {
  var ready = !!(get('globalAccountLoaded') && get('projectAccountLoaded'));
  if (ready && window.app) {
    app.fireEvent('accountready', get('account'));
  }
  return ready;
}, logoHtml:function(get) {
  var companyLogo = get('validatedCompanyLogo'), projectLogo = get('validatedProjectLogo'), html = '\x3cdiv class\x3d"top-logos"\x3e';
  if (companyLogo) {
    html += '\x3cimg class\x3d"company" src\x3d"' + companyLogo + '"\x3e';
  }
  if (projectLogo) {
    html += '\x3cimg class\x3d"project" src\x3d"' + projectLogo + '"\x3e';
  }
  html += '\x3c/div\x3e';
  return html;
}, _triggerValidateLogos:function(get) {
  var navSettings = get('navSettings'), companyLogo = navSettings.companyLogoURL, projectLogo = navSettings.projectLogoURL, companyImg = new Image, projectImg = new Image;
  companyImg.onload = Ext.bind(function() {
    this.set('validatedCompanyLogo', companyLogo);
  }, this);
  projectImg.onload = Ext.bind(function() {
    this.set('validatedProjectLogo', projectLogo);
  }, this);
  if (companyLogo) {
    companyImg.src = companyLogo;
  }
  if (projectLogo) {
    projectImg.src = projectLogo;
  }
}}}, 0, 0, 0, 0, ['viewmodel.clientNavigation'], 0, [clientNavigation.view.clientViewport, 'ClientViewportModel'], 0);
Ext.cmd.derive('clientPhotoViewerNew.Application', Ext.app.Application, {name:'clientPhotoViewerNew', mvInitLocale:true, controllers:['ToolbarActions@photoActions.controller'], init:function() {
  window.app = this;
}}, 0, 0, 0, 0, 0, 0, [clientPhotoViewerNew, 'Application'], 0);
Ext.cmd.derive('clientPhotoViewerNew.view.main.MainController', clientNavigation.view.clientViewport.ClientViewportController, {init:function() {
  this.initHelp();
  this.loadAccount();
  this.loadPermissions(function(canRead, canWrite) {
  });
  this.loadMainProjectData();
  var pageParams = Ext.Object.fromQueryString(document.location.search);
  pageParams.PhotoGroupType = pageParams.PhotoGroupType ? pageParams.PhotoGroupType.toUpperCase() : '';
  if (pageParams.PhotoGroupType == 'A') {
    this.launchViewer(Ext.create('floorplanViewer.model.PhotoGroup', {'Identifier':pageParams.AlbumUID, 'Type':'A'}));
  } else {
    if (pageParams.PhotoGroupType == 'S') {
      var ctrl = this;
      mdsAjax.doAjaxRequest({url:'/index.cfm?fuseaction\x3daClientPhotoViewer.getShootDetails', params:{ProjectUID:pageParams.ProjectUID, ShootUID:pageParams.ShootUID}, successCallback:function(data) {
        if (data[0].FloorplanUID) {
          ctrl.launchViewer(Ext.create('floorplanViewer.model.PhotoGroup', {Identifier:data[0].ProjectShootTypeUID, StartDate:data[0].ShootDate, 'Type':'D', Title:data[0].ProjectShootTypeDisplayLabel, Locations:data[0].FloorplanDescription ? [data[0].FloorplanDescription] : []}));
        } else {
          ctrl.launchViewer(Ext.create('floorplanViewer.model.PhotoGroup', {Identifier:data[0].ProjectShootTypeUID, StartDate:data[0].ShootDate, 'Type':'L', Title:data[0].ProjectShootTypeDisplayLabel, Locations:[]}));
        }
      }, scope:ctrl});
    } else {
      if (pageParams.PhotoGroupType == 'U') {
        this.launchViewer(Ext.create('floorplanViewer.model.PhotoGroup', {'Identifier':pageParams.MemberUID, 'Type':'U', 'StartDate':pageParams.PhotoGroupDate}));
      } else {
        if (pageParams.PhotoGroupType == 'Q') {
          this.launchViewer(Ext.create('floorplanViewer.model.PhotoGroup', {'Identifier':pageParams.PunchItemID, 'Type':'Q'}));
        } else {
          if (pageParams.PhotoGroupType == 'P') {
            this.launchViewer(Ext.create('floorplanViewer.model.PhotoGroup', {'Identifier':pageParams.PushpinUID, 'Type':'N'}));
          } else {
            if (pageParams.PhotoGroupType == 'M') {
              this.launchViewer(Ext.create('floorplanViewer.model.PhotoGroup', {'Identifier':pageParams.SNID1 + '-' + pageParams.SNID2, 'Type':'M'}));
            } else {
              if (pageParams.PhotoGroupType == 'H') {
                this.launchViewer(Ext.create('floorplanViewer.model.PhotoGroup', {'Identifier':pageParams.HotspotID, 'Type':'H'}));
              } else {
                if (pageParams.PhotoGroupType == 'W') {
                  this.launchViewer(Ext.create('floorplanViewer.model.PhotoGroup', {'Identifier':pageParams.WebcamUID, 'ArchivePositionID':pageParams.ArchivePositionID || 0, 'Type':'W'}));
                } else {
                  if (pageParams.WebcamUID) {
                    this.launchViewer();
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}, launchViewer:function(photoGroup) {
  var pageParams = Ext.Object.fromQueryString(document.location.search), viewerParams = {xtype:'photoviewer', photoGroup:photoGroup, standalone:true};
  if (pageParams.SelectedPhotoID) {
    viewerParams.photoId = 'P' + pageParams.SelectedPhotoID;
  } else {
    if (pageParams.SelectedUDEFPhotoUID) {
      viewerParams.photoId = 'U' + pageParams.SelectedUDEFPhotoUID;
    } else {
      if (pageParams.SelectedWebcamPhotoUID) {
        viewerParams.photoId = 'W' + pageParams.SelectedWebcamPhotoUID;
      }
    }
  }
  if (pageParams.ListTypeID) {
    viewerParams.ListTypeID = Number(pageParams.ListTypeID);
  }
  if (pageParams.WebcamUID) {
    viewerParams.WebcamUID = pageParams.WebcamUID;
  }
  this.getView().add(viewerParams).show();
}}, 0, 0, 0, 0, ['controller.main'], 0, [clientPhotoViewerNew.view.main, 'MainController'], 0);
Ext.cmd.derive('clientPhotoViewerNew.view.main.MainModel', clientNavigation.view.clientViewport.ClientViewportModel, {}, 0, 0, 0, 0, ['viewmodel.main'], 0, [clientPhotoViewerNew.view.main, 'MainModel'], 0);
Ext.cmd.derive('clientPhotoViewerNew.view.main.Main', Ext.container.Container, {controller:'main', viewModel:{type:'main'}}, 0, ['clientPhotoViewerNew'], ['component', 'box', 'container', 'clientPhotoViewerNew'], {'component':true, 'box':true, 'container':true, 'clientPhotoViewerNew':true}, ['widget.clientPhotoViewerNew'], 0, [clientPhotoViewerNew.view.main, 'Main'], 0);
mdslink.server = '';
Ext.application({name:'clientPhotoViewerNew', extend:clientPhotoViewerNew.Application, autoCreateViewport:'clientPhotoViewerNew.view.main.Main'});
